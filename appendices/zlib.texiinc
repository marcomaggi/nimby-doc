@node zlib
@appendix Zlib compression library


@macro zlibversion{}
1.2.3
@end macro


This is unofficial documentation for Zlib version @zlibversion{}.  It
was written by Marco Maggi @email{marcomaggi@@gna.org}, formatting text
in the @file{zlib.h} header file.  Any conversion error his to be
considered his fault.

@noindent
Copyright @copyright{} 1995-2005 Mark Adler @email{madler@@alumni.caltech.edu} @*
Copyright @copyright{} 1995-2005 Jean-loup Gailly @email{jloup@@gzip.org}

@quotation
This software is provided ``as--is'', without any express or implied
warranty.  In no event will the authors be held liable for any damages
arising from the use of this software.

Permission is granted to anyone to use this software for any purpose,
including commercial applications, and to alter it and redistribute it
freely, subject to the following restrictions:

@enumerate
@item
The origin of this software must not be misrepresented; you must not
claim that you wrote the original software.  If you use this software in
a product, an acknowledgment in the product documentation would be
appreciated but is not required.

@item
Altered source versions must be plainly marked as such, and must not be
misrepresented as being the original software.

@item
This notice may not be removed or altered from any source distribution.
@end enumerate
@end quotation


@menu
* zlib introduction::           Introduction to Zlib
* zlib types::                  Data types.
* zlib constants::              Constants.
* zlib basic::                  Basic functions.
* zlib advanced::               Advanced functions.
* zlib utility::                Utility functions.
* zlib file::                   File functions.
* zlib checksum::               Checksum functions.
* zlib misc::                   Miscellaneous functions.
* zlib references::             Bibliography and references.
@end menu


@c page
@node zlib introduction
@appendixsec Introduction


The Zlib compression library provides in--memory compression and
decompression functions, including integrity checks of the uncompressed
data.  This version of the library supports only one compression method
(deflation) but other algorithms will be added later and will have the
same stream interface.

Compression can be done in a single step if the buffers are large enough
(for example if an input file is mmap'ed), or can be done by repeated
calls of the compression function.  In the latter case, the application
must provide more input and/or consume the output (providing more output
space) before each call.

The compressed data format used by default by the in--memory functions
is the zlib format, which is a zlib wrapper documented in @acronym{RFC}
1950, wrapped around a deflate stream, which is itself documented in
@acronym{RFC} 1951.

The library also supports reading and writing files in gzip (@code{.gz})
format with an interface similar to that of @code{stdio} using the
functions that start with @code{gz}.  The @command{gzip} format is
different from the zlib format.  @command{gzip} is a gzip wrapper,
documented in @acronym{RFC} 1952, wrapped around a deflate stream.

This library can optionally read and write gzip streams in memory as
well.

The zlib format was designed to be compact and fast for use in memory
and on communication channels.  The gzip format was designed for
single--file compression on file systems, has a larger header than zlib
to maintain directory information, and uses a different, slower check
method than zlib.

The library does not install any signal handler.  The decoder checks the
consistency of the compressed data, so the library should never crash
even in case of corrupted input.

@c page
@node zlib types
@appendixsec Data types


@deftp {Typedef} Byte
On most platforms is an alias for @code{unsigned char}.
@end deftp


@deftp Typedef uInt
An alias for @code{unsigned int}.
@end deftp


@deftp Typedef uLong
An alias for @code{unsigned long}.
@end deftp


@deftp {Struct Pointer} gzFile
Declared as @code{void} pointer.  It's used to reference compressed file
descriptors.
@end deftp


@deftp {Typedef} z_off_t
Used to represent offsets in the file content.  On some systems it is an
alias for @code{off_t}, on other systems it is an alias for @code{long}.
@end deftp


@deftp {Struct Pointer} z_streamp
The pointer to the stream structure.
@end deftp


@deftp {Struct Typedef} z_stream
This is the data structure that is used to hold the state of an
in--memory compression/decompression stream.

Fields description follows.

@table @code
@item Bytef * next_in
Next input byte.

@item uInt avail_in
Number of bytes available at @code{next_in}.

@item uLong total_in
Total number of input bytes read so far.

@item Bytef * next_out
Next output byte should be put there.

@item uInt avail_out
Remaining free space at @code{next_out}.

@item uLong total_out
Total number of bytes output so far.

@item char * msg
Last error message, @code{NULL} if no error.

@item struct internal_state FAR * state
Not visible by applications.

@item alloc_func zalloc
Used to allocate the internal @code{state}.

@item free_func zfree
Used to free the internal @code{state}.

@item voidpf opaque
Private data object passed to @code{zalloc} and @code{zfree}.

@item int data_type
Best guess about the data type: ascii or binary.

@item uLong adler
Adler32 value of the uncompressed data.

@item uLong reserved
reserved for future use.
@end table

The application must update @code{next_in} and @code{avail_in} when
@code{avail_in} has dropped to zero.  It must update @code{next_out} and
@code{avail_out} when @code{avail_out} has dropped to zero.  The
application must initialize @code{zalloc}, @code{zfree} and
@code{opaque} before calling the init function.  All other fields are
set by the compression library and must not be updated by the
application.

The @code{opaque} value provided by the application will be passed as
the first parameter for calls of @code{zalloc} and @code{zfree}.  This
can be useful for custom memory management.  The compression library
attaches no meaning to the @code{opaque} value.

@code{zalloc} must return @code{Z_NULL} if there is not enough memory
for the object.  If zlib is used in a multi--threaded application,
@code{zalloc} and @code{zfree} must be thread safe.

On 16--bit systems, the functions @code{zalloc} and @code{zfree} must be
able to allocate exactly 65536 bytes, but will not be required to
allocate more than this if the symbol @code{MAXSEG_64K} is defined (see
@file{zconf.h}).  @strong{Warning}: On MSDOS, pointers returned by
@code{zalloc} for objects of exactly 65536 bytes @strong{must} have
their offset normalized to zero.  The default allocation function
provided by this library ensures this (see @file{zutil.c}).  To reduce
memory requirements and avoid any allocation of 64K objects, at the
expense of compression ratio, compile the library with
@code{-DMAX_WBITS=14} (see @file{zconf.h}).

The fields @code{total_in} and @code{total_out} can be used for
statistics or progress reports.  After compression, @code{total_in}
holds the total size of the uncompressed data and may be saved for use
in the decompressor (particularly if the decompressor wants to
decompress everything in a single step).
@end deftp


@deftp {Pointer Typedef} gz_headerp
Pointer to the header structure of gzip files.
@end deftp


@deftp {Struct Typedef} gz_header
Gzip header information passed to and from zlib routines.  See
@acronym{RFC} 1952 for more details on the meanings of these fields.
Fields description follows.

@table @code
@item int text
True if compressed data believed to be text.

@item uLong time
Modification time.

@item int xflags
Extra flags (not used when writing a gzip file).

@item int os
Operating system.

@item Bytef * extra
Pointer to extra field or @code{Z_NULL} if none.

@item uInt extra_len
Extra field length (valid if @code{extra != Z_NULL}).

@item uInt extra_max
Space at extra (only when reading header).

@item Bytef * name
Pointer to zero--terminated file name or @code{Z_NULL}.

@item uInt name_max
Space at name (only when reading header).

@item Bytef * comment
Pointer to zero--terminated comment or @code{Z_NULL}.

@item uInt comm_max
Space at comment (only when reading header).

@item int hcrc
True if there was or will be a header crc.

@item int done
True when done reading gzip header (not used when writing a gzip file).
@end table
@end deftp


@c page
@node zlib constants
@appendixsec Constants


@defmac Z_NO_FLUSH
@defmacx Z_SYNC_FLUSH
@defmacx Z_FULL_FLUSH
@defmacx Z_FINISH
@defmacx Z_BLOCK
Allowed flush values; see @cfunc{deflate} and @cfunc{inflate} for
details.
@end defmac


@defmac Z_OK
@defmacx Z_STREAM_END
@defmacx Z_NEED_DICT
@defmacx Z_ERRNO
@defmacx Z_STREAM_ERROR
@defmacx Z_DATA_ERROR
@defmacx Z_MEM_ERROR
@defmacx Z_BUF_ERROR
@defmacx Z_VERSION_ERROR
Return codes for the compression/decompression functions. Negative
values are errors, positive values are used for special but normal
events.
@end defmac


@defmac Z_NO_COMPRESSION
@defmacx Z_BEST_SPEED
@defmacx Z_BEST_COMPRESSION
@defmacx Z_DEFAULT_COMPRESSION
Compression levels.
@end defmac


@defmac Z_FILTERED
@defmacx Z_HUFFMAN_ONLY
@defmacx Z_RLE
@defmacx Z_DEFAULT_STRATEGY
Compression strategy; see @cfunc{deflateInit2} for details.
@end defmac


@defmac Z_BINARY
@defmacx Z_TEXT
@defmacx Z_ASCII
@defmacx Z_UNKNOWN
Possible values of the @code{data_type} field (though see
@cfunc{inflate}).  @code{Z_ASCII} is an alias for @code{Z_TEXT}.
@end defmac


@defmac Z_DEFLATED
The @cfunc{deflate} compression method (the only one supported in
this version).
@end defmac


@defmac Z_NULL
For initializing @code{zalloc}, @cfunc{zfree}, @cfunc{opaque}.  Its
value is zero.
@end defmac


@defmac ZLIB_VERSION
The library version as a string string.
@end defmac


@defmac ZLIB_VERNUM
The library version as a number; the version is encoded in hexadecimal
format.  For example @code{0x1230} means version @code{1.2.3}.
@end defmac


@c page
@node zlib basic
@appendixsec Basic functions


@menu
* zlib basic deflate::          Basic deflate functions.
* zlib basic inflate::          Basic inflate functions.
@end menu


@c page
@node zlib basic deflate
@appendixsubsec Basic deflate functions


To compress a block of data, basically we should do:

@example
#define SIZE 4096
uint8_t         input[SIZE];
uint8_t         output[SIZE];
z_stream        stream;
int             e;

/* copy in data to be compressed */
memcpy(input, SIZE, input_bytes);

stream.next_in   = input;
stream.avail_in  = SIZE;

stream.next_out  = output;
stream.avail_out = SIZE;

e = deflateInit(&stream, Z_BEST_COMPRESSION);
if (Z_OK != e) ... /* handle the error */

e = deflate(&stream, Z_FINISH);
if (Z_OK != e) ... /* handle the error */

deflateEnd(&stream);
if (Z_OK != e) ... /* handle the error */

/*
  Now the compressed bytes are in "output", and there
  are "stream.next_out - output" bytes of it.
*/
@end example


@deftypefun int deflateInit (z_streamp @var{strm}, int @var{level})
Initializes the internal stream state for compression.  This function
does not perform any compression: That will be done by @cfunc{deflate}.

The fields @samp{zalloc}, @samp{zfree} and @samp{opaque} must be
initialized before by the caller.  If @samp{zalloc} and @samp{zfree}
are set to @samp{Z_NULL}, the function updates them to use default
allocation functions.

The compression @var{level} must be @samp{Z_DEFAULT_COMPRESSION}, or
between 0 and 9: 1 gives best speed, 9 gives best compression, 0 gives
no compression at all (the input data is simply copied a block at a
time).  @samp{Z_DEFAULT_COMPRESSION} requests a default compromise
between speed and compression (currently equivalent to level 6).

The return value is:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_STREAM_ERROR
If @var{level} is not a valid compression level.

@item Z_VERSION_ERROR
If the Zlib library version (return value of @cfunc{zlibVersion}) is
incompatible with the version assumed by the caller (value of
@samp{ZLIB_VERSION}).
@end table

The field @samp{msg} is set to @cnull{} if there is no error message.
@end deftypefun


@deftypefun int deflate (z_streamp @var{strm}, int @var{flush})
This function compresses as much data as possible, and stops when the
input buffer becomes empty or the output buffer becomes full. It may
introduce some output latency (reading input without producing any
output) except when forced to flush.

The detailed semantics are as follows, with reference to the fields of
the @samp{z_stream} structure. The function performs one or both of the
following actions.

@itemize
@item
Compress more input starting at @samp{next_in} and update @samp{next_in}
and @samp{avail_in} accordingly.  If not all input can be processed
(because there is not enough room in the output buffer), @samp{next_in}
and @samp{avail_in} are updated and processing will resume at this
point; we are meant to call this function again after having provided a
new output buffer.

@item
Provide more output starting at @samp{next_out} and update
@samp{next_out} and @samp{avail_out} accordingly.  This action is forced
if the parameter @var{flush} is non zero.  Forcing flush frequently
degrades the compression ratio, so this parameter should be set only
when necessary (in interactive applications).  Some output may be
provided even if flush is not set.
@end itemize

Before the call to @cfunc{deflate}: The application should ensure that
at least one of the actions is possible, by providing more input and/or
consuming more output, and updating @samp{avail_in} or @samp{avail_out}
accordingly; @samp{avail_out} should never be zero before the call.

The application can consume the compressed output when it wants, for
example when the output buffer is full (@samp{avail_out == 0}), or after
each call.  If the return value is @samp{Z_OK} and with zero
@samp{avail_out}, it must be called again after making room in the
output buffer because there might be more output pending.

To compress a stream of bytes that is available in chunks we should
normally set @var{flush} to @samp{Z_NO_FLUSH} to process incoming data,
and to @samp{Z_FINISH} at the end to finish.  If the parameter
@var{flush} is set to:

@table @samp
@item Z_SYNC_FLUSH
All pending output is flushed to the output buffer and the output is
aligned on a byte boundary, so that the decompressor can get all input
data available so far (in particular @samp{avail_in} is zero after the
call if enough output space has been provided before the call).
Flushing may degrade compression for some compression algorithms and so
it should be used only when necessary.

@item Z_FULL_FLUSH
All output is flushed as with @samp{Z_SYNC_FLUSH}, and the compression
state is reset so that decompression can restart from this point if
previous compressed data has been damaged or if random access is
desired.  Using @samp{Z_FULL_FLUSH} too often can seriously degrade the
compression.

@item Z_FINISH
Pending input is processed, pending output is flushed and the return
value is @samp{Z_STREAM_END} if there was enough output space; if the
return value is @samp{Z_OK}, this function must be called again with
@samp{Z_FINISH} and more output space (updated @samp{avail_out}) but no
more input data, until it returns with @samp{Z_STREAM_END} or an error.
@end table

If the function returns with @samp{avail_out == 0}, it must be called
again with the same value of the @var{flush} parameter and more output
space (updated @samp{avail_out}), until the flush is complete (the
function returns with non-zero @samp{avail_out}).  In the case of a
@samp{Z_FULL_FLUSH} or @samp{Z_SYNC_FLUSH}, make sure that
@samp{avail_out} is greater than six to avoid repeated flush markers due
to @samp{avail_out == 0} on return.

After the function has returned @samp{Z_STREAM_END}, the only possible
operations on the stream are @cfunc{deflateReset} or @cfunc{deflateEnd}.

@samp{Z_FINISH} can be used immediately after @cfunc{deflateInit} if all
the compression is to be done in a single step.  In this case:
@samp{avail_out} must be at least the value returned by
@cfunc{deflateBound}.  If this function does not return
@samp{Z_STREAM_END}, then it must be called again as described above.

This function sets @samp{@var{strm}->adler} to the @emph{Adler32}
checksum of all input read so far (that is, @samp{total_in} bytes).

This function may update @samp{data_type} if it can make a good guess
about the input data type (@samp{Z_TEXT} or @samp{Z_BINARY}). In doubt,
the data is considered binary.  This field is only for information
purposes and does not affect the compression algorithm in any manner.

This function returns:

@table @samp
@item Z_OK
If some progress has been made (more input processed or more output
produced).

@item Z_STREAM_END
If all input has been consumed and all output has been produced (only
when @var{flush} is set to @samp{Z_FINISH}).

@item Z_STREAM_ERROR
If the stream state was inconsistent (for example if @samp{next_in} or
@samp{next_out} was @cnull{}).

@item Z_BUF_ERROR
If no progress is possible (for example @samp{avail_in} or
@samp{avail_out} was zero).  Note that this error is not fatal, and this
function can be called again with more input and more output space to
continue compressing.
@end table
@end deftypefun


@deftypefun int deflateEnd (z_streamp @var{strm})
All dynamically allocated data structures for this stream are freed.
This function discards any unprocessed input and does not flush any
pending output.

The return value is:

@table @samp
@item Z_OK
if success;

@item Z_STREAM_ERROR
if the stream state was inconsistent;

@item Z_DATA_ERROR
if the stream was freed prematurely (some input or output was
discarded).
@end table

In the error case: @samp{msg} may be set to a static string (which must
not be deallocated).
@end deftypefun

@c page
@node zlib basic inflate
@appendixsubsec Basic inflate functions


To decompress a block of data, basically we should do:

@example
#define SIZE 4096
uint8_t         input[SIZE];
uint8_t         output[10 * SIZE];
z_stream        stream;
int             e;

/* copy in data to be decompressed */
memcpy(input, SIZE, input_bytes);

stream.next_in   = input;
stream.avail_in  = SIZE;

stream.next_out  = output;
stream.avail_out = SIZE;

e = inflateInit(&stream);
if (Z_OK != e) ... /* handle the error */

e = inflate(&stream, Z_FINISH);
if (Z_STREAM_END != e) ... /* handle the error */

inflateEnd(&stream);
if (Z_OK != e) ... /* handle the error */

/*
  Now the decompressed bytes are in "output", and there
  are "stream.next_out - output" bytes of it.
*/
@end example


@deftypefun int inflateInit (z_streamp @var{strm})
Initializes the internal stream state for decompression.  This function
does not perform any decompression apart from reading the Zlib header if
present: decompression will be done by @cfunc{inflate}.

The fields @samp{next_in}, @samp{avail_in}, @samp{zalloc}, @samp{zfree}
and @samp{opaque} must be initialized before by the call and may be
modified by this function.  @samp{next_out} and @samp{avail_out} are
left untouched, and they can be left uninitialized until the first call
to @cfunc{inflate}.

If @samp{next_in} is not @cnull{} and @samp{avail_in} is large enough
(the exact value depends on the compression method), this function
determines the compression method from the Zlib header and allocates all
data structures accordingly; otherwise the allocation will be deferred
to the first call of @cfunc{inflate}.

If @samp{zalloc} and @samp{zfree} are set to @cnull{}, this function
updates them to use default allocation functions.

This function returns:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory to initialize the stream structure.

@item Z_VERSION_ERROR
If the Zlib library version is incompatible with the version assumed by
the caller.
@end table

The @samp{msg} field is set to @cnull{} if there is no error message.
@end deftypefun


@deftypefun int inflate (z_streamp @var{strm}, int @var{flush})
Decompress as much data as possible, and stop when the input buffer
becomes empty or the output buffer becomes full.  It may introduce some
output latency (reading input without producing any output) except when
forced to flush.

The detailed semantics are as follows.  This function performs one or
both of the following actions:

@itemize
@item
Decompress more input starting at @samp{next_in} and update
@samp{next_in} and @samp{avail_in} accordingly.  If not all input can be
processed (because there is not enough room in the output buffer),
@samp{next_in} is updated and processing will resume at this point for
the next call of @cfunc{inflate}.

@item
Provide more output starting at @samp{next_out} and update
@samp{next_out} and @samp{avail_out} accordingly.  @cfunc{inflate}
provides as much output as possible, until there is no more input data
or no more space in the output buffer (see below about the flush
parameter).
@end itemize

Before the call of @samp{inflate}, the application should ensure that at
least one of the actions is possible, by providing more input and/or
consuming more output, and updating the @samp{next_*} and @samp{avail_*}
values accordingly.

The application can consume the uncompressed output when it wants, for
example when the output buffer is full (@samp{0 == avail_out}), or after
each call to this function.  If the return value is @samp{Z_OK} and
@samp{0 == avail_out}: this function must be called again after making
room in the output buffer because there might be more output pending.

When decompressing incoming chunks of data, this function should
normally be called with @var{flush} set to @samp{Z_NO_FLUSH} until it
returns @samp{Z_STREAM_END} or an error.

However, if the decompression is to be performed in a single step (a
single call of @cfunc{inflate}), @var{flush} should be set to
@samp{Z_FINISH}.  In this case all pending input is processed and all
pending output is flushed; @samp{avail_out} must be large enough to hold
all the uncompressed data.  (The size of the uncompressed data may have
been saved by the compressor for this purpose.)  The use of
@samp{Z_FINISH} is never required, but can be used to inform Zlib that a
faster approach may be used for the single call.

When the return value is @samp{Z_STREAM_END}: the next operation on this
stream must be @cfunc{inflateEnd} to deallocate the decompression state.

The other values of the @var{flush} parameter have the following
meaning:

@table @samp
@item Z_SYNC_FLUSH
Requests to flush as much output as possible to the output buffer.

@item Z_BLOCK
Requests to stop if and when the next deflate block boundary is reached:

@itemize
@item
when decoding the Zlib or Gzip format, this will cause an immediate
return after the header and before the first block;
@item
when doing a raw inflate, this function will go ahead and process the
first block, and will return when it gets to the end of that block, or
when it runs out of data.
@end itemize

@samp{Z_BLOCK} assists in appending to or combining deflate streams.
Also to assist in this, on return this function will set
@samp{data_type} to the number of unused bits in the last byte taken
from @samp{next_in}, plus 64 if this function is currently decoding the
last block in the deflate stream, plus 128 if @cfunc{inflate} returned
immediately after decoding an end--of--block code or decoding the
complete header up to just before the first byte of the deflate stream.
The end--of--block will not be indicated until all of the uncompressed
data from that block has been written to @samp{next_out}.

The number of unused bits may in general be greater than seven, except
when bit 7 of @samp{data_type} is set, in which case the number of
unused bits will be less than eight.
@end table

In this implementation, Zlib always flushes as much data as possible to
the output buffer, and always uses the faster approach on the first
call.  So the only effect of the flush parameter in this implementation
is on the return value of @cfunc{inflate}, as noted below, or when it
returns early because @samp{Z_BLOCK} is used.

If a preset dictionary is needed after this call (see
@cfunc{inflateSetDictionary}), @samp{adler} is set to the Adler32
checksum of the dictionary chosen by the compressor and returns
@samp{Z_NEED_DICT}; otherwise it sets @samp{adler} to the Adler32
checksum of all output produced so far (that is, @samp{total_out} bytes)
and returns @samp{Z_OK}, @samp{Z_STREAM_END} or an error code.

At the end of the stream, @cfunc{inflate} checks that its computed
Adler32 checksum is equal to that saved by the compressor and returns
@samp{Z_STREAM_END} only if the checksum is correct.

@cfunc{inflate} will decompress and check either Zlib--wrapped or
Gzip--wrapped deflate data.  The header type is detected automatically.
Any information contained in the Gzip header is not retained, so
applications that need that information should instead use raw inflate
(see @cfunc{inflateInit2}) or @cfunc{inflateBack} and perform their own
processing of the gzip header and trailer.

This function returns:

@table @samp
@item Z_OK
If some progress has been made (more input processed or more output
produced).

@item Z_STREAM_END
If the end of the compressed data has been reached and all uncompressed
output has been produced.

@item Z_NEED_DICT
If a preset dictionary is needed at this point.

@item Z_DATA_ERROR
If the input data was corrupted (input stream not conforming to the zlib
format or incorrect check value).

@item Z_STREAM_ERROR
If the stream structure was inconsistent (for example if @samp{next_in}
or @samp{next_out} was @cnull{}).

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_BUF_ERROR
If no progress is possible or if there was not enough room in the output
buffer when @samp{Z_FINISH} is used.
@end table

Note that @samp{Z_BUF_ERROR} is not fatal, and @cfunc{inflate} can be
called again with more input and more output space to continue
decompressing.  If @samp{Z_DATA_ERROR} is returned, the application may
then call @cfunc{inflateSync} to look for a good compression block if a
partial recovery of the data is desired.
@end deftypefun


@deftypefun int inflateEnd (z_streamp @var{stream})
Discard any unprocessed input and do not flush any pending output.  All
dynamically allocated data structures in @var{stream} are freed.  Return
@samp{Z_OK} if success, @samp{Z_STREAM_ERROR} if the stream state was
inconsistent.  In the error case: @samp{msg} may be set to a static
string (which must not be deallocated).
@end deftypefun

@c page
@node zlib advanced
@appendixsec Advanced functions


The functions described in this section are needed only in some special
applications.

@menu
* zlib advanced deflate::       Advanced compression functions.
* zlib advanced inflate::       Advanced decompression functions.
* zlib advanced inflate back::  Other advanced compression functions.
@end menu

@c page
@node zlib advanced deflate
@appendixsubsec Advanced Deflate


@deftypefun int deflateInit2 (z_streamp @var{strm}, int @var{level}, int @var{method}, int @var{windowBits}, int @var{memLevel}, int @var{strategy})
This is another version of @cfunc{deflateInit} with more compression
options.  This function does not perform any compression: Compression is
done by @cfunc{deflate}.

The fields @samp{next_in}, @samp{zalloc}, @samp{zfree} and @samp{opaque}
must be initialized before by the caller.

The @var{method} parameter is the compression method; it must be
@samp{Z_DEFLATED} in this version of the library.

The @var{windowBits} parameter is the base two logarithm of the window
size (the size of the history buffer).  It should be in the range
@math{[8, 15]} for this version of the library.  Larger values of this
parameter result in better compression at the expense of memory usage.
The default value is @math{15} if @cfunc{deflateInit} is used instead.

@var{windowBits} can also be @math{[-8, -15]} for raw deflate.  In this
case, @math{-@var{windowBits}} determines the window size.
@cfunc{deflate} will then generate raw deflate data with no Zlib header
or trailer, and will not compute an Adler32 check value.

@var{windowBits} can also be greater than @math{15} for optional Gzip
encoding.  Add @math{16} to @var{windowBits} to write a simple Gzip
header and trailer around the compressed data instead of a Zlib wrapper.
The Gzip header will have no file name, no extra data, no comment, no
modification time (set to zero), no header @acronym{CRC}, and the
operating system will be set to @math{255} (unknown).

The @var{memLevel} parameter specifies how much memory should be
allocated for the internal compression state.  @samp{1 == memLevel} uses
minimum memory but is slow and reduces compression ratio; @samp{9 ==
memLevel} uses maximum memory for optimal speed.  The default value is
@math{8}.  See @file{zconf.h} for total memory usage as a function of
@var{windowBits} and @var{memLevel}.

The strategy parameter is used to tune the compression algorithm.  Use
the value:

@table @samp
@item Z_DEFAULT_STRATEGY
For normal data.

@item Z_FILTERED
For data produced by a filter (or predictor).

@item Z_HUFFMAN_ONLY
To force Huffman encoding only (no string match).

@item Z_RLE
To limit match distances to one (run--length encoding).
@end table

Filtered data consists mostly of small values with a somewhat random
distribution.  In this case, the compression algorithm is tuned to
compress them better.  The effect of @samp{Z_FILTERED} is to force more
Huffman coding and less string matching; it is somewhat intermediate
between @samp{Z_DEFAULT} and @samp{Z_HUFFMAN_ONLY}.  @samp{Z_RLE} is
designed to be almost as fast as @samp{Z_HUFFMAN_ONLY}, but give better
compression for @acronym{PNG} image data.  The strategy parameter only
affects the compression ratio but not the correctness of the compressed
output even if it is not set appropriately.

Return values are:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_STREAM_ERROR
If a parameter is invalid (such as an invalid method).
@end table

The @samp{msg} field of the stream structure is set to null if there is
no error message.
@end deftypefun


@deftypefun int deflateSetDictionary (z_streamp @var{strm}, const Bytef * @var{dictionary}, uInt @var{dictLength})
Initialize the compression dictionary from the given byte sequence
without producing any compressed output.

This function must be called immediately after @cfunc{deflateInit},
@cfunc{deflateInit2} or @cfunc{deflateReset}, before any call of
@cfunc{deflate}.  The compressor and decompressor must use exactly the
same dictionary (see @cfunc{inflateSetDictionary}).

The dictionary should consist of strings (byte sequences) that are
likely to be encountered later in the data to be compressed, with the
most commonly used strings preferably put towards the end of the
dictionary.  Using a dictionary is most useful when the data to be
compressed is short and can be predicted with good accuracy; the data
can then be compressed better than with the default empty dictionary.

Depending on the size of the compression data structures selected by
@cfunc{deflateInit} or @cfunc{deflateInit2}, a part of the dictionary
may in effect be discarded, for example if the dictionary is larger than
the window size in @cfunc{deflate} or @cfunc{deflate2}.  Thus the
strings most likely to be useful should be put at the end of the
dictionary, not at the front.

Upon return of this function, @samp{adler} is set to the Adler32 value
of the dictionary; the decompressor may later use this value to
determine which dictionary has been used by the compressor.  (The
Adler32 value applies to the whole dictionary even if only a subset of
the dictionary is actually used by the compressor.)  If a raw deflate
was requested, then the Adler32 value is not computed and @samp{adler}
is not set.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If a parameter is invalid (such as @cnull{} dictionary) or the stream
state is inconsistent (for example if @cfunc{deflate} has already been
called for this stream or if the compression method is bsort).
@end table
@end deftypefun


@deftypefun int deflateCopy (z_streamp @var{dest}, z_streamp @var{source})
Set the destination stream as a complete copy of the source stream.

This function can be useful when several compression strategies will be
tried, for example when there are several ways of pre--processing the
input data with a filter.  The streams that will be discarded should
then be freed by calling @cfunc{deflateEnd}.  Note that
@cfunc{deflateCopy} duplicates the internal compression state which can
be quite large, so this strategy is slow and can consume lots of memory.

Return values are:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_STREAM_ERROR
If the source stream state was inconsistent (such as @samp{zalloc} being
@cnull{}).
@end table

The @samp{msg} field of the stream structure is left unchanged in both
source and destination.
@end deftypefun


@deftypefun int deflateReset (z_streamp @var{strm})
This function is equivalent to @cfunc{deflateEnd} followed by
@cfunc{deflateInit}, but does not free and reallocate all the
internal compression state.  The stream will keep the same compression
level and any other attributes that may have been set by
@cfunc{deflateInit2}.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If the source stream state was inconsistent (such as @samp{zalloc} or
state being @cnull{}).
@end table
@end deftypefun


@deftypefun int deflateParams (z_streamp @var{strm}, int @var{level}, int @var{strategy})
Dynamically update the compression level and compression strategy.  The
interpretation of level and strategy is as in @cfunc{deflateInit2}.
This can be used to switch between compression and straight copy of the
input data, or to switch to a different kind of input data requiring a
different strategy.  If the compression level is changed, the input
available so far is compressed with the old level (and may be flushed);
the new level will take effect only at the next call of @cfunc{deflate}.

Before the call of @cfunc{deflateParams}, the stream state must be set
as for a call of @cfunc{deflate}, since the currently available input
may have to be compressed and flushed.  In particular, @samp{avail_out}
must be non--zero.

Return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If the source stream @samp{state} was inconsistent or if a parameter was
invalid.

@item Z_BUF_ERROR
If @samp{avail_out} was zero.
@end table
@end deftypefun


@deftypefun int deflateTune (z_streamp @var{strm}, int @var{good_length}, int @var{max_lazy}, int @var{nice_length}, int @var{max_chain})
Fine tune deflate's internal compression parameters.  This should only
be used by someone who understands the algorithm used by Zlib's deflate
for searching for the best matching string, and even then only by the
most fanatic optimizer trying to squeeze out the last compressed bit for
their specific input data.

Read the @file{deflate.c} source code for the meaning of the
@var{max_lazy}, @var{good_length}, @var{nice_length}, and
@var{max_chain} parameters.

This function can be called after @cfunc{deflateInit} or
@cfunc{deflateInit2}, and returns:

@table @samp
@item Z_OK
On success.

@item Z_STREAM_ERROR
For an invalid deflate stream.
@end table
@end deftypefun


@deftypefun uLong deflateBound (z_streamp @var{strm}, uLong @var{sourceLen})
Returns an upper bound on the compressed size after deflation of
@var{sourceLen} bytes.  It must be called after @cfunc{deflateInit}
or @cfunc{deflateInit2}.  This would be used to allocate an output
buffer for deflation in a single pass, and so would be called before
@cfunc{deflate}.
@end deftypefun


@deftypefun int deflatePrime (z_streamp @var{strm}, int @var{bits}, int @var{value})
Inserts bits in the deflate output stream.  The intent is that this
function is used to start off the deflate output with the bits leftover
from a previous deflate stream when appending to it.  As such, this
function can only be used for raw deflate, and must be used before the
first @cfunc{deflate} call after a @cfunc{deflateInit2} or
@cfunc{deflateReset}.  @var{bits} must be less than or equal to 16,
and that many of the least significant bits of @var{value} will be
inserted in the output.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If the source stream state was inconsistent.
@end table
@end deftypefun


@deftypefun int deflateSetHeader (z_streamp @var{strm}, gz_headerp @var{head})
Provide Gzip header informations for when a Gzip stream is requested by
@cfunc{deflateInit2}.  This function may be called after
@cfunc{deflateInit2} or @cfunc{deflateReset} and before the first call
of @cfunc{deflate}.

The @samp{text}, @samp{time}, @samp{os}, @samp{extra}, @samp{name}, and
@samp{comment} fields in the provided @samp{gz_header} structure are
written to the Gzip header (@samp{xflags} is ignored, the @samp{extra}
flags are set according to the compression level).

The caller must assure that, if not @cnull{}, @samp{name} and
@samp{comment} are terminated with a zero byte, and that if @samp{extra}
is not @cnull{}, that @samp{extra_len} bytes are available there.

If @samp{hcrc} is true, a Gzip header crc is included.

Note that the current versions of the command--line version of
@command{gzip} (up through version 1.3.x) does not support header crc's,
and will report that it is a ``multi--part gzip file'' and give up.

If this function is not used, the default Gzip header has @samp{text}
false, the @samp{time} set to zero, and @samp{os} set to 255, with no
@samp{extra}, @samp{name}, or @samp{comment} fields.

The Gzip header is returned to the default state by
@cfunc{deflateReset}.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If the source stream state was inconsistent.
@end table
@end deftypefun

@c page
@node zlib advanced inflate
@appendixsubsec Advanced Inflate


@deftypefun int inflateInit2 (z_streamp @var{strm}, int @var{windowBits})
This is another version of @cfunc{inflateInit} with an extra parameter.
This function does not perform any decompression apart from reading the
Zlib header if present (so @samp{next_in} and @samp{avail_in} may be
modified, but @samp{next_out} and @samp{avail_out} are unchanged).

The fields @samp{next_in}, @samp{avail_in}, @samp{zalloc}, @samp{zfree}
and @samp{opaque} must be initialized before by the caller.

The @var{windowBits} parameter is the base two logarithm of the maximum
window size (the size of the history buffer).  It should be in the range
8..15 for this version of the library.  The default value is 15 if
@cfunc{inflateInit} is used instead.  @var{windowBits} must be greater
than or equal to the @var{windowBits} value provided to
@cfunc{deflateInit2} while compressing, or it must be equal to 15 if
@cfunc{deflateInit2} was not used.  If a compressed stream with a larger
window size is given as input, @cfunc{inflate} will return with the
error code @samp{Z_DATA_ERROR} instead of trying to allocate a larger
window.

@var{windowBits} can also be -8..-15 for raw inflate.  In this case,
@samp{-@var{windowBits}} determines the window size.  @cfunc{inflate}
will then process raw deflate data, not looking for a Zlib or Gzip
header, not generating a check value, and not looking for any check
values for comparison at the end of the stream.  This is for use with
other formats that use the deflate compressed data format such as
@acronym{ZIP}.  Those formats provide their own check values.  If a
custom format is developed using the raw deflate format for compressed
data, it is recommended that a check value such as an Adler32 or a crc32
be applied to the uncompressed data as is done in the Zlib, Gzip, and
@acronym{ZIP} formats.  For most applications, the Zlib format should be
used as is.  Note that comments above on the use in @cfunc{deflateInit2}
applies to the magnitude of @var{windowBits}.

@var{windowBits} can also be greater than 15 for optional Gzip decoding.
Add 32 to @var{windowBits} to enable Zlib and Gzip decoding with
automatic header detection, or add 16 to decode only the Gzip format
(the Zlib format will return a @samp{Z_DATA_ERROR}).

Return values are:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_STREAM_ERROR
If a parameter is invalid (such as a negative @var{memLevel}).
@end table

The @samp{msg} field of the stream structure is set to @cnull{} if
there is no error message.
@end deftypefun


@deftypefun int inflateSetDictionary (z_streamp @var{strm}, const Bytef * @var{dictionary}, uInt @var{dictLength})
Initializes the decompression dictionary from the given uncompressed
byte sequence.  This function must be called immediately after a call of
@cfunc{inflate} if this call returned @samp{Z_NEED_DICT}.  The
dictionary chosen by the compressor can be determined from the Adler32
value returned by this call of @cfunc{inflate}.  The compressor and
decompressor must use exactly the same dictionary (see
@cfunc{deflateSetDictionary}).

Return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If a parameter is invalid (such as @cnull{} dictionary) or the stream
@samp{state} is inconsistent.

@item Z_DATA_ERROR
If the given dictionary doesn't match the expected one (incorrect
Adler32 value).
@end table
@end deftypefun


@deftypefun int inflateSync (z_streamp @var{strm})
Skips invalid compressed data until a full flush point (see above the
description of @cfunc{deflate} with @samp{Z_FULL_FLUSH}) can be found,
or until all available input is skipped.  No output is provided.

@cfunc{inflateSync} returns:

@table @samp
@item Z_OK
If a full flush point has been found.

@item Z_BUF_ERROR
If no more input was provided.

@item Z_DATA_ERROR
If no flush point has been found.

@item Z_STREAM_ERROR
If the stream structure was inconsistent.
@end table

In the success case, the application may save the current current value
of @samp{total_in} which indicates where valid compressed data was
found.  In the error case, the application may repeatedly call
@cfunc{inflateSync}, providing more input each time, until success or
end of the input data.
@end deftypefun


@deftypefun int inflateCopy (z_streamp @var{dest}, z_streamp @var{source})
Sets the destination stream as a complete copy of the source stream.

This function can be useful when randomly accessing a large stream.  The
first pass through the stream can periodically record the inflate state,
allowing restarting inflate at those points when randomly accessing the
stream.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_STREAM_ERROR
If the source stream state was inconsistent (such as @samp{zalloc} being
@cnull{}).
@end table

The @samp{msg} field of the stream structure is left unchanged in both
source and destination.
@end deftypefun


@deftypefun int inflateReset (z_streamp @var{strm})
This function is equivalent to @cfunc{inflateEnd} followed by
@cfunc{inflateInit}, but does not free and reallocate all the internal
decompression @samp{state}.  The stream will keep attributes that may
have been set by @cfunc{inflateInit2}.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If the source stream @samp{state} was inconsistent (such as
@samp{zalloc} or @samp{state} being @cnull{}).
@end table
@end deftypefun


@deftypefun int inflatePrime (z_streamp @var{strm}, int @var{bits}, int @var{value})
Insert bits in the inflate input stream.  The intent is that this
function is used to start inflating at a bit position in the middle of a
byte.  The provided bits will be used before any bytes are used from
@samp{next_in}.

This function should only be used with raw inflate, and should be used
before the first @cfunc{inflate} call after @cfunc{inflateInit2} or
@cfunc{inflateReset}.

@var{bits} must be less than or equal to 16, and that many of the
@strong{least} significant bits of @var{value} will be inserted in the
input.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If the source stream state was inconsistent.
@end table
@end deftypefun


@deftypefun int inflateGetHeader (z_streamp @var{strm}, gz_headerp @var{head})
Request that Gzip header informations be stored in the provided
@samp{gz_header} structure.  This function may be called after
@cfunc{inflateInit2} or @cfunc{inflateReset}, and before the first call
of @cfunc{inflate}.

As @cfunc{inflate} processes the Gzip stream, @samp{@var{head}->done} is
zero until the header is completed, at which time
@samp{@var{head}->done} is set to 1.

If a Zlib stream is being decoded, then @samp{@var{head}->done} is set
to -1 to indicate that there will be no Gzip header information
forthcoming.  Note that @samp{Z_BLOCK} can be used to force
@cfunc{inflate} to return immediately after header processing is
complete and before any actual data is decompressed.

The @samp{text}, @samp{time}, @samp{xflags}, and @samp{os} fields are
filled in with the Gzip header contents.  @samp{hcrc} is set to true if
there is a header @acronym{CRC}.  (The header @acronym{CRC} was valid if
done is set to one.)

If @samp{extra} is not @cnull{}, then @samp{extra_max} contains the
maximum number of bytes to write to @samp{extra}.

Once @samp{done} is true, @samp{extra_len} contains the actual extra
field length, and @samp{extra} contains the extra field, or that field
truncated if @samp{extra_max} is less than @samp{extra_len}.

If @samp{name} is not @cnull{}, then up to @samp{name_max} characters
are written there, terminated with a zero unless the length is greater
than @samp{name_max}.

If @samp{comment} is not @cnull{}, then up to @samp{comm_max}
characters are written there, terminated with a zero unless the length
is greater than @samp{comm_max}.

When any of @samp{extra}, @samp{name}, or @samp{comment} are not
@cnull{} and the respective field is not present in the header, then
that field is set to @cnull{} to signal its absence.  This allows the
use of this function with the returned structure to duplicate the
header.  However if those fields are set to allocated memory, then the
application will need to save those pointers elsewhere so that they can
be eventually freed.

If this function is not used, then the header information is simply
discarded.  The header is always checked for validity, including the
header @acronym{CRC} if present.  @cfunc{inflateReset} will reset the
process to discard the header information.  The application would need
to call this function again to retrieve the header from the next Gzip
stream.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_STREAM_ERROR
If the source stream state was inconsistent.
@end table
@end deftypefun

@c page
@node zlib advanced inflate back
@appendixsubsec Other advanced compression functions


@deftypefun int inflateBackInit (z_stream * @var{strm}, int @var{windowBits}, unsigned char  * @var{window})
Initialize the internal stream state for decompression using
@cfunc{inflateBack} calls.

The fields @samp{zalloc}, @samp{zfree} and @samp{opaque} in @var{strm}
must be initialized before the call.  If @samp{zalloc} and @samp{zfree}
are @samp{Z_NULL}, then the default library--derived memory allocation
routines are used.

@var{windowBits} is the base two logarithm of the window size, in the
range 8..15.  @var{window} is a caller supplied buffer of that size.
Except for special applications where it is assured that @cfunc{deflate}
was used with small window sizes, @var{windowBits} must be 15 and a 32K
byte @var{window} must be supplied to be able to decompress general
deflate streams.

See @cfunc{inflateBack} for the usage of these routines.

@cfunc{inflateBackInit} will return:

@table @samp
@item Z_OK
On success.

@item Z_STREAM_ERROR
If any of the paramaters are invalid.

@item Z_MEM_ERROR
If the internal state could not be allocated.

@item Z_VERSION_ERROR
If the version of the library does not match the version of the header
file.
@end table
@end deftypefun


@deftp {Function Typedef} in_func
Type definition for pointers to functions with signature:

@example
unsigned f (void *, unsigned char **)
@end example
@end deftp


@deftp {Function Typedef} out_func
Type definition for pointers to functions with signature:

@example
int f (void *, unsigned char *, unsigned)
@end example
@end deftp


@deftypefun int inflateBack (z_stream * @var{strm}, in_func @var{in}, void * @var{in_desc}, out_func @var{out}, void * @var{out_desc})
Does a raw inflate with a single call using a call--back interface for
input and output.  This is more efficient than @cfunc{inflate} for file
I/O applications in that it avoids copying between the output and the
sliding window by simply making the window itself the output buffer.
This function trusts the application to not change the output buffer
passed by the output function, at least until @cfunc{inflateBack}
returns.

@cfunc{inflateBackInit} must be called first to allocate the internal
state and to initialize the state with the user--provided window buffer.
This function may then be used multiple times to inflate a complete, raw
deflate stream with each call.  @cfunc{inflateBackEnd} is then called to
free the allocated state.

A raw deflate stream is one with no Zlib or Gzip header or trailer.
This routine would normally be used in a utility that reads
@acronym{ZIP} or Gzip files and writes out uncompressed files.  The
utility would decode the header and process the trailer on its own,
hence this routine expects only the raw deflate stream to decompress.
This is different from the normal behavior of @cfunc{inflate}, which
expects either a Zlib or Gzip header and trailer around the deflate
stream.

This function uses two subroutines supplied by the caller that are then
invoked for input and output.  The routines are called until a complete
deflate stream is read and all of the uncompressed data is written, or
until an error is encountered.  The routintes' parameters and return
types are defined above in the @samp{in_func} and @samp{out_func}
typedefs.

This function will call @samp{@var{in}(in_desc, &buf)} which should
return the number of bytes of provided input, and a pointer to that
input in @var{buf}.  If there is no input available, @var{in} must
return zero (@samp{buf} is ignored in that case) and this function will
return a buffer error.

This function will call @samp{@var{out}(out_desc, buf, len)} to write
the uncompressed data @samp{buf[0..len-1]}.  @var{out} should return
zero on success, or non--zero on failure.  If @var{out} returns
non--zero, this function will return with an error.

Neither @var{in} nor @var{out} are permitted to change the contents of
the window provided to @cfunc{inflateBackInit}, which is also the buffer
that @var{out} uses to write to.  The length written by @var{out} will
be at most the window size.  Any non--zero amount of input may be
provided by @var{in}.

For convenience, input can be provided to this function on the first
call by setting @samp{next_in} and @samp{avail_in}.  If that input is
exhausted, then @var{in} will be called.  Therefore @var{next_in} must
be initialized before calling this function: if @samp{next_in} is
@cnull{}, then @var{in} will be called immediately for input; if
@samp{next_in} is not @cnull{}, then @samp{avail_in} must also be
initialized, and then if @samp{avail_in} is not zero, input will
initially be taken from @samp{next_in[0 .. avail_in - 1]}.

The @var{in_desc} and @var{out_desc} parameters are passed as the first
argument to @var{in} and @var{out} respectively when they are called.
These descriptors can be optionally used to pass any information that
the caller--supplied @var{in} and @var{out} functions need to do their
job.

On return, @samp{next_in} and @samp{avail_in} will be set to pass back
any unused input that was provided by the last @var{in} call.

Note that this function cannot return @samp{Z_OK}.  The return values
are:

@table @samp
@item Z_STREAM_END
On success.

@item Z_BUF_ERROR
If @var{in} or @var{out} returned an error.

@item Z_DATA_ERROR
If there was a format error in the deflate stream (in which case
@samp{msg} is set to indicate the nature of the error).

@item Z_STREAM_ERROR
If the stream was not properly initialized.
@end table

In the case of @samp{Z_BUF_ERROR}, an input or output error can be
distinguished using @samp{next_in} which will be @cnull{} only if
@var{in} returned an error.  If @samp{next_in} is not @cnull{}, then the
@samp{Z_BUF_ERROR} was due to @var{out} returning non--zero (@var{in}
will always be called before @var{out}, so @samp{next_in} is assured to
be defined if @var{out} returns non--zero).
@end deftypefun


@deftypefun int inflateBackEnd (z_stream * @var{strm})
All memory allocated by @cfunc{inflateBackInit} is freed.  Return
@samp{Z_OK} on success, or @samp{Z_STREAM_ERROR} if the stream state was
inconsistent.
@end deftypefun

@c page
@node zlib utility
@appendixsec Utility functions


The following utility functions are implemented on top of the basic
stream--oriented functions.  To simplify the interface, some default
options are assumed (compression level and memory usage, standard memory
allocation functions).  The source code of these utility functions can
easily be modified if you need special options.


@deftypefun int compress (Bytef * @var{dstPtr}, uLongf * @var{dstLenVar}, const Bytef * @var{srcPtr}, uLong @var{srcLen})
Compress the source buffer into the destination buffer.  It is a wrapper
for the triplet @cfunc{deflateInit}, @cfunc{deflate},
@cfunc{deflateEnd}.

@var{srcLen} must be the byte length of the source buffer; @var{srcPtr}
must be the pointer to the source buffer, at least @var{srclen} bytes
wide.

Upon entry: @var{dstLenVar} must reference a variable holding be the
total size of the destination buffer, which (to avoid
@samp{Z_BUF_ERROR}) should be at least the value returned by
@cfunc{compressBound}). @var{dstPtr} must be the pointer to the
destination buffer, at least @var{dstLen} bytes wide.

Upon exit: The variable referenced by @var{dstLenVar} is modified to
hold the actual size of the compressed buffer.

The return value is:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_BUF_ERROR
If there was not enough room in the output buffer.

@item ...
Other error codes may be returned to signal invalid data.
@end table
@end deftypefun


@deftypefun int compress2 (Bytef * @var{dstPtr}, uLongf * @var{dstLenVar}, const Bytef * @var{srcPtr}, uLong @var{srcLen}, int @var{level})
Like @cfunc{compress} but allows the user to select a compression level.
@var{level} has the same meaning as in @cfunc{deflateInit}.  The return
values are the same as in @cfunc{compress}; @samp{Z_STREAM_ERROR} is
returned if @var{level} has an invalid value.
@end deftypefun


@deftypefun uLong compressBound (uLong @var{sourceLen})
Returns an upper bound on the compressed size after @cfunc{compress} or
@cfunc{compress2} on @var{sourceLen} bytes.  It would be used before a
@cfunc{compress} or @cfunc{compress2} call to allocate the destination
buffer.
@end deftypefun


@deftypefun int uncompress (Bytef * @var{dstPtr}, uLongf * @var{dstLenVar}, const Bytef * @var{srcPtr}, uLong @var{srcLen})
Decompress the source buffer into the destination buffer.
@cfunc{uncompress} is a wrapper for the triplet @cfunc{inflateInit},
@cfunc{inflate}, @cfunc{inflateEnd}.

@var{srcLen} must be the byte length of the source buffer; @var{srcPtr}
must be a pointer to the source buffer, at least @var{srcLen} bytes
wide.

Upon entry: @var{dstLenVar} must reference a variable holding the total
size of the destination buffer.  @var{dstPtr} must be the pointer to the
destination buffer, at least @var{dstLen} bytes wide.

Upon exit: The variable referenced by @var{dstLenVar} is modified to
hold the actual size of the compressed buffer.

The return values are:

@table @samp
@item Z_OK
If success.

@item Z_MEM_ERROR
If there was not enough memory.

@item Z_BUF_ERROR
If there was not enough room in the output buffer.

@item Z_DATA_ERROR
If the input data was corrupted or incomplete.

@item ...
Other codes may be returned to signal invalid data.
@end table

To avoid the @samp{Z_BUF_ERROR}: The size of the uncompressed data must
have been saved previously by the compressor and transmitted to the
decompressor by some mechanism outside the scope of this compression
library.  That size then can be used to allocate the output buffer.
@end deftypefun

@c page
@node zlib file
@appendixsec Compressed file functions


@menu
* zlib file open::              Opening and closing a compressed file.
* zlib file write::             Writing data to a compressed file.
* zlib file read::              Reading data from a compressed file.
* zlib file seek::              Moving the file position.
* zlib file config::            Configuring a file descriptor.
* zlib file errors::            Examining errors in file operartions.
@end menu

@c page
@node zlib file open
@appendixsubsec Opening and closing a compressed file


@deftypefun gzFile gzopen (const char * @var{path}, const char * @var{mode})
Open a Gzip file for reading or writing.

The @var{mode} parameter is as in the standard @cfunc{fopen} (@samp{rb}
or @samp{wb}) but can also include a compression level (@samp{wb9}) or a
strategy:

@table @samp
@item f
For filtered data as in @samp{wb6f}.

@item h
For Huffman only compression as in @samp{wb1h}.

@item R
For run--length encoding as in @samp{wb1R}.
@end table

@ref{zlib basic deflate}, for details on the strategy parameter.

The function can be used to read a file which is not in Gzip format; in
this case the file will be read directly without decompression.

The return value is @cnull{} if the file could not be opened or if
there was insufficient memory to allocate the (de)compression state;
@samp{errno} can be checked to distinguish the two cases: if
@samp{errno} is zero, the Zlib error is @samp{Z_MEM_ERROR}.
@end deftypefun


@deftypefun gzFile gzdopen (int @var{fd}, const char * @var{mode})
Associate a @samp{gzFile} with the file descriptor @var{fd}.

File descriptors are obtained from calls like @cfunc{open}, @cfunc{dup},
@cfunc{creat}, @cfunc{pipe} or @cfunc{fileno} if the file has been
previously opened with @cfunc{fopen}.

The @var{mode} parameter is as in @cfunc{gzopen}.

The next call of @cfunc{gzclose} on the returned @samp{gzFile} will also
close the file descriptor @var{fd}, just like:

@example
fclose(fdopen(fd), mode);
@end example

@noindent
closes the file descriptor @var{fd}.  If we want to keep @var{fd} open,
we use:

@example
gzdopen(dup(fd), mode);
@end example

@cfunc{gzdopen} returns @cnull{} if there was insufficient memory
to allocate the (de)compression state.
@end deftypefun


@deftypefun int gzclose (gzFile @var{file})
Flush all pending output if necessary, close the compressed file and
deallocate all the (de)compression state.  The return value is the Zlib
error number (@ref{zlib file errors} for details).
@end deftypefun


@deftypefun int gzdirect (gzFile @var{file})
Return 1 if @var{file} is being read directly without decompression,
otherwise zero.
@end deftypefun

@c page
@node zlib file write
@appendixsubsec Writing data to a compressed file


@deftypefun int gzwrite (gzFile @var{file}, void * @var{buf}, unsigned @var{len})
Write the given number of uncompressed bytes into the compressed file.
The return value is the number of uncompressed bytes actually written
(@samp{0} in case of error).
@end deftypefun


@deftypefun int gzprintf (gzFile @var{file}, const char * @var{format}, ...)
Convert, format, and write the args to the compressed file under control
of the @var{format} string, as in @cfunc{fprintf}.  The return value is
the number of uncompressed bytes actually written (@samp{0} in case of
error).

The number of uncompressed bytes written is limited to 4095.  The caller
should assure that this limit is not exceeded.  If it is exceeded, then
@cfunc{gzprintf} will return return an error with nothing written.  In
this case, there may also be a buffer overflow with unpredictable
consequences, which is possible only if Zlib was compiled with the
insecure functions @cfunc{sprintf} or @cfunc{vsprintf} because the
secure @cfunc{snprintf} or @cfunc{vsnprintf} functions were not
available.
@end deftypefun


@deftypefun int gzputs (gzFile @var{file}, const char * @var{s})
Write the given zero terminated string to the compressed file, excluding
the terminating zero character.  The return value is the number of
characters written, or @samp{-1} in case of error.
@end deftypefun


@deftypefun int gzputc (gzFile @var{file}, int @var{c})
Write @var{c}, converted to an @samp{unsigned char}, into the compressed
file.  The return value is the value that was written, or @samp{-1} in
case of error.
@end deftypefun


@deftypefun int gzflush (gzFile @var{file}, int @var{flush})
Flush all pending output into the compressed file.  The parameter
@var{flush} is as in the @cfunc{deflate} function.  The return value is
the Zlib error number (@ref{zlib file errors} for details).  The return
value is @samp{Z_OK} if the flush parameter is @samp{Z_FINISH} and all
output could be flushed.

This function should be called only when strictly necessary because it
can degrade compression.
@end deftypefun

@c page
@node zlib file read
@appendixsubsec Reading data from a compressed file


@deftypefun int gzread (gzFile @var{file}, voidp @var{buf}, unsigned @var{len})
Read the given number of uncompressed bytes from the compressed file.
If the input file was not in gzip format, this function copies the given
number of bytes into the buffer.

The return value is the number of uncompressed bytes actually read:
@samp{0} for end of file, @samp{-1} for error.
@end deftypefun


@deftypefun {char *} gzgets (gzFile @var{file}, char * @var{buf}, int @var{len})
Read bytes from the compressed file until @math{@var{len}-1} characters
are read, or a newline character is read and transferred to buf, or an
end--of--file condition is encountered.  The string is then terminated
with a null character.  The return value is @var{buf}, or @samp{Z_NULL}
in case of error.
@end deftypefun


@deftypefun int gzgetc (gzFile @var{file})
Read one byte from the compressed file.  The return value is this byte
or @samp{-1} in case of end--of--file or error.
@end deftypefun


@deftypefun int gzungetc (int @var{c}, gzFile @var{file})
Push one character back onto the stream to be read again later.  Only
one character of push--back is allowed.  @cfunc{gzungetc} returns the
character pushed, or @samp{-1} on failure.  @cfunc{gzungetc} will fail
if a character has been pushed but not read yet, or if @var{c} is
@samp{-1}.  The pushed character will be discarded if the stream is
repositioned with @cfunc{gzseek} or @cfunc{gzrewind}.
@end deftypefun


@deftypefun int gzeof (gzFile @var{file})
Return @samp{1} when end--of--file has previously been detected reading
the given input stream, otherwise zero.
@end deftypefun

@c page
@node zlib file seek
@appendixsubsec Moving the file position


@deftypefun z_off_t gzseek (gzFile @var{file}, z_off_t @var{offset}, int @var{whence})
Set the starting position for the next read or write operation on the
given compressed file.  The @var{offset} represents a number of bytes in
the uncompressed data stream.  The @var{whence} parameter is defined as
in @cfunc{lseek}; the value @samp{SEEK_END} is not supported.

If the file is opened for reading, this function is emulated but can be
extremely slow.  If the file is opened for writing, only forward seeks
are supported; the function then compresses a sequence of zeroes up to
the new starting position.

The return value is the resulting offset location as measured in bytes
from the beginning of the uncompressed stream, or @samp{-1} in case of
error: in particular if the file is opened for writing and the new
starting position would be before the current position.
@end deftypefun


@deftypefun int gzrewind (gzFile @var{file})
Rewind the given file.  This function is supported only for reading.  A
call to this function is equivalent to:

@example
(int) gzseek(file, 0L, SEEK_SET);
@end example
@end deftypefun


@deftypefun z_off_t gztell (gzFile @var{file})
Return the starting position for the next read or write operation on the
given compressed file.  This position represents a number of bytes in
the uncompressed data stream.

A call to this function is equivalent to:

@example
gzseek(file, 0L, SEEK_CUR);
@end example
@end deftypefun

@c page
@node zlib file config
@appendixsubsec Configuring a file descriptor


@deftypefun int gzsetparams (gzFile @var{file}, int @var{level}, int @var{strategy})
Dynamically update the compression level or strategy.  For the meaning
of these parameters @ref{zlib advanced deflate, deflateInit2}.  Return
@samp{Z_OK} if success, or @samp{Z_STREAM_ERROR} if the file was not
opened for writing.
@end deftypefun

@c page
@node zlib file errors
@appendixsubsec Examining errors in file operartions


@deftypefun {const char *} gzerror (gzFile @var{file}, int * @var{errnum})
Return the error message for the last error which occurred on the given
compressed file.  The variable referenced by @var{errnum} is set to the
Zlib error number.  If an error occurred in the file system and not in
the compression library, @samp{*@var{errnum}} is set to @samp{Z_ERRNO}
and the application may consult the standard variable @samp{errno} to
get the exact error code.

Example:

@example
#include <errno.h>
#include <string.h>
#include <zlib.h>


gzFile      descriptor;
char *      errorString;
int         errorCode;

...

errorString = gzerror(descriptor, &errorCode);
if (Z_ERRNO == errorCode)
  @{
     errorString = strerror(errno);
  @}
@end example
@end deftypefun


@deftypefun void gzclearerr (gzFile file)
Clear the error and end--of--file flags for file.  This is analogous to
the @cfunc{clearerr} function in @file{stdio.h}.  This is useful for
continuing to read a @samp{gzip} file that is being written
concurrently.
@end deftypefun

@c page
@node zlib checksum
@appendixsec Checksum functions


These functions are not related to compression but are exported anyway
because they might be useful in applications using the compression
library.


@deftypefun uLong adler32 (uLong @var{adler}, const Bytef * @var{buf}, uInt @var{len})
Update a running Adler--32 checksum with the bytes
@math{@var{buf}[0..@var{len}-1]} and return the updated checksum.  If
@var{buf} is @code{NULL}, this function returns the required initial
value for the checksum.

An Adler--32 checksum is almost as reliable as a @acronym{CRC32} but can
be computed much faster.  Usage example:

@example
uLong adler = adler32(0L, Z_NULL, 0);

while (read_buffer(buffer, length) != EOF)
  @{
    adler = adler32(adler, buffer, length);
  @}
if (adler != original_adler) error();
@end example
@end deftypefun


@deftypefun uLong adler32_combine (uLong @var{adler1}, uLong @var{adler2}, z_off_t @var{len2})
Combine two Adler--32 checksums into one.  For two sequences of bytes,
@var{seq1} and @var{seq2} with lengths @var{len1} and @var{len2},
Adler--32 checksums were calculated for each, @var{adler1} and
@var{adler2}.  Return the Adler--32 checksum of @var{seq1} and
@var{seq2} concatenated, requiring only @var{adler1}, @var{adler2}, and
@var{len2}.
@end deftypefun


@deftypefun uLong crc32 (uLong @var{crc}, const Bytef * @var{buf}, uInt @var{len})
Update a running crc with the bytes @math{@var{buf}[0..len-1]} and
return the updated crc. If buf is @cnull{}, this function returns the
required initial value for the crc.  Pre-- and post--conditioning (one's
complement) is performed within this function so it shouldn't be done by
the application.

Usage example:

@example
uLong crc = crc32(0L, Z_NULL, 0);

while (read_buffer(buffer, length) != EOF)
  @{
    crc = crc32(crc, buffer, length);
  @}
if (crc != original_crc) error();
@end example
@end deftypefun


@deftypefun uLong crc32_combine (uLong @var{crc1}, uLong @var{crc2}, z_off_t @var{len2})
Combine two @acronym{CRC-32} check values into one.  For two sequences
of bytes, @var{seq1} and @var{seq2} with lengths @var{len1} and
@var{len2}, @acronym{CRC-32} check values were calculated for each,
@var{crc1} and @var{crc2}.  Return the @acronym{CRC-32} check value of
@var{seq1} and @var{seq2} concatenated, requiring only @var{crc1},
@var{crc2}, and @var{len2}.
@end deftypefun

@c page
@node zlib misc
@appendixsec Miscellaneous functions


@cfunc{deflateInit} and @cfunc{inflateInit} are macros to allow
checking the Zlib version and the compiler's view of @samp{z_stream}.


@deftypefun {const char *} zlibVersion (void)
The application can compare the return value of this function and
@samp{ZLIB_VERSION} for consistency.  If the first character differs,
the library code actually used is not compatible with the @file{zlib.h}
header file used by the application.  This check is automatically made
by @cfunc{deflateInit} and @cfunc{inflateInit}.
@end deftypefun


@deftypefun {const char *} zError (int @var{err})
Converts an error code to string; exported for @cfunc{compress},
@cfunc{compress2} and @cfunc{uncompress}.
@end deftypefun


@deftypefun int inflateSyncPoint (z_streamp @var{z})
No description.
@end deftypefun


@deftypefun {const uLongf *} get_crc_table (void)
No description.
@end deftypefun


@deftypefun uLong zlibCompileFlags (void)
Return flags indicating compile--time options.

Type sizes: each field is two bits wide, @samp{00} means the size is 16
bits, @samp{01} means the size is 32 bits, @samp{10} means 64, @samp{11}
means other. Position of bits follows:

@table @samp
@item 1.0
Size of @samp{uInt} (bit one and bit zero).

@item 3.2
Size of @samp{uLong}.

@item 5.4
Size of @samp{voidpf} (pointer).

@item 7.6
Size of @samp{z_off_t}.
@end table

Compiler, assembler, and debug options:

@table @samp
@item 8
@samp{DEBUG}

@item 9
@samp{ASMV} or @samp{ASMINF}, use ASM code;

@item 10
@samp{ZLIB_WINAPI}, exported functions use the @acronym{WINAPI} calling
convention;

@item 11
0 (reserved).
@end table

One--time table building (smaller code, but not thread--safe if true):

@table @samp
@item 12
@samp{BUILDFIXED}, build static block decoding tables when needed;

@item 13
@samp{DYNAMIC_CRC_TABLE}, build @acronym{CRC} calculation tables when
needed;

@item 14,15
0 (reserved).
@end table

Library content (indicates missing functionality):

@table @samp
@item 16
@samp{NO_GZCOMPRESS}, @samp{gz*} functions cannot compress (to avoid
linking deflate code when not needed);

@item 17
@samp{NO_GZIP}, deflate can't write @command{gzip} streams, and inflate can't
detect and decode @command{gzip} streams (to avoid linking crc code);

@item 18-19
0 (reserved).
@end table

Operation variations (changes in library functionality):

@table @samp
@item 20
@samp{PKZIP_BUG_WORKAROUND}, slightly more permissive inflate;

@item 21
@samp{FASTEST}, deflate algorithm with only one, lowest compression
level;

@item 22,23
0 (reserved).
@end table

The @cfunc{sprintf} variant used by @cfunc{gzprintf} (zero is
best):

@table @samp
@item 24
0 = vs*, 1 = s* -- 1 means limited to 20 arguments after the format;

@item 25
0 = *nprintf, 1 = *printf -- 1 means @cfunc{gzprintf} not secure!

@item 26
0 = returns value, 1 = void -- 1 means inferred string length returned;
@end table

Remainder: @samp{27-31}: 0 (reserved).
@end deftypefun

@c page
@node zlib references
@appendixsec Bibliography and references


The data format used by the Zlib library is described by @acronym{RFC}
(Request for Comments) 1950 to 1952 in the files:

@table @url
@item ftp://ds.internic.net/rfc/rfc1950.txt
Zlib format;

@item ftp://ds.internic.net/rfc/rfc1951.txt
deflate format;

@item ftp://ds.internic.net/rfc/rfc1952.txt
@command{gzip} format.
@end table

Visit @url{http://ftp.cdrom.com/pub/infozip/zlib/} for the official
Zlib web page.


@c Local Variables:
@c mode: texinfo
@c End:
