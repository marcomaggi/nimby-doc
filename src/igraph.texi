\input texinfo.tex
@c %**start of header
@setfilename igraph.info
@settitle IGraph Reference Manual
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@macro version{}
0.5.2
@end macro

@c ------------------------------------------------------------
@c License macros.
@c ------------------------------------------------------------

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro

@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro csv{}
@acronym{CSV}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro rfc{}
@acronym{RFC}
@end macro

@macro sql{}
@acronym{SQL}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro utc{}
@acronym{UTC}
@end macro

@macro tai{}
@acronym{TAI}
@end macro

@macro axml{}
@acronym{XML}
@end macro

@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro

@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro ip{}
@acronym{IP}
@end macro

@macro ssh{}
@acronym{SSH}
@end macro

@macro ssl{}
@acronym{SSL}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro tls{}
@acronym{TLS}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro

@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro cnull{}
@code{NULL}
@end macro

@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro

@macro autoconfref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,autoconf}
@end macro

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      IGraph Reference Manual

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    igraph

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           igraph

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Gabor Csardi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{csardi@@rmki.kfki.hu}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2003-2010

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, a library
for the creation and manipulation of graphs.

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by @value{AUTHOR} @value{AUTHOR_EMAIL}

@quotation
Permission is granted to copy, distribute and/or modify this document
under the terms of the @gnu{} Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``@gnu{} Free
Documentation License''.
@end quotation

This document is an unofficial Texinfo reformatting of the original
IGraph documentation file; the maintainer of this version is Marco Maggi
@email{mrc.mgg@@gmail.com}.
@end copying

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Revision @version{}
@author @value{AUTHOR} @value{AUTHOR_EMAIL}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* igraph: (igraph).             IGraph, a library for graphs.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* intro::                       Overview of the package.
* install::                     Installation.
@ignore
@c * Tutorial::
@c * About igraph graphs, the basic interface: About igraph graphs; the basic interface.
@c * Error Handling::
@c * Data structure library; vector, matrix, other data types: Data structure library; vector; matrix; other data types.
@c * Graph Generators::
@c * Vertex and Edge Selectors and Sequences, Iterators: Vertex and Edge Selectors and Sequences; Iterators.
@c * Graph, Vertex and Edge Attributes: Graph; Vertex and Edge Attributes.
@c * Structural Properties of Graphs::
@c * Cliques and Independent Vertex Sets::
@c * Graph Isomorphism::
@c * Graph Motifs, Dyad Census and Triad Census: Graph Motifs; Dyad Census and Triad Census.
@c * Generating Layouts for Graph Drawing::
@c * Reading and Writing Graphs from and to Files::
@c * Maximum Flows, Minimum Cuts and related measures: Maximum Flows; Minimum Cuts and related measures.
@c * Detecting Community Structure::
@c * Graph Operators::
@c * Using ARPACK for igraph graphs::
@c * Bipartite, i.e. two-mode graphs: Bipartite; i_e_ two-mode graphs.
@c * Not Graph Related Functions : Not Graph Related Functions.
@end ignore

Appendices

* Package License::             GNU General Public License.
* Documentation License::       GNU Free Documentation License.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.
@end menu
@end ifnottex

@c page
@node intro
@chapter Overview of the package


This is a library for the creation and manipulation of graphs.  You can
look at it two ways: first, igraph contains the implementation of quite
a lot of graph algorithms.  These include classic graph algorithms like
graph isomorphism, graph girth and connectivity and also the new wave
graph algorithms like transitivity, graph motifs and community structure
detection.  Skim through the table of contents or the index of this book
to get an impression.

Second, igraph provides a platform for development and/or implementation
of graph algorithms.  It has a quite efficient data structure for
representing graphs and a number of other data structures like flexible
vectors, stacks, heaps, queues, adjacency lists to accomplish this.  In
fact, these data structures evolved along with the implementation of the
classic and non--classic graph algorithms which make up the major part
of the IGraph library.  This way they were fine tuned and checked for
correctness several times.

Our main goal with developing IGraph was to create a graph library which
is efficient on large but not extremely large graphs.  More precisely,
it is assumed that the graph(s) fit into the physical memory of the
computer.  Nowadays this means graphs with several million vertices
and/or edges.  Our definition of efficient is that it runs fast, both in
theory and (more importantly) in practice.

We believe that one of the big strengths of igraph is that it can be
embedded into a higher level language or environment.  Two such
embeddings (or interfaces if you look at them the other way) are
currently being developed by us: IGraph as a @gnu{} R package and IGraph
as a Python extension module.  A third embedding, being developed by
another developer is a Ruby extension.  Other are likely to come.  The
high level languages as R or Python make it possible to use graph
routines with much greater comfort, without actually writing a single
line of C code.  They have some, usually very small, speed penalty
compared to the C version, but add ease and much flexibility.  This
manual however covers only the C library.  If you want to use Python or
@gnu{} R, please see the documentation written specifically for these
interfaces and come back here only if you're interested in some detail
which is not covered in those documents.

We still consider IGraph as a child project.  It has much room for
development and we are sure that it will improve a lot in the near
future.  Any feedback we can get from the users is very important for
us, as most of the time these questions and comments guide us in what to
add and what to improve.

IGraph is open source and distributed under the terms of the @gnu{}
@gpl{}.  We strongly believe that all the algorithms used in science,
let that be graph theory or not, should have an efficient open source
implementation allowing use and modification for anyone.

@menu
* intro free::                  IGraph is free software.
* intro cite::                  Citing IGraph.
@end menu

@c page
@node intro free
@section IGraph is free software


IGraph library

Copyright @copyright{} 2003, 2004, 2005 Gabor Csardi
@email{csardi@@rmki.kfki.hu} MTA RMKI, Konkoly-Thege Miklos st. 29-33,
Budapest 1121, Hungary

This program is free software; you can redistribute it and/or modify it
under the terms of the @gnu{} General Public License as published by the
Free Software Foundation; either version 2 of the License, or (at your
option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place, Suite 330, Boston, MA 02111-1307 USA

@c page
@node intro cite
@section Citing IGraph


To cite IGraph in publications, please use the following reference:

@quotation
Ga'bor Csa'rdi, Tama's Nepusz: The igraph software package for complex
network research. InterJournal Complex Systems, 1695, 2006.
@end quotation

@c page
@node install
@chapter Installation


First download the latest version of IGraph from its homepage:

@center @url{http://cneurocvs.rmki.kfki.hu/igraph}

@noindent
or from SourceForge:

@center @url{http://sourceforge.net/project/showfiles.php?group_id=160289}

@noindent
and uncompress it to a temporary directory:

@example
$ wget http://cneurocvs.rmki.kfki.hu/igraph/download/igraph-0.2.tar.gz
$ tar xzf igraph-0.2.tar.gz
$ cd igraph-0.2
@end example

To install the complete C library type:

@example
$ ./configure
$ make
$ make install
@end example

@noindent
(the latter as root) should work on most systems.  You can try:

@example
$ ./configure --help
@end example

@noindent
to see installations options, and read the @file{INSTALL} file.

Installing the IGraph R package is very simple, you don't need to
download anything by hand, just give the command:

@example
> install.packages("igraph", lib="~/.R/library")
@end example

@noindent
in R and select a mirror site close to you.  The @code{lib} argument
specifies the directory to which the package will be installed.  If not
specified, this will be default system wide R package directory.  You
must have write permissions for this directory.

Also, consult your R documentation.

Installing the IGraph Python package is a little bit more difficult,
since chances are that you have to compile it for yourself (as long as
there is no compile farm at the Python Package Index and we can't
compile it ourselves to all platforms).  First, check if there is a
compiled version available for your system at IGraph's Python Package
Index page:

@center @url{http://www.python.org/pypi/igraph}

@noindent
if there is, just use that.  (Python eggs can be put anywhere in your
Python library path, executable installers should be executed of
course).  If there isn't, you'll have to compile it by hand.  So, first
install a recent C compiler.

We usually compile IGraph with the @gnu{} C compiler
(@url{http://gcc.gnu.org}).

@itemize
@item
If you are a Windows user, you can find it as part of the Cygwin
(@url{http://www.cygwin.com}) environment or in the MinGW+MSYS
(@url{http://www.mingw.org}) project.  You can also try Microsoft's free
C compiler suite (or even worse, Visual Studio), but there are known
issues with the compilation of IGraph in MSVC, and you'll have to
resolve them yourself by tweaking the source code.  (Patches are
welcome!  :)).

@item
If you use Linux, @command{gcc} is usually included in your default
system, but even if it isn't, there will be a package from which you can
install it.  (In Debian and Ubuntu Linux, you'll have to install the
package called @code{build-essential}).

@item
If you have a Mac, @command{gcc} is part of the Xcode developer suite,
which is usually included in your OS X install DVD, or can be obtained
freely from the Apple Developer Connection
(@url{http://developer.apple.com/tools/downloads/}) website.
@end itemize

After having obtained a C compiler, you'll have to install an XML
processing library called @code{libxml2}.

@itemize
@item
Windows users should get it from its website (@url{http://xmlsoft.org})
(there are binary versions, no need to compile anything).

@item
Linux users should be able to find a package again in their respective
distribution (Debian and Ubuntu users: install the @code{libxml2} and
@code{libxml2-dev} libraries).

@item
Mac users should not do anything, since @code{libxml2} is part of the
default system installation.
@end itemize

However, you should check it anyway, launch a terminal and type the
following command:

@example
$ xml2-config
@end example

@noindent
if you don't receive any error message, you can go on to the next step.

Now, get the IGraph source from the Python Package Index
(@url{http://www.python.org/pypi/igraph}), extract it to a directory and
start the compilation.  On Windows, launch the Cygwin or MinGW
environment and type:

@example
$ python setup.py build --compiler=cygwin
@end example

@noindent
(instead of @samp{--compiler=cygwin}, @samp{--compiler=mingw32} should
also work, then you have no @acronym{POSIX} emulation available (you
don't really need it for IGraph yet), but you also won't need
@file{cygwin1.dll}).

If the shell keeps on complaining that it does not find the Python
interpreter, use its full path.  For instance, if you have Python
installed in @file{C:\Devel\Python24}, use the following command:

@example
$ /cygdrive/c/devel/python24/python \
     setup.py build --compiler=cygwin
@end example

@noindent
if the compilation finished without errors, you can install the library:

@example
$ python setup.py install
@end example

@noindent
use the full path again if necessary.

Linux and Mac users should succeed with the following commands issued
from the IGraph root directory:

@example
$ python setup.py build
$ python setup.py install
@end example

Note that you'll need write permissions to the Python library path, so
usually you must have root permissions to issue the second command.  If
you want to install it to a different directory, just copy everything
from the @file{build/lib.*} subdirectory to wherever you want.

@c page
@c
@c File: igraph_reference_manual.info,  Node: Tutorial,  Next: About igraph graphs; the basic interface,  Prev: Installation,  Up: Top

@c 3 Tutorial
@c **********

@c * Menu:

@c * Lesson 1. Compiling programs using igraph.: Lesson 1_ Compiling programs using igraph_.
@c * Lesson 2. Creating your first graphs.: Lesson 2_ Creating your first graphs_.
@c * Lesson 3. Calculating various properties of graphs.: Lesson 3_ Calculating various properties of graphs_.

@c
@c File: igraph_reference_manual.info,  Node: Lesson 1_ Compiling programs using igraph_,  Next: Lesson 2_ Creating your first graphs_,  Up: Tutorial

@c 3.1 Lesson 1. Compiling programs using igraph.
@c ==============================================

@c The following short example program demonstrates the basic usage of the
@c `igraph' library.


@c      #include <igraph.h>

@c      int main(void)
@c      {
@c           igraph_real_t diameter;
@c           igraph_t graph;
@c           igraph_erdos_renyi_game(&graph, IGRAPH_ERDOS_RENYI_GNP, 1000, 5.0/1000,
@c                                   IGRAPH_UNDIRECTED, IGRAPH_NO_LOOPS);
@c           igraph_diameter(&graph, &diameter, 0, 0, 0, IGRAPH_UNDIRECTED, 1);
@c           printf("Diameter of a random graph with average degree 5: %f\n",
@c                   (double) diameter);
@c           igraph_destroy(&graph);
@c           return 0;
@c      }

@c    This example illustrates a couple of points. First, programs using
@c the `igraph' library should include the `igraph.h' header file. Second,
@c `igraph' uses the `igraph_real_t' type for real numbers instead of
@c `double'. Third, `igraph' graph objects are represented by the
@c `igraph_t' data type. Fourth, the `igraph_erdos_renyi_game()' (*note
@c igraph_erdos_renyi_game --- Generates a random [Erdos-Renyi] graph_::)
@c creates a graph and `igraph_destroy()' (*note igraph_destroy --- Frees
@c the memory allocated for a graph object_::) destroys it, ie.
@c deallocates the memory associated to it.

@c    For compiling this program you need a C compiler, if this is called
@c `gcc' and the previous code is saved in file `igraph_test.c', you will
@c need a command like this:


@c      gcc igraph_test.c -I/usr/local/igraph -L/usr/local/lib -ligraph -o igraph_test

@c    The exact form depends on where `igraph' was installed on your
@c system. The directory after the `-I' switch is the one containing the
@c `igraph.h' file, while the one following `-L' should contain the
@c library file itself, usually a file called `libigraph.so',
@c `libigraph.a' or `igraph.dll'.  It your system has the `pkg-config'
@c utility you are likely to get the neccessary compile options by issuing
@c the command


@c      pkg-config --libs --cflags igraph

@c    The executable can be run by simply typing its name like this:


@c      ./igraph_test

@c on most systems. If you use dynamic linking and the `igraph' libraries
@c are not at a standard place, you may need to set the `LD_LIBRARY_PATH'
@c variable, the syntax depends on the shell use are using. In `bash' it
@c goes like this:


@c      export LD_LIBRARY_PATH=$LD_LIBRARY_PATH:/home/user/libs/igraph
@c      ./igraph_test

@c Here we assumed that the `igraph' library is installed in
@c `/home/user/libs/igraph'. Alternatively, you can use the `LD_PRELOAD'
@c variable to preload the `igraph' library before invoking your program:


@c      LD_PRELOAD=/home/user/libs/igraph/libigraph.so ./igraph_test

@c Please note that `LD_PRELOAD' and `LD_LIBRARY_PATH' are usually
@c available only on Un*x-like systems. On Windows using Cygwin it is
@c usually enough to set the `PATH' enviroment variable to include the
@c folder in which the `igraph' library is installed, look for the
@c `cygigraph-0.dll' or similar file.

@c
@c File: igraph_reference_manual.info,  Node: Lesson 2_ Creating your first graphs_,  Next: Lesson 3_ Calculating various properties of graphs_,  Prev: Lesson 1_ Compiling programs using igraph_,  Up: Tutorial

@c 3.2 Lesson 2. Creating your first graphs.
@c =========================================

@c The functions generating graph objects are called graph generators.
@c Stochastic (=randomized) graph generators are called `games'.

@c    `igraph' can handle directed and undirected graphs. Most graph
@c generators are able to create both types of graphs and most other
@c functions are usually also capable of handling both. Eg.
@c `igraph_shortest_paths()' (*note igraph_shortest_paths --- The length
@c of the shortest paths between vertices_::) which (surprisingly)
@c calculates shortest paths from a vertex to another vertices can
@c calculate directed or undirected paths.

@c    `igraph' has sophisticated ways for creating graphs. The simplest
@c graphs are deterministic regular structures like star graphs
@c (`igraph_star()' (*note igraph_star --- Creates a star graph; every
@c vertex connects only to the center_::)), ring graphs (`igraph_ring()'
@c (*note igraph_ring --- Creates a ring graph; a one dimensional
@c lattice_::)), lattices (`igraph_lattice()' (*note igraph_lattice ---
@c Creates most kind of lattices_::)) or trees (`igraph_tree()' (*note
@c igraph_tree --- Creates a tree in which almost all vertices have the
@c same number of children_::)).

@c    The following example creates an undirected regular circular lattice,
@c adds some random edges to it and calculates the average length of
@c shortest paths between all pairs of vertices in the graph before and
@c after adding the random edges. (The message is that some random edges
@c can reduce path lengths a lot.)


@c      #include <igraph.h>

@c      int main(void) {
@c        igraph_real_t avg_path;
@c        igraph_t graph;
@c        igraph_vector_t dimvector;
@c        igraph_vector_t edges;
@c        int i;

@c        igraph_vector_init(&dimvector, 2);
@c        VECTOR(dimvector)[0]=30;
@c        VECTOR(dimvector)[1]=30;
@c        igraph_lattice(&graph, &dimvector, 0, IGRAPH_UNDIRECTED, 0, 1);

@c        srand(100);
@c        igraph_vector_init(&edges, 20);
@c        for (i=0; i<igraph_vector_size(&edges); i++) {
@c          VECTOR(edges)[i] = rand() % (int)igraph_vcount(&graph);
@c        }

@c        igraph_average_path_length(&graph, &avg_path, IGRAPH_UNDIRECTED, 1);
@c        printf("Average path length (lattice):            %f\n", (double) avg_path);

@c        igraph_add_edges(&graph, &edges, 0);
@c        igraph_average_path_length(&graph, &avg_path, IGRAPH_UNDIRECTED, 1);
@c        printf("Average path length (randomized lattice): %f\n", (double) avg_path);

@c        igraph_vector_destroy(&dimvector);
@c        igraph_vector_destroy(&edges);
@c        igraph_destroy(&graph);

@c        return 0;
@c      }

@c    This example illustrates some new points. `igraph' uses
@c `igraph_vector_t' (*note About igraph_vector_t objects::) instead of
@c plain C arrays. `igraph_vector_t' is superior to regular arrays in
@c almost every sense. Vectors are created by the `igraph_vector_init()'
@c (*note igraph_vector_init --- Initializes a vector object
@c [constructor]_::) function and like graphs they should be destroyed if
@c not needed any more by calling `igraph_vector_destroy()' (*note
@c igraph_vector_destroy --- Destroys a vector object_::) on them. A
@c vector can be indexed by the `VECTOR()' (*note VECTOR --- Accessing an
@c element of a vector_::) function (right now it is a macro). Vectors can
@c be resized, eg. most `igraph' functions returning the result in a
@c vector resize it to the size of the result.

@c    `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c lattices_::) takes a vector argument specifying the dimensions of the
@c lattice, in this example we generate a 30x30 two dimensional lattice.
@c See the documentation of `igraph_lattice()' (*note igraph_lattice ---
@c Creates most kind of lattices_::) in the reference manual for the other
@c arguments.

@c    The vertices in a graph are identified by an integer number between
@c 0 and N-1, N is the number of vertices in the graph (this can be
@c obtained by `igraph_vcount()' (*note igraph_vcount --- The number of
@c vertices in a graph::), as in the example).

@c    The `igraph_add_edges()' (*note igraph_add_edges --- Adds edges to a
@c graph object_::) function simply takes a graph and a vector of vertex
@c ids defining the new edges. The first edge is between the first two
@c vertex ids in the vector, the second edge is between the second two,
@c etc. This way we add ten random edges to the lattice.

@c    Note that in the example it is possible to add loop edges, edges
@c pointing to the same vertex and multiple edges, more than one edge
@c between the same pair of vertices.  `igraph_t' can of course represent
@c loops and multiple edges, although some routines expect simple graphs,
@c ie. graphs without loop and multiple edges, because for example some
@c structural properties are ill-defined for non-simple graphs. Loop edges
@c can be removed by calling `igraph_simplify()' (*note igraph_simplify
@c --- Removes loop and/or multiple edges from the graph_::).

@c
@c File: igraph_reference_manual.info,  Node: Lesson 3_ Calculating various properties of graphs_,  Prev: Lesson 2_ Creating your first graphs_,  Up: Tutorial

@c 3.3 Lesson 3. Calculating various properties of graphs.
@c =======================================================

@c In our next example we will calculate various centrality measures in a
@c friendship graph. The friendship graph is from the famous Zachary karate
@c club study. (Web search on 'Zachary karate' if you want to know more
@c about this.) Centrality measures quantify how central is the position of
@c individual vertices in the graph.


@c      #include <igraph.h>

@c      int main(void) {
@c           igraph_t graph;
@c           igraph_vector_t v;
@c           igraph_vector_t result;
@c           igraph_real_t edges[] = { 0, 1, 0, 2, 0, 3, 0, 4, 0, 5, 0, 6, 0, 7, 0, 8,
@c                                     0,10, 0,11, 0,12, 0,13, 0,17, 0,19, 0,21, 0,31,
@c                                     1, 2, 1, 3, 1, 7, 1,13, 1,17, 1,19, 1,21, 1,30,
@c                                     2, 3, 2, 7, 2,27, 2,28, 2,32, 2, 9, 2, 8, 2,13,
@c                                     3, 7, 3,12, 3,13, 4, 6, 4,10, 5, 6, 5,10, 5,16,
@c                                     6,16, 8,30, 8,32, 8,33, 9,33,13,33,14,32,14,33,
@c                                    15,32,15,33,18,32,18,33,19,33,20,32,20,33,
@c                                    22,32,22,33,23,25,23,27,23,32,23,33,23,29,
@c                                    24,25,24,27,24,31,25,31,26,29,26,33,27,33,
@c                                    28,31,28,33,29,32,29,33,30,32,30,33,31,32,31,33,
@c                                    32,33
@c           };

@c           igraph_vector_view(&v, edges, sizeof(edges)/sizeof(double));
@c           igraph_create(&graph, &v, 0, IGRAPH_UNDIRECTED);

@c           igraph_vector_init(&result, 0);

@c           igraph_degree(&graph, &result, igraph_vss_all(), IGRAPH_ALL,
@c                         IGRAPH_LOOPS);
@c           printf("Maximum degree is      %10i, vertex %2i.\n",
@c                  (int)igraph_vector_max(&result), (int)igraph_vector_which_max(&result));

@c           igraph_closeness(&graph, &result, igraph_vss_all(), IGRAPH_ALL);
@c           printf("Maximum closeness is   %10f, vertex %2i.\n",
@c                   (double)igraph_vector_max(&result), (int)igraph_vector_which_max(&result));

@c           igraph_betweenness(&graph, &result, igraph_vss_all(),
@c                                   IGRAPH_UNDIRECTED);
@c           printf("Maximum betweenness is %10f, vertex %2i.\n",
@c                   (double)igraph_vector_max(&result), (int)igraph_vector_which_max(&result));

@c           igraph_vector_destroy(&result);
@c           igraph_destroy(&graph);

@c           return 0;
@c      }

@c    This example reflects some new features. First of all, it shows a
@c way to define a graph simply as defining a C array with its edges.
@c Function `igraph_vector_view()' (*note igraph_vector_view --- Handle a
@c regular C array as a igraph_vector_t_::) creates a _view_ of a C array.
@c It does not copy any data, this also means that you should not call
@c `igraph_vector_destroy()' (*note igraph_vector_destroy --- Destroys a
@c vector object_::) on a vector created this way. This vector is then
@c used to create the undirected graph.

@c    Then the degree, closeness and betweenness centrality of the vertices
@c is calculated and the highest values are printed. Note that the vector
@c (`result') which returns the result from these functions has to be
@c initialized first, and also that the functions resize it to be able to
@c hold the result.

@c    The `igraph_vss_all()' argument tells the functions to calculate the
@c property for every vertex in the graph, it is shorthand for a _vertex
@c selector_ (`igraph_vs_t').  Vertex selectors help performing operations
@c on a subset of vertices, you can read more about them in one of the
@c following chapters. (*note Vertex and Edge Selectors and Sequences;
@c Iterators::)

@c
@c File: igraph_reference_manual.info,  Node: About igraph graphs; the basic interface,  Next: Error Handling,  Prev: Tutorial,  Up: Top

@c 4 About igraph graphs, the basic interface
@c ******************************************

@c * Menu:

@c * The igraph data model::
@c * The basic interface::

@c
@c File: igraph_reference_manual.info,  Node: The igraph data model,  Next: The basic interface,  Up: About igraph graphs; the basic interface

@c 4.1 The igraph data model
@c =========================

@c The igraph library can handle directed and undirected graphs. The
@c igraph graphs are multisets of ordered (if directed) or unordered (if
@c undirected) labeled pairs.  The labels of the pairs plus the number of
@c vertices always starts with zero and ends with the number of edges
@c minus one. In addition to that a table of metadata is also attached to
@c every graph, its most important entries are the number of vertices in
@c the graph and whether the graph is directed or undirected.

@c    Like the edges, the igraph vertices are also labeled by number
@c between zero and the number of vertices minus one.  So, to summarize, a
@c directed graph can be imagined like this:


@c        ( vertices: 6,
@c          directed: yes,
@c          {
@c           (0,2),
@c           (2,2),
@c           (2,3),
@c           (3,3),
@c           (3,4),
@c           (3,4),
@c           (4,1)
@c          }
@c        )

@c Here the edges are ordered pairs or vertex ids, and the graph is a
@c multiset of edges plus some meta-data.

@c    An undirected graph is like this:


@c        ( vertices: 6,
@c          directed: no,
@c          {
@c           {0,2},
@c           {2},
@c           {2,3},
@c           {3},
@c           {3,4},
@c           {3,4},
@c           {4,1}
@c          }
@c        )

@c Here an edge is a set of one or two vertex ids, two for most of the
@c time, except for loop edges. A graph is a multiset of edges plus meta
@c data, just like in the directed case.

@c    It is possible to convert a directed graph to an undirected one, see
@c the `igraph_to_directed()' (*note igraph_to_directed --- Convert an
@c undirected graph to a directed one::) and `igraph_to_undirected()'
@c (*note igraph_to_undirected --- Convert a directed graph to an
@c undirected one_::) functions.

@c    Note that igraph has some limited support for graphs with multiple
@c edges. The support means that multiple edges can be stored in igraph
@c graphs, but for most functions (like `igraph_betweenness()' (*note
@c igraph_betweenness --- Betweenness centrality of some vertices_::)) it
@c is not checked that they work well on graphs with multiple edges.  To
@c eliminate multiple edges from a graph, you can use `igraph_simplify()'
@c (*note igraph_simplify --- Removes loop and/or multiple edges from the
@c graph_::).

@c
@c File: igraph_reference_manual.info,  Node: The basic interface,  Prev: The igraph data model,  Up: About igraph graphs; the basic interface

@c 4.2 The basic interface
@c =======================

@c This is the very minimal API in `igraph'. All the other functions use
@c this minimal set for creating and manipulating the graphs.

@c    This is a very important principle since it makes possible to
@c implement other data representations by implementing only this minimal
@c set.

@c * Menu:

@c * Graph Constructors and Destructors::
@c * Basic Query Operations::
@c * Adding and Deleting Vertices and Edges::

@c
@c File: igraph_reference_manual.info,  Node: Graph Constructors and Destructors,  Next: Basic Query Operations,  Up: The basic interface

@c 4.2.1 Graph Constructors and Destructors
@c ----------------------------------------

@c * Menu:

@c * igraph_empty --- Creates an empty graph with some vertices and no edges.: igraph_empty --- Creates an empty graph with some vertices and no edges_.
@c * igraph_empty_attrs --- Creates an empty graph with some vertices, no edges and some graph attributes.: igraph_empty_attrs --- Creates an empty graph with some vertices; no edges and some graph attributes_.
@c * igraph_copy --- Creates an exact (deep) copy of a graph.: igraph_copy --- Creates an exact [deep] copy of a graph_.
@c * igraph_destroy --- Frees the memory allocated for a graph object. : igraph_destroy --- Frees the memory allocated for a graph object_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_empty --- Creates an empty graph with some vertices and no edges_,  Next: igraph_empty_attrs --- Creates an empty graph with some vertices; no edges and some graph attributes_,  Up: Graph Constructors and Destructors

@c 4.2.1.1 igraph_empty -- Creates an empty graph with some vertices and no edges.
@c ...............................................................................


@c      int igraph_empty(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed);

@c    The most basic constructor, all the other constructors should call
@c this to create a minimal graph object.

@c    *Arguments:. *

@c `graph':
@c      Pointer to a not-yet initialized graph object.

@c `n':
@c      The number of vertices in the graph, a non-negative integer number
@c      is expected.

@c `directed':
@c      Whether the graph is directed or not.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid number of vertices.

@c    Time complexity: O(|V|) for a graph with |V| vertices (and no edges).

@c
@c File: igraph_reference_manual.info,  Node: igraph_empty_attrs --- Creates an empty graph with some vertices; no edges and some graph attributes_,  Next: igraph_copy --- Creates an exact [deep] copy of a graph_,  Prev: igraph_empty --- Creates an empty graph with some vertices and no edges_,  Up: Graph Constructors and Destructors

@c 4.2.1.2 igraph_empty_attrs -- Creates an empty graph with some vertices, no edges and some graph attributes.
@c ............................................................................................................


@c      int igraph_empty_attrs(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed, void* attr);

@c    Use this instead of `igraph_empty()' (*note igraph_empty --- Creates
@c an empty graph with some vertices and no edges_::) if you wish to add
@c some graph attributes right after initialization. This function is
@c currently not very interesting for the ordinary user, just supply 0
@c here or use `igraph_empty()' (*note igraph_empty --- Creates an empty
@c graph with some vertices and no edges_::).

@c    *Arguments:. *

@c `graph':
@c      Pointer to a not-yet initialized graph object.

@c `n':
@c      The number of vertices in the graph, a non-negative integer number
@c      is expected.

@c `directed':
@c      Whether the graph is directed or not.

@c `attr':
@c      The attributes.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid number of vertices.

@c    Time complexity: O(|V|) for a graph with |V| vertices (and no edges).

@c
@c File: igraph_reference_manual.info,  Node: igraph_copy --- Creates an exact [deep] copy of a graph_,  Next: igraph_destroy --- Frees the memory allocated for a graph object_,  Prev: igraph_empty_attrs --- Creates an empty graph with some vertices; no edges and some graph attributes_,  Up: Graph Constructors and Destructors

@c 4.2.1.3 igraph_copy -- Creates an exact (deep) copy of a graph.
@c ...............................................................


@c      int igraph_copy(igraph_t *to, const igraph_t *from);

@c    This function deeply copies a graph object to create an exact
@c replica of it. The new replica should be destroyed by calling
@c `igraph_destroy()' (*note igraph_destroy --- Frees the memory allocated
@c for a graph object_::) on it when not needed any more.

@c    You can also create a shallow copy of a graph by simply using the
@c standard assignment operator, but be careful and do _not_ destroy a
@c shallow replica. To avoid this mistake creating shallow copies is not
@c recommended.

@c    *Arguments:. *

@c `to':
@c      Pointer to an uninitialized graph object.

@c `from':
@c      Pointer to the graph object to copy.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity:  O(|V|+|E|) for a graph with |V| vertices and |E|
@c edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_destroy --- Frees the memory allocated for a graph object_,  Prev: igraph_copy --- Creates an exact [deep] copy of a graph_,  Up: Graph Constructors and Destructors

@c 4.2.1.4 igraph_destroy -- Frees the memory allocated for a graph object.
@c ........................................................................


@c      int igraph_destroy(igraph_t *graph);

@c    This function should be called for every graph object exactly once.

@c    This function invalidates all iterators (of course), but the
@c iterators of are graph should be destroyed before the graph itself
@c anyway.

@c    *Arguments:. *

@c `graph':
@c      Pointer to the graph to free.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: operating system specific.

@c
@c File: igraph_reference_manual.info,  Node: Basic Query Operations,  Next: Adding and Deleting Vertices and Edges,  Prev: Graph Constructors and Destructors,  Up: The basic interface

@c 4.2.2 Basic Query Operations
@c ----------------------------

@c * Menu:

@c * igraph_vcount --- The number of vertices in a graph::
@c * igraph_ecount --- The number of edges in a graph::
@c * igraph_edge --- Gives the head and tail vertices of an edge.: igraph_edge --- Gives the head and tail vertices of an edge_.
@c * igraph_get_eid --- Get the edge id from the end points of an edge::
@c * igraph_neighbors --- Adjacent vertices to a vertex.: igraph_neighbors --- Adjacent vertices to a vertex_.
@c * igraph_adjacent --- Gives the adjacent edges of a vertex.: igraph_adjacent --- Gives the adjacent edges of a vertex_.
@c * igraph_is_directed --- Is this a directed graph?::
@c * igraph_degree --- The degree of some vertices in a graph.: igraph_degree --- The degree of some vertices in a graph_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vcount --- The number of vertices in a graph,  Next: igraph_ecount --- The number of edges in a graph,  Up: Basic Query Operations

@c 4.2.2.1 igraph_vcount -- The number of vertices in a graph
@c ..........................................................


@c      igraph_integer_t igraph_vcount(const igraph_t *graph);

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c    *Returns:. *

@c `'
@c      Number of vertices.

@c    Time complexity: O(1)

@c
@c File: igraph_reference_manual.info,  Node: igraph_ecount --- The number of edges in a graph,  Next: igraph_edge --- Gives the head and tail vertices of an edge_,  Prev: igraph_vcount --- The number of vertices in a graph,  Up: Basic Query Operations

@c 4.2.2.2 igraph_ecount -- The number of edges in a graph
@c .......................................................


@c      igraph_integer_t igraph_ecount(const igraph_t *graph);

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c    *Returns:. *

@c `'
@c      Number of edges.

@c    Time complexity: O(1)

@c
@c File: igraph_reference_manual.info,  Node: igraph_edge --- Gives the head and tail vertices of an edge_,  Next: igraph_get_eid --- Get the edge id from the end points of an edge,  Prev: igraph_ecount --- The number of edges in a graph,  Up: Basic Query Operations

@c 4.2.2.3 igraph_edge -- Gives the head and tail vertices of an edge.
@c ...................................................................


@c      int igraph_edge(const igraph_t *graph, igraph_integer_t eid,
@c      		igraph_integer_t *from, igraph_integer_t *to);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `eid':
@c      The edge id.

@c `from':
@c      Pointer to an `igraph_integer_t'. The tail of the edge will be
@c      placed here.

@c `to':
@c      Pointer to an `igraph_integer_t'. The head of the edge will be
@c      placed here.

@c    *Returns:. *

@c `'
@c      Error code. The current implementation always returns with success.

@c    *See also:. *

@c `'
@c      `igraph_get_eid()' (*note igraph_get_eid --- Get the edge id from
@c      the end points of an edge::) for the opposite operation.

@c    Added in version 0.2.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_eid --- Get the edge id from the end points of an edge,  Next: igraph_neighbors --- Adjacent vertices to a vertex_,  Prev: igraph_edge --- Gives the head and tail vertices of an edge_,  Up: Basic Query Operations

@c 4.2.2.4 igraph_get_eid -- Get the edge id from the end points of an edge
@c ........................................................................


@c      int igraph_get_eid(const igraph_t *graph, igraph_integer_t *eid,
@c      		   igraph_integer_t pfrom, igraph_integer_t pto,
@c      		   igraph_bool_t directed);

@c    For undirected graphs `from' and `to' are exchangable.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `eid':
@c      Pointer to an integer, the edge id will be stored here.

@c `from':
@c      The starting point of the edge.

@c `to':
@c      The end points of the edge.

@c `directed':
@c      Logical constant, whether to search for directed edges in a
@c      directed graph. Ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_edge()' (*note igraph_edge --- Gives the head and tail
@c      vertices of an edge_::) for the opposite operation.

@c    Time complexity: O(log (d)), where d is smaller of the out-degree of
@c from and in-degree of to if `directed' is true. If `directed' is false,
@c then it is O(log(d)+log(d2)), where d is the same as before and d2 is
@c the minimum of the out-degree of to and the in-degree of from.  Added
@c in version 0.2.

@c
@c File: igraph_reference_manual.info,  Node: igraph_neighbors --- Adjacent vertices to a vertex_,  Next: igraph_adjacent --- Gives the adjacent edges of a vertex_,  Prev: igraph_get_eid --- Get the edge id from the end points of an edge,  Up: Basic Query Operations

@c 4.2.2.5 igraph_neighbors -- Adjacent vertices to a vertex.
@c ..........................................................


@c      int igraph_neighbors(const igraph_t *graph, igraph_vector_t *neis, igraph_integer_t pnode,
@c      		     igraph_neimode_t mode);

@c    *Arguments:. *

@c `graph':
@c      The graph to work on.

@c `neis':
@c      This vector will contain the result. The vector should be
@c      initialized before and will be resized. Starting from igraph
@c      version 0.4 this vector is always sorted, the vertex ids are in
@c      increasing order.

@c `pnode':
@c      The id of the node of which the adjacent vertices are searched.

@c `mode':
@c      Defines the way adjacent vertices are searched for directed
@c      graphs. It can have the following values: `IGRAPH_OUT', vertices
@c      reachable by an edge from the specified vertex are searched,
@c      `IGRAPH_IN', vertices from which the specified vertex is reachable
@c      are searched.  `IGRAPH_ALL', both kind of vertices are searched.
@c      This parameter is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVVID': invalid vertex id.
@c      `IGRAPH_EINVMODE': invalid mode argument.  `IGRAPH_ENOMEM': not
@c      enough memory.

@c    Time complexity: O(d), d is the number of adjacent vertices to the
@c queried vertex.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjacent --- Gives the adjacent edges of a vertex_,  Next: igraph_is_directed --- Is this a directed graph?,  Prev: igraph_neighbors --- Adjacent vertices to a vertex_,  Up: Basic Query Operations

@c 4.2.2.6 igraph_adjacent -- Gives the adjacent edges of a vertex.
@c ................................................................


@c      int igraph_adjacent(const igraph_t *graph, igraph_vector_t *eids,
@c      		    igraph_integer_t pnode, igraph_neimode_t mode);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `eids':
@c      An initialized `vector_t' object. It will be resized to hold the
@c      result.

@c `pnode':
@c      A vertex id.

@c `mode':
@c      Specifies what kind of edges to include for directed graphs.
@c      `IGRAPH_OUT' means only outgoing edges, `IGRAPH_IN' only incoming
@c      edges, `IGRAPH_ALL' both. This parameter is ignored for undirected
@c      graphs.

@c    *Returns:. *

@c `'
@c      Error code. `IGRAPH_EINVVID': invalid `pnode' argument,
@c      `IGRAPH_EINVMODE': invalid `mode' argument.

@c    Added in version 0.2.

@c    Time complexity: O(d), the number of adjacent edges to `pnode'.

@c
@c File: igraph_reference_manual.info,  Node: igraph_is_directed --- Is this a directed graph?,  Next: igraph_degree --- The degree of some vertices in a graph_,  Prev: igraph_adjacent --- Gives the adjacent edges of a vertex_,  Up: Basic Query Operations

@c 4.2.2.7 igraph_is_directed -- Is this a directed graph?
@c .......................................................


@c      igraph_bool_t igraph_is_directed(const igraph_t *graph);

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c    *Returns:. *

@c `'
@c      Logical value, ` TRUE'  if the graph is directed, ` FALSE'
@c      otherwise.

@c    Time complexity: O(1)

@c
@c File: igraph_reference_manual.info,  Node: igraph_degree --- The degree of some vertices in a graph_,  Prev: igraph_is_directed --- Is this a directed graph?,  Up: Basic Query Operations

@c 4.2.2.8 igraph_degree -- The degree of some vertices in a graph.
@c ................................................................


@c      int igraph_degree(const igraph_t *graph, igraph_vector_t *res,
@c      		  const igraph_vs_t vids,
@c      		  igraph_neimode_t mode, igraph_bool_t loops);

@c    This function calculates the in-, out- or total degree of the
@c specified vertices.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `res':
@c      Vector, this will contain the result. It should be initialized and
@c      will be resized to be the appropriate size.

@c `vids':
@c      Vector, giving the vertex ids of which the degree will be
@c      calculated.

@c `mode':
@c      Defines the type of the degree.  `IGRAPH_OUT', out-degree,
@c      `IGRAPH_IN', in-degree, `IGRAPH_ALL', total degree (sum of the in-
@c      and out-degree).  This parameter is ignored for undirected graphs.

@c `loops':
@c      Boolean, gives whether the self-loops should be counted.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVVID': invalid vertex id.
@c      `IGRAPH_EINVMODE': invalid mode argument.

@c    Time complexity: O(v) if loops is TRUE, and O(v*d) otherwise. v is
@c the number vertices for which the degree will be calculated, and d is
@c their (average) degree.

@c    *See also:. *

@c `'
@c      `igraph_strength()' (*note igraph_strength --- Strength of the
@c      vertices; weighted vertex degree in other words::) for the version
@c      that takes into account edge weigths.

@c
@c File: igraph_reference_manual.info,  Node: Adding and Deleting Vertices and Edges,  Prev: Basic Query Operations,  Up: The basic interface

@c 4.2.3 Adding and Deleting Vertices and Edges
@c --------------------------------------------

@c * Menu:

@c * igraph_add_edge --- Adds a single edge to a graph::
@c * igraph_add_edges --- Adds edges to a graph object. : igraph_add_edges --- Adds edges to a graph object_.
@c * igraph_add_vertices --- Adds vertices to a graph. : igraph_add_vertices --- Adds vertices to a graph_.
@c * igraph_delete_edges --- Removes edges from a graph.: igraph_delete_edges --- Removes edges from a graph_.
@c * igraph_delete_vertices --- Removes vertices (with all their edges) from the graph.: igraph_delete_vertices --- Removes vertices [with all their edges] from the graph_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_add_edge --- Adds a single edge to a graph,  Next: igraph_add_edges --- Adds edges to a graph object_,  Up: Adding and Deleting Vertices and Edges

@c 4.2.3.1 igraph_add_edge -- Adds a single edge to a graph
@c ........................................................


@c      int igraph_add_edge(igraph_t *graph, igraph_integer_t from, igraph_integer_t to);

@c    For directed graphs the edge points from `from' to `to'.

@c    Note that if you want to add many edges to a big graph, then it is
@c unefficient to add them one by one, it is better to collect them into a
@c vector and add all of them via a single `igraph_add_edges()' (*note
@c igraph_add_edges --- Adds edges to a graph object_::) call.

@c    *Arguments:. *

@c `igraph':
@c      The graph.

@c `from':
@c      The id of the first vertex of the edge.

@c `to':
@c      The id of the second vertex of the edge.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_add_edges()' (*note igraph_add_edges --- Adds edges to a
@c      graph object_::) to add many edges, `igraph_delete_edges()' (*note
@c      igraph_delete_edges --- Removes edges from a graph_::) to remove
@c      edges and `igraph_add_vertices()' (*note igraph_add_vertices ---
@c      Adds vertices to a graph_::) to add vertices.

@c    Time complexity: O(|V|+|E|), the number of edges plus the number of
@c vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_add_edges --- Adds edges to a graph object_,  Next: igraph_add_vertices --- Adds vertices to a graph_,  Prev: igraph_add_edge --- Adds a single edge to a graph,  Up: Adding and Deleting Vertices and Edges

@c 4.2.3.2 igraph_add_edges -- Adds edges to a graph object.
@c .........................................................


@c      int igraph_add_edges(igraph_t *graph, const igraph_vector_t *edges,
@c      		     void *attr);

@c    The edges are given in a vector, the first two elements define the
@c first edge (the order is ` from' , ` to'  for directed graphs). The
@c vector should contain even number of integer numbers between zero and
@c the number of vertices in the graph minus one (inclusive). If you also
@c want to add new vertices, call igraph_add_vertices() first.

@c    *Arguments:. *

@c `graph':
@c      The graph to which the edges will be added.

@c `edges':
@c      The edges themselves.

@c `attr':
@c      The attributes of the new edges, only used by high level
@c      interfaces currently, you can supply 0 here.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVEVECTOR': invalid (odd) edges vector
@c      length, `IGRAPH_EINVVID': invalid vertex id in edges vector.

@c    This function invalidates all iterators.

@c    Time complexity: O(|V|+|E|) where |V| is the number of vertices and
@c |E| is the number of edges in the _new,_ extended graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_add_vertices --- Adds vertices to a graph_,  Next: igraph_delete_edges --- Removes edges from a graph_,  Prev: igraph_add_edges --- Adds edges to a graph object_,  Up: Adding and Deleting Vertices and Edges

@c 4.2.3.3 igraph_add_vertices -- Adds vertices to a graph.
@c ........................................................


@c      int igraph_add_vertices(igraph_t *graph, igraph_integer_t nv, void *attr);

@c    This function invalidates all iterators.

@c    *Arguments:. *

@c `graph':
@c      The graph object to extend.

@c `nv':
@c      Non-negative integer giving the number of vertices to add.

@c `attr':
@c      The attributes of the new vertices, only used by high level
@c      interfaces, you can supply 0 here.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid number of new vertices.

@c    Time complexity: O(|V|) where |V| is the number of vertices in the
@c _new,_ extended graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_delete_edges --- Removes edges from a graph_,  Next: igraph_delete_vertices --- Removes vertices [with all their edges] from the graph_,  Prev: igraph_add_vertices --- Adds vertices to a graph_,  Up: Adding and Deleting Vertices and Edges

@c 4.2.3.4 igraph_delete_edges -- Removes edges from a graph.
@c ..........................................................


@c      int igraph_delete_edges(igraph_t *graph, igraph_es_t edges);

@c    The edges to remove are given as an edge selector.

@c    This function cannot remove vertices, they will be kept, even if
@c they lose all their edges.

@c    This function invalidates all iterators.

@c    *Arguments:. *

@c `graph':
@c      The graph to work on.

@c `edges':
@c      The edges to remove.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|) where |V| and |E| are the number of
@c vertices and edges in the _original_ graph, respectively.

@c
@c File: igraph_reference_manual.info,  Node: igraph_delete_vertices --- Removes vertices [with all their edges] from the graph_,  Prev: igraph_delete_edges --- Removes edges from a graph_,  Up: Adding and Deleting Vertices and Edges

@c 4.2.3.5 igraph_delete_vertices -- Removes vertices (with all their edges) from the graph.
@c .........................................................................................


@c      int igraph_delete_vertices(igraph_t *graph, const igraph_vs_t vertices);

@c    This function changes the ids of the vertices (except in some very
@c special cases, but these should not be relied on anyway).

@c    This function invalidates all iterators.

@c    *Arguments:. *

@c `graph':
@c      The graph to work on.

@c `vertices':
@c      The ids of the vertices to remove in a vector. The vector may
@c      contain the same id more than once.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVVID': invalid vertex id.

@c    Time complexity: O(|V|+|E|), |V| and |E| are the number of vertices
@c and edges in the original graph.

@c
@c File: igraph_reference_manual.info,  Node: Error Handling,  Next: Data structure library; vector; matrix; other data types,  Prev: About igraph graphs; the basic interface,  Up: Top

@c 5 Error Handling
@c ****************

@c * Menu:

@c * Error handling basics::
@c * Error handlers::
@c * Error codes::
@c * Advanced topics::

@c
@c File: igraph_reference_manual.info,  Node: Error handling basics,  Next: Error handlers,  Up: Error Handling

@c 5.1 Error handling basics
@c =========================

@c `igraph' functions can run into various problems preventing them from
@c normal operation: the user might have supplied invalid arguments, eg. a
@c non-square matrix when a square-matrix was expected, or the program has
@c run out of memory while some more memory allocation is required, etc.

@c    By default `igraph' aborts the program when it runs into an error.
@c While this behavior might be good enough for smaller programs, it is
@c without doubt avoidable in larger projects. Please read further if your
@c project requires more sophisticated error handling. You can safely skip
@c the rest of this chapter otherwise.

@c
@c File: igraph_reference_manual.info,  Node: Error handlers,  Next: Error codes,  Prev: Error handling basics,  Up: Error Handling

@c 5.2 Error handlers
@c ==================

@c If `igraph' runs into an error - an invalid argument was supplied to a
@c function, or we've ran out of memory - the control is transferred to
@c the _ error handler _ function.

@c    The default error handler is `igraph_error_handler_abort' (*note
@c igraph_error_handler_abort --- Abort program in case of error_::) which
@c prints an error message and aborts the program.

@c    The `igraph_set_error_handler()' (*note igraph_set_error_handler ---
@c Set a new error handler_::) function can be used to set a new error
@c handler function of type `igraph_error_handler_t' (*note
@c igraph_error_handler_t --- Type of error handler functions_::), see the
@c documentation of this type for details.

@c    There are two other predefined error handler functions,
@c `igraph_error_handler_ignore' (*note igraph_error_handler_ignore ---
@c Ignore errors_::) and `igraph_error_handler_printignore' (*note
@c igraph_error_handler_printignore --- Print and ignore errors_::), these
@c deallocate the temporarily allocated memory (more about this later) and
@c return with the error code. The latter also prints an error message. If
@c you use these error handlers you need to take care about possible
@c errors yourself by checking the return value of (almost) every non-void
@c `igraph' function.

@c    Independently of the error handler installed, all functions in the
@c library do their best to leave their arguments _semantically_ unchanged
@c if an error happens. By semantically we mean that the implementation of
@c an object supplied as an argument might change, but its `meaning' in
@c most cases does not. The rare occasions when this rule is violated are
@c documented in this manual.

@c * Menu:

@c * igraph_error_handler_t --- Type of error handler functions.: igraph_error_handler_t --- Type of error handler functions_.
@c * igraph_error_handler_abort --- Abort program in case of error.: igraph_error_handler_abort --- Abort program in case of error_.
@c * igraph_error_handler_ignore --- Ignore errors.: igraph_error_handler_ignore --- Ignore errors_.
@c * igraph_error_handler_printignore --- Print and ignore errors.: igraph_error_handler_printignore --- Print and ignore errors_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_error_handler_t --- Type of error handler functions_,  Next: igraph_error_handler_abort --- Abort program in case of error_,  Up: Error handlers

@c 5.2.1 igraph_error_handler_t -- Type of error handler functions.
@c ----------------------------------------------------------------


@c      typedef void igraph_error_handler_t (const char * reason, const char * file,
@c      				     int line, int igraph_errno);

@c    This is the type of the error handler functions.

@c    *Arguments:. *

@c `reason':
@c      Textual description of the error.

@c `file':
@c      The source file in which the error is noticed.

@c `line':
@c      The number of the line in the source file which triggered the error

@c `igraph_errno':
@c      The `igraph' error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_error_handler_abort --- Abort program in case of error_,  Next: igraph_error_handler_ignore --- Ignore errors_,  Prev: igraph_error_handler_t --- Type of error handler functions_,  Up: Error handlers

@c 5.2.2 igraph_error_handler_abort -- Abort program in case of error.
@c -------------------------------------------------------------------


@c      extern igraph_error_handler_t igraph_error_handler_abort;

@c    The default error handler, prints an error message and aborts the
@c program.

@c
@c File: igraph_reference_manual.info,  Node: igraph_error_handler_ignore --- Ignore errors_,  Next: igraph_error_handler_printignore --- Print and ignore errors_,  Prev: igraph_error_handler_abort --- Abort program in case of error_,  Up: Error handlers

@c 5.2.3 igraph_error_handler_ignore -- Ignore errors.
@c ---------------------------------------------------


@c      extern igraph_error_handler_t igraph_error_handler_ignore;

@c    This error handler frees the temporarily allocated memory and returns
@c with the error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_error_handler_printignore --- Print and ignore errors_,  Prev: igraph_error_handler_ignore --- Ignore errors_,  Up: Error handlers

@c 5.2.4 igraph_error_handler_printignore -- Print and ignore errors.
@c ------------------------------------------------------------------


@c      extern igraph_error_handler_t igraph_error_handler_printignore;

@c    Frees temporarily allocated memory, prints an error message to the
@c standard error and returns with the error code.

@c
@c File: igraph_reference_manual.info,  Node: Error codes,  Next: Advanced topics,  Prev: Error handlers,  Up: Error Handling

@c 5.3 Error codes
@c ===============

@c Every `igraph' function which can fail return a single integer error
@c code. Some functions are very simple and cannot run into any error,
@c these may return other types, or `void' as well. The error codes are
@c defined by the `igraph_error_type_t' (*note igraph_error_type_t ---
@c Error code type_::) enumeration.

@c * Menu:

@c * igraph_error_type_t --- Error code type.: igraph_error_type_t --- Error code type_.
@c * igraph_strerror --- Textual description of an error.: igraph_strerror --- Textual description of an error_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_error_type_t --- Error code type_,  Next: igraph_strerror --- Textual description of an error_,  Up: Error codes

@c 5.3.1 igraph_error_type_t -- Error code type.
@c ---------------------------------------------


@c      typedef enum {
@c        IGRAPH_SUCCESS       = 0,
@c        IGRAPH_FAILURE       = 1,
@c        IGRAPH_ENOMEM        = 2,
@c        IGRAPH_PARSEERROR    = 3,
@c        IGRAPH_EINVAL        = 4,
@c        IGRAPH_EXISTS        = 5,
@c        IGRAPH_EINVEVECTOR   = 6,
@c        IGRAPH_EINVVID       = 7,
@c        IGRAPH_NONSQUARE     = 8,
@c        IGRAPH_EINVMODE      = 9,
@c        IGRAPH_EFILE         = 10,
@c        IGRAPH_UNIMPLEMENTED = 12,
@c        IGRAPH_INTERRUPTED   = 13,
@c        IGRAPH_DIVERGED      = 14,
@c        IGRAPH_ARPACK_PROD      = 15,
@c        IGRAPH_ARPACK_NPOS      = 16,
@c        IGRAPH_ARPACK_NEVNPOS   = 17,
@c        IGRAPH_ARPACK_NCVSMALL  = 18,
@c        IGRAPH_ARPACK_NONPOSI   = 19,
@c        IGRAPH_ARPACK_WHICHINV  = 20,
@c        IGRAPH_ARPACK_BMATINV   = 21,
@c        IGRAPH_ARPACK_WORKLSMALL= 22,
@c        IGRAPH_ARPACK_TRIDERR   = 23,
@c        IGRAPH_ARPACK_ZEROSTART = 24,
@c        IGRAPH_ARPACK_MODEINV   = 25,
@c        IGRAPH_ARPACK_MODEBMAT  = 26,
@c        IGRAPH_ARPACK_ISHIFT    = 27,
@c        IGRAPH_ARPACK_NEVBE     = 28,
@c        IGRAPH_ARPACK_NOFACT    = 29,
@c        IGRAPH_ARPACK_FAILED    = 30,
@c        IGRAPH_ARPACK_HOWMNY    = 31,
@c        IGRAPH_ARPACK_HOWMNYS   = 32,
@c        IGRAPH_ARPACK_EVDIFF    = 33,
@c        IGRAPH_ARPACK_SHUR      = 34,
@c        IGRAPH_ARPACK_LAPACK    = 35,
@c        IGRAPH_ARPACK_UNKNOWN   = 36,
@c        IGRAPH_ENEGLOOP         = 37,
@c        IGRAPH_EINTERNAL        = 38
@c      } igraph_error_type_t;

@c    These are the possible valued returned by `igraph' functions.  Note
@c that these are interesting only if you defined an error handler with
@c `igraph_set_error_handler()' (*note igraph_set_error_handler --- Set a
@c new error handler_::). Otherwise the program is aborted and the
@c function causing the error never returns.

@c    *Values:. *

@c `IGRAPH_SUCCESS':
@c      The function successfully completed its task.

@c `IGRAPH_FAILURE':
@c      Something went wrong. You'll almost never meet this error as
@c      normally more specific error codes are used.

@c `IGRAPH_ENOMEM':
@c      There wasn't enough memory to allocate on the heap.

@c `IGRAPH_PARSEERROR':
@c      A parse error was found in a file.

@c `IGRAPH_EINVAL':
@c      A parameter's value is invalid. Eg. negative number was specified
@c      as the number of vertices.

@c `IGRAPH_EXISTS':
@c      A graph/vertex/edge attribute is already installed with the given
@c      name.

@c `IGRAPH_EINVEVECTOR':
@c      Invalid vector of vertex ids. A vertex id is either negative or
@c      bigger than the number of vertices minus one.

@c `IGRAPH_EINVVID':
@c      Invalid vertex id, negative or too big.

@c `IGRAPH_NONSQUARE':
@c      A non-square matrix was received while a square matrix was
@c      expected.

@c `IGRAPH_EINVMODE':
@c      Invalid mode parameter.

@c `IGRAPH_EFILE':
@c      A file operation failed. Eg. a file doesn't exist, or the user ha
@c      no rights to open it.

@c `IGRAPH_UNIMPLEMENTED':
@c      Attempted to call an unimplemented or disabled (at compile-time)
@c      function.

@c `IGRAPH_DIVERGED':
@c      A numeric algorithm failed to converge.

@c `IGRAPH_ARPACK_PROD':
@c      Matrix-vector product failed.

@c `IGRAPH_ARPACK_NPOS':
@c      N must be positive.

@c `IGRAPH_ARPACK_NEVNPOS':
@c      NEV must be positive.

@c `IGRAPH_ARPACK_NCVSMALL':
@c      NCV must be bigger.

@c `IGRAPH_ARPACK_NONPOSI':
@c      Maximum number of iterations should be positive.

@c `IGRAPH_ARPACK_WHICHINV':
@c      Invalid WHICH parameter.

@c `IGRAPH_ARPACK_BMATINV':
@c      Invalid BMAT parameter.

@c `IGRAPH_ARPACK_WORKLSMALL':
@c      WORKL is too small.

@c `IGRAPH_ARPACK_TRIDERR':
@c      LAPACK error in tridiagonal eigenvalue calculation.

@c `IGRAPH_ARPACK_ZEROSTART':
@c      Starting vector is zero.

@c `IGRAPH_ARPACK_MODEINV':
@c      MODE is invalid.

@c `IGRAPH_ARPACK_MODEBMAT':
@c      MODE and BMAT are not compatible.

@c `IGRAPH_ARPACK_ISHIFT':
@c      ISHIFT must be 0 or 1.

@c `IGRAPH_ARPACK_NEVBE':
@c      NEV and WHICH='BE' are incompatible.

@c `IGRAPH_ARPACK_NOFACT':
@c      Could not build an Arnoldi factorization.

@c `IGRAPH_ARPACK_FAILED':
@c      No eigenvalues to sufficient accuracy.

@c `IGRAPH_ARPACK_HOWMNY':
@c      HOWMNY is invalid.

@c `IGRAPH_ARPACK_HOWMNYS':
@c      HOWMNY='S' is not implemented.

@c `IGRAPH_ARPACK_EVDIFF':
@c      Different number of converged Ritz values.

@c `IGRAPH_ARPACK_SHUR':
@c      Error from calculation of a real Schur form.

@c `IGRAPH_ARPACK_LAPACK':
@c      LAPACK (dtrevc) error for calculating eigenvectors.

@c `IGRAPH_ARPACK_UNKNOWN':
@c      Unkown ARPACK error.

@c `IGRAPH_ENEGLOOP':
@c      Negative loop detected while calculating shortest paths.

@c `IGRAPH_EINTERNAL':
@c      Internal error, likely a bug in igraph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strerror --- Textual description of an error_,  Prev: igraph_error_type_t --- Error code type_,  Up: Error codes

@c 5.3.2 igraph_strerror -- Textual description of an error.
@c ---------------------------------------------------------


@c      const char* igraph_strerror(const int igraph_errno);

@c    This is a simple utility function, it gives a short general textual
@c description for an `igraph' error code.

@c    *Arguments:. *

@c `igraph_errno':
@c      The `igraph' error code.

@c    *Returns:. *

@c `'
@c      pointer to the textual description of the error code.

@c
@c File: igraph_reference_manual.info,  Node: Advanced topics,  Prev: Error codes,  Up: Error Handling

@c 5.4 Advanced topics
@c ===================

@c * Menu:

@c * Writing error handlers::
@c * Error handling internals::
@c * Deallocating memory::
@c * Writing igraph functions with proper error handling::
@c * Error handling and threads::

@c
@c File: igraph_reference_manual.info,  Node: Writing error handlers,  Next: Error handling internals,  Up: Advanced topics

@c 5.4.1 Writing error handlers
@c ----------------------------

@c The contents of the rest of this chapter might be useful only for those
@c who want to create an interface to `igraph' from another language. Most
@c readers can safely skip to the next chapter.

@c    You can write and install error handlers simply by defining a
@c function of type `igraph_error_handler_t' (*note igraph_error_handler_t
@c --- Type of error handler functions_::) and calling
@c `igraph_set_error_handler()' (*note igraph_set_error_handler --- Set a
@c new error handler_::). This feature is useful for interface writers, as
@c `igraph' will have the chance to signal errors the appropriate way, eg.
@c the R interface defines an error handler which calls the `error()'
@c function, as required by R, while the Python interface has an error
@c handler which raises an exception according to the Python way.

@c    If you want to write an error handler, your error handler should
@c call `IGRAPH_FINALLY_FREE()' (*note IGRAPH_FINALLY_FREE --- Deallocate
@c all registered objects_::) to deallocate all temporary memory to
@c prevent memory leaks.

@c * Menu:

@c * igraph_set_error_handler --- Set a new error handler.: igraph_set_error_handler --- Set a new error handler_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_set_error_handler --- Set a new error handler_,  Up: Writing error handlers

@c 5.4.1.1 igraph_set_error_handler -- Set a new error handler.
@c ............................................................


@c      igraph_error_handler_t*
@c      igraph_set_error_handler(igraph_error_handler_t* new_handler);

@c    Installs a new error handler. If called with 0, it installs the
@c default error handler (which is currently `igraph_error_handler_abort'
@c (*note igraph_error_handler_abort --- Abort program in case of
@c error_::)).

@c    *Arguments:. *

@c `new_handler':
@c      The error handler function to install.

@c    *Returns:. *

@c `'
@c      The old error handler function. This should be saved and restored
@c      if `new_handler' is not needed any more.

@c
@c File: igraph_reference_manual.info,  Node: Error handling internals,  Next: Deallocating memory,  Prev: Writing error handlers,  Up: Advanced topics

@c 5.4.2 Error handling internals
@c ------------------------------

@c If an error happens, the functions in the library call the
@c `IGRAPH_ERROR' (*note IGRAPH_ERROR --- Trigger an error_::) macro with
@c a textual description of the error and an `igraph' error code. This
@c macro calls (through the `igraph_error()' (*note igraph_error ---
@c Trigger an error_::) function) the installed error handler. Another
@c useful macro is `IGRAPH_CHECK()' (*note IGRAPH_CHECK --- Check the
@c return value of a function call_::), this checks the return value of its
@c argument which is normally a function call, and calls `IGRAPH_ERROR'
@c (*note IGRAPH_ERROR --- Trigger an error_::) if it is not
@c `IGRAPH_SUCCESS'.

@c * Menu:

@c * IGRAPH_ERROR --- Trigger an error.: IGRAPH_ERROR --- Trigger an error_.
@c * igraph_error --- Trigger an error.: igraph_error --- Trigger an error_.
@c * IGRAPH_CHECK --- Check the return value of a function call.: IGRAPH_CHECK --- Check the return value of a function call_.

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_ERROR --- Trigger an error_,  Next: igraph_error --- Trigger an error_,  Up: Error handling internals

@c 5.4.2.1 IGRAPH_ERROR -- Trigger an error.
@c .........................................


@c      #define IGRAPH_ERROR(reason,igraph_errno)

@c    `igraph' functions usually use this macro when they notice an error.
@c It calls `igraph_error()' (*note igraph_error --- Trigger an error_::)
@c with the proper parameters and if that returns the macro returns the
@c "calling" function as well, with the error code. If for some
@c (suspicious) reason you want to call the error handler without
@c returning from the current function, call `igraph_error()' (*note
@c igraph_error --- Trigger an error_::) directly.

@c    *Arguments:. *

@c `reason':
@c      Textual description of the error. This should be something more
@c      explaning than the text associated with the error code. Eg. if the
@c      error code is `IGRAPH_EINVAL', its asssociated text (see
@c      `igraph_strerror()' (*note igraph_strerror --- Textual description
@c      of an error_::)) is "Invalid value" and this string should explain
@c      which parameter was invalid and maybe why.

@c `igraph_errno':
@c      The `igraph' error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_error --- Trigger an error_,  Next: IGRAPH_CHECK --- Check the return value of a function call_,  Prev: IGRAPH_ERROR --- Trigger an error_,  Up: Error handling internals

@c 5.4.2.2 igraph_error -- Trigger an error.
@c .........................................


@c      int igraph_error(const char *reason, const char *file, int line,
@c      		 int igraph_errno);

@c    `igraph' functions usually call this fuction (most often via the
@c `IGRAPH_ERROR' (*note IGRAPH_ERROR --- Trigger an error_::) macro) if
@c they notice an error.  It calls the currently installed error handler
@c function with the supplied arguments.

@c    *Arguments:. *

@c `reason':
@c      Textual description of the error.

@c `file':
@c      The source file in which the error was noticed.

@c `line':
@c      The number of line in the source file which triggered the error.

@c `igraph_errno':
@c      The `igraph' error code.

@c    *Returns:. *

@c `'
@c      the error code (if it returns)

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_CHECK --- Check the return value of a function call_,  Prev: igraph_error --- Trigger an error_,  Up: Error handling internals

@c 5.4.2.3 IGRAPH_CHECK -- Check the return value of a function call.
@c ..................................................................


@c      #define IGRAPH_CHECK(a)

@c    *Arguments:. *

@c `a':
@c      An expression, usually a function call.

@c    Executes the expression and checks its value. If this is not
@c `IGRAPH_SUCCESS', it calls `IGRAPH_ERROR' (*note IGRAPH_ERROR ---
@c Trigger an error_::) with the value as the error code. Here is an
@c example usage:

@c       IGRAPH_CHECK(vector_push_back(&v, 100));

@c    There is only one reason to use this macro when writing `igraph'
@c functions. If the user installs an error handler which returns to the
@c auxilary calling code (like `igraph_error_handler_ignore' (*note
@c igraph_error_handler_ignore --- Ignore errors_::) and
@c `igraph_error_handler_printignore' (*note
@c igraph_error_handler_printignore --- Print and ignore errors_::)), and
@c the `igraph' function signalling the error is called from another
@c `igraph' function then we need to make sure that the error is
@c propagated back to the auxilary (ie. non-igraph) calling function. This
@c is achieved by using `IGRAPH_CHECK' on every `igraph' call which can
@c return an error code.

@c
@c File: igraph_reference_manual.info,  Node: Deallocating memory,  Next: Writing igraph functions with proper error handling,  Prev: Error handling internals,  Up: Advanced topics

@c 5.4.3 Deallocating memory
@c -------------------------

@c If a function runs into an error (and the program is not aborted) the
@c error handler should deallocate all temporary memory. This is done by
@c storing the address and the destroy function of all temporary objects
@c in a stack. The `IGRAPH_FINALLY' (*note IGRAPH_FINALLY --- Register an
@c object for deallocation_::) function declares an object as temporary by
@c placing its address in the stack. If an `igraph' function returns with
@c success it calls `IGRAPH_FINALLY_CLEAN()' (*note IGRAPH_FINALLY_CLEAN
@c --- Signal clean deallocation of objects_::) with the number of objects
@c to remove from the stack. If an error happens however, the error
@c handler should call `IGRAPH_FINALLY_FREE()' (*note IGRAPH_FINALLY_FREE
@c --- Deallocate all registered objects_::) to deallocate each object
@c added to the stack. This means that the temporary objects allocated in
@c the calling function (and etc.) will be freed as well.

@c * Menu:

@c * IGRAPH_FINALLY --- Register an object for deallocation.: IGRAPH_FINALLY --- Register an object for deallocation_.
@c * IGRAPH_FINALLY_CLEAN --- Signal clean deallocation of objects.: IGRAPH_FINALLY_CLEAN --- Signal clean deallocation of objects_.
@c * IGRAPH_FINALLY_FREE --- Deallocate all registered objects.: IGRAPH_FINALLY_FREE --- Deallocate all registered objects_.

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_FINALLY --- Register an object for deallocation_,  Next: IGRAPH_FINALLY_CLEAN --- Signal clean deallocation of objects_,  Up: Deallocating memory

@c 5.4.3.1 IGRAPH_FINALLY -- Register an object for deallocation.
@c ..............................................................


@c      #define IGRAPH_FINALLY(func,ptr)

@c    *Arguments:. *

@c `func':
@c      The address of the function which is normally called to destroy
@c      the object.

@c `ptr':
@c      Pointer to the object itself.

@c    This macro places the address of an object, together with the
@c address of its destructor in a stack. This stack is used if an error
@c happens to deallocate temporarily allocated objects to prevent memory
@c leaks.

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_FINALLY_CLEAN --- Signal clean deallocation of objects_,  Next: IGRAPH_FINALLY_FREE --- Deallocate all registered objects_,  Prev: IGRAPH_FINALLY --- Register an object for deallocation_,  Up: Deallocating memory

@c 5.4.3.2 IGRAPH_FINALLY_CLEAN -- Signal clean deallocation of objects.
@c .....................................................................


@c      void IGRAPH_FINALLY_CLEAN(int num);

@c    Removes the specified number of objects from the stack of
@c temporarily allocated objects. Most often this is called just before
@c returning from a function.

@c    *Arguments:. *

@c `num':
@c      The number of objects to remove from the bookkeeping stack.

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_FINALLY_FREE --- Deallocate all registered objects_,  Prev: IGRAPH_FINALLY_CLEAN --- Signal clean deallocation of objects_,  Up: Deallocating memory

@c 5.4.3.3 IGRAPH_FINALLY_FREE -- Deallocate all registered objects.
@c .................................................................


@c      void IGRAPH_FINALLY_FREE(void);

@c    Calls the destroy function for all objects in the stack of
@c temporarily allocated objects. This is usually called only from an
@c error handler. It is _not_ appropriate to use it instead of destroying
@c each unneeded object of a function, as it destroys the temporary
@c objects of the caller function (and so on) as well.

@c
@c File: igraph_reference_manual.info,  Node: Writing igraph functions with proper error handling,  Next: Error handling and threads,  Prev: Deallocating memory,  Up: Advanced topics

@c 5.4.4 Writing igraph functions with proper error handling
@c ---------------------------------------------------------

@c There are some simple rules to keep in order to have functions behaving
@c well in erroneous situations. First, check the arguments of the
@c functions and call `IGRAPH_ERROR' (*note IGRAPH_ERROR --- Trigger an
@c error_::) if they are invalid. Second, call `IGRAPH_FINALLY' (*note
@c IGRAPH_FINALLY --- Register an object for deallocation_::) on each
@c dynamically allocated object and call `IGRAPH_FINALLY_CLEAN()' (*note
@c IGRAPH_FINALLY_CLEAN --- Signal clean deallocation of objects_::) with
@c the proper argument before returning. Third, use IGRAPH_CHECK on all
@c `igraph' function calls which can generate errors.

@c    The size of the stack used for this bookkeeping is fixed, and small.
@c If you want to allocate several objects, write a destroy function which
@c can deallocate all of these. See the `adjlist.c' file in the `igraph'
@c source for an example.

@c    For some functions these mechanisms are simply not flexible enough.
@c These functions should define their own error handlers and restore the
@c error handler before they return.

@c
@c File: igraph_reference_manual.info,  Node: Error handling and threads,  Prev: Writing igraph functions with proper error handling,  Up: Advanced topics

@c 5.4.5 Error handling and threads
@c --------------------------------

@c It is likely that the `igraph' error handling method is _not_
@c thread-safe, mainly because of the static global stack which is used to
@c store the address of the temporarily allocated objects. This issue
@c might be addressed in a later version of `igraph'.

@c
@c File: igraph_reference_manual.info,  Node: Data structure library; vector; matrix; other data types,  Next: Graph Generators,  Prev: Error Handling,  Up: Top

@c 6 Data structure library: vector, matrix, other data types
@c **********************************************************

@c * Menu:

@c * About template types::
@c * Vectors::
@c * Matrices::
@c * Sparse matrices::
@c * Stacks::
@c * Double-ended queues::
@c * Maximum and minimum heaps::
@c * String vectors::
@c * Adjacency lists::

@c
@c File: igraph_reference_manual.info,  Node: About template types,  Next: Vectors,  Up: Data structure library; vector; matrix; other data types

@c 6.1 About template types
@c ========================

@c Some of the container types listed in this section are defined for many
@c base types. This is similar to templates in C++ and generics in Ada,
@c but it is implemented via precompiler macros since the C language
@c cannot handle it. Here is the list of template types and the all base
@c types they currently support:

@c vector
@c      Vector is currently defined for `igraph_real_t', `long int'
@c      (long), `char' (char), `igraph_bool_t' (bool). The default is
@c      `igraph_real_t'.

@c matrix
@c      Matrix is currently defined for `igraph_real_t', `long int'
@c      (long), `char' (char), `igraph_bool_t' (bool). The default is
@c      `igraph_real_t'.

@c array3
@c      Array3 is currently defined for `igraph_real_t', `long int'
@c      (long), `char' (char), `igraph_bool_t' (bool). The default is
@c      `igraph_real_t'.

@c stack
@c      Stack is currently defined for `igraph_real_t', `long int' (long),
@c      `char' (char), `igraph_bool_t' (bool). The default is
@c      `igraph_real_t'.

@c double-ended queue
@c      Dqueue is currently defined for `igraph_real_t', `long int'
@c      (long), `char' (char), `igraph_bool_t' (bool). The default is
@c      `igraph_real_t'.

@c heap
@c      Heap is currently defined for `igraph_real_t', `long int' (long),
@c      `char' (char).  In addition both maximum and minimum heaps are
@c      available.  The default is the `igraph_real_t' maximum heap.

@c    The name of the base element (in parens) is added to the function
@c names, except for te default type.

@c    Some examples:

@c    * `igraph_vector_t' is a vector of `igraph_real_t' elements. Its
@c      functions are `igraph_vector_init', `igraph_vector_destroy',
@c      `igraph_vector_sort', etc.

@c    * `igraph_vector_bool_t' is a vector of `igraph_bool_t' elements,
@c      initialize it with `igraph_vector_bool_init', destroy it with
@c      `igraph_vector_bool_destroy', etc.

@c    * `igraph_heap_t' is a maximum heap with `igraph_real_t' elements.
@c      The corresponding functions are `igraph_heap_init',
@c      `igraph_heap_pop', etc.

@c    * `igraph_heap_min_t' is a minimum heap with `igraph_real_t'
@c      elements. The corresponding functions are called
@c      `igraph_heap_min_init', `igraph_heap_min_pop', etc.

@c    * `igraph_heap_long_t' is a maximum heap with `long int' elements.
@c      Its function have the `igraph_heap_long_' prefix.

@c    * `igraph_heap_min_long_t' is a minimum heap containing `long int'
@c      elements. Its functions have the `igraph_heap_min_long_' prefix.

@c    Note that the VECTOR (*note VECTOR --- Accessing an element of a
@c vector_::) and the MATRIX (*note MATRIX --- Accessing an element of a
@c matrix_::) macros can be used on _all_ vector and matrix types.

@c
@c File: igraph_reference_manual.info,  Node: Vectors,  Next: Matrices,  Prev: About template types,  Up: Data structure library; vector; matrix; other data types

@c 6.2 Vectors
@c ===========

@c * Menu:

@c * About igraph_vector_t objects::
@c * Constructors and Destructors::
@c * Initializing elements::
@c * Accessing elements::
@c * Vector views::
@c * Copying vectors::
@c * Exchanging elements::
@c * Vector operations::
@c * Finding minimum and maximum::
@c * Vector properties::
@c * Searching for elements::
@c * Resizing operations::
@c * Sorting::
@c * Pointer vectors (igraph_vector_ptr_t): Pointer vectors [igraph_vector_ptr_t].

@c
@c File: igraph_reference_manual.info,  Node: About igraph_vector_t objects,  Next: Constructors and Destructors,  Up: Vectors

@c 6.2.1 About igraph_vector_t objects
@c -----------------------------------

@c The `igraph_vector_t' data type is a simple and efficient interface to
@c arrays containing numbers. It is something similar as (but much simpler
@c than) the `vector' template in the C++ standard library.

@c    Vectors are used extensively in `igraph', all functions which expect
@c or return a list of numbers use igraph_vector_t to achieve this.

@c    The `igraph_vector_t' type usually uses O(n) space to store n
@c elements. Sometimes it uses more, this is because vectors can shrink,
@c but even if they shrink, the current implementation does not free a
@c single bit of memory.

@c    The elements in an `igraph_vector_t' object are indexed from zero,
@c we follow the usual C convention here.

@c    The elements of a vector always occupy a single block of memory, the
@c starting address of this memory block can be queried with the `VECTOR'
@c (*note VECTOR --- Accessing an element of a vector_::) macro. This way,
@c vector objects can be used with standard mathematical libraries, like
@c the GNU Scientific Library.

@c
@c File: igraph_reference_manual.info,  Node: Constructors and Destructors,  Next: Initializing elements,  Prev: About igraph_vector_t objects,  Up: Vectors

@c 6.2.2 Constructors and Destructors
@c ----------------------------------

@c `igraph_vector_t' objects have to be initialized before using them,
@c this is analogous to calling a constructor on them. There are a number
@c of `igraph_vector_t' constructors, for your convenience.
@c `igraph_vector_init()' (*note igraph_vector_init --- Initializes a
@c vector object [constructor]_::) is the basic constructor, it creates a
@c vector of the given length, filled with zeros.  `igraph_vector_copy()'
@c (*note igraph_vector_copy --- Initializes a vector from another vector
@c object [constructor]_::) creates a new identical copy of an already
@c existing and initialized vector. `igraph_vector_init_copy()' (*note
@c igraph_vector_init_copy --- Initializes a vector from an ordinary C
@c array [constructor]_::) creates a vector by copying a regular C array.
@c `igraph_vector_init_seq()' (*note igraph_vector_init_seq ---
@c Initializes a vector with a sequence_::) creates a vector containing a
@c regular sequence with increment one.

@c    `igraph_vector_view()' (*note igraph_vector_view --- Handle a
@c regular C array as a igraph_vector_t_::) is a special constructor, it
@c allows you to handle a regular C array as a `vector' without copying
@c its elements.

@c    If a `igraph_vector_t' object is not needed any more, it should be
@c destroyed to free its allocated memory by calling the `igraph_vector_t'
@c destructor, `igraph_vector_destroy()' (*note igraph_vector_destroy ---
@c Destroys a vector object_::).

@c    Note that vectors created by `igraph_vector_view()' (*note
@c igraph_vector_view --- Handle a regular C array as a
@c igraph_vector_t_::) are special, you mustn't call
@c `igraph_vector_destroy()' (*note igraph_vector_destroy --- Destroys a
@c vector object_::) on these.

@c * Menu:

@c * igraph_vector_init --- Initializes a vector object (constructor).: igraph_vector_init --- Initializes a vector object [constructor]_.
@c * igraph_vector_init_copy --- Initializes a vector from an ordinary C array (constructor).: igraph_vector_init_copy --- Initializes a vector from an ordinary C array [constructor]_.
@c * igraph_vector_init_seq --- Initializes a vector with a sequence.: igraph_vector_init_seq --- Initializes a vector with a sequence_.
@c * igraph_vector_copy --- Initializes a vector from another vector object (constructor).: igraph_vector_copy --- Initializes a vector from another vector object [constructor]_.
@c * igraph_vector_destroy --- Destroys a vector object.: igraph_vector_destroy --- Destroys a vector object_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_init --- Initializes a vector object [constructor]_,  Next: igraph_vector_init_copy --- Initializes a vector from an ordinary C array [constructor]_,  Up: Constructors and Destructors

@c 6.2.2.1 igraph_vector_init -- Initializes a vector object (constructor).
@c ........................................................................


@c      int igraph_vector_init      (igraph_vector_t* v, int long size);

@c    Every vector needs to be initialized before it can be used, and
@c there are a number of initialization functions or otherwise called
@c constructors.

@c    Every vector object initialized by this function should be destroyed
@c (ie. the memory allocated for it should be freed) when it is not needed
@c anymore, the `igraph_vector_destroy()' (*note igraph_vector_destroy ---
@c Destroys a vector object_::) function is responsible for this.

@c    *Arguments:. *

@c `v':
@c      Pointer to a not yet initialized vector object.

@c `size':
@c      The size of the vector.

@c    *Returns:. *

@c `'
@c      error code: `IGRAPH_ENOMEM' if there is not enough memory.

@c    Time complexity: operating system dependent, the amount of `time'
@c required to allocate O(n) elements, n is the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_init_copy --- Initializes a vector from an ordinary C array [constructor]_,  Next: igraph_vector_init_seq --- Initializes a vector with a sequence_,  Prev: igraph_vector_init --- Initializes a vector object [constructor]_,  Up: Constructors and Destructors

@c 6.2.2.2 igraph_vector_init_copy -- Initializes a vector from an ordinary C array (constructor).
@c ...............................................................................................


@c      int igraph_vector_init_copy(igraph_vector_t *v,
@c      				      igraph_real_t *data, long int length);

@c    *Arguments:. *

@c `v':
@c      Pointer to an uninitialized vector object.

@c `data':
@c      A regular C array.

@c `length':
@c      The length of the C array.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM' if there is not enough memory.

@c    Time complexity: operating system specific, usually O(`length').

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_init_seq --- Initializes a vector with a sequence_,  Next: igraph_vector_copy --- Initializes a vector from another vector object [constructor]_,  Prev: igraph_vector_init_copy --- Initializes a vector from an ordinary C array [constructor]_,  Up: Constructors and Destructors

@c 6.2.2.3 igraph_vector_init_seq -- Initializes a vector with a sequence.
@c .......................................................................


@c      int igraph_vector_init_seq(igraph_vector_t *v,
@c      				     igraph_real_t from, igraph_real_t to);

@c    The vector will contain the numbers `from', `from'+1, ..., `to'.

@c    *Arguments:. *

@c `v':
@c      Pointer to an uninitialized vector object.

@c `from':
@c      The lower limit in the sequence (inclusive).

@c `to':
@c      The upper limit in the sequence (inclusive).

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM': out of memory.

@c    Time complexity: O(n), the number of elements in the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_copy --- Initializes a vector from another vector object [constructor]_,  Next: igraph_vector_destroy --- Destroys a vector object_,  Prev: igraph_vector_init_seq --- Initializes a vector with a sequence_,  Up: Constructors and Destructors

@c 6.2.2.4 igraph_vector_copy -- Initializes a vector from another vector object (constructor).
@c ............................................................................................


@c      int igraph_vector_copy(igraph_vector_t *to,
@c      				 const igraph_vector_t *from);

@c    The contents of the existing vector object will be copied to the new
@c one.

@c    *Arguments:. *

@c `to':
@c      Pointer to a not yet initialized vector object.

@c `from':
@c      The original vector object to copy.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM' if there is not enough memory.

@c    Time complexity: operating system dependent, usually O(n), n is the
@c size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_destroy --- Destroys a vector object_,  Prev: igraph_vector_copy --- Initializes a vector from another vector object [constructor]_,  Up: Constructors and Destructors

@c 6.2.2.5 igraph_vector_destroy -- Destroys a vector object.
@c ..........................................................


@c      void igraph_vector_destroy   (igraph_vector_t* v);

@c    All vectors initialized by `igraph_vector_init()' (*note
@c igraph_vector_init --- Initializes a vector object [constructor]_::)
@c should be properly destroyed by this function. A destroyed vector needs
@c to be reinitialized by `igraph_vector_init()' (*note igraph_vector_init
@c --- Initializes a vector object [constructor]_::),
@c `igraph_vector_init_copy()' (*note igraph_vector_init_copy ---
@c Initializes a vector from an ordinary C array [constructor]_::) or
@c another constructor.

@c    *Arguments:. *

@c `v':
@c      Pointer to the (previously initialized) vector object to destroy.

@c    Time complexity: operating system dependent.

@c
@c File: igraph_reference_manual.info,  Node: Initializing elements,  Next: Accessing elements,  Prev: Constructors and Destructors,  Up: Vectors

@c 6.2.3 Initializing elements
@c ---------------------------

@c * Menu:

@c * igraph_vector_null --- Sets each element in the vector to zero.: igraph_vector_null --- Sets each element in the vector to zero_.
@c * igraph_vector_fill --- Fill a vector with a constant element::

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_null --- Sets each element in the vector to zero_,  Next: igraph_vector_fill --- Fill a vector with a constant element,  Up: Initializing elements

@c 6.2.3.1 igraph_vector_null -- Sets each element in the vector to zero.
@c ......................................................................


@c      void igraph_vector_null      (igraph_vector_t* v);

@c    Note that `igraph_vector_init()' (*note igraph_vector_init ---
@c Initializes a vector object [constructor]_::) sets the elements to zero
@c as well, so it makes no sense to call this function on a just
@c initialized vector.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    Time complexity: O(n), the size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_fill --- Fill a vector with a constant element,  Prev: igraph_vector_null --- Sets each element in the vector to zero_,  Up: Initializing elements

@c 6.2.3.2 igraph_vector_fill -- Fill a vector with a constant element
@c ...................................................................


@c      void igraph_vector_fill      (igraph_vector_t* v, igraph_real_t e);

@c    Sets each element of the vector to the supplied constant.

@c    *Arguments:. *

@c `vector':
@c      The vector to work on.

@c `e':
@c      The element to fill with.

@c    Time complexity: O(n), the size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: Accessing elements,  Next: Vector views,  Prev: Initializing elements,  Up: Vectors

@c 6.2.4 Accessing elements
@c ------------------------

@c The simplest way to access an element of a vector is to use the
@c `VECTOR' (*note VECTOR --- Accessing an element of a vector_::) macro.
@c This macro can be used both for querying and setting `igraph_vector_t'
@c elements. If you need a function, `igraph_vector_e()' (*note
@c igraph_vector_e --- Access an element of a vector_::) queries and
@c `igraph_vector_set()' (*note igraph_vector_set --- Assignment to an
@c element of a vector_::) sets an element of a vector.
@c `igraph_vector_e_ptr()' (*note igraph_vector_e_ptr --- Get the address
@c of an element of a vector::) returns the address of an element.

@c    `igraph_vector_tail()' (*note igraph_vector_tail --- Returns the
@c last element in a vector_::) returns the last element of a non-empty
@c vector. There is no `igraph_vector_head()' function however, as it is
@c easy to write ` VECTOR(v)[0]' instead.

@c * Menu:

@c * VECTOR --- Accessing an element of a vector.: VECTOR --- Accessing an element of a vector_.
@c * igraph_vector_e --- Access an element of a vector.: igraph_vector_e --- Access an element of a vector_.
@c * igraph_vector_e_ptr --- Get the address of an element of a vector::
@c * igraph_vector_set --- Assignment to an element of a vector.: igraph_vector_set --- Assignment to an element of a vector_.
@c * igraph_vector_tail --- Returns the last element in a vector.: igraph_vector_tail --- Returns the last element in a vector_.

@c
@c File: igraph_reference_manual.info,  Node: VECTOR --- Accessing an element of a vector_,  Next: igraph_vector_e --- Access an element of a vector_,  Up: Accessing elements

@c 6.2.4.1 VECTOR -- Accessing an element of a vector.
@c ...................................................


@c      #define VECTOR(v)

@c    Usage:

@c       VECTOR(v)[0]

@c to access the first element of the vector, you can also use this in
@c assignments, like:

@c       VECTOR(v)[10]=5;

@c Note that there are no range checks right now.  This functionality
@c might be redefined later as a real function instead of a ` #define' .

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_e --- Access an element of a vector_,  Next: igraph_vector_e_ptr --- Get the address of an element of a vector,  Prev: VECTOR --- Accessing an element of a vector_,  Up: Accessing elements

@c 6.2.4.2 igraph_vector_e -- Access an element of a vector.
@c .........................................................


@c      igraph_real_t igraph_vector_e         (const igraph_vector_t* v, long int pos);

@c    *Arguments:. *

@c `v':
@c      The `igraph_vector_t' object.

@c `pos':
@c      The position of the element, the index of the first element is
@c      zero.

@c    *Returns:. *

@c `'
@c      The desired element.

@c    *See also:. *

@c `'
@c      `igraph_vector_e_ptr()' (*note igraph_vector_e_ptr --- Get the
@c      address of an element of a vector::) and the `VECTOR' (*note
@c      VECTOR --- Accessing an element of a vector_::) macro.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_e_ptr --- Get the address of an element of a vector,  Next: igraph_vector_set --- Assignment to an element of a vector_,  Prev: igraph_vector_e --- Access an element of a vector_,  Up: Accessing elements

@c 6.2.4.3 igraph_vector_e_ptr -- Get the address of an element of a vector
@c ........................................................................


@c      igraph_real_t* igraph_vector_e_ptr  (const igraph_vector_t* v, long int pos);

@c    *Arguments:. *

@c `v':
@c      The `igraph_vector_t' object.

@c `pos':
@c      The position of the element, the position of the first element is
@c      zero.

@c    *Returns:. *

@c `'
@c      Pointer to the desired element.

@c    *See also:. *

@c `'
@c      `igraph_vector_e()' (*note igraph_vector_e --- Access an element
@c      of a vector_::) and the `VECTOR' (*note VECTOR --- Accessing an
@c      element of a vector_::) macro.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_set --- Assignment to an element of a vector_,  Next: igraph_vector_tail --- Returns the last element in a vector_,  Prev: igraph_vector_e_ptr --- Get the address of an element of a vector,  Up: Accessing elements

@c 6.2.4.4 igraph_vector_set -- Assignment to an element of a vector.
@c ..................................................................


@c      void igraph_vector_set       (igraph_vector_t* v,
@c      					long int pos, igraph_real_t value);

@c    *Arguments:. *

@c `v':
@c      The `igraph_vector_t' element.

@c `pos':
@c      Position of the element to set.

@c `value':
@c      New value of the element.

@c    *See also:. *

@c `'
@c      `igraph_vector_e()' (*note igraph_vector_e --- Access an element
@c      of a vector_::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_tail --- Returns the last element in a vector_,  Prev: igraph_vector_set --- Assignment to an element of a vector_,  Up: Accessing elements

@c 6.2.4.5 igraph_vector_tail -- Returns the last element in a vector.
@c ...................................................................


@c      igraph_real_t igraph_vector_tail(const igraph_vector_t *v);

@c    It is an error to call this function on an empty vector, the result
@c is undefined.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    *Returns:. *

@c `'
@c      The last element.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Vector views,  Next: Copying vectors,  Prev: Accessing elements,  Up: Vectors

@c 6.2.5 Vector views
@c ------------------

@c * Menu:

@c * igraph_vector_view --- Handle a regular C array as a igraph_vector_t.: igraph_vector_view --- Handle a regular C array as a igraph_vector_t_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_view --- Handle a regular C array as a igraph_vector_t_,  Up: Vector views

@c 6.2.5.1 igraph_vector_view -- Handle a regular C array as a igraph_vector_t.
@c ............................................................................


@c      const igraph_vector_t*igraph_vector_view (const igraph_vector_t *v,
@c      							const igraph_real_t *data,
@c      							long int length);

@c    This is a special `igraph_vector_t' constructor. It allows to handle
@c a regular C array as a `igraph_vector_t' temporarily.  Be sure that you
@c _don't_ ever call the destructor (`igraph_vector_destroy()' (*note
@c igraph_vector_destroy --- Destroys a vector object_::)) on objects
@c created by this constructor.

@c    *Arguments:. *

@c `v':
@c      Pointer to an uninitialized `igraph_vector_t' object.

@c `data':
@c      Pointer, the C array.

@c `length':
@c      The length of the C array.

@c    *Returns:. *

@c `'
@c      Pointer to the vector object, the same as the `v' parameter, for
@c      convenience.

@c    Time complexity: O(1)

@c
@c File: igraph_reference_manual.info,  Node: Copying vectors,  Next: Exchanging elements,  Prev: Vector views,  Up: Vectors

@c 6.2.6 Copying vectors
@c ---------------------

@c * Menu:

@c * igraph_vector_copy_to --- Copies the contents of a vector to a C array.: igraph_vector_copy_to --- Copies the contents of a vector to a C array_.
@c * igraph_vector_update --- Update a vector from another one.: igraph_vector_update --- Update a vector from another one_.
@c * igraph_vector_append --- Append a vector to another one.: igraph_vector_append --- Append a vector to another one_.
@c * igraph_vector_swap --- Swap elements of two vectors.: igraph_vector_swap --- Swap elements of two vectors_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_copy_to --- Copies the contents of a vector to a C array_,  Next: igraph_vector_update --- Update a vector from another one_,  Up: Copying vectors

@c 6.2.6.1 igraph_vector_copy_to -- Copies the contents of a vector to a C array.
@c ..............................................................................


@c      void igraph_vector_copy_to(const igraph_vector_t *v, igraph_real_t *to);

@c    The C array should have sufficient length.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c `to':
@c      The C array.

@c    Time complexity: O(n), n is the size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_update --- Update a vector from another one_,  Next: igraph_vector_append --- Append a vector to another one_,  Prev: igraph_vector_copy_to --- Copies the contents of a vector to a C array_,  Up: Copying vectors

@c 6.2.6.2 igraph_vector_update -- Update a vector from another one.
@c .................................................................


@c      int igraph_vector_update(igraph_vector_t *to,
@c      				   const igraph_vector_t *from);

@c    After this operation the contents of `to' will be exactly the same
@c `from'. `to' will be resized if it was originally shorter or longer
@c than `from'.

@c    *Arguments:. *

@c `to':
@c      The vector to update.

@c `from':
@c      The vector to update from.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of elements in `from'.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_append --- Append a vector to another one_,  Next: igraph_vector_swap --- Swap elements of two vectors_,  Prev: igraph_vector_update --- Update a vector from another one_,  Up: Copying vectors

@c 6.2.6.3 igraph_vector_append -- Append a vector to another one.
@c ...............................................................


@c      int igraph_vector_append(igraph_vector_t *to,
@c      				   const igraph_vector_t *from);

@c    The target vector will be resized (except `from' is empty).

@c    *Arguments:. *

@c `to':
@c      The vector to append to.

@c `from':
@c      The vector to append, it is kept unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of elements in the new vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_swap --- Swap elements of two vectors_,  Prev: igraph_vector_append --- Append a vector to another one_,  Up: Copying vectors

@c 6.2.6.4 igraph_vector_swap -- Swap elements of two vectors.
@c ...........................................................


@c      int igraph_vector_swap(igraph_vector_t *v1, igraph_vector_t *v2);

@c    The two vectors must have the same length, otherwise an error
@c happens.

@c    *Arguments:. *

@c `v1':
@c      The first vector.

@c `v2':
@c      The second vector.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the length of the vectors.

@c
@c File: igraph_reference_manual.info,  Node: Exchanging elements,  Next: Vector operations,  Prev: Copying vectors,  Up: Vectors

@c 6.2.7 Exchanging elements
@c -------------------------

@c * Menu:

@c * igraph_vector_swap_elements --- Swap two elements in a vector.: igraph_vector_swap_elements --- Swap two elements in a vector_.
@c * igraph_vector_reverse --- Reverse the elements of a vector.: igraph_vector_reverse --- Reverse the elements of a vector_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_swap_elements --- Swap two elements in a vector_,  Next: igraph_vector_reverse --- Reverse the elements of a vector_,  Up: Exchanging elements

@c 6.2.7.1 igraph_vector_swap_elements -- Swap two elements in a vector.
@c .....................................................................


@c      int igraph_vector_swap_elements(igraph_vector_t *v,
@c      					  long int i, long int j);

@c    Note that currently no range checking if performed.

@c    *Arguments:. *

@c `v':
@c      The input vector.

@c `i':
@c      Index of the first element.

@c `j':
@c      index of the second element. (Might be the same the first.)

@c    *Returns:. *

@c `'
@c      Error code, currently always `IGRAPH_SUCCESS'.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_reverse --- Reverse the elements of a vector_,  Prev: igraph_vector_swap_elements --- Swap two elements in a vector_,  Up: Exchanging elements

@c 6.2.7.2 igraph_vector_reverse -- Reverse the elements of a vector.
@c ..................................................................


@c      int igraph_vector_reverse(igraph_vector_t *v);

@c    The first element will be last, the last element will be first, etc.

@c    *Arguments:. *

@c `v':
@c      The input vector.

@c    *Returns:. *

@c `'
@c      Error code, currently always `IGRAPH_SUCCESS'.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: Vector operations,  Next: Finding minimum and maximum,  Prev: Exchanging elements,  Up: Vectors

@c 6.2.8 Vector operations
@c -----------------------

@c * Menu:

@c * igraph_vector_add_constant --- Add a constant to the vector.: igraph_vector_add_constant --- Add a constant to the vector_.
@c * igraph_vector_scale --- Multiply all elements of a vector by a constant::
@c * igraph_vector_add --- Add two vectors.: igraph_vector_add --- Add two vectors_.
@c * igraph_vector_sub --- Subtract a vector from another one.: igraph_vector_sub --- Subtract a vector from another one_.
@c * igraph_vector_mul --- Multiply two vectors.: igraph_vector_mul --- Multiply two vectors_.
@c * igraph_vector_div --- Divide a vector by another one.: igraph_vector_div --- Divide a vector by another one_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_add_constant --- Add a constant to the vector_,  Next: igraph_vector_scale --- Multiply all elements of a vector by a constant,  Up: Vector operations

@c 6.2.8.1 igraph_vector_add_constant -- Add a constant to the vector.
@c ...................................................................


@c      void igraph_vector_add_constant(igraph_vector_t *v, igraph_real_t plus);

@c    `plus' is added to every element of `v'. Note that overflow might
@c happen.

@c    *Arguments:. *

@c `v':
@c      The input vector.

@c `plus':
@c      The constant to add.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_scale --- Multiply all elements of a vector by a constant,  Next: igraph_vector_add --- Add two vectors_,  Prev: igraph_vector_add_constant --- Add a constant to the vector_,  Up: Vector operations

@c 6.2.8.2 igraph_vector_scale -- Multiply all elements of a vector by a constant
@c ..............................................................................


@c      void igraph_vector_scale(igraph_vector_t *v, igraph_real_t by);

@c    *Arguments:. *

@c `v':
@c      The vector.

@c `by':
@c      The constant.

@c    *Returns:. *

@c `'
@c      Error code. The current implementation always returns with success.

@c    Added in version 0.2.

@c    Time complexity: O(n), the number of elements in a vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_add --- Add two vectors_,  Next: igraph_vector_sub --- Subtract a vector from another one_,  Prev: igraph_vector_scale --- Multiply all elements of a vector by a constant,  Up: Vector operations

@c 6.2.8.3 igraph_vector_add -- Add two vectors.
@c .............................................


@c      int igraph_vector_add(igraph_vector_t *v1,
@c      				const igraph_vector_t *v2);

@c    Add the elements of `v2' to `v1', the result is stored in `v1'. The
@c two vectors must have the same length.

@c    *Arguments:. *

@c `v1':
@c      The first vector, the result will be stored here.

@c `v2':
@c      The second vector, its contents will be unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_sub --- Subtract a vector from another one_,  Next: igraph_vector_mul --- Multiply two vectors_,  Prev: igraph_vector_add --- Add two vectors_,  Up: Vector operations

@c 6.2.8.4 igraph_vector_sub -- Subtract a vector from another one.
@c ................................................................


@c      int igraph_vector_sub(igraph_vector_t *v1,
@c      				const igraph_vector_t *v2);

@c    Substract the elements of `v2' from `v1', the result is stored in
@c `v1'. The two vectors must have the same length.

@c    *Arguments:. *

@c `v1':
@c      The first vector, to subtract from. The result is stored here.

@c `v2':
@c      The vector to subtract, it will be unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the length of the vectors.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_mul --- Multiply two vectors_,  Next: igraph_vector_div --- Divide a vector by another one_,  Prev: igraph_vector_sub --- Subtract a vector from another one_,  Up: Vector operations

@c 6.2.8.5 igraph_vector_mul -- Multiply two vectors.
@c ..................................................


@c      int igraph_vector_mul(igraph_vector_t *v1,
@c      				const igraph_vector_t *v2);

@c    `v1' will be multiplied by `v2', elementwise. The two vectors must
@c have the same length.

@c    *Arguments:. *

@c `v1':
@c      The first vector, the result will be stored here.

@c `v2':
@c      The second vector, it is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_div --- Divide a vector by another one_,  Prev: igraph_vector_mul --- Multiply two vectors_,  Up: Vector operations

@c 6.2.8.6 igraph_vector_div -- Divide a vector by another one.
@c ............................................................


@c      int igraph_vector_div(igraph_vector_t *v1,
@c      				const igraph_vector_t *v2);

@c    `v1' is divided by `v2', elementwise. They must have the same
@c length. If the base type of the vector can generate divide by zero
@c errors then please make sure that `v2' contains no zero if you want to
@c avoid trouble.

@c    *Arguments:. *

@c `v1':
@c      The dividend. The result is also stored here.

@c `v2':
@c      The divisor, it is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the length of the vectors.

@c
@c File: igraph_reference_manual.info,  Node: Finding minimum and maximum,  Next: Vector properties,  Prev: Vector operations,  Up: Vectors

@c 6.2.9 Finding minimum and maximum
@c ---------------------------------

@c * Menu:

@c * igraph_vector_min --- Smallest element of a vector.: igraph_vector_min --- Smallest element of a vector_.
@c * igraph_vector_max --- Gives the maximum element of the vector.: igraph_vector_max --- Gives the maximum element of the vector_.
@c * igraph_vector_which_min --- Index of the smallest element.: igraph_vector_which_min --- Index of the smallest element_.
@c * igraph_vector_which_max --- Gives the position of the maximum element of the vector.: igraph_vector_which_max --- Gives the position of the maximum element of the vector_.
@c * igraph_vector_minmax --- Minimum and maximum elements of a vector.: igraph_vector_minmax --- Minimum and maximum elements of a vector_.
@c * igraph_vector_which_minmax --- Index of the minimum and maximum elements::

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_min --- Smallest element of a vector_,  Next: igraph_vector_max --- Gives the maximum element of the vector_,  Up: Finding minimum and maximum

@c 6.2.9.1 igraph_vector_min -- Smallest element of a vector.
@c ..........................................................


@c      igraph_real_t igraph_vector_min(const igraph_vector_t* v);

@c    The vector must be non-empty.

@c    *Arguments:. *

@c `v':
@c      The input vector.

@c    *Returns:. *

@c `'
@c      The smallest element of `v'.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_max --- Gives the maximum element of the vector_,  Next: igraph_vector_which_min --- Index of the smallest element_,  Prev: igraph_vector_min --- Smallest element of a vector_,  Up: Finding minimum and maximum

@c 6.2.9.2 igraph_vector_max -- Gives the maximum element of the vector.
@c .....................................................................


@c      igraph_real_t igraph_vector_max(const igraph_vector_t* v);

@c    If the size of the vector is zero, an arbitrary number is returned.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    *Returns:. *

@c `'
@c      The maximum element.

@c    Time complexity: O(n), n is the size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_which_min --- Index of the smallest element_,  Next: igraph_vector_which_max --- Gives the position of the maximum element of the vector_,  Prev: igraph_vector_max --- Gives the maximum element of the vector_,  Up: Finding minimum and maximum

@c 6.2.9.3 igraph_vector_which_min -- Index of the smallest element.
@c .................................................................


@c      long int igraph_vector_which_min(const igraph_vector_t* v);

@c    The vector must be non-empty.  If the smallest element is not
@c unique, then the index of the first is returned.

@c    *Arguments:. *

@c `v':
@c      The input vector.

@c    *Returns:. *

@c `'
@c      Index of the smallest element.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_which_max --- Gives the position of the maximum element of the vector_,  Next: igraph_vector_minmax --- Minimum and maximum elements of a vector_,  Prev: igraph_vector_which_min --- Index of the smallest element_,  Up: Finding minimum and maximum

@c 6.2.9.4 igraph_vector_which_max -- Gives the position of the maximum element of the vector.
@c ...........................................................................................


@c      long int igraph_vector_which_max(const igraph_vector_t* v);

@c    If the size of the vector is zero, -1 is returned.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    *Returns:. *

@c `'
@c      The position of the first maximum element.

@c    Time complexity: O(n), n is the size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_minmax --- Minimum and maximum elements of a vector_,  Next: igraph_vector_which_minmax --- Index of the minimum and maximum elements,  Prev: igraph_vector_which_max --- Gives the position of the maximum element of the vector_,  Up: Finding minimum and maximum

@c 6.2.9.5 igraph_vector_minmax -- Minimum and maximum elements of a vector.
@c .........................................................................


@c      int igraph_vector_minmax(const igraph_vector_t *v,
@c      				   igraph_real_t *min, igraph_real_t *max);

@c    Handy if you want to have both the smallest and largest element of a
@c vector. The vector is only traversed once. The vector must by non-empty.

@c    *Arguments:. *

@c `v':
@c      The input vector. It must contain at least one element.

@c `min':
@c      Pointer to a base type variable, the minimum is stored here.

@c `max':
@c      Pointer to a base type variable, the maximum is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_which_minmax --- Index of the minimum and maximum elements,  Prev: igraph_vector_minmax --- Minimum and maximum elements of a vector_,  Up: Finding minimum and maximum

@c 6.2.9.6 igraph_vector_which_minmax -- Index of the minimum and maximum elements
@c ...............................................................................


@c      int igraph_vector_which_minmax(const igraph_vector_t *v,
@c      					 long int *which_min, long int *which_max);

@c    Handy if you need the indices of the smallest and largest elements.
@c The vector is traversed only once. The vector must to non-empty.

@c    *Arguments:. *

@c `v':
@c      The input vector. It must contain at least one element.

@c `which_min':
@c      The index of the minimum element will be stored here.

@c `which_max':
@c      The index of the maximum element will be stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: Vector properties,  Next: Searching for elements,  Prev: Finding minimum and maximum,  Up: Vectors

@c 6.2.10 Vector properties
@c ------------------------

@c * Menu:

@c * igraph_vector_empty --- Decides whether the size of the vector is zero.: igraph_vector_empty --- Decides whether the size of the vector is zero_.
@c * igraph_vector_size --- Gives the size (=length) of the vector.: igraph_vector_size --- Gives the size [=length] of the vector_.
@c * igraph_vector_sum --- Calculates the sum of the elements in the vector.: igraph_vector_sum --- Calculates the sum of the elements in the vector_.
@c * igraph_vector_prod --- Calculates the product of the elements in the vector.: igraph_vector_prod --- Calculates the product of the elements in the vector_.
@c * igraph_vector_isininterval --- Checks if all elements of a vector are in the given::
@c * igraph_vector_is_equal --- Decides whether two vectors contain exactly the same elements::
@c * igraph_vector_maxdifference --- The largest element of m1 - m2::

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_empty --- Decides whether the size of the vector is zero_,  Next: igraph_vector_size --- Gives the size [=length] of the vector_,  Up: Vector properties

@c 6.2.10.1 igraph_vector_empty -- Decides whether the size of the vector is zero.
@c ...............................................................................


@c      igraph_bool_t igraph_vector_empty     (const igraph_vector_t* v);

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    *Returns:. *

@c `'
@c      Non-zero number if the size of the vector is not zero and zero
@c      otherwise.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_size --- Gives the size [=length] of the vector_,  Next: igraph_vector_sum --- Calculates the sum of the elements in the vector_,  Prev: igraph_vector_empty --- Decides whether the size of the vector is zero_,  Up: Vector properties

@c 6.2.10.2 igraph_vector_size -- Gives the size (=length) of the vector.
@c ......................................................................


@c      long int igraph_vector_size      (const igraph_vector_t* v);

@c    *Arguments:. *

@c `v':
@c      The vector object

@c    *Returns:. *

@c `'
@c      The size of the vector.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_sum --- Calculates the sum of the elements in the vector_,  Next: igraph_vector_prod --- Calculates the product of the elements in the vector_,  Prev: igraph_vector_size --- Gives the size [=length] of the vector_,  Up: Vector properties

@c 6.2.10.3 igraph_vector_sum -- Calculates the sum of the elements in the vector.
@c ...............................................................................


@c      igraph_real_t igraph_vector_sum(const igraph_vector_t *v);

@c    For the empty vector 0.0 is returned.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    *Returns:. *

@c `'
@c      The sum of the elements.

@c    Time complexity: O(n), the size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_prod --- Calculates the product of the elements in the vector_,  Next: igraph_vector_isininterval --- Checks if all elements of a vector are in the given,  Prev: igraph_vector_sum --- Calculates the sum of the elements in the vector_,  Up: Vector properties

@c 6.2.10.4 igraph_vector_prod -- Calculates the product of the elements in the vector.
@c ....................................................................................


@c      igraph_real_t igraph_vector_prod(const igraph_vector_t *v);

@c    For the empty vector one (1) is returned.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    *Returns:. *

@c `'
@c      The product of the elements.

@c    Time complexity: O(n), the size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_isininterval --- Checks if all elements of a vector are in the given,  Next: igraph_vector_is_equal --- Decides whether two vectors contain exactly the same elements,  Prev: igraph_vector_prod --- Calculates the product of the elements in the vector_,  Up: Vector properties

@c 6.2.10.5 igraph_vector_isininterval -- Checks if all elements of a vector are in the given
@c ..........................................................................................


@c      igraph_bool_t igraph_vector_isininterval(const igraph_vector_t *v,
@c      						   igraph_real_t low,
@c      						   igraph_real_t high);

@c    interval.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c `low':
@c      The lower limit of the interval (inclusive).

@c `high':
@c      The higher limit of the interval (inclusive).

@c    *Returns:. *

@c `'
@c      True (positive integer) if all vector elements are in the
@c      interval, false (zero) otherwise.

@c    Time complexity: O(n), the number of elements in the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_is_equal --- Decides whether two vectors contain exactly the same elements,  Next: igraph_vector_maxdifference --- The largest element of m1 - m2,  Prev: igraph_vector_isininterval --- Checks if all elements of a vector are in the given,  Up: Vector properties

@c 6.2.10.6 igraph_vector_is_equal -- Decides whether two vectors contain exactly the same elements
@c ................................................................................................


@c      igraph_bool_t igraph_vector_is_equal(const igraph_vector_t *lhs,
@c      					       const igraph_vector_t *rhs);

@c    (in the same order).

@c    *Arguments:. *

@c `lhs':
@c      The first vector.

@c `rhs':
@c      The second vector.

@c    *Returns:. *

@c `'
@c      Positive integer if the two vectors are equal element by element
@c      or zero if they are not.

@c    Time complexity: O(n), the length of the vectors.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_maxdifference --- The largest element of m1 - m2,  Prev: igraph_vector_is_equal --- Decides whether two vectors contain exactly the same elements,  Up: Vector properties

@c 6.2.10.7 igraph_vector_maxdifference -- The largest element of m1 - m2
@c ......................................................................


@c      igraph_real_t igraph_vector_maxdifference(const igraph_vector_t *m1,
@c      					   const igraph_vector_t *m2);

@c    The maximum the elementwise performed difference is returned.  Both
@c vectors must be non-empty, but they not need to have the same length,
@c the extra elements in the longer vector are ignored.

@c    *Arguments:. *

@c `m1':
@c      The first vector.

@c `m2':
@c      The second vector.

@c    *Returns:. *

@c `'
@c      The maximum of the difference of `m1' and `m2'.

@c    Time complexity: O(n), the number of elements in the shorter vector.

@c
@c File: igraph_reference_manual.info,  Node: Searching for elements,  Next: Resizing operations,  Prev: Vector properties,  Up: Vectors

@c 6.2.11 Searching for elements
@c -----------------------------

@c * Menu:

@c * igraph_vector_contains --- Linear search in a vector.: igraph_vector_contains --- Linear search in a vector_.
@c * igraph_vector_search --- Search from a given position::
@c * igraph_vector_binsearch --- Finds an element by binary searching a sorted vector.: igraph_vector_binsearch --- Finds an element by binary searching a sorted vector_.
@c * igraph_vector_binsearch2 --- Binary search, without returning the index.: igraph_vector_binsearch2 --- Binary search; without returning the index_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_contains --- Linear search in a vector_,  Next: igraph_vector_search --- Search from a given position,  Up: Searching for elements

@c 6.2.11.1 igraph_vector_contains -- Linear search in a vector.
@c .............................................................


@c      igraph_bool_t igraph_vector_contains(const igraph_vector_t *v,
@c      					       igraph_real_t e);

@c    Check whether the supplied element is included in the vector, by
@c linear search.

@c    *Arguments:. *

@c `v':
@c      The input vector.

@c `e':
@c      The element to look for.

@c    *Returns:. *

@c `'
@c      `TRUE' if the element is found and `FALSE' otherwise.

@c    Time complexity: O(n), the length of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_search --- Search from a given position,  Next: igraph_vector_binsearch --- Finds an element by binary searching a sorted vector_,  Prev: igraph_vector_contains --- Linear search in a vector_,  Up: Searching for elements

@c 6.2.11.2 igraph_vector_search -- Search from a given position
@c .............................................................


@c      igraph_bool_t igraph_vector_search(const igraph_vector_t *v,
@c      					     long int from, igraph_real_t what,
@c      					     long int *pos);

@c    The supplied element `what' is searched in vector `v', starting from
@c element index `from'. If found then the index of the first instance
@c (after `from') is stored in `pos'.

@c    *Arguments:. *

@c `v':
@c      The input vector.

@c `from':
@c      The index to start searching from. No range checking is performed.

@c `what':
@c      The element to find.

@c `pos':
@c      If not `NULL' then the index of the found element is stored here.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' if the element was found, `FALSE' otherwise.

@c    Time complexity: O(m), the number of elements to search, the length
@c of the vector minus the `from' argument.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_binsearch --- Finds an element by binary searching a sorted vector_,  Next: igraph_vector_binsearch2 --- Binary search; without returning the index_,  Prev: igraph_vector_search --- Search from a given position,  Up: Searching for elements

@c 6.2.11.3 igraph_vector_binsearch -- Finds an element by binary searching a sorted vector.
@c .........................................................................................


@c      igraph_bool_t igraph_vector_binsearch(const igraph_vector_t *v,
@c      						igraph_real_t what, long int *pos);

@c    It is assumed that the vector is sorted. If the specified element
@c (`what') is not in the vector, then the position of where it should be
@c inserted (to keep the vector sorted) is returned.

@c    *Arguments:. *

@c `v':
@c      The `igraph_vector_t' object.

@c `what':
@c      The element to search for.

@c `pos':
@c      Pointer to a `long' int. This is set to the position of an
@c      instance of `what' in the vector if it is present. If `v' does not
@c      contain `what' then `pos' is set to the position to which it
@c      should be inserted (to keep the the vector sorted of course).

@c    *Returns:. *

@c `'
@c      Positive integer (true) if `what' is found in the vector, zero
@c      (false) otherwise.

@c    Time complexity: O(log(n)), n is the number of elements in `v'.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_binsearch2 --- Binary search; without returning the index_,  Prev: igraph_vector_binsearch --- Finds an element by binary searching a sorted vector_,  Up: Searching for elements

@c 6.2.11.4 igraph_vector_binsearch2 -- Binary search, without returning the index.
@c ................................................................................


@c      igraph_bool_t igraph_vector_binsearch2(const igraph_vector_t *v,
@c      						 igraph_real_t what);

@c    It is assumed that the vector is sorted. If the specified element
@c (`what') is not in the vector, then the position of where it should be
@c inserted (to keep the vector sorted) is returned.

@c    *Arguments:. *

@c `v':
@c      The `igraph_vector_t' object.

@c `what':
@c      The element to search for.

@c    *Returns:. *

@c `'
@c      Positive integer (true) if `what' is found in the vector, zero
@c      (false) otherwise.

@c    Time complexity: O(log(n)), n is the number of elements in `v'.

@c
@c File: igraph_reference_manual.info,  Node: Resizing operations,  Next: Sorting,  Prev: Searching for elements,  Up: Vectors

@c 6.2.12 Resizing operations
@c --------------------------

@c * Menu:

@c * igraph_vector_clear --- Removes all elements from a vector.: igraph_vector_clear --- Removes all elements from a vector_.
@c * igraph_vector_reserve --- Reserves memory for a vector.: igraph_vector_reserve --- Reserves memory for a vector_.
@c * igraph_vector_resize --- Resize the vector.: igraph_vector_resize --- Resize the vector_.
@c * igraph_vector_push_back --- Appends one element to a vector.: igraph_vector_push_back --- Appends one element to a vector_.
@c * igraph_vector_pop_back --- Removes and returns the last element of a vector.: igraph_vector_pop_back --- Removes and returns the last element of a vector_.
@c * igraph_vector_insert --- Inserts a single element into a vector.: igraph_vector_insert --- Inserts a single element into a vector_.
@c * igraph_vector_remove --- Removes a single element from a vector.: igraph_vector_remove --- Removes a single element from a vector_.
@c * igraph_vector_remove_section --- Deletes a section from a vector.: igraph_vector_remove_section --- Deletes a section from a vector_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_clear --- Removes all elements from a vector_,  Next: igraph_vector_reserve --- Reserves memory for a vector_,  Up: Resizing operations

@c 6.2.12.1 igraph_vector_clear -- Removes all elements from a vector.
@c ...................................................................


@c      void igraph_vector_clear     (igraph_vector_t* v);

@c    This function simply sets the size of the vector to zero, it does
@c not free any allocated memory. For that you have to call
@c `igraph_vector_destroy()' (*note igraph_vector_destroy --- Destroys a
@c vector object_::).

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_reserve --- Reserves memory for a vector_,  Next: igraph_vector_resize --- Resize the vector_,  Prev: igraph_vector_clear --- Removes all elements from a vector_,  Up: Resizing operations

@c 6.2.12.2 igraph_vector_reserve -- Reserves memory for a vector.
@c ...............................................................


@c      int igraph_vector_reserve   (igraph_vector_t* v, long int size);

@c    `igraph' vectors are flexible, they can grow and shrink. Growing
@c however occasionally needs the data in the vector to be copyed.  In
@c order to avoid you can call this function to reserve space for future
@c growth of the vector.

@c    Note that this function does _not_ change the size of the vector.
@c Let us see a small example to clarify things: if you reserve space for
@c 100 elements and the size of your vector was (and still is) 60, then
@c you can surely add additional 40 elements to your vector before it will
@c be copied.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c `size':
@c      The new _allocated_ size of the vector.

@c    *Returns:. *

@c `'
@c      Error code: `IGRPAH_ENOMEM' if there is not enough memory.

@c    Time complexity: operating system dependent, should be around O(n), n
@c is the new allocated size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_resize --- Resize the vector_,  Next: igraph_vector_push_back --- Appends one element to a vector_,  Prev: igraph_vector_reserve --- Reserves memory for a vector_,  Up: Resizing operations

@c 6.2.12.3 igraph_vector_resize -- Resize the vector.
@c ...................................................


@c      int igraph_vector_resize(igraph_vector_t* v, long int newsize);

@c    Note that this function does not free any memory, just sets the size
@c of the vector to the given one. It can on the other hand allocate more
@c memory if the new size is larger than the previous one. In this case
@c the newly appeared elements in the vector are _not_ set to zero, they
@c are uninitialized.

@c    *Arguments:. *

@c `v':
@c      The vector object

@c `newsize':
@c      The new size of the vector.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_ENOMEM' if there is not enough memory. Note
@c      that this function _never_ returns an error if the vector is made
@c      smaller.

@c    *See also:. *

@c `'
@c      `igraph_vector_reserve()' (*note igraph_vector_reserve ---
@c      Reserves memory for a vector_::) for allocating memory for future
@c      extensions of a vector.

@c    Time complexity: O(1) if the new size is smaller, operating system
@c dependent if it is larger. In the latter case it is usually around O(n),
@c n is the new size of the vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_push_back --- Appends one element to a vector_,  Next: igraph_vector_pop_back --- Removes and returns the last element of a vector_,  Prev: igraph_vector_resize --- Resize the vector_,  Up: Resizing operations

@c 6.2.12.4 igraph_vector_push_back -- Appends one element to a vector.
@c ....................................................................


@c      int igraph_vector_push_back (igraph_vector_t* v, igraph_real_t e);

@c    This function resizes the vector to be one element longer and sets
@c the very last element in the vector to `e'.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c `e':
@c      The element to append to the vector.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM': not enough memory.

@c    Time complexity: operating system dependent. What is important that
@c a sequence of n subsequent calls to this function has time complexity
@c O(n), even if there hadn't been any space reserved for the new elements
@c by `igraph_vector_reserve()' (*note igraph_vector_reserve --- Reserves
@c memory for a vector_::). This is implemented by a trick similar to the
@c C++ `vector' class: each time more memory is allocated for a vector,
@c the size of the additionally allocated memory is the same as the
@c vector's current length. (We assume here that the time complexity of
@c memory allocation is at most linear.)

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_pop_back --- Removes and returns the last element of a vector_,  Next: igraph_vector_insert --- Inserts a single element into a vector_,  Prev: igraph_vector_push_back --- Appends one element to a vector_,  Up: Resizing operations

@c 6.2.12.5 igraph_vector_pop_back -- Removes and returns the last element of a vector.
@c ....................................................................................


@c      igraph_real_t igraph_vector_pop_back(igraph_vector_t* v);

@c    It is an error to call this function with an empty vector.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c    *Returns:. *

@c `'
@c      The removed last element.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_insert --- Inserts a single element into a vector_,  Next: igraph_vector_remove --- Removes a single element from a vector_,  Prev: igraph_vector_pop_back --- Removes and returns the last element of a vector_,  Up: Resizing operations

@c 6.2.12.6 igraph_vector_insert -- Inserts a single element into a vector.
@c ........................................................................


@c      int igraph_vector_insert(igraph_vector_t *v, long int pos,
@c      				   igraph_real_t value);

@c    Note that this function does not do range checking. Insertion will
@c shift the elements from the position given to the end of the vector one
@c position to the right, and the new element will be inserted in the
@c empty space created at the given position. The size of the vector will
@c increase by one.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c `pos':
@c      The position where the new element is inserted.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_remove --- Removes a single element from a vector_,  Next: igraph_vector_remove_section --- Deletes a section from a vector_,  Prev: igraph_vector_insert --- Inserts a single element into a vector_,  Up: Resizing operations

@c 6.2.12.7 igraph_vector_remove -- Removes a single element from a vector.
@c ........................................................................


@c      void igraph_vector_remove(igraph_vector_t *v, long int elem);

@c    Note that this function does not do range checking.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c `elem':
@c      The position of the element to remove.

@c    Time complexity: O(n-elem), n is the number of elements in the
@c vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_remove_section --- Deletes a section from a vector_,  Prev: igraph_vector_remove --- Removes a single element from a vector_,  Up: Resizing operations

@c 6.2.12.8 igraph_vector_remove_section -- Deletes a section from a vector.
@c .........................................................................


@c      void igraph_vector_remove_section(igraph_vector_t *v,
@c      					    long int from, long int to);

@c    Note that this function does not do range checking. The result is
@c undefined if you supply invalid limits.

@c    *Arguments:. *

@c `v':
@c      The vector object.

@c `from':
@c      The position of the first element to remove.

@c `to':
@c      The position of the first element _not_ to remove.

@c    Time complexity: O(n-from), n is the number of elements in the
@c vector.

@c
@c File: igraph_reference_manual.info,  Node: Sorting,  Next: Pointer vectors [igraph_vector_ptr_t],  Prev: Resizing operations,  Up: Vectors

@c 6.2.13 Sorting
@c --------------

@c * Menu:

@c * igraph_vector_sort --- Sorts the elements of the vector into ascending order.: igraph_vector_sort --- Sorts the elements of the vector into ascending order_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_sort --- Sorts the elements of the vector into ascending order_,  Up: Sorting

@c 6.2.13.1 igraph_vector_sort -- Sorts the elements of the vector into ascending order.
@c .....................................................................................


@c      void igraph_vector_sort(igraph_vector_t *v);

@c    This function uses the built-in sort function of the C library.

@c    *Arguments:. *

@c `v':
@c      Pointer to an initialized vector object.

@c    Time complexity: should be O(nlogn) for n elements.

@c
@c File: igraph_reference_manual.info,  Node: Pointer vectors [igraph_vector_ptr_t],  Prev: Sorting,  Up: Vectors

@c 6.2.14 Pointer vectors (igraph_vector_ptr_t)
@c --------------------------------------------

@c The `igraph_vector_ptr_t' data type is very similar to the
@c `igraph_vector_t' type, but it stores generic pointers instead of real
@c numbers.

@c    This type has the same space complexity as `igraph_vector_t', and
@c most implemented operations work the same way as for `igraph_vector_t'.

@c    This type is mostly used to pass to or receive from a set of graphs
@c to some `igraph' functions, such as `igraph_decompose()' (*note
@c igraph_decompose --- Decompose a graph into connected components_::),
@c which decomposes a graph to connected components.

@c    The same `VECTOR' (*note VECTOR --- Accessing an element of a
@c vector_::) macro used for ordinary vectors can be used for pointer
@c vectors as well, please note that a typeless generic pointer will be
@c provided by this macro and you may need to cast it to a specific
@c pointer before starting to work with it.

@c * Menu:

@c * igraph_vector_ptr_init --- Initialize a pointer vector (constructor).: igraph_vector_ptr_init --- Initialize a pointer vector [constructor]_.
@c * igraph_vector_ptr_copy --- Copy a pointer vector (constructor).: igraph_vector_ptr_copy --- Copy a pointer vector [constructor]_.
@c * igraph_vector_ptr_destroy --- Destroys a pointer vector.: igraph_vector_ptr_destroy --- Destroys a pointer vector_.
@c * igraph_vector_ptr_size --- Gives the number of elements in the pointer vector.: igraph_vector_ptr_size --- Gives the number of elements in the pointer vector_.
@c * igraph_vector_ptr_clear --- Removes all elements from a pointer vector.: igraph_vector_ptr_clear --- Removes all elements from a pointer vector_.
@c * igraph_vector_ptr_push_back --- Appends an elements to the back of a pointer vector.: igraph_vector_ptr_push_back --- Appends an elements to the back of a pointer vector_.
@c * igraph_vector_ptr_e --- Access an element of a pointer vector.: igraph_vector_ptr_e --- Access an element of a pointer vector_.
@c * igraph_vector_ptr_set --- Assign to an element of a pointer vector.: igraph_vector_ptr_set --- Assign to an element of a pointer vector_.
@c * igraph_vector_ptr_resize --- Resizes a pointer vector.: igraph_vector_ptr_resize --- Resizes a pointer vector_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_init --- Initialize a pointer vector [constructor]_,  Next: igraph_vector_ptr_copy --- Copy a pointer vector [constructor]_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.1 igraph_vector_ptr_init -- Initialize a pointer vector (constructor).
@c .............................................................................


@c      int igraph_vector_ptr_init      (igraph_vector_ptr_t* v, int long size);

@c    This is the constructor of the pointer vector data type. All pointer
@c vectors constructed this way should be destroyed via calling
@c `igraph_vector_ptr_destroy()' (*note igraph_vector_ptr_destroy ---
@c Destroys a pointer vector_::).

@c    *Arguments:. *

@c `v':
@c      Pointer to an uninitialized `igraph_vector_ptr_t' object, to be
@c      created.

@c `size':
@c      Integer, the size of the pointer vector.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM' if out of memory

@c    Time complexity: operating system dependent, the amount of `time'
@c required to allocate `size' elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_copy --- Copy a pointer vector [constructor]_,  Next: igraph_vector_ptr_destroy --- Destroys a pointer vector_,  Prev: igraph_vector_ptr_init --- Initialize a pointer vector [constructor]_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.2 igraph_vector_ptr_copy -- Copy a pointer vector (constructor).
@c .......................................................................


@c      int igraph_vector_ptr_copy(igraph_vector_ptr_t *to, const igraph_vector_ptr_t *from);

@c    This function creates a pointer vector by copying another one. This
@c is shallow copy, only the pointers in the vector will be copyed.

@c    *Arguments:. *

@c `to':
@c      Pointer to an uninitialized pointer vector object.

@c `from':
@c      A pointer vector object.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM' if out of memory

@c    Time complexity: O(n) if allocating memory for n elements can be
@c done in O(n) time.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_destroy --- Destroys a pointer vector_,  Next: igraph_vector_ptr_size --- Gives the number of elements in the pointer vector_,  Prev: igraph_vector_ptr_copy --- Copy a pointer vector [constructor]_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.3 igraph_vector_ptr_destroy -- Destroys a pointer vector.
@c ................................................................


@c      void igraph_vector_ptr_destroy   (igraph_vector_ptr_t* v);

@c    The destructor for pointer vectors.

@c    *Arguments:. *

@c `v':
@c      Pointer to the pointer vector to destroy.

@c    Time complexity: operating system dependend, the `time' required to
@c deallocate O(n) bytes, n is the number of elements allocated for the
@c pointer vector (not neccessarily the number of elements in the vector).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_size --- Gives the number of elements in the pointer vector_,  Next: igraph_vector_ptr_clear --- Removes all elements from a pointer vector_,  Prev: igraph_vector_ptr_destroy --- Destroys a pointer vector_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.4 igraph_vector_ptr_size -- Gives the number of elements in the pointer vector.
@c ......................................................................................


@c      long int igraph_vector_ptr_size      (const igraph_vector_ptr_t* v);

@c    *Arguments:. *

@c `v':
@c      The pointer vector object.

@c    *Returns:. *

@c `'
@c      The size of the object, ie. the number of pointers stored.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_clear --- Removes all elements from a pointer vector_,  Next: igraph_vector_ptr_push_back --- Appends an elements to the back of a pointer vector_,  Prev: igraph_vector_ptr_size --- Gives the number of elements in the pointer vector_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.5 igraph_vector_ptr_clear -- Removes all elements from a pointer vector.
@c ...............................................................................


@c      void igraph_vector_ptr_clear     (igraph_vector_ptr_t* v);

@c    This function resizes a pointer to vector to zero length. Note that
@c the pointed objects are _not_ deallocated, you should call free() on
@c them, or make sure that their allocated memory is freed in some other
@c way, you'll get memory leaks otherwise.

@c    Note that the current implementation of this function does _not_
@c deallocate the memory required for storing the pointers, so making a
@c pointer vector smaller this way does not give back any memory. This
@c behavior might change in the future.

@c    *Arguments:. *

@c `v':
@c      The pointer vector to clear.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_push_back --- Appends an elements to the back of a pointer vector_,  Next: igraph_vector_ptr_e --- Access an element of a pointer vector_,  Prev: igraph_vector_ptr_clear --- Removes all elements from a pointer vector_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.6 igraph_vector_ptr_push_back -- Appends an elements to the back of a pointer vector.
@c ............................................................................................


@c      int igraph_vector_ptr_push_back (igraph_vector_ptr_t* v, void* e);

@c    *Arguments:. *

@c `v':
@c      The pointer vector.

@c `e':
@c      The new element to include in the pointer vector.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      igraph_vector_push_back() for the corresponding operation of the
@c      ordinary vector type.

@c    Time complexity: O(1) or O(n), n is the number of elements in the
@c vector. The pointer vector implementation ensures that n subsequent
@c push_back operations need O(n) time to complete.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_e --- Access an element of a pointer vector_,  Next: igraph_vector_ptr_set --- Assign to an element of a pointer vector_,  Prev: igraph_vector_ptr_push_back --- Appends an elements to the back of a pointer vector_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.7 igraph_vector_ptr_e -- Access an element of a pointer vector.
@c ......................................................................


@c      void* igraph_vector_ptr_e         (const igraph_vector_ptr_t* v, long int pos);

@c    *Arguments:. *

@c `v':
@c      Pointer to a pointer vector.

@c `pos':
@c      The index of the pointer to return.

@c    *Returns:. *

@c `'
@c      The pointer at `pos' position.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_set --- Assign to an element of a pointer vector_,  Next: igraph_vector_ptr_resize --- Resizes a pointer vector_,  Prev: igraph_vector_ptr_e --- Access an element of a pointer vector_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.8 igraph_vector_ptr_set -- Assign to an element of a pointer vector.
@c ...........................................................................


@c      void igraph_vector_ptr_set       (igraph_vector_ptr_t* v, long int pos, void* value);

@c    *Arguments:. *

@c `v':
@c      Pointer to a pointer vector.

@c `pos':
@c      The index of the pointer to update.

@c `value':
@c      The new pointer to set in the vector.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vector_ptr_resize --- Resizes a pointer vector_,  Prev: igraph_vector_ptr_set --- Assign to an element of a pointer vector_,  Up: Pointer vectors [igraph_vector_ptr_t]

@c 6.2.14.9 igraph_vector_ptr_resize -- Resizes a pointer vector.
@c ..............................................................


@c      int igraph_vector_ptr_resize(igraph_vector_ptr_t* v, long int newsize);

@c    Note that if a vector is made smaller the pointed object are not
@c deallocated by this function.

@c    *Arguments:. *

@c `v':
@c      A pointer vector.

@c `newsize':
@c      The new size of the pointer vector.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1) if the vector if made smaller. Operating
@c system dependent otherwise, the amount of `time' needed to allocate the
@c memory for the vector elements.

@c
@c File: igraph_reference_manual.info,  Node: Matrices,  Next: Sparse matrices,  Prev: Vectors,  Up: Data structure library; vector; matrix; other data types

@c 6.3 Matrices
@c ============

@c * Menu:

@c * About igraph_matrix_t objects::
@c * Matrix constructors and destructors::
@c * Initializing elements: Initializing elements <1>.
@c * Copying matrices::
@c * Accessing elements of a matrix::
@c * Operations on rows and columns::
@c * Matrix operations::
@c * Combining matrices::
@c * Finding minimum and maximum: Finding minimum and maximum <1>.
@c * Matrix properties::
@c * Searching for elements: Searching for elements <1>.
@c * Resizing operations: Resizing operations <1>.

@c
@c File: igraph_reference_manual.info,  Node: About igraph_matrix_t objects,  Next: Matrix constructors and destructors,  Up: Matrices

@c 6.3.1 About igraph_matrix_t objects
@c -----------------------------------

@c This type is just an interface to `igraph_vector_t'.

@c    The `igraph_matrix_t' type usually stores n elements in O(n) space,
@c but not always, see the documentation of the vector type.

@c
@c File: igraph_reference_manual.info,  Node: Matrix constructors and destructors,  Next: Initializing elements <1>,  Prev: About igraph_matrix_t objects,  Up: Matrices

@c 6.3.2 Matrix constructors and destructors
@c -----------------------------------------

@c * Menu:

@c * igraph_matrix_init --- Initializes a matrix.: igraph_matrix_init --- Initializes a matrix_.
@c * igraph_matrix_copy --- Copies a matrix.: igraph_matrix_copy --- Copies a matrix_.
@c * igraph_matrix_destroy --- Destroys a matrix object.: igraph_matrix_destroy --- Destroys a matrix object_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_init --- Initializes a matrix_,  Next: igraph_matrix_copy --- Copies a matrix_,  Up: Matrix constructors and destructors

@c 6.3.2.1 igraph_matrix_init -- Initializes a matrix.
@c ...................................................


@c      int igraph_matrix_init(igraph_matrix_t *m, long int nrow, long int ncol);

@c    Every matrix needs to be initialized before using it, this is done
@c by calling this function. A matrix has to be destroyed if it is not
@c needed any more, see `igraph_matrix_destroy()' (*note
@c igraph_matrix_destroy --- Destroys a matrix object_::).

@c    *Arguments:. *

@c `m':
@c      Pointer to a not yet initialized matrix object to be initialized.

@c `nrow':
@c      The number of rows in the matrix.

@c `ncol':
@c      The number of columns in the matrix.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: usually O(n), n is the number of elements in the
@c matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_copy --- Copies a matrix_,  Next: igraph_matrix_destroy --- Destroys a matrix object_,  Prev: igraph_matrix_init --- Initializes a matrix_,  Up: Matrix constructors and destructors

@c 6.3.2.2 igraph_matrix_copy -- Copies a matrix.
@c ..............................................


@c      int igraph_matrix_copy(igraph_matrix_t *to, const igraph_matrix_t *from);

@c    Creates a matrix object by copying another one.

@c    *Arguments:. *

@c `to':
@c      Pointer to an uninitialized matrix object.

@c `from':
@c      The initialized matrix object to copy.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_ENOMEM' if there isn't enough memory to
@c      allocate the new matrix.

@c    Time complexity: O(n), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_destroy --- Destroys a matrix object_,  Prev: igraph_matrix_copy --- Copies a matrix_,  Up: Matrix constructors and destructors

@c 6.3.2.3 igraph_matrix_destroy -- Destroys a matrix object.
@c ..........................................................


@c      void igraph_matrix_destroy(igraph_matrix_t *m);

@c    This function frees all the memory allocated for a matrix object.
@c The destroyed object needs to be reinitialized before using it again.

@c    *Arguments:. *

@c `m':
@c      The matrix to destroy.

@c    Time complexity: operating system dependent.

@c
@c File: igraph_reference_manual.info,  Node: Initializing elements <1>,  Next: Copying matrices,  Prev: Matrix constructors and destructors,  Up: Matrices

@c 6.3.3 Initializing elements
@c ---------------------------

@c * Menu:

@c * igraph_matrix_null --- Sets all element in a matrix to zero.: igraph_matrix_null --- Sets all element in a matrix to zero_.
@c * igraph_matrix_fill --- Fill with an element.: igraph_matrix_fill --- Fill with an element_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_null --- Sets all element in a matrix to zero_,  Next: igraph_matrix_fill --- Fill with an element_,  Up: Initializing elements <1>

@c 6.3.3.1 igraph_matrix_null -- Sets all element in a matrix to zero.
@c ...................................................................


@c      void igraph_matrix_null(igraph_matrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized matrix object.

@c    Time complexity: O(n), n is the number of  elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_fill --- Fill with an element_,  Prev: igraph_matrix_null --- Sets all element in a matrix to zero_,  Up: Initializing elements <1>

@c 6.3.3.2 igraph_matrix_fill -- Fill with an element.
@c ...................................................


@c      void igraph_matrix_fill(igraph_matrix_t *m, igraph_real_t e);

@c    Set the matrix to a constant matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `e':
@c      The element to set.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: Copying matrices,  Next: Accessing elements of a matrix,  Prev: Initializing elements <1>,  Up: Matrices

@c 6.3.4 Copying matrices
@c ----------------------

@c * Menu:

@c * igraph_matrix_copy_to --- Copies a matrix to a regular C array.: igraph_matrix_copy_to --- Copies a matrix to a regular C array_.
@c * igraph_matrix_update --- Update from another matrix.: igraph_matrix_update --- Update from another matrix_.
@c * igraph_matrix_swap --- Swap two matrices::

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_copy_to --- Copies a matrix to a regular C array_,  Next: igraph_matrix_update --- Update from another matrix_,  Up: Copying matrices

@c 6.3.4.1 igraph_matrix_copy_to -- Copies a matrix to a regular C array.
@c ......................................................................


@c      void igraph_matrix_copy_to(const igraph_matrix_t *m, igraph_real_t *to);

@c    The matrix is copied columnwise, as this is the format most programs
@c and languages use.  The C array should be of sufficient size, there are
@c (of course) not range checks done.

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized matrix object.

@c `to':
@c      Pointer to a C array, the place to copy the data to.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), n is the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_update --- Update from another matrix_,  Next: igraph_matrix_swap --- Swap two matrices,  Prev: igraph_matrix_copy_to --- Copies a matrix to a regular C array_,  Up: Copying matrices

@c 6.3.4.2 igraph_matrix_update -- Update from another matrix.
@c ...........................................................


@c      int igraph_matrix_update(igraph_matrix_t *to,
@c      				   const igraph_matrix_t *from);

@c    This function replicates `from' in the matrix `to'.  Note that `to'
@c must be already initialized.

@c    *Arguments:. *

@c `to':
@c      The result matrix.

@c `from':
@c      The matrix to replicate, it is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_swap --- Swap two matrices,  Prev: igraph_matrix_update --- Update from another matrix_,  Up: Copying matrices

@c 6.3.4.3 igraph_matrix_swap -- Swap two matrices
@c ...............................................


@c      int igraph_matrix_swap(igraph_matrix_t *m1, igraph_matrix_t *m2);

@c    The contents of the two matrices will be swapped. They must be the
@c same size.

@c    *Arguments:. *

@c `m1':
@c      The first matrix.

@c `m2':
@c      The second matrix.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements in the matrices.

@c
@c File: igraph_reference_manual.info,  Node: Accessing elements of a matrix,  Next: Operations on rows and columns,  Prev: Copying matrices,  Up: Matrices

@c 6.3.5 Accessing elements of a matrix
@c ------------------------------------

@c * Menu:

@c * MATRIX --- Accessing an element of a matrix.: MATRIX --- Accessing an element of a matrix_.
@c * igraph_matrix_e --- Extract an element::
@c * igraph_matrix_e_ptr --- Pointer to an element::
@c * igraph_matrix_set --- Set an element.: igraph_matrix_set --- Set an element_.

@c
@c File: igraph_reference_manual.info,  Node: MATRIX --- Accessing an element of a matrix_,  Next: igraph_matrix_e --- Extract an element,  Up: Accessing elements of a matrix

@c 6.3.5.1 MATRIX -- Accessing an element of a matrix.
@c ...................................................


@c      #define MATRIX(m,i,j)

@c    Note that there are no range checks right now.  This functionality
@c might be redefines as a proper function later.

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c `i':
@c      The index of the row, starting with zero.

@c `j':
@c      The index of the column, starting with zero.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_e --- Extract an element,  Next: igraph_matrix_e_ptr --- Pointer to an element,  Prev: MATRIX --- Accessing an element of a matrix_,  Up: Accessing elements of a matrix

@c 6.3.5.2 igraph_matrix_e -- Extract an element
@c .............................................


@c      igraph_real_t igraph_matrix_e(const igraph_matrix_t *m,
@c      			       long int row, long int col);

@c    Use this if you need a function for some reason and cannot use the
@c `MATRIX' (*note MATRIX --- Accessing an element of a matrix_::) macro.
@c Note that no range checking is performed.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `row':
@c      The row index.

@c `col':
@c      The column index.

@c    *Returns:. *

@c `'
@c      The element in the given row and column.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_e_ptr --- Pointer to an element,  Next: igraph_matrix_set --- Set an element_,  Prev: igraph_matrix_e --- Extract an element,  Up: Accessing elements of a matrix

@c 6.3.5.3 igraph_matrix_e_ptr -- Pointer to an element
@c ....................................................


@c      igraph_real_t* igraph_matrix_e_ptr(const igraph_matrix_t *m,
@c      				    long int row, long int col);

@c    The function returns a pointer to an element. No range checking is
@c performed.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `row':
@c      The row index.

@c `col':
@c      The column index.

@c    *Returns:. *

@c `'
@c      Pointer to the element in the given row and column.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_set --- Set an element_,  Prev: igraph_matrix_e_ptr --- Pointer to an element,  Up: Accessing elements of a matrix

@c 6.3.5.4 igraph_matrix_set -- Set an element.
@c ............................................


@c      void igraph_matrix_set(igraph_matrix_t* m, long int row, long int col,
@c      				 igraph_real_t value);

@c    Set and element of a matrix. No range cheking is performed.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `row':
@c      The row index.

@c `col':
@c      The column index.

@c `value':
@c      The new value of the element.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Operations on rows and columns,  Next: Matrix operations,  Prev: Accessing elements of a matrix,  Up: Matrices

@c 6.3.6 Operations on rows and columns
@c ------------------------------------

@c * Menu:

@c * igraph_matrix_get_row --- Extract a row::
@c * igraph_matrix_get_col --- Select a column::
@c * igraph_matrix_set_row --- Set a row from a vector.: igraph_matrix_set_row --- Set a row from a vector_.
@c * igraph_matrix_set_col --- Set a column from a vector.: igraph_matrix_set_col --- Set a column from a vector_.
@c * igraph_matrix_swap_rows --- Swap two rows::
@c * igraph_matrix_swap_cols --- Swap two columns::
@c * igraph_matrix_select_rows --- Select some rows of a matrix::
@c * igraph_matrix_select_cols --- Select some columns of a matrix::

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_get_row --- Extract a row,  Next: igraph_matrix_get_col --- Select a column,  Up: Operations on rows and columns

@c 6.3.6.1 igraph_matrix_get_row -- Extract a row
@c ..............................................


@c      int igraph_matrix_get_row(const igraph_matrix_t *m,
@c      				    igraph_vector_t *res, long int index);

@c    Extract a row from a matrix and return it as a vector.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `res':
@c      Pointer to an initialized vector, it will be resized if needed.

@c `index':
@c      The index of the row to select.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of columns in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_get_col --- Select a column,  Next: igraph_matrix_set_row --- Set a row from a vector_,  Prev: igraph_matrix_get_row --- Extract a row,  Up: Operations on rows and columns

@c 6.3.6.2 igraph_matrix_get_col -- Select a column
@c ................................................


@c      int igraph_matrix_get_col(const igraph_matrix_t *m,
@c      				    igraph_vector_t *res,
@c      				    long int index);

@c    Extract a column of a matrix and return it in a vector.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `res':
@c      The result will we stored in this vector. It should be initialized
@c      and will be resized as needed.

@c `index':
@c      The index of the solumn to select.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of rows in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_set_row --- Set a row from a vector_,  Next: igraph_matrix_set_col --- Set a column from a vector_,  Prev: igraph_matrix_get_col --- Select a column,  Up: Operations on rows and columns

@c 6.3.6.3 igraph_matrix_set_row -- Set a row from a vector.
@c .........................................................


@c      int igraph_matrix_set_row(igraph_matrix_t *m,
@c      				    const igraph_vector_t *v, long int index);

@c    Sets the elements of a row, from the given vector. The length of the
@c vector and the number of columns in the matrix must match, otherwise
@c and error is triggered.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `v':
@c      The vector containing the new elements of the row.

@c `index':
@c      Index of the row to set.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of columns in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_set_col --- Set a column from a vector_,  Next: igraph_matrix_swap_rows --- Swap two rows,  Prev: igraph_matrix_set_row --- Set a row from a vector_,  Up: Operations on rows and columns

@c 6.3.6.4 igraph_matrix_set_col -- Set a column from a vector.
@c ............................................................


@c      int igraph_matrix_set_col(igraph_matrix_t *m,
@c      				    const igraph_vector_t *v, long int index);

@c    Sets the elements of a column, from the given vector. The length of
@c the vector and the number of rows in the matrix must match, otherwise
@c and error is triggered.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `v':
@c      The vector containing the new elements of the column.

@c `index':
@c      Index of the column to set.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(m), the number of rows in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_swap_rows --- Swap two rows,  Next: igraph_matrix_swap_cols --- Swap two columns,  Prev: igraph_matrix_set_col --- Set a column from a vector_,  Up: Operations on rows and columns

@c 6.3.6.5 igraph_matrix_swap_rows -- Swap two rows
@c ................................................


@c      int igraph_matrix_swap_rows(igraph_matrix_t *m,
@c      				      long int i, long int j);

@c    Swap two rows in the matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `i':
@c      The index of the first row.

@c `j':
@c      The index of the second row.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of columns.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_swap_cols --- Swap two columns,  Next: igraph_matrix_select_rows --- Select some rows of a matrix,  Prev: igraph_matrix_swap_rows --- Swap two rows,  Up: Operations on rows and columns

@c 6.3.6.6 igraph_matrix_swap_cols -- Swap two columns
@c ...................................................


@c      int igraph_matrix_swap_cols(igraph_matrix_t *m,
@c      				      long int i, long int j);

@c    Swap two columns in the matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `i':
@c      The index of the first column.

@c `j':
@c      The index of the second column.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(m), the number of rows.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_select_rows --- Select some rows of a matrix,  Next: igraph_matrix_select_cols --- Select some columns of a matrix,  Prev: igraph_matrix_swap_cols --- Swap two columns,  Up: Operations on rows and columns

@c 6.3.6.7 igraph_matrix_select_rows -- Select some rows of a matrix
@c .................................................................


@c      int igraph_matrix_select_rows(const igraph_matrix_t *m,
@c      					igraph_matrix_t *res,
@c      					const igraph_vector_t *rows);

@c    This function selects some rows of a matrix and returns them in a
@c new matrix. The result matrix should be initialized before calling the
@c function.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `res':
@c      The result matrix. It should be initialized and will be resized as
@c      needed.

@c `rows':
@c      Vector, it contains the row indices (starting with zero) to
@c      extract. Note that no range checking is performed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(nm), n is the number of rows, m the number of
@c columns of the result matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_select_cols --- Select some columns of a matrix,  Prev: igraph_matrix_select_rows --- Select some rows of a matrix,  Up: Operations on rows and columns

@c 6.3.6.8 igraph_matrix_select_cols -- Select some columns of a matrix
@c ....................................................................


@c      int igraph_matrix_select_cols(const igraph_matrix_t *m,
@c      					igraph_matrix_t *res,
@c      					const igraph_vector_t *cols);

@c    This function selects some columns of a matrix and returns them in a
@c new matrix. The result matrix should be initialized before calling the
@c function.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `res':
@c      The result matrix. It should be initialized and will be resized as
@c      needed.

@c `cols':
@c      Vector, it contains the column indices (starting with zero) to
@c      extract. Note that no range checking is performed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(nm), n is the number of rows, m the number of
@c columns of the result matrix.

@c
@c File: igraph_reference_manual.info,  Node: Matrix operations,  Next: Combining matrices,  Prev: Operations on rows and columns,  Up: Matrices

@c 6.3.7 Matrix operations
@c -----------------------

@c * Menu:

@c * igraph_matrix_add_constant --- Add a constant to every element.: igraph_matrix_add_constant --- Add a constant to every element_.
@c * igraph_matrix_scale --- Multiplies each element of the matrix by a constant.: igraph_matrix_scale --- Multiplies each element of the matrix by a constant_.
@c * igraph_matrix_add --- Add two matrices.: igraph_matrix_add --- Add two matrices_.
@c * igraph_matrix_sub --- Difference of two matrices.: igraph_matrix_sub --- Difference of two matrices_.
@c * igraph_matrix_mul_elements --- Elementwise multiplication.: igraph_matrix_mul_elements --- Elementwise multiplication_.
@c * igraph_matrix_div_elements --- Elementwise division.: igraph_matrix_div_elements --- Elementwise division_.
@c * igraph_matrix_sum --- Sum of elements::
@c * igraph_matrix_prod --- Product of the elements.: igraph_matrix_prod --- Product of the elements_.
@c * igraph_matrix_rowsum --- Rowwise sum::
@c * igraph_matrix_colsum --- Columnwise sum::
@c * igraph_matrix_transpose --- Transpose::

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_add_constant --- Add a constant to every element_,  Next: igraph_matrix_scale --- Multiplies each element of the matrix by a constant_,  Up: Matrix operations

@c 6.3.7.1 igraph_matrix_add_constant -- Add a constant to every element.
@c ......................................................................


@c      void igraph_matrix_add_constant(igraph_matrix_t *m, igraph_real_t plus);

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `plud':
@c      The constant to add.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_scale --- Multiplies each element of the matrix by a constant_,  Next: igraph_matrix_add --- Add two matrices_,  Prev: igraph_matrix_add_constant --- Add a constant to every element_,  Up: Matrix operations

@c 6.3.7.2 igraph_matrix_scale -- Multiplies each element of the matrix by a constant.
@c ...................................................................................


@c      void igraph_matrix_scale(igraph_matrix_t *m, igraph_real_t by);

@c    *Arguments:. *

@c `m':
@c      The matrix.

@c `by':
@c      The constant.

@c    Added in version 0.2.

@c    Time complexity: O(n), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_add --- Add two matrices_,  Next: igraph_matrix_sub --- Difference of two matrices_,  Prev: igraph_matrix_scale --- Multiplies each element of the matrix by a constant_,  Up: Matrix operations

@c 6.3.7.3 igraph_matrix_add -- Add two matrices.
@c ..............................................


@c      int igraph_matrix_add(igraph_matrix_t *m1,
@c      				const igraph_matrix_t *m2);

@c    Add `m2' to `m1', and store the result in `m1'. The size of the
@c matrices must match.

@c    *Arguments:. *

@c `m1':
@c      The first matrix, the result will be stored here.

@c `m2':
@c      The second matrix, it is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_sub --- Difference of two matrices_,  Next: igraph_matrix_mul_elements --- Elementwise multiplication_,  Prev: igraph_matrix_add --- Add two matrices_,  Up: Matrix operations

@c 6.3.7.4 igraph_matrix_sub -- Difference of two matrices.
@c ........................................................


@c      int igraph_matrix_sub(igraph_matrix_t *m1,
@c      				const igraph_matrix_t *m2);

@c    Subtract `m2' from `m1' and store the result in `m1'.  The size of
@c the two matrices must match.

@c    *Arguments:. *

@c `m1':
@c      The first matrix, the result is stored here.

@c `m2':
@c      The second matrix, it is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_mul_elements --- Elementwise multiplication_,  Next: igraph_matrix_div_elements --- Elementwise division_,  Prev: igraph_matrix_sub --- Difference of two matrices_,  Up: Matrix operations

@c 6.3.7.5 igraph_matrix_mul_elements -- Elementwise multiplication.
@c .................................................................


@c      int igraph_matrix_mul_elements(igraph_matrix_t *m1,
@c      					 const igraph_matrix_t *m2);

@c    Multiply `m1' by `m2' elementwise and store the result in `m1'.  The
@c size of the two matrices must match.

@c    *Arguments:. *

@c `m1':
@c      The first matrix, the result is stored here.

@c `m2':
@c      The second matrix, it is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_div_elements --- Elementwise division_,  Next: igraph_matrix_sum --- Sum of elements,  Prev: igraph_matrix_mul_elements --- Elementwise multiplication_,  Up: Matrix operations

@c 6.3.7.6 igraph_matrix_div_elements -- Elementwise division.
@c ...........................................................


@c      int igraph_matrix_div_elements(igraph_matrix_t *m1,
@c      					 const igraph_matrix_t *m2);

@c    Divide `m1' by `m2' elementwise and store the result in `m1'.  The
@c size of the two matrices must match.

@c    *Arguments:. *

@c `m1':
@c      The divident. The result is store here.

@c `m2':
@c      The divisor. It is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_sum --- Sum of elements,  Next: igraph_matrix_prod --- Product of the elements_,  Prev: igraph_matrix_div_elements --- Elementwise division_,  Up: Matrix operations

@c 6.3.7.7 igraph_matrix_sum -- Sum of elements
@c ............................................


@c      igraph_real_t igraph_matrix_sum(const igraph_matrix_t *m);

@c    Returns the sum of the elements of a matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c    *Returns:. *

@c `'
@c      The sum of the elements.

@c    Time complexity: O(mn), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_prod --- Product of the elements_,  Next: igraph_matrix_rowsum --- Rowwise sum,  Prev: igraph_matrix_sum --- Sum of elements,  Up: Matrix operations

@c 6.3.7.8 igraph_matrix_prod -- Product of the elements.
@c ......................................................


@c      igraph_real_t igraph_matrix_prod(const igraph_matrix_t *m);

@c    Note this function can result an overflow easily, even for not too
@c big matrices.

@c    *Arguments:. *

@c `The':
@c      input matrix.

@c    *Returns:. *

@c `'
@c      The product of the elements.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_rowsum --- Rowwise sum,  Next: igraph_matrix_colsum --- Columnwise sum,  Prev: igraph_matrix_prod --- Product of the elements_,  Up: Matrix operations

@c 6.3.7.9 igraph_matrix_rowsum -- Rowwise sum
@c ...........................................


@c      int igraph_matrix_rowsum(const igraph_matrix_t *m,
@c      				   igraph_vector_t *res);

@c    Calculate the sum of the elements in each row.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `res':
@c      Pointer to an initialized vector, the result is stored here. It
@c      will be resized if necessary.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_colsum --- Columnwise sum,  Next: igraph_matrix_transpose --- Transpose,  Prev: igraph_matrix_rowsum --- Rowwise sum,  Up: Matrix operations

@c 6.3.7.10 igraph_matrix_colsum -- Columnwise sum
@c ...............................................


@c      int igraph_matrix_colsum(const igraph_matrix_t *m,
@c      				   igraph_vector_t *res);

@c    Calculate the sum of the elements in each column.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `res':
@c      Pointer to an initialized vector, the result is stored here. It
@c      will be resized if necessary.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_transpose --- Transpose,  Prev: igraph_matrix_colsum --- Columnwise sum,  Up: Matrix operations

@c 6.3.7.11 igraph_matrix_transpose -- Transpose
@c .............................................


@c      int igraph_matrix_transpose(igraph_matrix_t *m);

@c    Calculate the transpose of a matrix. Note that the function
@c reallocates the memory used for the matrix.

@c    *Arguments:. *

@c `m':
@c      The input (and output) matrix.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: Combining matrices,  Next: Finding minimum and maximum <1>,  Prev: Matrix operations,  Up: Matrices

@c 6.3.8 Combining matrices
@c ------------------------

@c * Menu:

@c * igraph_matrix_rbind --- Combine two matrices rowwise::
@c * igraph_matrix_cbind --- Combine matrices, columnwise.: igraph_matrix_cbind --- Combine matrices; columnwise_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_rbind --- Combine two matrices rowwise,  Next: igraph_matrix_cbind --- Combine matrices; columnwise_,  Up: Combining matrices

@c 6.3.8.1 igraph_matrix_rbind -- Combine two matrices rowwise
@c ...........................................................


@c      int igraph_matrix_rbind(igraph_matrix_t *to,
@c      				  const igraph_matrix_t *from);

@c    This function places the rows of `from' below the rows of `to' and
@c stores the result in `to'. The number of columns in the two matrices
@c must match.

@c    *Arguments:. *

@c `to':
@c      The upper matrix, the result is also stored here.

@c `from':
@c      The lower matrix. It is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements in the newly created
@c matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_cbind --- Combine matrices; columnwise_,  Prev: igraph_matrix_rbind --- Combine two matrices rowwise,  Up: Combining matrices

@c 6.3.8.2 igraph_matrix_cbind -- Combine matrices, columnwise.
@c ............................................................


@c      int igraph_matrix_cbind(igraph_matrix_t *to,
@c      				  const igraph_matrix_t *from);

@c    This function places the columns of `from' on the right of `to', and
@c stores the result in `to'.

@c    *Arguments:. *

@c `to':
@c      The left matrix, the result is stored here too.

@c `from':
@c      The right matrix. It is left unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements on the new matrix.

@c
@c File: igraph_reference_manual.info,  Node: Finding minimum and maximum <1>,  Next: Matrix properties,  Prev: Combining matrices,  Up: Matrices

@c 6.3.9 Finding minimum and maximum
@c ---------------------------------

@c * Menu:

@c * igraph_matrix_min --- Minimum element.: igraph_matrix_min --- Minimum element_.
@c * igraph_matrix_max --- Returns the maximal element of a matrix.: igraph_matrix_max --- Returns the maximal element of a matrix_.
@c * igraph_matrix_which_min --- Indices of the minimum.: igraph_matrix_which_min --- Indices of the minimum_.
@c * igraph_matrix_which_max --- Indices of the maximum.: igraph_matrix_which_max --- Indices of the maximum_.
@c * igraph_matrix_minmax --- Minimum and maximum::
@c * igraph_matrix_which_minmax --- Indices of the minimum and maximum::

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_min --- Minimum element_,  Next: igraph_matrix_max --- Returns the maximal element of a matrix_,  Up: Finding minimum and maximum <1>

@c 6.3.9.1 igraph_matrix_min -- Minimum element.
@c .............................................


@c      igraph_real_t igraph_matrix_min(const igraph_matrix_t *m);

@c    Returns the smallest element of a non-empty matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c    *Returns:. *

@c `'
@c      The smallest element.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_max --- Returns the maximal element of a matrix_,  Next: igraph_matrix_which_min --- Indices of the minimum_,  Prev: igraph_matrix_min --- Minimum element_,  Up: Finding minimum and maximum <1>

@c 6.3.9.2 igraph_matrix_max -- Returns the maximal element of a matrix.
@c .....................................................................


@c      igraph_real_t igraph_matrix_max(const igraph_matrix_t *m);

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c    *Returns:. *

@c `'
@c      The maximum element. For empty matrix the returned value is
@c      undefined.

@c    Added in version 0.2.

@c    Time complexity: O(n), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_which_min --- Indices of the minimum_,  Next: igraph_matrix_which_max --- Indices of the maximum_,  Prev: igraph_matrix_max --- Returns the maximal element of a matrix_,  Up: Finding minimum and maximum <1>

@c 6.3.9.3 igraph_matrix_which_min -- Indices of the minimum.
@c ..........................................................


@c      int igraph_matrix_which_min(const igraph_matrix_t *m,
@c      				      long int *i, long int *j);

@c    Gives the indices of the (first) smallest element in a non-empty
@c matrix.

@c    *Arguments:. *

@c `m':
@c      The matrix.

@c `i':
@c      Pointer to a `long int'. The row index of the minimum is stored
@c      here.

@c `j':
@c      Pointer to a `long int'. The column index of the minimum is stored
@c      here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_which_max --- Indices of the maximum_,  Next: igraph_matrix_minmax --- Minimum and maximum,  Prev: igraph_matrix_which_min --- Indices of the minimum_,  Up: Finding minimum and maximum <1>

@c 6.3.9.4 igraph_matrix_which_max -- Indices of the maximum.
@c ..........................................................


@c      int igraph_matrix_which_max(const igraph_matrix_t *m,
@c      				      long int *i, long int *j);

@c    Gives the indices of the (first) largest element in a non-empty
@c matrix.

@c    *Arguments:. *

@c `m':
@c      The matrix.

@c `i':
@c      Pointer to a `long int'. The row index of the maximum is stored
@c      here.

@c `j':
@c      Pointer to a `long int'. The column index of the maximum is stored
@c      here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_minmax --- Minimum and maximum,  Next: igraph_matrix_which_minmax --- Indices of the minimum and maximum,  Prev: igraph_matrix_which_max --- Indices of the maximum_,  Up: Finding minimum and maximum <1>

@c 6.3.9.5 igraph_matrix_minmax -- Minimum and maximum
@c ...................................................


@c      int igraph_matrix_minmax(const igraph_matrix_t *m,
@c      				   igraph_real_t *min, igraph_real_t *max);

@c    The maximum and minimum elements of a non-empty matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `min':
@c      Pointer to a base type. The minimum is stored here.

@c `max':
@c      Pointer to a base type. The maximum is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_which_minmax --- Indices of the minimum and maximum,  Prev: igraph_matrix_minmax --- Minimum and maximum,  Up: Finding minimum and maximum <1>

@c 6.3.9.6 igraph_matrix_which_minmax -- Indices of the minimum and maximum
@c ........................................................................


@c      int igraph_matrix_which_minmax(const igraph_matrix_t *m,
@c      					 long int *imin, long int *jmin,
@c      					 long int *imax, long int *jmax);

@c    Find the positions of the smallest and largest elements of a
@c non-empty matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `imin':
@c      Pointer to a `long int', the row index of the minimum is stored
@c      here.

@c `jmin':
@c      Pointer to a `long int', the column index of the minimum is stored
@c      here.

@c `imax':
@c      Pointer to a `long int', the row index of the maximum is stored
@c      here.

@c `jmax':
@c      Pointer to a `long int', the column index of the maximum is stored
@c      here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: Matrix properties,  Next: Searching for elements <1>,  Prev: Finding minimum and maximum <1>,  Up: Matrices

@c 6.3.10 Matrix properties
@c ------------------------

@c * Menu:

@c * igraph_matrix_empty --- Check for an empty matrix.: igraph_matrix_empty --- Check for an empty matrix_.
@c * igraph_matrix_isnull --- Check for a null matrix.: igraph_matrix_isnull --- Check for a null matrix_.
@c * igraph_matrix_size --- The number of elements in a matrix.: igraph_matrix_size --- The number of elements in a matrix_.
@c * igraph_matrix_nrow --- The number of rows in a matrix.: igraph_matrix_nrow --- The number of rows in a matrix_.
@c * igraph_matrix_ncol --- The number of columns in a matrix.: igraph_matrix_ncol --- The number of columns in a matrix_.
@c * igraph_matrix_is_symmetric --- Check for symmetric matrix.: igraph_matrix_is_symmetric --- Check for symmetric matrix_.
@c * igraph_matrix_is_equal --- Are two matrices equal?::
@c * igraph_matrix_maxdifference --- Maximum difference::

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_empty --- Check for an empty matrix_,  Next: igraph_matrix_isnull --- Check for a null matrix_,  Up: Matrix properties

@c 6.3.10.1 igraph_matrix_empty -- Check for an empty matrix.
@c ..........................................................


@c      igraph_bool_t igraph_matrix_empty(const igraph_matrix_t *m);

@c    It is possible to have a matrix with zero rows or zero columns, or
@c even both. This functions checks for these.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' if the matrix contains zero elements, and `FALSE'
@c      otherwise.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_isnull --- Check for a null matrix_,  Next: igraph_matrix_size --- The number of elements in a matrix_,  Prev: igraph_matrix_empty --- Check for an empty matrix_,  Up: Matrix properties

@c 6.3.10.2 igraph_matrix_isnull -- Check for a null matrix.
@c .........................................................


@c      igraph_bool_t igraph_matrix_isnull(const igraph_matrix_t *m);

@c    Checks whether all elements are zero.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' is `m' contains only zeros and `FALSE' otherwise.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_size --- The number of elements in a matrix_,  Next: igraph_matrix_nrow --- The number of rows in a matrix_,  Prev: igraph_matrix_isnull --- Check for a null matrix_,  Up: Matrix properties

@c 6.3.10.3 igraph_matrix_size -- The number of elements in a matrix.
@c ..................................................................


@c      long int igraph_matrix_size(const igraph_matrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized matrix object.

@c    *Returns:. *

@c `'
@c      The size of the matrix.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_nrow --- The number of rows in a matrix_,  Next: igraph_matrix_ncol --- The number of columns in a matrix_,  Prev: igraph_matrix_size --- The number of elements in a matrix_,  Up: Matrix properties

@c 6.3.10.4 igraph_matrix_nrow -- The number of rows in a matrix.
@c ..............................................................


@c      long int igraph_matrix_nrow(const igraph_matrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized matrix object.

@c    *Returns:. *

@c `'
@c      The number of rows in the matrix.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_ncol --- The number of columns in a matrix_,  Next: igraph_matrix_is_symmetric --- Check for symmetric matrix_,  Prev: igraph_matrix_nrow --- The number of rows in a matrix_,  Up: Matrix properties

@c 6.3.10.5 igraph_matrix_ncol -- The number of columns in a matrix.
@c .................................................................


@c      long int igraph_matrix_ncol(const igraph_matrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized matrix object.

@c    *Returns:. *

@c `'
@c      The number of columns in the matrix.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_is_symmetric --- Check for symmetric matrix_,  Next: igraph_matrix_is_equal --- Are two matrices equal?,  Prev: igraph_matrix_ncol --- The number of columns in a matrix_,  Up: Matrix properties

@c 6.3.10.6 igraph_matrix_is_symmetric -- Check for symmetric matrix.
@c ..................................................................


@c      igraph_bool_t igraph_matrix_is_symmetric(const igraph_matrix_t *m);

@c    A non-square matrix is not symmetric by definition.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' if the matrix is square and symmetric, `FALSE'
@c      otherwise.

@c    Time complexity: O(mn), the number of elements. O(1) for non-square
@c matrices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_is_equal --- Are two matrices equal?,  Next: igraph_matrix_maxdifference --- Maximum difference,  Prev: igraph_matrix_is_symmetric --- Check for symmetric matrix_,  Up: Matrix properties

@c 6.3.10.7 igraph_matrix_is_equal -- Are two matrices equal?
@c ..........................................................


@c      igraph_bool_t igraph_matrix_is_equal(const igraph_matrix_t *m1,
@c      					      const igraph_matrix_t *m2);

@c    Decides whether two matrices are equal. Two matrices are equal if
@c they have the same size and contain exactly the same elements.

@c    *Arguments:. *

@c `m1':
@c      The first matrix.

@c `m2':
@c      The second matrix.

@c    *Returns:. *

@c `'
@c      `TRUE' if they are equal, `FALSE' otherwise.

@c    Time complexity: O(1) if the sizes are different, O(mn) otherwise.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_maxdifference --- Maximum difference,  Prev: igraph_matrix_is_equal --- Are two matrices equal?,  Up: Matrix properties

@c 6.3.10.8 igraph_matrix_maxdifference -- Maximum difference
@c ..........................................................


@c      igraph_real_t igraph_matrix_maxdifference(const igraph_matrix_t *m1,
@c      					   const igraph_matrix_t *m2);

@c    Calculate the maximum difference of two matrices. Both matrices must
@c be non-empty. If their size differs then a warning is given and the
@c comparision is performed by vectors columnwise from both matrices,
@c columnwise, the remaining elements in the larger vector are ignored.

@c    *Arguments:. *

@c `m1':
@c      The first matrix.

@c `m2':
@c      The second matrix.

@c    *Returns:. *

@c `'
@c      The maximum of `m1' - `m2'.

@c    Time complexity: O(mn), the elements in the smaller matrix.

@c
@c File: igraph_reference_manual.info,  Node: Searching for elements <1>,  Next: Resizing operations <1>,  Prev: Matrix properties,  Up: Matrices

@c 6.3.11 Searching for elements
@c -----------------------------

@c * Menu:

@c * igraph_matrix_contains --- Search for an element.: igraph_matrix_contains --- Search for an element_.
@c * igraph_matrix_search --- Search from a given position.: igraph_matrix_search --- Search from a given position_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_contains --- Search for an element_,  Next: igraph_matrix_search --- Search from a given position_,  Up: Searching for elements <1>

@c 6.3.11.1 igraph_matrix_contains -- Search for an element.
@c .........................................................


@c      igraph_bool_t igraph_matrix_contains(const igraph_matrix_t *m,
@c      					       igraph_real_t e);

@c    Search for the given element in the matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `e':
@c      The element to search for.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' if the matrix contains `e', `FALSE' otherwise.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_search --- Search from a given position_,  Prev: igraph_matrix_contains --- Search for an element_,  Up: Searching for elements <1>

@c 6.3.11.2 igraph_matrix_search -- Search from a given position.
@c ..............................................................


@c      igraph_bool_t igraph_matrix_search(const igraph_matrix_t *m,
@c      					     long int from, igraph_real_t what,
@c      					     long int *pos,
@c      					     long int *row, long int *col);

@c    Search for an element in a matrix and start the search from the
@c given position. The search is performed columnwise.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `from':
@c      The position to search from, the positions are enumerated
@c      columnwise.

@c `what':
@c      The element to search for.

@c `pos':
@c      Pointer to a `long int'. If the element is found, then this is set
@c      to the position of its first appearance.

@c `row':
@c      Pointer to a `long int'. If the element is found, then this is set
@c      to its row index.

@c `col':
@c      Pointer to a `long int'. If the element is found, then this is set
@c      to its column index.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' if the element is found, `FALSE' otherwise.

@c    Time complexity: O(mn), the number of elements.

@c
@c File: igraph_reference_manual.info,  Node: Resizing operations <1>,  Prev: Searching for elements <1>,  Up: Matrices

@c 6.3.12 Resizing operations
@c --------------------------

@c * Menu:

@c * igraph_matrix_resize --- Resizes a matrix.: igraph_matrix_resize --- Resizes a matrix_.
@c * igraph_matrix_add_rows --- Adds rows to a matrix.: igraph_matrix_add_rows --- Adds rows to a matrix_.
@c * igraph_matrix_add_cols --- Adds columns to a matrix.: igraph_matrix_add_cols --- Adds columns to a matrix_.
@c * igraph_matrix_remove_row --- Remove a row::
@c * igraph_matrix_remove_col --- Removes a column from a matrix.: igraph_matrix_remove_col --- Removes a column from a matrix_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_resize --- Resizes a matrix_,  Next: igraph_matrix_add_rows --- Adds rows to a matrix_,  Up: Resizing operations <1>

@c 6.3.12.1 igraph_matrix_resize -- Resizes a matrix.
@c ..................................................


@c      int igraph_matrix_resize(igraph_matrix_t *m, long int nrow, long int ncol);

@c    This function resizes a matrix by adding more elements to it.  The
@c matrix contains arbitrary data after resizing it.  Ie. after calling
@c this function you cannot expect that element (i,j) in the matrix
@c remains the same as before.

@c    *Arguments:. *

@c `m':
@c      Pointer to an already initialized matrix object.

@c `nrow':
@c      The number of rows in the resized matrix.

@c `ncol':
@c      The number of columns in the resized matrix.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1) if the matrix gets smaller, usually O(n) if it
@c gets larger, n is the number of elements in the resized matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_add_rows --- Adds rows to a matrix_,  Next: igraph_matrix_add_cols --- Adds columns to a matrix_,  Prev: igraph_matrix_resize --- Resizes a matrix_,  Up: Resizing operations <1>

@c 6.3.12.2 igraph_matrix_add_rows -- Adds rows to a matrix.
@c .........................................................


@c      int igraph_matrix_add_rows(igraph_matrix_t *m, long int n);

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c `n':
@c      The number of rows to add.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_ENOMEM' if there isn't enough memory for the
@c      operation.

@c    Time complexity: linear with the number of elements of the new,
@c resized, matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_add_cols --- Adds columns to a matrix_,  Next: igraph_matrix_remove_row --- Remove a row,  Prev: igraph_matrix_add_rows --- Adds rows to a matrix_,  Up: Resizing operations <1>

@c 6.3.12.3 igraph_matrix_add_cols -- Adds columns to a matrix.
@c ............................................................


@c      int igraph_matrix_add_cols(igraph_matrix_t *m, long int n);

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c `n':
@c      The number of columns to add.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_ENOMEM' if there is not enough memory to
@c      perform the operation.

@c    Time complexity: linear with the number of elements of the new,
@c resized matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_remove_row --- Remove a row,  Next: igraph_matrix_remove_col --- Removes a column from a matrix_,  Prev: igraph_matrix_add_cols --- Adds columns to a matrix_,  Up: Resizing operations <1>

@c 6.3.12.4 igraph_matrix_remove_row -- Remove a row
@c .................................................


@c      int igraph_matrix_remove_row(igraph_matrix_t *m, long int row);

@c    A row is removed from the matrix.

@c    *Arguments:. *

@c `m':
@c      The input matrix.

@c `row':
@c      The index of the row to remove.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(mn), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_matrix_remove_col --- Removes a column from a matrix_,  Prev: igraph_matrix_remove_row --- Remove a row,  Up: Resizing operations <1>

@c 6.3.12.5 igraph_matrix_remove_col -- Removes a column from a matrix.
@c ....................................................................


@c      int igraph_matrix_remove_col(igraph_matrix_t *m, long int col);

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c `col':
@c      The column to remove.

@c    *Returns:. *

@c `'
@c      Error code, always returns with success.

@c    Time complexity: linear with the number of elements of the new,
@c resized matrix.

@c
@c File: igraph_reference_manual.info,  Node: Sparse matrices,  Next: Stacks,  Prev: Matrices,  Up: Data structure library; vector; matrix; other data types

@c 6.4 Sparse matrices
@c ===================

@c * Menu:

@c * About igraph_spmatrix_t objects::
@c * Sparse matrix constructors and destructors.: Sparse matrix constructors and destructors_.
@c * Accessing elements of a sparse matrix::
@c * Matrix query operations::
@c * Matrix operations: Matrix operations <1>.

@c
@c File: igraph_reference_manual.info,  Node: About igraph_spmatrix_t objects,  Next: Sparse matrix constructors and destructors_,  Up: Sparse matrices

@c 6.4.1 About igraph_spmatrix_t objects
@c -------------------------------------

@c The `igraph_spmatrix_t' type stores a sparse matrix with the assumption
@c that the number of nonzero elements in the matrix scales linearly with
@c the row or column count of the matrix (so most of the elements are
@c zero). Of course it can store an arbitrary real matrix, but if most of
@c the elements are nonzero, one should use `igraph_matrix_t' instead.

@c    The elements are stored in column compressed format, so the elements
@c in the same column are stored adjacent in the computer's memory. The
@c storage requirement for a sparse matrix is O(n) where n is the number
@c of nonzero elements. Actually it can be a bit larger, see the
@c documentation of the vector type for an explanation.

@c
@c File: igraph_reference_manual.info,  Node: Sparse matrix constructors and destructors_,  Next: Accessing elements of a sparse matrix,  Prev: About igraph_spmatrix_t objects,  Up: Sparse matrices

@c 6.4.2 Sparse matrix constructors and destructors.
@c -------------------------------------------------

@c * Menu:

@c * igraph_spmatrix_init --- Initializes a sparse matrix.: igraph_spmatrix_init --- Initializes a sparse matrix_.
@c * igraph_spmatrix_copy --- Copies a sparse matrix.: igraph_spmatrix_copy --- Copies a sparse matrix_.
@c * igraph_spmatrix_destroy --- Destroys a sparse matrix object.: igraph_spmatrix_destroy --- Destroys a sparse matrix object_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_init --- Initializes a sparse matrix_,  Next: igraph_spmatrix_copy --- Copies a sparse matrix_,  Up: Sparse matrix constructors and destructors_

@c 6.4.2.1 igraph_spmatrix_init -- Initializes a sparse matrix.
@c ............................................................


@c      int igraph_spmatrix_init(igraph_spmatrix_t *m, long int nrow, long int ncol);

@c    Every sparse matrix needs to be initialized before using it, this is
@c done by calling this function. A matrix has to be destroyed if it is not
@c needed any more, see `igraph_spmatrix_destroy()' (*note
@c igraph_spmatrix_destroy --- Destroys a sparse matrix object_::).

@c    *Arguments:. *

@c `m':
@c      Pointer to a not yet initialized sparse matrix object to be
@c      initialized.

@c `nrow':
@c      The number of rows in the matrix.

@c `ncol':
@c      The number of columns in the matrix.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: operating system dependent.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_copy --- Copies a sparse matrix_,  Next: igraph_spmatrix_destroy --- Destroys a sparse matrix object_,  Prev: igraph_spmatrix_init --- Initializes a sparse matrix_,  Up: Sparse matrix constructors and destructors_

@c 6.4.2.2 igraph_spmatrix_copy -- Copies a sparse matrix.
@c .......................................................


@c      int igraph_spmatrix_copy(igraph_spmatrix_t *to, const igraph_spmatrix_t *from);

@c    Creates a sparse matrix object by copying another one.

@c    *Arguments:. *

@c `to':
@c      Pointer to an uninitialized sparse matrix object.

@c `from':
@c      The initialized sparse matrix object to copy.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_ENOMEM' if there isn't enough memory to
@c      allocate the new sparse matrix.

@c    Time complexity: O(n), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_destroy --- Destroys a sparse matrix object_,  Prev: igraph_spmatrix_copy --- Copies a sparse matrix_,  Up: Sparse matrix constructors and destructors_

@c 6.4.2.3 igraph_spmatrix_destroy -- Destroys a sparse matrix object.
@c ...................................................................


@c      void igraph_spmatrix_destroy(igraph_spmatrix_t *m);

@c    This function frees all the memory allocated for a sparse matrix
@c object. The destroyed object needs to be reinitialized before using it
@c again.

@c    *Arguments:. *

@c `m':
@c      The matrix to destroy.

@c    Time complexity: operating system dependent.

@c
@c File: igraph_reference_manual.info,  Node: Accessing elements of a sparse matrix,  Next: Matrix query operations,  Prev: Sparse matrix constructors and destructors_,  Up: Sparse matrices

@c 6.4.3 Accessing elements of a sparse matrix
@c -------------------------------------------

@c * Menu:

@c * igraph_spmatrix_e --- Accessing an element of a sparse matrix.: igraph_spmatrix_e --- Accessing an element of a sparse matrix_.
@c * igraph_spmatrix_set --- Setting an element of a sparse matrix.: igraph_spmatrix_set --- Setting an element of a sparse matrix_.
@c * igraph_spmatrix_add_e --- Adding a real value to an element of a sparse matrix.: igraph_spmatrix_add_e --- Adding a real value to an element of a sparse matrix_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_e --- Accessing an element of a sparse matrix_,  Next: igraph_spmatrix_set --- Setting an element of a sparse matrix_,  Up: Accessing elements of a sparse matrix

@c 6.4.3.1 igraph_spmatrix_e -- Accessing an element of a sparse matrix.
@c .....................................................................


@c      igraph_real_t igraph_spmatrix_e(const igraph_spmatrix_t *m,
@c                                      long int row, long int col);

@c    Note that there are no range checks right now.

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c `row':
@c      The index of the row, starting with zero.

@c `col':
@c      The index of the column, starting with zero.

@c    Time complexity: O(log n), where n is the number of nonzero elements
@c in the requested column.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_set --- Setting an element of a sparse matrix_,  Next: igraph_spmatrix_add_e --- Adding a real value to an element of a sparse matrix_,  Prev: igraph_spmatrix_e --- Accessing an element of a sparse matrix_,  Up: Accessing elements of a sparse matrix

@c 6.4.3.2 igraph_spmatrix_set -- Setting an element of a sparse matrix.
@c .....................................................................


@c      int igraph_spmatrix_set(igraph_spmatrix_t *m, long int row, long int col,
@c                  igraph_real_t value);

@c    Note that there are no range checks right now.

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c `row':
@c      The index of the row, starting with zero.

@c `col':
@c      The index of the column, starting with zero.

@c `value':
@c      The new value.

@c    Time complexity: O(log n), where n is the number of nonzero elements
@c in the requested column.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_add_e --- Adding a real value to an element of a sparse matrix_,  Prev: igraph_spmatrix_set --- Setting an element of a sparse matrix_,  Up: Accessing elements of a sparse matrix

@c 6.4.3.3 igraph_spmatrix_add_e -- Adding a real value to an element of a sparse matrix.
@c ......................................................................................


@c      int igraph_spmatrix_add_e(igraph_spmatrix_t *m, long int row, long int col,
@c                  igraph_real_t value);

@c    Note that there are no range checks right now. This is implemented
@c to avoid double lookup of a given element in the matrix by using
@c `igraph_spmatrix_e()' (*note igraph_spmatrix_e --- Accessing an element
@c of a sparse matrix_::) and `igraph_spmatrix_set()' (*note
@c igraph_spmatrix_set --- Setting an element of a sparse matrix_::)
@c consecutively.

@c    *Arguments:. *

@c `m':
@c      The matrix object.

@c `row':
@c      The index of the row, starting with zero.

@c `col':
@c      The index of the column, starting with zero.

@c `value':
@c      The value to add.

@c    Time complexity: O(log n), where n is the number of nonzero elements
@c in the requested column.

@c
@c File: igraph_reference_manual.info,  Node: Matrix query operations,  Next: Matrix operations <1>,  Prev: Accessing elements of a sparse matrix,  Up: Sparse matrices

@c 6.4.4 Matrix query operations
@c -----------------------------

@c * Menu:

@c * igraph_spmatrix_size --- The number of elements in a sparse matrix.: igraph_spmatrix_size --- The number of elements in a sparse matrix_.
@c * igraph_spmatrix_nrow --- The number of rows in a sparse matrix.: igraph_spmatrix_nrow --- The number of rows in a sparse matrix_.
@c * igraph_spmatrix_ncol --- The number of columns in a sparse matrix.: igraph_spmatrix_ncol --- The number of columns in a sparse matrix_.
@c * igraph_spmatrix_count_nonzero --- The number of non-zero elements in a sparse matrix.: igraph_spmatrix_count_nonzero --- The number of non-zero elements in a sparse matrix_.
@c * igraph_spmatrix_max --- Returns the maximum element of a matrix.: igraph_spmatrix_max --- Returns the maximum element of a matrix_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_size --- The number of elements in a sparse matrix_,  Next: igraph_spmatrix_nrow --- The number of rows in a sparse matrix_,  Up: Matrix query operations

@c 6.4.4.1 igraph_spmatrix_size -- The number of elements in a sparse matrix.
@c ..........................................................................


@c      long int igraph_spmatrix_size(const igraph_spmatrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized sparse matrix object.

@c    *Returns:. *

@c `'
@c      The size of the matrix.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_nrow --- The number of rows in a sparse matrix_,  Next: igraph_spmatrix_ncol --- The number of columns in a sparse matrix_,  Prev: igraph_spmatrix_size --- The number of elements in a sparse matrix_,  Up: Matrix query operations

@c 6.4.4.2 igraph_spmatrix_nrow -- The number of rows in a sparse matrix.
@c ......................................................................


@c      long int igraph_spmatrix_nrow(const igraph_spmatrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized sparse matrix object.

@c    *Returns:. *

@c `'
@c      The number of rows in the matrix.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_ncol --- The number of columns in a sparse matrix_,  Next: igraph_spmatrix_count_nonzero --- The number of non-zero elements in a sparse matrix_,  Prev: igraph_spmatrix_nrow --- The number of rows in a sparse matrix_,  Up: Matrix query operations

@c 6.4.4.3 igraph_spmatrix_ncol -- The number of columns in a sparse matrix.
@c .........................................................................


@c      long int igraph_spmatrix_ncol(const igraph_spmatrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized sparse matrix object.

@c    *Returns:. *

@c `'
@c      The number of columns in the sparse matrix.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_count_nonzero --- The number of non-zero elements in a sparse matrix_,  Next: igraph_spmatrix_max --- Returns the maximum element of a matrix_,  Prev: igraph_spmatrix_ncol --- The number of columns in a sparse matrix_,  Up: Matrix query operations

@c 6.4.4.4 igraph_spmatrix_count_nonzero -- The number of non-zero elements in a sparse matrix.
@c ............................................................................................


@c      long int igraph_spmatrix_count_nonzero(const igraph_spmatrix_t *m);

@c    *Arguments:. *

@c `m':
@c      Pointer to an initialized sparse matrix object.

@c    *Returns:. *

@c `'
@c      The size of the matrix.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_max --- Returns the maximum element of a matrix_,  Prev: igraph_spmatrix_count_nonzero --- The number of non-zero elements in a sparse matrix_,  Up: Matrix query operations

@c 6.4.4.5 igraph_spmatrix_max -- Returns the maximum element of a matrix.
@c .......................................................................


@c      igraph_real_t igraph_spmatrix_max(const igraph_spmatrix_t *m,
@c          igraph_real_t *ridx, igraph_real_t *cidx);

@c    If the matrix is empty, zero is returned.

@c    *Arguments:. *

@c `m':
@c      the matrix object.

@c `ridx':
@c      the row index of the maximum element if not `NULL'.

@c `cidx':
@c      the column index of the maximum element if not `NULL'.

@c    Time complexity: O(n), the number of nonzero elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: Matrix operations <1>,  Prev: Matrix query operations,  Up: Sparse matrices

@c 6.4.5 Matrix operations
@c -----------------------

@c * Menu:

@c * igraph_spmatrix_scale --- Multiplies each element of the sparse matrix by a constant.: igraph_spmatrix_scale --- Multiplies each element of the sparse matrix by a constant_.
@c * igraph_spmatrix_add_rows --- Adds rows to a sparse matrix.: igraph_spmatrix_add_rows --- Adds rows to a sparse matrix_.
@c * igraph_spmatrix_add_cols --- Adds columns to a sparse matrix.: igraph_spmatrix_add_cols --- Adds columns to a sparse matrix_.
@c * igraph_spmatrix_resize --- Resizes a sparse matrix.: igraph_spmatrix_resize --- Resizes a sparse matrix_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_scale --- Multiplies each element of the sparse matrix by a constant_,  Next: igraph_spmatrix_add_rows --- Adds rows to a sparse matrix_,  Up: Matrix operations <1>

@c 6.4.5.1 igraph_spmatrix_scale -- Multiplies each element of the sparse matrix by a constant.
@c ............................................................................................


@c      void igraph_spmatrix_scale(igraph_spmatrix_t *m, igraph_real_t by);

@c    *Arguments:. *

@c `m':
@c      The matrix.

@c `by':
@c      The constant.

@c    Time complexity: O(n), the number of elements in the matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_add_rows --- Adds rows to a sparse matrix_,  Next: igraph_spmatrix_add_cols --- Adds columns to a sparse matrix_,  Prev: igraph_spmatrix_scale --- Multiplies each element of the sparse matrix by a constant_,  Up: Matrix operations <1>

@c 6.4.5.2 igraph_spmatrix_add_rows -- Adds rows to a sparse matrix.
@c .................................................................


@c      int igraph_spmatrix_add_rows(igraph_spmatrix_t *m, long int n);

@c    *Arguments:. *

@c `m':
@c      The sparse matrix object.

@c `n':
@c      The number of rows to add.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_add_cols --- Adds columns to a sparse matrix_,  Next: igraph_spmatrix_resize --- Resizes a sparse matrix_,  Prev: igraph_spmatrix_add_rows --- Adds rows to a sparse matrix_,  Up: Matrix operations <1>

@c 6.4.5.3 igraph_spmatrix_add_cols -- Adds columns to a sparse matrix.
@c ....................................................................


@c      int igraph_spmatrix_add_cols(igraph_spmatrix_t *m, long int n);

@c    *Arguments:. *

@c `m':
@c      The sparse matrix object.

@c `n':
@c      The number of columns to add.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_spmatrix_resize --- Resizes a sparse matrix_,  Prev: igraph_spmatrix_add_cols --- Adds columns to a sparse matrix_,  Up: Matrix operations <1>

@c 6.4.5.4 igraph_spmatrix_resize -- Resizes a sparse matrix.
@c ..........................................................


@c      int igraph_spmatrix_resize(igraph_spmatrix_t *m, long int nrow, long int ncol);

@c    This function resizes a sparse matrix by adding more elements to it.
@c The matrix retains its data even after resizing it, except for the data
@c which lies outside the new boundaries (if the new size is smaller).

@c    *Arguments:. *

@c `m':
@c      Pointer to an already initialized sparse matrix object.

@c `nrow':
@c      The number of rows in the resized matrix.

@c `ncol':
@c      The number of columns in the resized matrix.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n).  n is the number of elements in the old
@c matrix.

@c
@c File: igraph_reference_manual.info,  Node: Stacks,  Next: Double-ended queues,  Prev: Sparse matrices,  Up: Data structure library; vector; matrix; other data types

@c 6.5 Stacks
@c ==========

@c * Menu:

@c * igraph_stack_init --- Initializes a stack.: igraph_stack_init --- Initializes a stack_.
@c * igraph_stack_destroy --- Destroys a stack object.: igraph_stack_destroy --- Destroys a stack object_.
@c * igraph_stack_reserve --- Reserve memory.: igraph_stack_reserve --- Reserve memory_.
@c * igraph_stack_empty --- Decides whether a stack object is empty.: igraph_stack_empty --- Decides whether a stack object is empty_.
@c * igraph_stack_size --- Returns the number of elements in a stack.: igraph_stack_size --- Returns the number of elements in a stack_.
@c * igraph_stack_clear --- Removes all elements from a stack.: igraph_stack_clear --- Removes all elements from a stack_.
@c * igraph_stack_push --- Places an element on the top of a stack.: igraph_stack_push --- Places an element on the top of a stack_.
@c * igraph_stack_pop --- Removes and returns an element from the top of a stack.: igraph_stack_pop --- Removes and returns an element from the top of a stack_.
@c * igraph_stack_top --- Query top element.: igraph_stack_top --- Query top element_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_init --- Initializes a stack_,  Next: igraph_stack_destroy --- Destroys a stack object_,  Up: Stacks

@c 6.5.1 igraph_stack_init -- Initializes a stack.
@c -----------------------------------------------


@c      int igraph_stack_init       (igraph_stack_t* s, long int size);

@c    The initialized stack is always empty.

@c    *Arguments:. *

@c `s':
@c      Pointer to an uninitialized stack.

@c `size':
@c      The number of elements to allocate memory for.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(`size').

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_destroy --- Destroys a stack object_,  Next: igraph_stack_reserve --- Reserve memory_,  Prev: igraph_stack_init --- Initializes a stack_,  Up: Stacks

@c 6.5.2 igraph_stack_destroy -- Destroys a stack object.
@c ------------------------------------------------------


@c      void igraph_stack_destroy    (igraph_stack_t* s);

@c    Deallocate the memory used for a stack.  It is possible to
@c reinitialize a destroyed stack again by `igraph_stack_init()' (*note
@c igraph_stack_init --- Initializes a stack_::).

@c    *Arguments:. *

@c `s':
@c      The stack to destroy.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_reserve --- Reserve memory_,  Next: igraph_stack_empty --- Decides whether a stack object is empty_,  Prev: igraph_stack_destroy --- Destroys a stack object_,  Up: Stacks

@c 6.5.3 igraph_stack_reserve -- Reserve memory.
@c ---------------------------------------------


@c      int igraph_stack_reserve    (igraph_stack_t* s, long int size);

@c    Reverse memory for future use. The actual size of the stack is
@c unchanged.

@c    *Arguments:. *

@c `s':
@c      The stack object.

@c `size':
@c      The number of elements to reserve memory for. If it is not bigger
@c      than the current size then nothing happens.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: should be around O(n), the new allocated size of
@c the stack.

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_empty --- Decides whether a stack object is empty_,  Next: igraph_stack_size --- Returns the number of elements in a stack_,  Prev: igraph_stack_reserve --- Reserve memory_,  Up: Stacks

@c 6.5.4 igraph_stack_empty -- Decides whether a stack object is empty.
@c --------------------------------------------------------------------


@c      igraph_bool_t igraph_stack_empty      (igraph_stack_t* s);

@c    *Arguments:. *

@c `s':
@c      The stack object.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' if the stack is empty, `FALSE' otherwise.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_size --- Returns the number of elements in a stack_,  Next: igraph_stack_clear --- Removes all elements from a stack_,  Prev: igraph_stack_empty --- Decides whether a stack object is empty_,  Up: Stacks

@c 6.5.5 igraph_stack_size -- Returns the number of elements in a stack.
@c ---------------------------------------------------------------------


@c      long int igraph_stack_size       (igraph_stack_t* s);

@c    *Arguments:. *

@c `s':
@c      The stack object.

@c    *Returns:. *

@c `'
@c      The number of elements in the stack.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_clear --- Removes all elements from a stack_,  Next: igraph_stack_push --- Places an element on the top of a stack_,  Prev: igraph_stack_size --- Returns the number of elements in a stack_,  Up: Stacks

@c 6.5.6 igraph_stack_clear -- Removes all elements from a stack.
@c --------------------------------------------------------------


@c      void igraph_stack_clear      (igraph_stack_t* s);

@c    *Arguments:. *

@c `s':
@c      The stack object.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_push --- Places an element on the top of a stack_,  Next: igraph_stack_pop --- Removes and returns an element from the top of a stack_,  Prev: igraph_stack_clear --- Removes all elements from a stack_,  Up: Stacks

@c 6.5.7 igraph_stack_push -- Places an element on the top of a stack.
@c -------------------------------------------------------------------


@c      int igraph_stack_push(igraph_stack_t* s, igraph_real_t elem);

@c    The capacity of the stack is increased, if needed.

@c    *Arguments:. *

@c `s':
@c      The stack object.

@c `elem':
@c      The element to push.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1) is no reallocation is needed, O(n) otherwise,
@c but it is ensured that n push operations are performed in O(n) time.

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_pop --- Removes and returns an element from the top of a stack_,  Next: igraph_stack_top --- Query top element_,  Prev: igraph_stack_push --- Places an element on the top of a stack_,  Up: Stacks

@c 6.5.8 igraph_stack_pop -- Removes and returns an element from the top of a stack.
@c ---------------------------------------------------------------------------------


@c      igraph_real_t igraph_stack_pop        (igraph_stack_t* s);

@c    The stack must contain at least one element, call
@c `igraph_stack_empty()' (*note igraph_stack_empty --- Decides whether a
@c stack object is empty_::) to make sure of this.

@c    *Arguments:. *

@c `s':
@c      The stack object.

@c    *Returns:. *

@c `'
@c      The removed top element.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_stack_top --- Query top element_,  Prev: igraph_stack_pop --- Removes and returns an element from the top of a stack_,  Up: Stacks

@c 6.5.9 igraph_stack_top -- Query top element.
@c --------------------------------------------


@c      igraph_real_t igraph_stack_top        (const igraph_stack_t* s);

@c    Returns the top element of the stack, without removing it.  The
@c stack must be non-empty.

@c    *Arguments:. *

@c `s':
@c      The stack.

@c    *Returns:. *

@c `'
@c      The top element.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Double-ended queues,  Next: Maximum and minimum heaps,  Prev: Stacks,  Up: Data structure library; vector; matrix; other data types

@c 6.6 Double-ended queues
@c =======================

@c * Menu:

@c * igraph_dqueue_init --- Initialize a double ended queue (deque).: igraph_dqueue_init --- Initialize a double ended queue [deque]_.
@c * igraph_dqueue_destroy --- Destroy a double ended queue.: igraph_dqueue_destroy --- Destroy a double ended queue_.
@c * igraph_dqueue_empty --- Decide whether the queue is empty.: igraph_dqueue_empty --- Decide whether the queue is empty_.
@c * igraph_dqueue_full --- Check whether the queue is full.: igraph_dqueue_full --- Check whether the queue is full_.
@c * igraph_dqueue_clear --- Remove all elements from the queue.: igraph_dqueue_clear --- Remove all elements from the queue_.
@c * igraph_dqueue_size --- Number of elements in the queue.: igraph_dqueue_size --- Number of elements in the queue_.
@c * igraph_dqueue_head --- Head of the queue.: igraph_dqueue_head --- Head of the queue_.
@c * igraph_dqueue_back --- Tail of the queue.: igraph_dqueue_back --- Tail of the queue_.
@c * igraph_dqueue_pop --- Remove the head.: igraph_dqueue_pop --- Remove the head_.
@c * igraph_dqueue_pop_back --- Remove the tail::
@c * igraph_dqueue_push --- Appends an element.: igraph_dqueue_push --- Appends an element_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_init --- Initialize a double ended queue [deque]_,  Next: igraph_dqueue_destroy --- Destroy a double ended queue_,  Up: Double-ended queues

@c 6.6.1 igraph_dqueue_init -- Initialize a double ended queue (deque).
@c --------------------------------------------------------------------


@c      int igraph_dqueue_init (igraph_dqueue_t* q, long int size);

@c    The queue will be always empty.

@c    *Arguments:. *

@c `q':
@c      Pointer to an uninitialized deque.

@c `size':
@c      How many elements to allocate memory for.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(`size').

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_destroy --- Destroy a double ended queue_,  Next: igraph_dqueue_empty --- Decide whether the queue is empty_,  Prev: igraph_dqueue_init --- Initialize a double ended queue [deque]_,  Up: Double-ended queues

@c 6.6.2 igraph_dqueue_destroy -- Destroy a double ended queue.
@c ------------------------------------------------------------


@c      void igraph_dqueue_destroy (igraph_dqueue_t* q);

@c    *Arguments:. *

@c `q':
@c      The queue to destroy

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_empty --- Decide whether the queue is empty_,  Next: igraph_dqueue_full --- Check whether the queue is full_,  Prev: igraph_dqueue_destroy --- Destroy a double ended queue_,  Up: Double-ended queues

@c 6.6.3 igraph_dqueue_empty -- Decide whether the queue is empty.
@c ---------------------------------------------------------------


@c      igraph_bool_t igraph_dqueue_empty (igraph_dqueue_t* q);

@c    *Arguments:. *

@c `q':
@c      The queue.

@c    *Returns:. *

@c `'
@c      Boolean, `TRUE' if `q' contains at least one element, `FALSE'
@c      otherwise.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_full --- Check whether the queue is full_,  Next: igraph_dqueue_clear --- Remove all elements from the queue_,  Prev: igraph_dqueue_empty --- Decide whether the queue is empty_,  Up: Double-ended queues

@c 6.6.4 igraph_dqueue_full -- Check whether the queue is full.
@c ------------------------------------------------------------


@c      igraph_bool_t igraph_dqueue_full (igraph_dqueue_t* q);

@c    If a queue is full the next igraph_dqueue_push() operation will
@c allocate more memory.

@c    *Arguments:. *

@c `q':
@c      The queue.

@c    *Returns:. *

@c `'
@c      `TRUE' if `q' is full, `FALSE' otherwise.

@c    Time complecity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_clear --- Remove all elements from the queue_,  Next: igraph_dqueue_size --- Number of elements in the queue_,  Prev: igraph_dqueue_full --- Check whether the queue is full_,  Up: Double-ended queues

@c 6.6.5 igraph_dqueue_clear -- Remove all elements from the queue.
@c ----------------------------------------------------------------


@c      void igraph_dqueue_clear   (igraph_dqueue_t* q);

@c    *Arguments:. *

@c `q':
@c      The queue

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_size --- Number of elements in the queue_,  Next: igraph_dqueue_head --- Head of the queue_,  Prev: igraph_dqueue_clear --- Remove all elements from the queue_,  Up: Double-ended queues

@c 6.6.6 igraph_dqueue_size -- Number of elements in the queue.
@c ------------------------------------------------------------


@c      long int igraph_dqueue_size (igraph_dqueue_t* q);

@c    *Arguments:. *

@c `q':
@c      The queue.

@c    *Returns:. *

@c `'
@c      Integer, the number of elements currently in the queue.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_head --- Head of the queue_,  Next: igraph_dqueue_back --- Tail of the queue_,  Prev: igraph_dqueue_size --- Number of elements in the queue_,  Up: Double-ended queues

@c 6.6.7 igraph_dqueue_head -- Head of the queue.
@c ----------------------------------------------


@c      igraph_real_t igraph_dqueue_head (igraph_dqueue_t* q);

@c    The queue must contain at least one element.

@c    *Arguments:. *

@c `q':
@c      The queue.

@c    *Returns:. *

@c `'
@c      The first element in the queue.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_back --- Tail of the queue_,  Next: igraph_dqueue_pop --- Remove the head_,  Prev: igraph_dqueue_head --- Head of the queue_,  Up: Double-ended queues

@c 6.6.8 igraph_dqueue_back -- Tail of the queue.
@c ----------------------------------------------


@c      igraph_real_t igraph_dqueue_back (igraph_dqueue_t* q);

@c    The queue must contain at least one element.

@c    *Arguments:. *

@c `q':
@c      The queue.

@c    *Returns:. *

@c `'
@c      The last element in the queue.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_pop --- Remove the head_,  Next: igraph_dqueue_pop_back --- Remove the tail,  Prev: igraph_dqueue_back --- Tail of the queue_,  Up: Double-ended queues

@c 6.6.9 igraph_dqueue_pop -- Remove the head.
@c -------------------------------------------


@c      igraph_real_t igraph_dqueue_pop (igraph_dqueue_t* q);

@c    Removes and returns the first element in the queue. The queue must
@c be non-empty.

@c    *Arguments:. *

@c `q':
@c      The input queue.

@c    *Returns:. *

@c `'
@c      The first element in the queue.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_pop_back --- Remove the tail,  Next: igraph_dqueue_push --- Appends an element_,  Prev: igraph_dqueue_pop --- Remove the head_,  Up: Double-ended queues

@c 6.6.10 igraph_dqueue_pop_back -- Remove the tail
@c ------------------------------------------------


@c      igraph_real_t igraph_dqueue_pop_back (igraph_dqueue_t* q);

@c    Removes and returns the last element in the queue. The queue must be
@c non-empty.

@c    *Arguments:. *

@c `q':
@c      The queue.

@c    *Returns:. *

@c `'
@c      The last element in the queue.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_dqueue_push --- Appends an element_,  Prev: igraph_dqueue_pop_back --- Remove the tail,  Up: Double-ended queues

@c 6.6.11 igraph_dqueue_push -- Appends an element.
@c ------------------------------------------------


@c      int igraph_dqueue_push (igraph_dqueue_t* q, igraph_real_t elem);

@c    Append an element to the end of the queue.

@c    *Arguments:. *

@c `q':
@c      The queue.

@c `elem':
@c      The element to append.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1) if no memory allocation is needed, O(n), the
@c number of elements in the queue otherwise. But not that by allocating
@c always twice as much memory as the current size of the queue we ensure
@c that n push operations can always be done in at most O(n) time.
@c (Assuming memory allocation is at most linear.)

@c
@c File: igraph_reference_manual.info,  Node: Maximum and minimum heaps,  Next: String vectors,  Prev: Double-ended queues,  Up: Data structure library; vector; matrix; other data types

@c 6.7 Maximum and minimum heaps
@c =============================

@c * Menu:

@c * igraph_heap_init --- Initializes an empty heap object.: igraph_heap_init --- Initializes an empty heap object_.
@c * igraph_heap_init_array --- Build a heap from an array.: igraph_heap_init_array --- Build a heap from an array_.
@c * igraph_heap_destroy --- Destroys an initialized heap object.: igraph_heap_destroy --- Destroys an initialized heap object_.
@c * igraph_heap_empty --- Decides whether a heap object is empty.: igraph_heap_empty --- Decides whether a heap object is empty_.
@c * igraph_heap_push --- Add an element.: igraph_heap_push --- Add an element_.
@c * igraph_heap_top --- Top element.: igraph_heap_top --- Top element_.
@c * igraph_heap_delete_top --- Return and removes the top element::
@c * igraph_heap_size --- Number of elements::
@c * igraph_heap_reserve --- Allocate more memory::

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_init --- Initializes an empty heap object_,  Next: igraph_heap_init_array --- Build a heap from an array_,  Up: Maximum and minimum heaps

@c 6.7.1 igraph_heap_init -- Initializes an empty heap object.
@c -----------------------------------------------------------


@c      int igraph_heap_init(igraph_heap_t* h, long int alloc_size);

@c    Creates an empty heap, but allocates size for some elements.

@c    *Arguments:. *

@c `h':
@c      Pointer to an uninitialized heap object.

@c `alloc_size':
@c      Number of elements to allocate memory for.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(`alloc_size'), assuming memory allocation is a
@c linear operation.

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_init_array --- Build a heap from an array_,  Next: igraph_heap_destroy --- Destroys an initialized heap object_,  Prev: igraph_heap_init --- Initializes an empty heap object_,  Up: Maximum and minimum heaps

@c 6.7.2 igraph_heap_init_array -- Build a heap from an array.
@c -----------------------------------------------------------


@c      int igraph_heap_init_array(igraph_heap_t *h, igraph_real_t* data, long int len);

@c    Initializes a heap object from an array, the heap is also built of
@c course (constructor).

@c    *Arguments:. *

@c `h':
@c      Pointer to an uninitialized heap object.

@c `data':
@c      Pointer to an array of base data type.

@c `len':
@c      The length of the array at `data'.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of elements in the heap.

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_destroy --- Destroys an initialized heap object_,  Next: igraph_heap_empty --- Decides whether a heap object is empty_,  Prev: igraph_heap_init_array --- Build a heap from an array_,  Up: Maximum and minimum heaps

@c 6.7.3 igraph_heap_destroy -- Destroys an initialized heap object.
@c -----------------------------------------------------------------


@c      void igraph_heap_destroy(igraph_heap_t* h);

@c    *Arguments:. *

@c `h':
@c      The heap object.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_empty --- Decides whether a heap object is empty_,  Next: igraph_heap_push --- Add an element_,  Prev: igraph_heap_destroy --- Destroys an initialized heap object_,  Up: Maximum and minimum heaps

@c 6.7.4 igraph_heap_empty -- Decides whether a heap object is empty.
@c ------------------------------------------------------------------


@c      igraph_bool_t igraph_heap_empty(igraph_heap_t* h);

@c    *Arguments:. *

@c `h':
@c      The heap object.

@c    *Returns:. *

@c `'
@c      `TRUE' if the heap is empty, `FALSE' otherwise.

@c    TIme complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_push --- Add an element_,  Next: igraph_heap_top --- Top element_,  Prev: igraph_heap_empty --- Decides whether a heap object is empty_,  Up: Maximum and minimum heaps

@c 6.7.5 igraph_heap_push -- Add an element.
@c -----------------------------------------


@c      int igraph_heap_push(igraph_heap_t* h, igraph_real_t elem);

@c    Adds an element to the heap.

@c    *Arguments:. *

@c `h':
@c      The heap object.

@c `elem':
@c      The element to add.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(log n), n is the number of elements in the heap
@c if no reallocation is needed, O(n) otherwise. It is ensured that n push
@c operations are performed in O(n log n) time.

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_top --- Top element_,  Next: igraph_heap_delete_top --- Return and removes the top element,  Prev: igraph_heap_push --- Add an element_,  Up: Maximum and minimum heaps

@c 6.7.6 igraph_heap_top -- Top element.
@c -------------------------------------


@c      igraph_real_t igraph_heap_top(igraph_heap_t* h);

@c    For maximum heaps this is the largest, for minimum heaps the
@c smallest element of the heap.

@c    *Arguments:. *

@c `h':
@c      The heap object.

@c    *Returns:. *

@c `'
@c      The top element.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_delete_top --- Return and removes the top element,  Next: igraph_heap_size --- Number of elements,  Prev: igraph_heap_top --- Top element_,  Up: Maximum and minimum heaps

@c 6.7.7 igraph_heap_delete_top -- Return and removes the top element
@c ------------------------------------------------------------------


@c      igraph_real_t igraph_heap_delete_top(igraph_heap_t* h);

@c    Removes and returns the top element of the heap. For maximum heaps
@c this is the largest, for minimum heaps the smallest element.

@c    *Arguments:. *

@c `h':
@c      The heap object.

@c    *Returns:. *

@c `'
@c      The top element.

@c    Time complexity: O(log n), n is the number of elements in the heap.

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_size --- Number of elements,  Next: igraph_heap_reserve --- Allocate more memory,  Prev: igraph_heap_delete_top --- Return and removes the top element,  Up: Maximum and minimum heaps

@c 6.7.8 igraph_heap_size -- Number of elements
@c --------------------------------------------


@c      long int igraph_heap_size(igraph_heap_t* h);

@c    Gives the number of elements in a heap.

@c    *Arguments:. *

@c `h':
@c      The heap object.

@c    *Returns:. *

@c `'
@c      The number of elements in the heap.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_heap_reserve --- Allocate more memory,  Prev: igraph_heap_size --- Number of elements,  Up: Maximum and minimum heaps

@c 6.7.9 igraph_heap_reserve -- Allocate more memory
@c -------------------------------------------------


@c      int igraph_heap_reserve(igraph_heap_t* h, long int size);

@c    Allocates memory for future use. The size of the heap is unchanged.
@c If the heap is larger than the `size' parameter then nothing happens.

@c    *Arguments:. *

@c `h':
@c      The heap object.

@c `size':
@c      The number of elements to allocate memory for.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(`size') if `size' is larger than the current
@c number of elements. O(1) otherwise.

@c
@c File: igraph_reference_manual.info,  Node: String vectors,  Next: Adjacency lists,  Prev: Maximum and minimum heaps,  Up: Data structure library; vector; matrix; other data types

@c 6.8 String vectors
@c ==================

@c The `igraph_strvector_t' type is a vector of strings.  The current
@c implementation is very simple and not too efficient. It works fine for
@c not too many strings, e.g. the list of attribute names is returned in a
@c string vector by `igraph_cattribute_list()' (*note
@c igraph_cattribute_list --- List all attributes::). Do not expect great
@c performace from this type.

@c * Menu:

@c * igraph_strvector_init --- Initialize::
@c * igraph_strvector_copy --- Initialization by copying.: igraph_strvector_copy --- Initialization by copying_.
@c * igraph_strvector_destroy --- Free allocated memory::
@c * STR --- Indexing string vectors::
@c * igraph_strvector_get --- Indexing::
@c * igraph_strvector_set --- Set an element::
@c * igraph_strvector_set2 --- Sets an element::
@c * igraph_strvector_remove --- Removes a single element from a string vector.: igraph_strvector_remove --- Removes a single element from a string vector_.
@c * igraph_strvector_append --- Concatenate two string vectors.: igraph_strvector_append --- Concatenate two string vectors_.
@c * igraph_strvector_clear --- Remove all elements::
@c * igraph_strvector_resize --- Resize::
@c * igraph_strvector_size --- Gives the size of a string vector.: igraph_strvector_size --- Gives the size of a string vector_.
@c * igraph_strvector_add --- Adds an element to the back of a string vector.: igraph_strvector_add --- Adds an element to the back of a string vector_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_init --- Initialize,  Next: igraph_strvector_copy --- Initialization by copying_,  Up: String vectors

@c 6.8.1 igraph_strvector_init -- Initialize
@c -----------------------------------------


@c      int igraph_strvector_init(igraph_strvector_t *sv, long int len);

@c    Reserves memory for the string vector, a string vector must be first
@c initialized before calling other functions on it.  All elements of the
@c string vector are set to the empty string.

@c    *Arguments:. *

@c `sv':
@c      Pointer to an initialized string vector.

@c `len':
@c      The (initial) length of the string vector.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(`len').

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_copy --- Initialization by copying_,  Next: igraph_strvector_destroy --- Free allocated memory,  Prev: igraph_strvector_init --- Initialize,  Up: String vectors

@c 6.8.2 igraph_strvector_copy -- Initialization by copying.
@c ---------------------------------------------------------


@c      int igraph_strvector_copy(igraph_strvector_t *to,
@c      			  const igraph_strvector_t *from);

@c    Initializes a string vector by copying another string vector.

@c    *Arguments:. *

@c `to':
@c      Pointer to an uninitialized string vector.

@c `from':
@c      The other string vector, to be copied.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(l), the total length of the strings in `from'.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_destroy --- Free allocated memory,  Next: STR --- Indexing string vectors,  Prev: igraph_strvector_copy --- Initialization by copying_,  Up: String vectors

@c 6.8.3 igraph_strvector_destroy -- Free allocated memory
@c -------------------------------------------------------


@c      void igraph_strvector_destroy(igraph_strvector_t *sv);

@c    Destroy a string vector. It may be reinitialized with
@c `igraph_strvector_init()' (*note igraph_strvector_init ---
@c Initialize::) later.

@c    *Arguments:. *

@c `sv':
@c      The string vector.

@c    Time complexity: O(l), the total length of the strings, maybe less
@c depending on the memory manager.

@c
@c File: igraph_reference_manual.info,  Node: STR --- Indexing string vectors,  Next: igraph_strvector_get --- Indexing,  Prev: igraph_strvector_destroy --- Free allocated memory,  Up: String vectors

@c 6.8.4 STR -- Indexing string vectors
@c ------------------------------------


@c      #define STR(sv,i)

@c    This is a macro which allows to query the elements of a string
@c vector in simpler way than `igraph_strvector_get()' (*note
@c igraph_strvector_get --- Indexing::). Note this macro cannot be used to
@c set an element, for that use `igraph_strvector_set()' (*note
@c igraph_strvector_set --- Set an element::).

@c    *Arguments:. *

@c `sv':
@c      The string vector

@c `i':
@c      The the index of the element.

@c    *Returns:. *

@c `'
@c      The element at position `i'.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_get --- Indexing,  Next: igraph_strvector_set --- Set an element,  Prev: STR --- Indexing string vectors,  Up: String vectors

@c 6.8.5 igraph_strvector_get -- Indexing
@c --------------------------------------


@c      void igraph_strvector_get(const igraph_strvector_t *sv, long int idx,
@c      			  char **value);

@c    Query an element of a string vector. See also the `STR' (*note STR
@c --- Indexing string vectors::) macro for an easier way.

@c    *Arguments:. *

@c `sv':
@c      The input string vector.

@c `idx':
@c      The index of the element to query.

@c `Pointer':
@c      to a `char*', the address of the string is stored here.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_set --- Set an element,  Next: igraph_strvector_set2 --- Sets an element,  Prev: igraph_strvector_get --- Indexing,  Up: String vectors

@c 6.8.6 igraph_strvector_set -- Set an element
@c --------------------------------------------


@c      int igraph_strvector_set(igraph_strvector_t *sv, long int idx,
@c      			 const char *value);

@c    The provided `value' is copied into the `idx' position in the string
@c vector.

@c    *Arguments:. *

@c `sv':
@c      The string vector.

@c `idx':
@c      The position to set.

@c `value':
@c      The new value.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(l), the length of the new string. Maybe more,
@c depending on the memory management, if reallocation is needed.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_set2 --- Sets an element,  Next: igraph_strvector_remove --- Removes a single element from a string vector_,  Prev: igraph_strvector_set --- Set an element,  Up: String vectors

@c 6.8.7 igraph_strvector_set2 -- Sets an element
@c ----------------------------------------------


@c      int igraph_strvector_set2(igraph_strvector_t *sv, long int idx,
@c      			  const char *value, int len);

@c    This is almost the same as `igraph_strvector_set' (*note
@c igraph_strvector_set --- Set an element::), but the new value is not a
@c zero terminated string, but its length is given.

@c    *Arguments:. *

@c `sv':
@c      The string vector.

@c `idx':
@c      The position to set.

@c `value':
@c      The new value.

@c `len':
@c      The length of the new value.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(l), the length of the new string. Maybe more,
@c depending on the memory management, if reallocation is needed.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_remove --- Removes a single element from a string vector_,  Next: igraph_strvector_append --- Concatenate two string vectors_,  Prev: igraph_strvector_set2 --- Sets an element,  Up: String vectors

@c 6.8.8 igraph_strvector_remove -- Removes a single element from a string vector.
@c -------------------------------------------------------------------------------


@c      void igraph_strvector_remove(igraph_strvector_t *v, long int elem);

@c    The string will be one shorter.

@c    *Arguments:. *

@c `The':
@c      string vector.

@c `elem':
@c      The index of the element to remove.

@c    Time complexity: O(n), the length of the string.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_append --- Concatenate two string vectors_,  Next: igraph_strvector_clear --- Remove all elements,  Prev: igraph_strvector_remove --- Removes a single element from a string vector_,  Up: String vectors

@c 6.8.9 igraph_strvector_append -- Concatenate two string vectors.
@c ----------------------------------------------------------------


@c      int igraph_strvector_append(igraph_strvector_t *to,
@c      			    const igraph_strvector_t *from);

@c    *Arguments:. *

@c `to':
@c      The first string vector, the result is stored here.

@c `from':
@c      The second string vector, it is kep unchanged.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n+l2), n is the number of strings in the new
@c string vector, l2 is the total length of strings in the `from' string
@c vector.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_clear --- Remove all elements,  Next: igraph_strvector_resize --- Resize,  Prev: igraph_strvector_append --- Concatenate two string vectors_,  Up: String vectors

@c 6.8.10 igraph_strvector_clear -- Remove all elements
@c ----------------------------------------------------


@c      void igraph_strvector_clear(igraph_strvector_t *sv);

@c    After this operation the string vector will be empty.

@c    *Arguments:. *

@c `sv':
@c      The string vector.

@c    Time complexity: O(l), the total length of strings, maybe less,
@c depending on the memory manager.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_resize --- Resize,  Next: igraph_strvector_size --- Gives the size of a string vector_,  Prev: igraph_strvector_clear --- Remove all elements,  Up: String vectors

@c 6.8.11 igraph_strvector_resize -- Resize
@c ----------------------------------------


@c      int igraph_strvector_resize(igraph_strvector_t* v, long int newsize);

@c    If the new size is bigger then empty strings are added, if it is
@c smaller then the unneeded elements are removed.

@c    *Arguments:. *

@c `v':
@c      The string vector.

@c `newsize':
@c      The new size.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of strings if the vector is made
@c bigger, O(l), the total length of the deleted strings if it is made
@c smaller, maybe less, depending on memory management.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_size --- Gives the size of a string vector_,  Next: igraph_strvector_add --- Adds an element to the back of a string vector_,  Prev: igraph_strvector_resize --- Resize,  Up: String vectors

@c 6.8.12 igraph_strvector_size -- Gives the size of a string vector.
@c ------------------------------------------------------------------


@c      long int igraph_strvector_size(const igraph_strvector_t *sv);

@c    *Arguments:. *

@c `sv':
@c      The string vector.

@c    *Returns:. *

@c `'
@c      The length of the string vector.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_strvector_add --- Adds an element to the back of a string vector_,  Prev: igraph_strvector_size --- Gives the size of a string vector_,  Up: String vectors

@c 6.8.13 igraph_strvector_add -- Adds an element to the back of a string vector.
@c ------------------------------------------------------------------------------


@c      int igraph_strvector_add(igraph_strvector_t *v, const char *value);

@c    *Arguments:. *

@c `v':
@c      The string vector.

@c `value':
@c      The string to add, it will be copied.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n+l), n is the total number of strings, l is the
@c length of the new string.

@c
@c File: igraph_reference_manual.info,  Node: Adjacency lists,  Prev: String vectors,  Up: Data structure library; vector; matrix; other data types

@c 6.9 Adjacency lists
@c ===================

@c Sometimes it is easier to work with a graph which is in adjacency list
@c format: a list of vectors; each vector contains the neighbor vertices
@c or adjacent edges of a given vertex. Typically, this representation is
@c good if we need to iterate over the neigbors of all vertices many
@c times. E.g. when finding the shortest paths between every pairs of
@c vertices or calculating closeness centrality for all the vertices.

@c    The `igraph_adjlist_t' stores the adjacency lists of a graph. After
@c creation it is independent of the original graph, it can be modified
@c freely with the usual vector operations, the graph is not affected.
@c E.g. the adjacency list can be used to rewire the edges of a graph
@c efficiently. If one used the straightforward `igraph_delete_edges()'
@c (*note igraph_delete_edges --- Removes edges from a graph_::) and
@c `igraph_add_edges()' (*note igraph_add_edges --- Adds edges to a graph
@c object_::) combination for this that needs O(|V|+|E|) time for every
@c single deletion and insertion operation, it is thus very slow if many
@c edges are rewired. Extracting the graph into an adjacency list, do all
@c the rewiring operations on the vectors of the adjacency list and then
@c creating a new graph needs (depending on how exactly the rewiring is
@c done) typically O(|V|+|E|) time for the whole rewiring process.

@c    Lazy adjacency lists are a bit different. When creating a lazy
@c adjacency list, the neighbors of the vertices are not queried, only
@c some memory is allocated for the vectors. When
@c `igraph_lazy_adjlist_get()' (*note igraph_lazy_adjlist_get --- Query
@c neighbor vertices::) is called for vertex v the first time, the
@c neighbors of v are queried and stored in a vector of the adjacency
@c list, so they don't need to be queried again. Lazy adjacency lists are
@c handy if you have an at least linear operation (because initialization
@c is generally linear in terms of number of vertices), but you don't know
@c how many vertices you will visit during the computation.

@c * Menu:

@c * Adjacent vertices::
@c * Adjacent edges::
@c * Lazy adjacency list for vertices::
@c * Lazy adjacency list for edges::

@c
@c File: igraph_reference_manual.info,  Node: Adjacent vertices,  Next: Adjacent edges,  Up: Adjacency lists

@c 6.9.1 Adjacent vertices
@c -----------------------

@c * Menu:

@c * igraph_adjlist_init --- Initialize an adjacency list of vertices::
@c * igraph_adjlist_init_complementer --- Adjacency lists for the complementer graph::
@c * igraph_adjlist_destroy --- Deallocate memory::
@c * igraph_adjlist_get --- Query a vector in an adjlist::
@c * igraph_adjlist_sort --- Sort each vector in an adjacency list.: igraph_adjlist_sort --- Sort each vector in an adjacency list_.
@c * igraph_adjlist_simplify --- Simplify::

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjlist_init --- Initialize an adjacency list of vertices,  Next: igraph_adjlist_init_complementer --- Adjacency lists for the complementer graph,  Up: Adjacent vertices

@c 6.9.1.1 igraph_adjlist_init -- Initialize an adjacency list of vertices
@c .......................................................................


@c      int igraph_adjlist_init(const igraph_t *graph, igraph_adjlist_t *al,
@c      			  igraph_neimode_t mode);

@c    Create a list of vectors containing the neighbors of all vertices in
@c a graph. The adjacency list is independent of the graph after creation,
@c e.g. the graph can be destroyed and modified, the adjacency list
@c contains the state of the graph at the time of its initialization.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `al':
@c      Pointer to an uninitialized `igraph_adjlist_t' object.

@c `mode':
@c      Constant specifying whether outgoing (` IGRAPH_OUT' ), incoming (`
@c      IGRAPH_IN' ), or both (` IGRAPH_ALL' ) types of neighbors to
@c      include in the adjacency list. It is ignored for undirected
@c      networks.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjlist_init_complementer --- Adjacency lists for the complementer graph,  Next: igraph_adjlist_destroy --- Deallocate memory,  Prev: igraph_adjlist_init --- Initialize an adjacency list of vertices,  Up: Adjacent vertices

@c 6.9.1.2 igraph_adjlist_init_complementer -- Adjacency lists for the complementer graph
@c ......................................................................................


@c      int igraph_adjlist_init_complementer(const igraph_t *graph,
@c      				       igraph_adjlist_t *al,
@c      				       igraph_neimode_t mode,
@c      				       igraph_bool_t loops);

@c    This function creates adjacency lists for the complementer of the
@c input graph. In the complementer graph all edges are present which are
@c not present in the original graph. Multiple edges in the input graph
@c are ignored.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `al':
@c      Pointer to a not yet initialized adjacency list.

@c `mode':
@c      Constant specifying whether outgoing (` IGRAPH_OUT' ), incoming (`
@c      IGRAPH_IN' ), or both (` IGRAPH_ALL' ) types of neighbors (in the
@c      complementer graph) to include in the adjacency list. It is
@c      ignored for undirected networks.

@c `loops':
@c      Whether to consider loop edges.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^2+|E|), quadratic in the number of vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjlist_destroy --- Deallocate memory,  Next: igraph_adjlist_get --- Query a vector in an adjlist,  Prev: igraph_adjlist_init_complementer --- Adjacency lists for the complementer graph,  Up: Adjacent vertices

@c 6.9.1.3 igraph_adjlist_destroy -- Deallocate memory
@c ...................................................


@c      void igraph_adjlist_destroy(igraph_adjlist_t *al);

@c    Free all memory allocated for an adjacency list.

@c    *Arguments:. *

@c `al':
@c      The adjacency list to destroy.

@c    Time complexity: depends on memory management.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjlist_get --- Query a vector in an adjlist,  Next: igraph_adjlist_sort --- Sort each vector in an adjacency list_,  Prev: igraph_adjlist_destroy --- Deallocate memory,  Up: Adjacent vertices

@c 6.9.1.4 igraph_adjlist_get -- Query a vector in an adjlist
@c ..........................................................


@c      #define igraph_adjlist_get(al,no)

@c    Returns a pointer to an `igraph_vector_t' object from an adjacency
@c list. The vector can be modified as desired.

@c    *Arguments:. *

@c `al':
@c      The adjacency list object.

@c `no':
@c      The vertex of which the vertex of adjacent vertices are returned.

@c    *Returns:. *

@c `'
@c      Pointer to the `igraph_vector_t' object.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjlist_sort --- Sort each vector in an adjacency list_,  Next: igraph_adjlist_simplify --- Simplify,  Prev: igraph_adjlist_get --- Query a vector in an adjlist,  Up: Adjacent vertices

@c 6.9.1.5 igraph_adjlist_sort -- Sort each vector in an adjacency list.
@c .....................................................................


@c      void igraph_adjlist_sort(igraph_adjlist_t *al);

@c    Sorts every vector of the adjacency list.

@c    *Arguments:. *

@c `al':
@c      The adjacency list.

@c    Time complexity: O(n log n), n is the total number of elements in
@c the adjacency list.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjlist_simplify --- Simplify,  Prev: igraph_adjlist_sort --- Sort each vector in an adjacency list_,  Up: Adjacent vertices

@c 6.9.1.6 igraph_adjlist_simplify -- Simplify
@c ...........................................


@c      int igraph_adjlist_simplify(igraph_adjlist_t *al);

@c    Simplify an adjacency list, ie. remove loop and multiple edges.

@c    *Arguments:. *

@c `al':
@c      The adjacency list.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of edges and
@c vertices.

@c
@c File: igraph_reference_manual.info,  Node: Adjacent edges,  Next: Lazy adjacency list for vertices,  Prev: Adjacent vertices,  Up: Adjacency lists

@c 6.9.2 Adjacent edges
@c --------------------

@c * Menu:

@c * igraph_adjedgelist_init --- Initialize an adjacency list of edges::
@c * igraph_adjedgelist_destroy --- Destroy::
@c * igraph_adjedgelist_get --- Query a vector in an adjedgelist::

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjedgelist_init --- Initialize an adjacency list of edges,  Next: igraph_adjedgelist_destroy --- Destroy,  Up: Adjacent edges

@c 6.9.2.1 igraph_adjedgelist_init -- Initialize an adjacency list of edges
@c ........................................................................


@c      int igraph_adjedgelist_init(const igraph_t *graph,
@c      			      igraph_adjedgelist_t *ael,
@c      			      igraph_neimode_t mode);

@c    Create a list of vectors containing the adjacent edges for all
@c vertices. The adjacency list is independent of the graph after
@c creation, subsequent changes of the graph object do not update the
@c adjacency list, and changes to the adjacency list do no update the
@c graph.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `ael':
@c      Pointer to an uninitialized adjcency list.

@c `mode':
@c      Constant specifying whether incoming edges (` IGRAPH_IN' ),
@c      outgoing edges (` IGRAPH_OUT' ) or both (` IGRAPH_ALL' ) to
@c      include in the adjacency lists of directed graphs. It is ignored
@c      for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjedgelist_destroy --- Destroy,  Next: igraph_adjedgelist_get --- Query a vector in an adjedgelist,  Prev: igraph_adjedgelist_init --- Initialize an adjacency list of edges,  Up: Adjacent edges

@c 6.9.2.2 igraph_adjedgelist_destroy -- Destroy
@c .............................................


@c      void igraph_adjedgelist_destroy(igraph_adjedgelist_t *ael);

@c    Free all memory allocated for an adjacency list.

@c    *Arguments:. *

@c `eal':
@c      The adjcency list to destroy.

@c    Time complexity: depends on memory management.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjedgelist_get --- Query a vector in an adjedgelist,  Prev: igraph_adjedgelist_destroy --- Destroy,  Up: Adjacent edges

@c 6.9.2.3 igraph_adjedgelist_get -- Query a vector in an adjedgelist
@c ..................................................................


@c      #define igraph_adjedgelist_get(ael,no)

@c    Returns a pointer to an `igraph_vector_t' object from an adjacency
@c list containing edge ids. The vector can be modified, resized, etc. as
@c desired.

@c    *Arguments:. *

@c `graph':
@c      ael The edge adjacency list.

@c `no':
@c      The vertex of which the adjacent edges are returned.

@c    *Returns:. *

@c `'
@c      Pointer to an `igraph_vector_t' object.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Lazy adjacency list for vertices,  Next: Lazy adjacency list for edges,  Prev: Adjacent edges,  Up: Adjacency lists

@c 6.9.3 Lazy adjacency list for vertices
@c --------------------------------------

@c * Menu:

@c * igraph_lazy_adjlist_init --- Constructor::
@c * igraph_lazy_adjlist_destroy --- Deallocate memory::
@c * igraph_lazy_adjlist_get --- Query neighbor vertices::

@c
@c File: igraph_reference_manual.info,  Node: igraph_lazy_adjlist_init --- Constructor,  Next: igraph_lazy_adjlist_destroy --- Deallocate memory,  Up: Lazy adjacency list for vertices

@c 6.9.3.1 igraph_lazy_adjlist_init -- Constructor
@c ...............................................


@c      int igraph_lazy_adjlist_init(const igraph_t *graph,
@c      			       igraph_lazy_adjlist_t *al,
@c      			       igraph_neimode_t mode,
@c      			       igraph_lazy_adlist_simplify_t simplify);

@c    Create a lazy adjacency list for vertices. This function only
@c allocates some memory for storing the vectors of an adjacency list, but
@c the neighbor vertices are not queried, only at the
@c `igraph_lazy_adjlist_get()' (*note igraph_lazy_adjlist_get --- Query
@c neighbor vertices::) calls.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `al':
@c      Pointer to an uninitialized adjacency list object.

@c `mode':
@c      Constant, it gives whether incoming edges (` IGRAPH_IN' ),
@c      outgoing edges (` IGRPAH_OUT' ) or both types of edges (`
@c      IGRAPH_ALL' ) are considered. It is ignored for undirected graphs.

@c `simplify':
@c      Constant, it gives whether to simplify the vectors in the
@c      adjacency list (` IGRAPH_SIMPLIFY' ) ot not (`
@c      IGRAPH_DONT_SIMPLIFY' ).

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|), the number of vertices, possibly, but
@c depends on the underlying memory management too.

@c
@c File: igraph_reference_manual.info,  Node: igraph_lazy_adjlist_destroy --- Deallocate memory,  Next: igraph_lazy_adjlist_get --- Query neighbor vertices,  Prev: igraph_lazy_adjlist_init --- Constructor,  Up: Lazy adjacency list for vertices

@c 6.9.3.2 igraph_lazy_adjlist_destroy -- Deallocate memory
@c ........................................................


@c      void igraph_lazy_adjlist_destroy(igraph_lazy_adjlist_t *al);

@c    Free all allocated memory for a lazy adjacency list.

@c    *Arguments:. *

@c `al':
@c      The adjacency list to deallocate.

@c    Time complexity: depends on the memory management.

@c
@c File: igraph_reference_manual.info,  Node: igraph_lazy_adjlist_get --- Query neighbor vertices,  Prev: igraph_lazy_adjlist_destroy --- Deallocate memory,  Up: Lazy adjacency list for vertices

@c 6.9.3.3 igraph_lazy_adjlist_get -- Query neighbor vertices
@c ..........................................................


@c      #define igraph_lazy_adjlist_get(al,no)

@c    If the function is called for the first time for a vertex then the
@c result is stored in the adjacency list and no further query operations
@c are needed when the neighbors of the same vertex are queried again.

@c    *Arguments:. *

@c `al':
@c      The lazy adjacency list.

@c `no':
@c      The vertex id to query.

@c    *Returns:. *

@c `'
@c      Pointer to a vector. It is allowed to modify it and modification
@c      does not affect the original graph.

@c    Time complexity: O(d), the number of neighbor vertices for the first
@c time, O(1) for subsequent calls.

@c
@c File: igraph_reference_manual.info,  Node: Lazy adjacency list for edges,  Prev: Lazy adjacency list for vertices,  Up: Adjacency lists

@c 6.9.4 Lazy adjacency list for edges
@c -----------------------------------

@c * Menu:

@c * igraph_lazy_adjedgelist_init --- Constructor::
@c * igraph_lazy_adjedgelist_destroy --- Deallocate memory::
@c * igraph_lazy_adjedgelist_get --- Query adjacent edges::

@c
@c File: igraph_reference_manual.info,  Node: igraph_lazy_adjedgelist_init --- Constructor,  Next: igraph_lazy_adjedgelist_destroy --- Deallocate memory,  Up: Lazy adjacency list for edges

@c 6.9.4.1 igraph_lazy_adjedgelist_init -- Constructor
@c ...................................................


@c      int igraph_lazy_adjedgelist_init(const igraph_t *graph,
@c      				   igraph_lazy_adjedgelist_t *al,
@c      				   igraph_neimode_t mode);

@c    Create a lazy adjacency list for edges. This function only allocates
@c some memory for storing the vectors of an adjacency list, but the
@c adjacent edges are not queried, only when
@c `igraph_lazy_adjedgelist_get()' (*note igraph_lazy_adjedgelist_get ---
@c Query adjacent edges::) is called.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `al':
@c      Pointer to an uninitialized adjacency list.

@c `mode':
@c      Constant, it gives whether incoming edges (` IGRAPH_IN' ),
@c      outgoing edges (` IGRPAH_OUT' ) or both types of edges (`
@c      IGRAPH_ALL' ) are considered. It is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|), the number of vertices, possibly. But it
@c also depends on the underlying memory management too.

@c
@c File: igraph_reference_manual.info,  Node: igraph_lazy_adjedgelist_destroy --- Deallocate memory,  Next: igraph_lazy_adjedgelist_get --- Query adjacent edges,  Prev: igraph_lazy_adjedgelist_init --- Constructor,  Up: Lazy adjacency list for edges

@c 6.9.4.2 igraph_lazy_adjedgelist_destroy -- Deallocate memory
@c ............................................................


@c      void igraph_lazy_adjedgelist_destroy(igraph_lazy_adjedgelist_t *al);

@c    Free all allocated memory for a lazy edge adjacency list.

@c    *Arguments:. *

@c `al':
@c      The adjacency list to deallocate.

@c    Time complexity: depends on memory management.

@c
@c File: igraph_reference_manual.info,  Node: igraph_lazy_adjedgelist_get --- Query adjacent edges,  Prev: igraph_lazy_adjedgelist_destroy --- Deallocate memory,  Up: Lazy adjacency list for edges

@c 6.9.4.3 igraph_lazy_adjedgelist_get -- Query adjacent edges
@c ...........................................................


@c      #define igraph_lazy_adjedgelist_get(al,no)

@c    If the function is called for the first time for a vertex, then the
@c result is stored in the adjacency list and no further query operations
@c are needed when the adjacent edges of the same vertex are queried again.

@c    *Arguments:. *

@c `al':
@c      The lazy adjacency list object.

@c `no':
@c      The vertex id to query.

@c    *Returns:. *

@c `'
@c      Pointer to a vector. It is allowed to modify it and modification
@c      does not affect the original graph.

@c    Time complexity: O(d), the number of adjacent edges for the first
@c time, O(1) for subsequent calls with the same `no' argument.

@c
@c File: igraph_reference_manual.info,  Node: Graph Generators,  Next: Vertex and Edge Selectors and Sequences; Iterators,  Prev: Data structure library; vector; matrix; other data types,  Up: Top

@c 7 Graph Generators
@c ******************

@c Graph generators create graphs.

@c    Almost all functions which create graph objects are documented here.
@c The exceptions are `igraph_subgraph()' (*note igraph_subgraph ---
@c Creates a subgraph with the specified vertices_::) and alike, these
@c create graphs based on another graph.

@c * Menu:

@c * Deterministic Graph Generators::
@c * Games; Randomized Graph Generators::

@c
@c File: igraph_reference_manual.info,  Node: Deterministic Graph Generators,  Next: Games; Randomized Graph Generators,  Up: Graph Generators

@c 7.1 Deterministic Graph Generators
@c ==================================

@c * Menu:

@c * igraph_create --- Creates a graph with the specified edges.: igraph_create --- Creates a graph with the specified edges_.
@c * igraph_small --- Shortand to create a short graph, giving the edges as agruments: igraph_small --- Shortand to create a short graph; giving the edges as agruments.
@c * igraph_adjacency --- Creates a graph object from an adjacency matrix.: igraph_adjacency --- Creates a graph object from an adjacency matrix_.
@c * igraph_weighted_adjacency --- Creates a graph object from a weighted adjacency matrix.: igraph_weighted_adjacency --- Creates a graph object from a weighted adjacency matrix_.
@c * igraph_adjlist --- Create a graph from an adjacency list::
@c * igraph_star --- Creates a star graph, every vertex connects only to the center.: igraph_star --- Creates a star graph; every vertex connects only to the center_.
@c * igraph_lattice --- Creates most kind of lattices.: igraph_lattice --- Creates most kind of lattices_.
@c * igraph_ring --- Creates a ring graph, a one dimensional lattice.: igraph_ring --- Creates a ring graph; a one dimensional lattice_.
@c * igraph_tree --- Creates a tree in which almost all vertices have the same number of children.: igraph_tree --- Creates a tree in which almost all vertices have the same number of children_.
@c * igraph_full --- Creates a full graph (directed or undirected, with or without loops). : igraph_full --- Creates a full graph [directed or undirected; with or without loops]_.
@c * igraph_full_citation --- Creates a full citation graph::
@c * igraph_famous --- Create a famous graph by simply providing its name::
@c * igraph_lcf --- Create a graph from LCF notation::
@c * igraph_lcf_vector --- Create a graph from LCF notation::
@c * igraph_atlas --- Create a small graph from the Graph Atlas.: igraph_atlas --- Create a small graph from the Graph Atlas_.
@c * igraph_de_bruijn --- Generate a de Bruijn graph.: igraph_de_bruijn --- Generate a de Bruijn graph_.
@c * igraph_kautz --- Generate a Kautz graph.: igraph_kautz --- Generate a Kautz graph_.
@c * igraph_extended_chordal_ring --- Create an extended chordal ring::
@c * igraph_connect_neighborhood --- Connects every vertex to its neighborhood::

@c
@c File: igraph_reference_manual.info,  Node: igraph_create --- Creates a graph with the specified edges_,  Next: igraph_small --- Shortand to create a short graph; giving the edges as agruments,  Up: Deterministic Graph Generators

@c 7.1.1 igraph_create -- Creates a graph with the specified edges.
@c ----------------------------------------------------------------


@c      int igraph_create(igraph_t *graph, const igraph_vector_t *edges, igraph_integer_t n,
@c      		  igraph_bool_t directed);

@c    *Arguments:. *

@c `graph':
@c      An uninitialized graph object.

@c `edges':
@c      The edges to add, the first two elements are the first edge, etc.

@c `n':
@c      The number of vertices in the graph, if smaller or equal to the
@c      highest vertex id in the `edges' vector it will be increased
@c      automatically. So it is safe to give 0 here.

@c `directed':
@c      Boolean, whether to create a directed graph or not. If yes, then
@c      the first edge points from the first vertex id in `edges' to the
@c      second, etc.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVEVECTOR': invalid edges vector (odd number
@c      of vertices).  `IGRAPH_EINVVID': invalid (negative) vertex id.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| the
@c number of edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_small --- Shortand to create a short graph; giving the edges as agruments,  Next: igraph_adjacency --- Creates a graph object from an adjacency matrix_,  Prev: igraph_create --- Creates a graph with the specified edges_,  Up: Deterministic Graph Generators

@c 7.1.2 igraph_small -- Shortand to create a short graph, giving the edges as agruments
@c -------------------------------------------------------------------------------------


@c      int igraph_small(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed,
@c      		 ...);

@c    This function is handy when a relatively small graph needs to be
@c created.  Instead giving the edges in vector, they are given simply as
@c arguments and a '-1' needs to be given after the last meaningful edge
@c argument.

@c    Note that only graphs which have vertices less than the highest
@c value of the 'int' type can be created this way. If you give larger
@c values then the result is undefined.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object, the result will be
@c      stored here.

@c `n':
@c      The number of vertices in the graph, an integer.

@c `directed':
@c      Logical constant, gives whether the graph should be directed.

@c `...':
@c      The additional arguments giving the edges of the graph. Don't
@c      forget to supply an additional '-1' after the last (meaningful)
@c      argument.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph to create.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjacency --- Creates a graph object from an adjacency matrix_,  Next: igraph_weighted_adjacency --- Creates a graph object from a weighted adjacency matrix_,  Prev: igraph_small --- Shortand to create a short graph; giving the edges as agruments,  Up: Deterministic Graph Generators

@c 7.1.3 igraph_adjacency -- Creates a graph object from an adjacency matrix.
@c --------------------------------------------------------------------------


@c      int igraph_adjacency(igraph_t *graph, igraph_matrix_t *adjmatrix,
@c      		     igraph_adjacency_t mode);

@c    The order of the vertices in the matrix is preserved, i.e. the vertex
@c corresponding to the first row/column will be vertex with id 0, the
@c next row is for vertex 1, etc.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `adjmatrix':
@c      The adjacency matrix. How it is interpreted depends on the `mode'
@c      argument.

@c `mode':
@c      Constant to specify how the given matrix is interpreted as an
@c      adjacency matrix. Possible values (A(i,j) is the element in row i
@c      and column j in the adjacency matrix (`adjmatrix'):

@c     `IGRAPH_ADJ_DIRECTED'
@c           the graph will be directed and an element gives the number of
@c           edges between two vertices.

@c     `IGRAPH_ADJ_UNDIRECTED'
@c           this is the same as `IGRAPH_ADJ_MAX', for convenience.

@c     `IGRAPH_ADJ_MAX'
@c           undirected graph will be created and the number of edges
@c           between vertex i and j is max(A(i,j), A(j,i)).

@c     `IGRAPH_ADJ_MIN'
@c           undirected graph will be created with min(A(i,j), A(j,i))
@c           edges between vertex i and j.

@c     `IGRAPH_ADJ_PLUS '
@c           undirected graph will be created with A(i,j)+A(j,i) edges
@c           between vertex i and j.

@c     `IGRAPH_ADJ_UPPER '
@c           undirected graph will be created, only the upper right
@c           triangle (including the diagonal) is used for the number of
@c           edges.

@c     `IGRAPH_ADJ_LOWER '
@c           undirected graph will be created, only the lower left
@c           triangle (including the diagonal) is used for creating the
@c           edges.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_NONSQUARE': non-square matrix.

@c    Time complexity: O(|V||V|), |V| is the number of vertices in the
@c graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_weighted_adjacency --- Creates a graph object from a weighted adjacency matrix_,  Next: igraph_adjlist --- Create a graph from an adjacency list,  Prev: igraph_adjacency --- Creates a graph object from an adjacency matrix_,  Up: Deterministic Graph Generators

@c 7.1.4 igraph_weighted_adjacency -- Creates a graph object from a weighted adjacency matrix.
@c -------------------------------------------------------------------------------------------


@c      int igraph_weighted_adjacency(igraph_t *graph, igraph_matrix_t *adjmatrix,
@c      		     igraph_adjacency_t mode, const char* attr);

@c    The order of the vertices in the matrix is preserved, i.e. the vertex
@c corresponding to the first row/column will be vertex with id 0, the
@c next row is for vertex 1, etc.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `adjmatrix':
@c      The weighted adjacency matrix. How it is interpreted depends on
@c      the `mode' argument. The common feature is that edges with zero
@c      weights are considered nonexistent (however, negative weights are
@c      permitted).

@c `mode':
@c      Constant to specify how the given matrix is interpreted as an
@c      adjacency matrix. Possible values (A(i,j) is the element in row i
@c      and column j in the adjacency matrix (`adjmatrix'):

@c     `IGRAPH_ADJ_DIRECTED'
@c           the graph will be directed and an element gives the weight of
@c           the edge between two vertices.

@c     `IGRAPH_ADJ_UNDIRECTED'
@c           this is the same as `IGRAPH_ADJ_MAX', for convenience.

@c     `IGRAPH_ADJ_MAX'
@c           undirected graph will be created and the weight of the edge
@c           between vertex i and j is max(A(i,j), A(j,i)).

@c     `IGRAPH_ADJ_MIN'
@c           undirected graph will be created with edge weight min(A(i,j),
@c           A(j,i)) between vertex i and j.

@c     `IGRAPH_ADJ_PLUS '
@c           undirected graph will be created with edge weight
@c           A(i,j)+A(j,i) between vertex i and j.

@c     `IGRAPH_ADJ_UPPER '
@c           undirected graph will be created, only the upper right
@c           triangle (including the diagonal) is used for the edge
@c           weights.

@c     `IGRAPH_ADJ_LOWER '
@c           undirected graph will be created, only the lower left
@c           triangle (including the diagonal) is used for the edge
@c           weights.

@c `attr':
@c      the name of the attribute that will store the edge weights.  If
@c      `NULL' , it will use `weight' as the attribute name.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_NONSQUARE': non-square matrix.

@c    Time complexity: O(|V||V|), |V| is the number of vertices in the
@c graph.a

@c
@c File: igraph_reference_manual.info,  Node: igraph_adjlist --- Create a graph from an adjacency list,  Next: igraph_star --- Creates a star graph; every vertex connects only to the center_,  Prev: igraph_weighted_adjacency --- Creates a graph object from a weighted adjacency matrix_,  Up: Deterministic Graph Generators

@c 7.1.5 igraph_adjlist -- Create a graph from an adjacency list
@c -------------------------------------------------------------


@c      int igraph_adjlist(igraph_t *graph, const igraph_adjlist_t *adjlist,
@c      		   igraph_bool_t directed, igraph_bool_t duplicate);

@c    An adjacency list is list of vectors, containing the neighbors of
@c all vertices. For operations that involve many changes of the graph
@c structure, it is recommended that you convert the graph into and
@c adjacency list via `igraph_adjlist_init()' (*note igraph_adjlist_init
@c --- Initialize an adjacency list of vertices::), perform the
@c modifications (these are cheap for an adjacency list) and then recreate
@c the igraph graph via this function.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `adjlist':
@c      The adjacency list.

@c `directed':
@c      Logical, whether or not to create a directed graph.

@c `duplicate':
@c      Logical, for undirected graphs this specified whether each edge is
@c      included twice, in the vectors of both adjacenct vertices. If this
@c      is false (0), then it is assumed that every edge is included only
@c      once. This argument is ignored for directed graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_adjlist_init()' (*note igraph_adjlist_init --- Initialize
@c      an adjacency list of vertices::) for the opposite operation.

@c    Time complexity: O(|V|+|E|).

@c
@c File: igraph_reference_manual.info,  Node: igraph_star --- Creates a star graph; every vertex connects only to the center_,  Next: igraph_lattice --- Creates most kind of lattices_,  Prev: igraph_adjlist --- Create a graph from an adjacency list,  Up: Deterministic Graph Generators

@c 7.1.6 igraph_star -- Creates a star graph, every vertex connects only to the center.
@c ------------------------------------------------------------------------------------


@c      int igraph_star(igraph_t *graph, igraph_integer_t n, igraph_star_mode_t mode,
@c      		igraph_integer_t center);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object, this will be the result.

@c `n':
@c      Integer constant, the number of vertices in the graph.

@c `mode':
@c      Constant, gives the type of the star graph to create. Possible
@c      values:

@c     `IGRAPH_STAR_OUT'
@c           directed star graph, edges point _from_ the center to the
@c           other vertices.

@c     `IGRAPH_STAR_IN'
@c           directed star graph, edges point _to_ the center from the
@c           other vertices.

@c     `IGRAPH_STAR_UNDIRECTED '
@c           an undirected star graph is created.

@c `center':
@c      Id of the vertex which will be the center of the graph.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_EINVVID '
@c           invalid number of vertices.

@c     `IGRAPH_EINVAL '
@c           invalid center vertex.

@c     `IGRAPH_EINVMODE '
@c           invalid mode argument.

@c    Time complexity: O(|V|), the number of vertices in the graph.

@c    *See also:. *

@c `'
@c      `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c      lattices_::), `igraph_ring()' (*note igraph_ring --- Creates a
@c      ring graph; a one dimensional lattice_::), `igraph_tree()' (*note
@c      igraph_tree --- Creates a tree in which almost all vertices have
@c      the same number of children_::) for creating other regular
@c      structures.

@c
@c File: igraph_reference_manual.info,  Node: igraph_lattice --- Creates most kind of lattices_,  Next: igraph_ring --- Creates a ring graph; a one dimensional lattice_,  Prev: igraph_star --- Creates a star graph; every vertex connects only to the center_,  Up: Deterministic Graph Generators

@c 7.1.7 igraph_lattice -- Creates most kind of lattices.
@c ------------------------------------------------------


@c      int igraph_lattice(igraph_t *graph, const igraph_vector_t *dimvector, igraph_integer_t nei,
@c      		   igraph_bool_t directed, igraph_bool_t mutual, igraph_bool_t circular);

@c    *Arguments:. *

@c `graph':
@c      An uninitialized graph object.

@c `dimvector':
@c      Vector giving the sizes of the lattice in each of its dimensions.
@c      Ie. the dimension of the lattice will be the same as the length of
@c      this vector.

@c `nei':
@c      Integer value giving the distance (number of steps) within which
@c      two vertices will be connected. Not implemented yet.

@c `directed':
@c      Boolean, whether to create a directed graph. The direction of the
@c      edges is determined by the generation algorithm and is unlikely to
@c      suit you, so this isn't a very useful option.

@c `mutual':
@c      Boolean, if the graph is directed this gives whether to create all
@c      connections as mutual.

@c `circular':
@c      Boolean, defines whether the generated lattice is periodic.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid (negative) dimension vector.

@c    Time complexity: if `nei' is less than two then it is O(|V|+|E|) (as
@c far as i remember), |V| and |E| are the number of vertices and edges in
@c the generated graph. Otherwise it is O(|V|*d^o+|E|), d is the average
@c degree of the graph, o is the `nei' argument.

@c
@c File: igraph_reference_manual.info,  Node: igraph_ring --- Creates a ring graph; a one dimensional lattice_,  Next: igraph_tree --- Creates a tree in which almost all vertices have the same number of children_,  Prev: igraph_lattice --- Creates most kind of lattices_,  Up: Deterministic Graph Generators

@c 7.1.8 igraph_ring -- Creates a ring graph, a one dimensional lattice.
@c ---------------------------------------------------------------------


@c      int igraph_ring(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed, igraph_bool_t mutual,
@c      		igraph_bool_t circular);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `n':
@c      The number of vertices in the ring.

@c `directed':
@c      Logical, whether to create a directed ring.

@c `mutual':
@c      Logical, whether to create mutual edges in a directed ring. It is
@c      ignored for undirected graphs.

@c `circular':
@c      Logical, if false, the ring will be open (this is not a real
@c      _ring_ actually).

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid number of vertices.

@c    Time complexity: O(|V|), the number of vertices in the graph.

@c    *See also:. *

@c `'
@c      `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c      lattices_::) for generating more general lattices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_tree --- Creates a tree in which almost all vertices have the same number of children_,  Next: igraph_full --- Creates a full graph [directed or undirected; with or without loops]_,  Prev: igraph_ring --- Creates a ring graph; a one dimensional lattice_,  Up: Deterministic Graph Generators

@c 7.1.9 igraph_tree -- Creates a tree in which almost all vertices have the same number of children.
@c --------------------------------------------------------------------------------------------------


@c      int igraph_tree(igraph_t *graph, igraph_integer_t n, igraph_integer_t children,
@c      		igraph_tree_mode_t type);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `n':
@c      Integer, the number of vertices in the graph.

@c `children':
@c      Integer, the number of children of a vertex in the tree.

@c `type':
@c      Constant, gives whether to create a directed tree, and if this is
@c      the case, also its orientation. Possible values:

@c     `IGRAPH_TREE_OUT '
@c           directed tree, the edges point from the parents to their
@c           children,

@c     `IGRAPH_TREE_IN '
@c           directed tree, the edges point from the children to their
@c           parents.

@c     `IGRAPH_TREE_UNDIRECTED'
@c           undirected tree.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid number of vertices.
@c      `IGRAPH_INVMODE': invalid mode argument.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph.

@c    *See also:. *

@c `'
@c      `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c      lattices_::), `igraph_star()' (*note igraph_star --- Creates a
@c      star graph; every vertex connects only to the center_::) for
@c      creating other regular structures.

@c
@c File: igraph_reference_manual.info,  Node: igraph_full --- Creates a full graph [directed or undirected; with or without loops]_,  Next: igraph_full_citation --- Creates a full citation graph,  Prev: igraph_tree --- Creates a tree in which almost all vertices have the same number of children_,  Up: Deterministic Graph Generators

@c 7.1.10 igraph_full -- Creates a full graph (directed or undirected, with or without loops).
@c -------------------------------------------------------------------------------------------


@c      int igraph_full(igraph_t *graph, igraph_integer_t n, igraph_bool_t directed, igraph_bool_t loops);

@c    In a full graph every possible edge is present, every vertex is
@c connected to every other vertex.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `n':
@c      Integer, the number of vertices in the graph.

@c `directed':
@c      Logical, whether to create a directed graph.

@c `loops':
@c      Logical, whether to include self-edges (loops).

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid number of vertices.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| the
@c number of edges in the graph. Of course this is the same as
@c O(|E|)=O(|V||V|) here.

@c    *See also:. *

@c `'
@c      `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c      lattices_::), `igraph_star()' (*note igraph_star --- Creates a
@c      star graph; every vertex connects only to the center_::),
@c      `igraph_tree()' (*note igraph_tree --- Creates a tree in which
@c      almost all vertices have the same number of children_::) for
@c      creating other regular structures.

@c
@c File: igraph_reference_manual.info,  Node: igraph_full_citation --- Creates a full citation graph,  Next: igraph_famous --- Create a famous graph by simply providing its name,  Prev: igraph_full --- Creates a full graph [directed or undirected; with or without loops]_,  Up: Deterministic Graph Generators

@c 7.1.11 igraph_full_citation -- Creates a full citation graph
@c ------------------------------------------------------------


@c      int igraph_full_citation(igraph_t *graph, igraph_integer_t n,
@c      			 igraph_bool_t directed);

@c    This is a directed graph, where every ` i->j'  edge is present if
@c and only if ` j<i' .  If the `directed' argument is zero then an
@c undirected graph is created, and it is just a full graph.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object, the result is stored
@c      here.

@c `n':
@c      The number of vertices.

@c `directed':
@c      Whether to created a directed graph. If zero an undirected graph
@c      is created.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^2), as we have many edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_famous --- Create a famous graph by simply providing its name,  Next: igraph_lcf --- Create a graph from LCF notation,  Prev: igraph_full_citation --- Creates a full citation graph,  Up: Deterministic Graph Generators

@c 7.1.12 igraph_famous -- Create a famous graph by simply providing its name
@c --------------------------------------------------------------------------


@c      int igraph_famous(igraph_t *graph, const char *name);

@c    The name of the graph can be simply supplied as a string.  Note that
@c this function creates graphs which don't take any parameters, there are
@c separate functions for graphs with parameters, eg. `igraph_full()'
@c (*note igraph_full --- Creates a full graph [directed or undirected;
@c with or without loops]_::) for creating a full graph.

@c    The following graphs are supported:

@c `Bull'
@c      The bull graph, 5 vertices, 5 edges, resembles to the head of a
@c      bull if drawn properly.

@c `Chvatal '
@c      This is the smallest triangle-free graph that is both 4-chromatic
@c      and 4-regular. According to the Grunbaum conjecture there exists
@c      an m-regular, m-chromatic graph with n vertices for every m>1 and
@c      n>2. The Chvatal graph is an example for m=4 and n=12. It has 24
@c      edges.

@c `Coxeter '
@c      A non-Hamiltonian cubic symmetric graph with 28 vertices and 42
@c      edges.

@c `Cubical'
@c      The Platonic graph of the cube. A convex regular polyhedron with 8
@c      vertices and 12 edges.

@c `Diamond'
@c      A graph with 4 vertices and 5 edges, resembles to a schematic
@c      diamond if drawn properly.

@c `Dodecahedral, Dodecahedron'
@c      Another Platonic solid with 20 vertices and 30 edges.

@c `Folkman '
@c      The semisymmetric graph with minimum number of vertices, 20 and 40
@c      edges. A semisymmetric graph is regular, edge transitive and not
@c      vertex transitive.

@c `Franklin '
@c      This is a graph whose embedding to the Klein bottle can be colored
@c      with six colors, it is a counterexample to the neccessity of the
@c      Heawood conjecture on a Klein bottle. It has 12 vertices and 18
@c      edges.

@c `Frucht '
@c      The Frucht Graph is the smallest cubical graph whose automorphism
@c      group consists only of the identity element. It has 12 vertices
@c      and 18 edges.

@c `Grotzsch '
@c      The Gro"tzsch graph is a triangle-free graph with 11 vertices, 20
@c      edges, and chromatic number 4. It is named after German
@c      mathematician Herbert Gro"tzsch, and its existence demonstrates
@c      that the assumption of planarity is necessary in Gro"tzsch's
@c      theorem that every triangle-free planar graph is 3-colorable.

@c `Heawood '
@c      The Heawood graph is an undirected graph with 14 vertices and 21
@c      edges. The graph is cubic, and all cycles in the graph have six or
@c      more edges. Every smaller cubic graph has shorter cycles, so this
@c      graph is the 6-cage, the smallest cubic graph of girth 6.

@c `Herschel '
@c      The Herschel graph is the smallest nonhamiltonian polyhedral
@c      graph. It is the unique such graph on 11 nodes, and has 18 edges.

@c `House'
@c      The house graph is a 5-vertex, 6-edge graph, the schematic draw of
@c      a house if drawn properly, basicly a triangle of the top of a
@c      square.

@c `HouseX'
@c      The same as the house graph with an X in the square. 5 vertices
@c      and 8 edges.

@c `Icosahedral, Icosahedron '
@c      A Platonic solid with 12 vertices and 30 edges.

@c `Krackhardt_Kite'
@c      A social network with 10 vertices and 18 edges.  Krackhardt, D.
@c      Assessing the Political Landscape: Structure, Cognition, and Power
@c      in Organizations.  Admin. Sci. Quart. 35, 342-369, 1990.

@c `Levi '
@c      The graph is a 4-arc transitive cubic graph, it has 30 vertices
@c      and 45 edges.

@c `McGee '
@c      The McGee graph is the unique 3-regular 7-cage graph, it has 24
@c      vertices and 36 edges.

@c `Meredith '
@c      The Meredith graph is a quartic graph on 70 nodes and 140 edges
@c      that is a counterexample to the conjecture that every 4-regular
@c      4-connected graph is Hamiltonian.

@c `Noperfectmatching '
@c      A connected graph with 16 vertices and 27 edges containing no
@c      perfect matching. A matching in a graph is a set of pairwise
@c      non-adjacent edges; that is, no two edges share a common vertex. A
@c      perfect matching is a matching which covers all vertices of the
@c      graph.

@c `Nonline '
@c      A graph whose connected components are the 9 graphs whose presence
@c      as a vertex-induced subgraph in a graph makes a nonline graph. It
@c      has 50 vertices and 72 edges.

@c `Octahedral, Octahedron '
@c      Platonic solid with 6 vertices and 12 edges.

@c `Petersen'
@c      A 3-regular graph with 10 vertices and 15 edges. It is the
@c      smallest hypohamiltonian graph, ie. it is non-hamiltonian but
@c      removing any single vertex from it makes it Hamiltonian.

@c `Robertson '
@c      The unique (4,5)-cage graph, ie. a 4-regular graph of girth 5. It
@c      has 19 vertices and 38 edges.

@c `Smallestcyclicgroup '
@c      A smallest nontrivial graph whose automorphism group is cyclic. It
@c      has 9 vertices and 15 edges.

@c `Tetrahedral, Tetrahedron '
@c      Platonic solid with 4 vertices and 6 edges.

@c `Thomassen '
@c      The smallest hypotraceable graph, on 34 vertices and 52 edges. A
@c      hypotracable graph does not contain a Hamiltonian path but after
@c      removing any single vertex from it the remainder always contains a
@c      Hamiltonian path. A graph containing a Hamiltonian path is called
@c      tracable.

@c `Tutte '
@c      Tait's Hamiltonian graph conjecture states that every 3-connected
@c      3-regular planar graph is Hamiltonian.  This graph is a
@c      counterexample. It has 46 vertices and 69 edges.

@c `Uniquely3colorable '
@c      Returns a 12-vertex, triangle-free graph with chromatic number 3
@c      that is uniquely 3-colorable.

@c `Walther '
@c      An identity graph with 25 vertices and 31 edges. An identity graph
@c      has a single graph automorphism, the trivial one.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an unitialized graph object.

@c `name':
@c      Character constant, the name of the graph to be created, it is
@c      case insensitive.

@c    *Returns:. *

@c `'
@c      Error code, IGRAPH_EINVAL if there is no graph with the given name.

@c    *See also:. *

@c `'
@c      Other functions for creating graph structures: `igraph_ring()'
@c      (*note igraph_ring --- Creates a ring graph; a one dimensional
@c      lattice_::), `igraph_tree()' (*note igraph_tree --- Creates a tree
@c      in which almost all vertices have the same number of children_::),
@c      `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c      lattices_::), `igraph_full()' (*note igraph_full --- Creates a
@c      full graph [directed or undirected; with or without loops]_::).

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_lcf --- Create a graph from LCF notation,  Next: igraph_lcf_vector --- Create a graph from LCF notation,  Prev: igraph_famous --- Create a famous graph by simply providing its name,  Up: Deterministic Graph Generators

@c 7.1.13 igraph_lcf -- Create a graph from LCF notation
@c -----------------------------------------------------


@c      int igraph_lcf(igraph_t *graph, igraph_integer_t n, ...);

@c    LCF is short for Lederberg-Coxeter-Frucht, it is a concise notation
@c for 3-regular Hamiltonian graphs. It consists of three parameters, the
@c number of vertices in the graph, a list of shifts giving additional
@c edges to a cycle backbone and another integer giving how many times the
@c shifts should be performed. See
@c http://mathworld.wolfram.com/LCFNotation.html
@c (http://mathworld.wolfram.com/LCFNotation.html) for details.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `n':
@c      Integer, the number of vertices in the graph.

@c `...':
@c      The shifts and the number of repeats for the shifts, plus an
@c      additional 0 to mark the end of the arguments.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      See `igraph_lcf_vector()' (*note igraph_lcf_vector --- Create a
@c      graph from LCF notation::) for a similar function using a vector_t
@c      instead of the variable length argument list.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_lcf_vector --- Create a graph from LCF notation,  Next: igraph_atlas --- Create a small graph from the Graph Atlas_,  Prev: igraph_lcf --- Create a graph from LCF notation,  Up: Deterministic Graph Generators

@c 7.1.14 igraph_lcf_vector -- Create a graph from LCF notation
@c ------------------------------------------------------------


@c      int igraph_lcf_vector(igraph_t *graph, igraph_integer_t n,
@c      		      const igraph_vector_t *shifts,
@c      		      igraph_integer_t repeats);

@c    This function is essentially the same as `igraph_lcf()' (*note
@c igraph_lcf --- Create a graph from LCF notation::), only the way for
@c giving the arguments is different. See `igraph_lcf()' (*note igraph_lcf
@c --- Create a graph from LCF notation::) for details.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `n':
@c      Integer constant giving the number of vertices.

@c `shifts':
@c      A vector giving the shifts.

@c `repeats':
@c      An integer constant giving the number of repeats for the shifts.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_lcf()' (*note igraph_lcf --- Create a graph from LCF
@c      notation::)

@c    Time complexity: O(|V|+|E|), linear in the number of vertices plus
@c the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_atlas --- Create a small graph from the Graph Atlas_,  Next: igraph_de_bruijn --- Generate a de Bruijn graph_,  Prev: igraph_lcf_vector --- Create a graph from LCF notation,  Up: Deterministic Graph Generators

@c 7.1.15 igraph_atlas -- Create a small graph from the Graph Atlas.
@c -----------------------------------------------------------------


@c      int igraph_atlas(igraph_t *graph, int number);

@c    The number of the graph is given as a parameter.  The graphs are
@c listed:

@c   1. in increasing order of number of nodes;

@c   2. for a fixed number of nodes, in increasing order of the number of
@c      edges;

@c   3. for fixed numbers of nodes and edges, in increasing order of the
@c      degree sequence, for example 111223 < 112222;

@c   4. for fixed degree sequence, in increasing number of automorphisms.

@c    The data was converted from the networkx software package, see
@c http://networkx.lanl.gov. (http://networkx.lanl.gov.)

@c    See _ An Atlas of Graphs _ by Ronald C. Read and Robin J. Wilson,
@c Oxford University Press, 1998.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `number':
@c      The number of the graph to generate.

@c    Added in version 0.2.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_de_bruijn --- Generate a de Bruijn graph_,  Next: igraph_kautz --- Generate a Kautz graph_,  Prev: igraph_atlas --- Create a small graph from the Graph Atlas_,  Up: Deterministic Graph Generators

@c 7.1.16 igraph_de_bruijn -- Generate a de Bruijn graph.
@c ------------------------------------------------------


@c      int igraph_de_bruijn(igraph_t *graph, igraph_integer_t m, igraph_integer_t n);

@c    A de Bruijn graph represents relationships between strings. An
@c alphabet of `m' letters are used and strings of length `n' are
@c considered.  A vertex corresponds to every possible string and there is
@c a directed edge from vertex `v' to vertex `w' if the string of `v' can
@c be transformed into the string of `w' by removing its first letter and
@c appending a letter to it.

@c    Please note that the graph will have `m' to the power `n' vertices
@c and even more edges, so probably you don't want to supply too big
@c numbers for `m' and `n'.

@c    De Bruijn graphs have some interesting properties, please see
@c another source, eg. Wikipedia for details.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object, the result will be
@c      stored here.

@c `m':
@c      Integer, the number of letters in the alphabet.

@c `n':
@c      Integer, the length of the strings.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_kautz()' (*note igraph_kautz --- Generate a Kautz
@c      graph_::).

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_kautz --- Generate a Kautz graph_,  Next: igraph_extended_chordal_ring --- Create an extended chordal ring,  Prev: igraph_de_bruijn --- Generate a de Bruijn graph_,  Up: Deterministic Graph Generators

@c 7.1.17 igraph_kautz -- Generate a Kautz graph.
@c ----------------------------------------------


@c      int igraph_kautz(igraph_t *graph, igraph_integer_t m, igraph_integer_t n);

@c    A Kautz graph is a labeled graph, vertices are labeled by strings of
@c length `n'+1 above an alphabet with `m'+1 letters, with the restriction
@c that every two consecutive letters in the string must be different.
@c There is a directed edge from a vertex `v' to another vertex `w' if it
@c is possible to transform the string of `v' into the string of `w' by
@c removing the first letter and appending a letter to it.

@c    Kautz graphs have some interesting properties, see eg. Wikipedia for
@c details.

@c    Vincent Matossian wrote the first version of this function in R,
@c thanks.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object, the result will be
@c      stored here.

@c `m':
@c      Integer, `m'+1 is the number of letters in the alphabet.

@c `n':
@c      Integer, `n'+1 is the length of the strings.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_de_bruijn()' (*note igraph_de_bruijn --- Generate a de
@c      Bruijn graph_::).

@c    Time complexity: O(|V|* [(m+1)/m]^n +|E|), in practice it is more
@c like O(|V|+|E|). |V| is the number of vertices, |E| is the number of
@c edges and `m' and `n' are the corresponding arguments.

@c
@c File: igraph_reference_manual.info,  Node: igraph_extended_chordal_ring --- Create an extended chordal ring,  Next: igraph_connect_neighborhood --- Connects every vertex to its neighborhood,  Prev: igraph_kautz --- Generate a Kautz graph_,  Up: Deterministic Graph Generators

@c 7.1.18 igraph_extended_chordal_ring -- Create an extended chordal ring
@c ----------------------------------------------------------------------


@c      int igraph_extended_chordal_ring(igraph_t *graph, igraph_integer_t nodes,
@c      				 const igraph_matrix_t *W);

@c    An extended chordal ring is regular graph, each node has the same
@c degree. It can be obtained from a simple ring by adding some extra
@c edges specified by a matrix. Let p denote the number of columns in the
@c `W' matrix. The extra edges of vertex i are added according to column
@c (i mod p) in `W'. The number of extra edges is the number of rows in
@c `W': for each row j an edge i->i+w[ij] is added if i+w[ij] is less than
@c the number of total nodes.

@c    See also Kotsis, G: Interconnection Topologies for Parallel
@c Processing Systems, PARS Mitteilungen 11, 1-6, 1993.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object, the result will be
@c      stored here. The result is always an undirected graph.

@c `nodes':
@c      Integer constant, the number of vertices in the graph. It must be
@c      at least 3.

@c `W':
@c      The matrix specifying the extra edges. The number of columns
@c      should divide the number of total vertices.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_ring()' (*note igraph_ring --- Creates a ring graph; a one
@c      dimensional lattice_::).

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_connect_neighborhood --- Connects every vertex to its neighborhood,  Prev: igraph_extended_chordal_ring --- Create an extended chordal ring,  Up: Deterministic Graph Generators

@c 7.1.19 igraph_connect_neighborhood -- Connects every vertex to its neighborhood
@c -------------------------------------------------------------------------------


@c      int igraph_connect_neighborhood(igraph_t *graph, igraph_integer_t order,
@c      				igraph_neimode_t mode);

@c    This function adds new edges to graph. For each vertex vertices
@c reachable by at most `order' steps and not yet connected to the vertex
@c a new edge is created.

@c    Note that the input graph is modified in place, no new graph is
@c created, call `igraph_copy()' (*note igraph_copy --- Creates an exact
@c [deep] copy of a graph_::) if you want to keep the original graph as
@c well.

@c    For undirected graphs reachability is always symmetric, if vertex A
@c can be reached from vertex B in at most `order' steps, then the
@c opposite is also true. Only one undirected (A,B) edge will be added in
@c this case.

@c    *Arguments:. *

@c `graph':
@c      The input graph, this is the output graph as well.

@c `order':
@c      Integer constant, it gives the distance within which the vertices
@c      will be connected to the source vertex.

@c `mode':
@c      Constant, it specifies how the neighborhood search is performed
@c      for directed graphs. If `IGRAPH_OUT' then vertices reachable from
@c      the source vertex will be connected, `IGRAPH_IN' is the opposite.
@c      If `IGRAPH_ALL' then the directed graph is considered as an
@c      undirected one.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c      lattices_::) uses this function to connect the neighborhood of the
@c      vertices.

@c    Time complexity: O(|V|*d^o), |V| is the number of vertices in the
@c graph, d is the average degree and o is the `order' argument.

@c
@c File: igraph_reference_manual.info,  Node: Games; Randomized Graph Generators,  Prev: Deterministic Graph Generators,  Up: Graph Generators

@c 7.2 Games: Randomized Graph Generators
@c ======================================

@c Games are randomized graph generators. Randomization means that they
@c generate a different graph every time you call them.

@c * Menu:

@c * igraph_grg_game --- Generating geometric random graphs.: igraph_grg_game --- Generating geometric random graphs_.
@c * igraph_barabasi_game --- Generates a graph based on the Baraba'si-Albert model.: igraph_barabasi_game --- Generates a graph based on the Baraba'si-Albert model_.
@c * igraph_nonlinear_barabasi_game --- Generates graph with non-linear preferential attachment::
@c * igraph_erdos_renyi_game --- Generates a random (Erdos-Renyi) graph.: igraph_erdos_renyi_game --- Generates a random [Erdos-Renyi] graph_.
@c * igraph_watts_strogatz_game --- The Watts-Strogatz small-world model::
@c * igraph_rewire_edges --- Rewire the edges of a graph with constant probability::
@c * igraph_degree_sequence_game --- Generates a random graph with a given degree sequence : igraph_degree_sequence_game --- Generates a random graph with a given degree sequence.
@c * igraph_forest_fire_game --- Generates a network according to the forest fire game::
@c * igraph_rewire --- Randomly rewires a graph while preserving the degree distribution.: igraph_rewire --- Randomly rewires a graph while preserving the degree distribution_.
@c * igraph_growing_random_game --- Generates a growing random graph.: igraph_growing_random_game --- Generates a growing random graph_.
@c * igraph_callaway_traits_game --- Simulate a growing network with vertex types.: igraph_callaway_traits_game --- Simulate a growing network with vertex types_.
@c * igraph_establishment_game --- Generates a graph with a simple growing model with vertex types.: igraph_establishment_game --- Generates a graph with a simple growing model with vertex types_.
@c * igraph_preference_game --- Generates a graph with vertex types and connection preferences : igraph_preference_game --- Generates a graph with vertex types and connection preferences.
@c * igraph_asymmetric_preference_game --- Generates a graph with asymmetric vertex types and connection preferences : igraph_asymmetric_preference_game --- Generates a graph with asymmetric vertex types and connection preferences.
@c * igraph_recent_degree_game --- Stochastic graph generator based on the number of adjacent edges a node has gained recently::
@c * igraph_barabasi_aging_game --- Preferential attachment with aging of vertices::
@c * igraph_recent_degree_aging_game --- Preferential attachment based on the number of edges gained recently, with aging of vertices: igraph_recent_degree_aging_game --- Preferential attachment based on the number of edges gained recently; with aging of vertices.
@c * igraph_cited_type_game --- Simulate a citation based on vertex types.: igraph_cited_type_game --- Simulate a citation based on vertex types_.
@c * igraph_citing_cited_type_game --- Simulate a citation network based on vertex types.: igraph_citing_cited_type_game --- Simulate a citation network based on vertex types_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_grg_game --- Generating geometric random graphs_,  Next: igraph_barabasi_game --- Generates a graph based on the Baraba'si-Albert model_,  Up: Games; Randomized Graph Generators

@c 7.2.1 igraph_grg_game -- Generating geometric random graphs.
@c ------------------------------------------------------------


@c      int igraph_grg_game(igraph_t *graph, igraph_integer_t nodes,
@c      		    igraph_real_t radius, igraph_bool_t torus,
@c      		    igraph_vector_t *x, igraph_vector_t *y);

@c    A geometric random graph is created by dropping points (=vertices)
@c randomly to the unit square and then connecting all those pairs which
@c are less than `radius' apart in Euclidean norm.

@c    Original code contributed by Keith Briggs, thanks Keith.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object,

@c `nodes':
@c      The number of vertices in the graph.

@c `radius':
@c      The radius within which the vertices will be connected.

@c `torus':
@c      Logical constant, if true periodic boundary conditions will be
@c      used, ie. the vertices are assumed to be on a torus instead of a
@c      square.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: TODO, less than O(|V|^2+|E|).

@c
@c File: igraph_reference_manual.info,  Node: igraph_barabasi_game --- Generates a graph based on the Baraba'si-Albert model_,  Next: igraph_nonlinear_barabasi_game --- Generates graph with non-linear preferential attachment,  Prev: igraph_grg_game --- Generating geometric random graphs_,  Up: Games; Randomized Graph Generators

@c 7.2.2 igraph_barabasi_game -- Generates a graph based on the Baraba'si-Albert model.
@c ------------------------------------------------------------------------------------


@c      int igraph_barabasi_game(igraph_t *graph, igraph_integer_t n, igraph_integer_t m,
@c      			 const igraph_vector_t *outseq, igraph_bool_t outpref,
@c      			 igraph_bool_t directed);

@c    *Arguments:. *

@c `graph':
@c      An uninitialized graph object.

@c `n':
@c      The number of vertices in the graph.

@c `m':
@c      The number of outgoing edges generated for each vertex. (Only if
@c      `outseq' is `NULL'.)

@c `outseq':
@c      Gives the (out-)degrees of the vertices. If this is constant, this
@c      can be a NULL pointer or an empty (but initialized!) vector, in
@c      this case `m' contains the constant out-degree. The very first
@c      vertex has by definition no outgoing edges, so the first number in
@c      this vector is ignored.

@c `outpref':
@c      Boolean, if true not only the in- but also the out-degree of a
@c      vertex increases its citation probability. Ie. the citation
@c      probability is determined by the total degree of the vertices.

@c `directed':
@c      Boolean, whether to generate a directed graph.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid `n', `m' or `outseq'
@c      parameter.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_nonlinear_barabasi_game --- Generates graph with non-linear preferential attachment,  Next: igraph_erdos_renyi_game --- Generates a random [Erdos-Renyi] graph_,  Prev: igraph_barabasi_game --- Generates a graph based on the Baraba'si-Albert model_,  Up: Games; Randomized Graph Generators

@c 7.2.3 igraph_nonlinear_barabasi_game -- Generates graph with non-linear preferential attachment
@c -----------------------------------------------------------------------------------------------


@c      int igraph_nonlinear_barabasi_game(igraph_t *graph, igraph_integer_t n,
@c      				   igraph_real_t power,
@c      				   igraph_integer_t m,
@c      				   const igraph_vector_t *outseq,
@c      				   igraph_bool_t outpref,
@c      				   igraph_real_t zeroappeal,
@c      				   igraph_bool_t directed);

@c    This function is very similar to `igraph_barabasi_game()' (*note
@c igraph_barabasi_game --- Generates a graph based on the
@c Baraba'si-Albert model_::), only in this game the probability that a
@c new vertex attaches to a given old vertex is not proportional to the
@c degree of the old node, but some power of the degree of the old node.

@c    More precisely the attachment probability is the degree to the power
@c of `power' plus `zeroappeal'.

@c    This function might generate graphs with multiple edges if the value
@c of `m' is at least two. You can call `igraph_simplify()' (*note
@c igraph_simplify --- Removes loop and/or multiple edges from the
@c graph_::) to get rid of the multiple edges.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object, the generated graph will
@c      be stored here.

@c `n':
@c      The number of vertices in the generated graph.

@c `power':
@c      The power of the preferential attachment.

@c `m':
@c      The number of edges to generate in each time step, if the `outseq'
@c      parameter is a null vector or a vector with length zero. It is
@c      ignored otherwise.

@c `outseq':
@c      The number of edges to generate in each time step. For directed
@c      graphs this is exactly the out-degree of the vertices. The first
@c      element of the vector is ignored. If this is a null vector or a
@c      vector of length zero then it is ignored and the value of the `m'
@c      argument is used.

@c `outpref':
@c      Logical constant, if TRUE then the preferential attachment is
@c      based on the total degree of the nodes instead of the in-degree.

@c `zeroappeal':
@c      Positive number, the attachment probability for vertices with
@c      degree zero.

@c `directed':
@c      Logical constant, whether to generate a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|*m*log(|V|)+|E|), |V| is the number of
@c vertices, |E| is the number of edges and m is the average number of
@c edges added in a time step.

@c    *See also:. *

@c `'
@c      `igraph_barabasi_game()' (*note igraph_barabasi_game --- Generates
@c      a graph based on the Baraba'si-Albert model_::) for the slightly
@c      more efficient implementation of the special case `power'=1.

@c
@c File: igraph_reference_manual.info,  Node: igraph_erdos_renyi_game --- Generates a random [Erdos-Renyi] graph_,  Next: igraph_watts_strogatz_game --- The Watts-Strogatz small-world model,  Prev: igraph_nonlinear_barabasi_game --- Generates graph with non-linear preferential attachment,  Up: Games; Randomized Graph Generators

@c 7.2.4 igraph_erdos_renyi_game -- Generates a random (Erdos-Renyi) graph.
@c ------------------------------------------------------------------------


@c      int igraph_erdos_renyi_game(igraph_t *graph, igraph_erdos_renyi_t type,
@c      			    igraph_integer_t n, igraph_real_t p_or_m,
@c      			    igraph_bool_t directed, igraph_bool_t loops);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `type':
@c      The type of the random graph, possible values:

@c     `IGRAPH_ERDOS_RENYI_GNM'
@c           G(n,m) graph, m edges are selected uniformly randomly in a
@c           graph with n vertices.

@c     `IGRAPH_ERDOS_RENYI_GNP'
@c           G(n,p) graph, every possible edge is included in the graph
@c           with probability p.

@c `n':
@c      The number of vertices in the graph.

@c `p_or_m':
@c      This is the p parameter for G(n,p) graphs and the m parameter for
@c      G(n,m) graphs.

@c `directed':
@c      Logical, whether to generate a directed graph.

@c `loops':
@c      Logical, whether to generate loops (self) edges.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid `type', `n', `p' or `m'
@c      parameter.  `IGRAPH_ENOMEM': there is not enought memory for the
@c      operation.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph.

@c    *See also:. *

@c `'
@c      `igraph_barabasi_game()' (*note igraph_barabasi_game --- Generates
@c      a graph based on the Baraba'si-Albert model_::),
@c      `igraph_growing_random_game()' (*note igraph_growing_random_game
@c      --- Generates a growing random graph_::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_watts_strogatz_game --- The Watts-Strogatz small-world model,  Next: igraph_rewire_edges --- Rewire the edges of a graph with constant probability,  Prev: igraph_erdos_renyi_game --- Generates a random [Erdos-Renyi] graph_,  Up: Games; Randomized Graph Generators

@c 7.2.5 igraph_watts_strogatz_game -- The Watts-Strogatz small-world model
@c ------------------------------------------------------------------------


@c      int igraph_watts_strogatz_game(igraph_t *graph, igraph_integer_t dim,
@c      			       igraph_integer_t size, igraph_integer_t nei,
@c      			       igraph_real_t p);

@c    This function generates a graph according to the Watts-Strogatz
@c model of small-world networks. The graph is obtained by creating a
@c circular undirected lattice and then rewire the edges randomly with a
@c constant probability.

@c    See also: Duncan J Watts and Steven H Strogatz: Collective dynamics
@c of `small world' networks, Nature 393, 440-442, 1998.

@c    *Arguments:. *

@c `graph':
@c      The graph to initialize.

@c `dim':
@c      The dimension of the lattice.

@c `size':
@c      The size of the lattice along each dimension.

@c `nei':
@c      The size of the neighborhood for each vertex. This is the same as
@c      the `nei' argument of `igraph_connect_neighborhood()' (*note
@c      igraph_connect_neighborhood --- Connects every vertex to its
@c      neighborhood::).

@c `p':
@c      The rewiring probability. A real number between zero and one
@c      (inclusive).

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_lattice()' (*note igraph_lattice --- Creates most kind of
@c      lattices_::), `igraph_connect_neighborhood()' (*note
@c      igraph_connect_neighborhood --- Connects every vertex to its
@c      neighborhood::) and `igraph_rewire_edges()' (*note
@c      igraph_rewire_edges --- Rewire the edges of a graph with constant
@c      probability::) can be used if more flexibility is needed, eg. a
@c      different type of lattice.

@c    Time complexity: O(|V|*d^o+|E|), |V| ans |E| are the number of
@c vertices and edges, d is the average degree, o is the `nei' argument.

@c
@c File: igraph_reference_manual.info,  Node: igraph_rewire_edges --- Rewire the edges of a graph with constant probability,  Next: igraph_degree_sequence_game --- Generates a random graph with a given degree sequence,  Prev: igraph_watts_strogatz_game --- The Watts-Strogatz small-world model,  Up: Games; Randomized Graph Generators

@c 7.2.6 igraph_rewire_edges -- Rewire the edges of a graph with constant probability
@c ----------------------------------------------------------------------------------


@c      int igraph_rewire_edges(igraph_t *graph, igraph_real_t prob);

@c    This function rewires the edges of a graph with a constant
@c probability. More precisely each end point of each edge is rewired to
@c an uniformly randomly chosen vertex with constant probability `prob'.

@c    Note that this function modifies the input `graph', call
@c `igraph_copy()' (*note igraph_copy --- Creates an exact [deep] copy of
@c a graph_::) if you want to keep it.

@c    *Arguments:. *

@c `graph':
@c      The input graph, this will be rewired, it can be directed or
@c      undirected.

@c `prob':
@c      The rewiring probability a constant between zero and one
@c      (inclusive).

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_watts_strogatz_game()' (*note igraph_watts_strogatz_game
@c      --- The Watts-Strogatz small-world model::) uses this function for
@c      the rewiring.

@c    Time complexity: O(|V|+|E|).

@c
@c File: igraph_reference_manual.info,  Node: igraph_degree_sequence_game --- Generates a random graph with a given degree sequence,  Next: igraph_forest_fire_game --- Generates a network according to the forest fire game,  Prev: igraph_rewire_edges --- Rewire the edges of a graph with constant probability,  Up: Games; Randomized Graph Generators

@c 7.2.7 igraph_degree_sequence_game -- Generates a random graph with a given degree sequence
@c ------------------------------------------------------------------------------------------


@c      int igraph_degree_sequence_game(igraph_t *graph, const igraph_vector_t *out_deg,
@c      				const igraph_vector_t *in_deg,
@c      				igraph_degseq_t method);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `out_deg':
@c      The degree sequence for an undirected graph (if `in_seq' is of
@c      length zero), or the out-degree sequence of a directed graph (if
@c      `in_deq' is not of length zero.

@c `in_deg':
@c      It is either a zero-length vector or `NULL' (if an undirected
@c      graph is generated), or the in-degree sequence.

@c `method':
@c      The method to generate the graph. Possible values:
@c      `IGRAPH_DEGSEQ_SIMPLE', for undirected graphs this method puts all
@c      vertex ids in a bag, the multiplicity of a vertex in the bag is
@c      the same as its degree. Then it draws pairs from the bag, until it
@c      is empty. This method can generate both loop (self) edges and
@c      multiple edges.  For directed graphs, the algorithm is basically
@c      the same, but two separate bags are used for the in- and
@c      out-degrees.  `IGRAPH_DEGSEQ_VL' is a much more sophisticated
@c      generator, that can sample undirected, connected simple graphs
@c      uniformly.  It uses Monte-Carlo methods to randomize the graphs.
@c      This generator should be favoured if undirected and connected
@c      graphs are to be generated. igraph uses the original implementation
@c      Fabien Viger; see http://www-rp.lip6.fr/~latapy/FV/generation.html
@c      (http://www-rp.lip6.fr/~latapy/FV/generation.html) and the paper
@c      cited on it for the details of the algorithm.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM': there is not enough memory to perform
@c      the operation.  `IGRAPH_EINVAL': invalid method parameter, or
@c      invalid in- and/or out-degree vectors. The degree vectors should
@c      be non-negative, `out_deg' should sum up to an even integer for
@c      undirected graphs; the length and sum of `out_deg' and `in_deg'
@c      should match for directed graphs.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c    *See also:. *

@c `'
@c      `igraph_barabasi_game()' (*note igraph_barabasi_game --- Generates
@c      a graph based on the Baraba'si-Albert model_::),
@c      `igraph_erdos_renyi_game()' (*note igraph_erdos_renyi_game ---
@c      Generates a random [Erdos-Renyi] graph_::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_forest_fire_game --- Generates a network according to the forest fire game,  Next: igraph_rewire --- Randomly rewires a graph while preserving the degree distribution_,  Prev: igraph_degree_sequence_game --- Generates a random graph with a given degree sequence,  Up: Games; Randomized Graph Generators

@c 7.2.8 igraph_forest_fire_game -- Generates a network according to the forest fire game
@c --------------------------------------------------------------------------------------


@c      int igraph_forest_fire_game(igraph_t *graph, igraph_integer_t nodes,
@c      			    igraph_real_t fw_prob, igraph_real_t bw_factor,
@c      			    igraph_integer_t pambs, igraph_bool_t directed);

@c    The forest fire model intends to reproduce the following network
@c characteristics, observed in real networks:

@c    * Heavy-tailed in-degree distribution.

@c    * Heavy-tailed out-degree distribution.

@c    * Communities.

@c    * Densification power-law. The network is densifying in time,
@c      according to a power-law rule.

@c    * Shrinking diameter. The diameter of the network decreases in time.

@c    The network is generated in the following way. One vertex is added at
@c a time. This vertex connects to (cites) ` ambs'  vertices already
@c present in the network, chosen uniformly random. Now, for each cited
@c vertex ` v'  we do the following procedure:

@c   1. We generate two random number, ` x'  and ` y' , that are
@c      geometrically distributed with means ` p/(1-p)'  and ` rp(1-rp)' .
@c      (` p'  is ` fw_prob' , ` r'  is ` bw_factor' .) The new vertex
@c      cites ` x'  outgoing neighbors and ` y'  incoming neighbors of `
@c      v' , from those which are not yet cited by the new vertex. If
@c      there are less than ` x'  or ` y'  such vertices available then we
@c      cite all of them.

@c   2. The same procedure is applied to all the newly cited vertices.

@c    See also: Jure Leskovec, Jon Kleinberg and Christos Faloutsos.
@c Graphs over time: densification laws, shrinking diameters and possible
@c explanations.  _ KDD '05: Proceeding of the eleventh ACM SIGKDD
@c international conference on Knowledge discovery in data mining _,
@c 177-187, 2005.

@c    Note however, that the version of the model in the published paper
@c is incorrect in the sense that it cannot generate the kind of graphs
@c the authors claim. A corrected version is available from
@c http://www.cs.cmu.edu/~jure/pubs/powergrowth-tkdd.pdf, our
@c implementation is based on this.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `nodes':
@c      The number of vertices in the graph.

@c `fw_prob':
@c      The forward burning probability.

@c `bw_factor':
@c      The backward burning ratio. The backward burning probability is
@c      calculated as ` bw.factor*fw.prob' .

@c `pambs':
@c      The number of ambassador vertices.

@c `directed':
@c      Whether to create a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_rewire --- Randomly rewires a graph while preserving the degree distribution_,  Next: igraph_growing_random_game --- Generates a growing random graph_,  Prev: igraph_forest_fire_game --- Generates a network according to the forest fire game,  Up: Games; Randomized Graph Generators

@c 7.2.9 igraph_rewire -- Randomly rewires a graph while preserving the degree distribution.
@c -----------------------------------------------------------------------------------------


@c      int igraph_rewire(igraph_t *graph, igraph_integer_t n, igraph_rewiring_t mode);

@c    This function generates a new graph based on the original one by
@c randomly rewiring edges while preserving the original graph's degree
@c distribution.  Please note that the rewiring is done "in place", so no
@c new graph will be allocated. If you would like to keep the original
@c graph intact, use `igraph_copy()' (*note igraph_copy --- Creates an
@c exact [deep] copy of a graph_::) before.

@c    *Arguments:. *

@c `graph':
@c      The graph object to be rewired.

@c `n':
@c      Number of rewiring trials to perform.

@c `mode':
@c      The rewiring algorithm to be used. It can be one of the following:
@c      `IGRAPH_REWIRING_SIMPLE': simple rewiring algorithm which chooses
@c      two arbitrary edges in each step (namely (a,b) and (c,d)) and
@c      substitutes them with (a,d) and (c,b) if they don't exist.  Time
@c      complexity: TODO.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_EINVMODE'
@c           Invalid rewiring mode.

@c     `IGRAPH_EINVAL'
@c           Graph unsuitable for rewiring (e.g. it has less than 4 nodes
@c           in case of `IGRAPH_REWIRING_SIMPLE')

@c     `IGRAPH_ENOMEM'
@c           Not enough memory for temporary data.

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_growing_random_game --- Generates a growing random graph_,  Next: igraph_callaway_traits_game --- Simulate a growing network with vertex types_,  Prev: igraph_rewire --- Randomly rewires a graph while preserving the degree distribution_,  Up: Games; Randomized Graph Generators

@c 7.2.10 igraph_growing_random_game -- Generates a growing random graph.
@c ----------------------------------------------------------------------


@c      int igraph_growing_random_game(igraph_t *graph, igraph_integer_t n,
@c      			       igraph_integer_t m, igraph_bool_t directed,
@c      			       igraph_bool_t citation);

@c    This function simulates a growing random graph. In each discrete
@c time step a new vertex is added and a number of new edges are also
@c added. These graphs are known to be different from standard (not
@c growing) random graphs.

@c    *Arguments:. *

@c `graph':
@c      Uninitialized graph object.

@c `n':
@c      The number of vertices in the graph.

@c `m':
@c      The number of edges to add in a time step (ie. after adding a
@c      vertex).

@c `directed':
@c      Boolean, whether to generate a directed graph.

@c `citation':
@c      Boolean, if `TRUE', the edges always originate from the most
@c      recently added vertex.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid `n' or `m' parameter.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_callaway_traits_game --- Simulate a growing network with vertex types_,  Next: igraph_establishment_game --- Generates a graph with a simple growing model with vertex types_,  Prev: igraph_growing_random_game --- Generates a growing random graph_,  Up: Games; Randomized Graph Generators

@c 7.2.11 igraph_callaway_traits_game -- Simulate a growing network with vertex types.
@c -----------------------------------------------------------------------------------


@c      int igraph_callaway_traits_game (igraph_t *graph, igraph_integer_t nodes,
@c      				igraph_integer_t types, igraph_integer_t edges_per_step,
@c      				igraph_vector_t *type_dist,
@c      				igraph_matrix_t *pref_matrix,
@c      				igraph_bool_t directed);

@c    The different types of vertices prefer to connect other types of
@c vertices with a given probability.

@c    The simulation goes like this: in each discrete time step a new
@c vertex is added to the graph. The type of this vertex is generated
@c based on `type_dist'. Then two vertices are selected uniformly randomly
@c from the graph. The probability that they will be connected depends on
@c the types of these vertices and is taken from `pref_matrix'. Then
@c another two vertices are selected and this is repeated `edges_per_step'
@c times in each time step.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph.

@c `nodes':
@c      The number of nodes in the graph.

@c `types':
@c      Number of node types.

@c `edges_per_step':
@c      The number of edges to be add per time step.

@c `type_dist':
@c      Vector giving the distribution of the vertex types.

@c `pref_matrix':
@c      Matrix giving the connection probabilities for the vertex types.

@c `directed':
@c      Logical, whether to generate a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2.

@c    Time complexity: O(|V|e*log(|V|)), |V| is the number of vertices, e
@c is `edges_per_step'.

@c
@c File: igraph_reference_manual.info,  Node: igraph_establishment_game --- Generates a graph with a simple growing model with vertex types_,  Next: igraph_preference_game --- Generates a graph with vertex types and connection preferences,  Prev: igraph_callaway_traits_game --- Simulate a growing network with vertex types_,  Up: Games; Randomized Graph Generators

@c 7.2.12 igraph_establishment_game -- Generates a graph with a simple growing model with vertex types.
@c ----------------------------------------------------------------------------------------------------


@c      int igraph_establishment_game(igraph_t *graph, igraph_integer_t nodes,
@c      			      igraph_integer_t types, igraph_integer_t k,
@c      			      igraph_vector_t *type_dist,
@c      			      igraph_matrix_t *pref_matrix,
@c      			      igraph_bool_t directed);

@c    The simulation goes like this: a single vertex is added at each time
@c step. This new vertex tries to connect to `k' vertices in the graph.
@c The probability that such a connection is realized depends on the types
@c of the vertices involved.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph.

@c `nodes':
@c      The number of vertices in the graph.

@c `types':
@c      The number of vertex types.

@c `k':
@c      The number of connections tried in each time step.

@c `type_dist':
@c      Vector giving the distribution of vertex types.

@c `pref_matrix':
@c      Matrix giving the connection probabilities for different vertex
@c      types.

@c `directed':
@c      Logical, whether to generate a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2.

@c    Time complexity: O(|V|*k*log(|V|)), |V| is the number of vertices
@c and k is the `k' parameter.

@c
@c File: igraph_reference_manual.info,  Node: igraph_preference_game --- Generates a graph with vertex types and connection preferences,  Next: igraph_asymmetric_preference_game --- Generates a graph with asymmetric vertex types and connection preferences,  Prev: igraph_establishment_game --- Generates a graph with a simple growing model with vertex types_,  Up: Games; Randomized Graph Generators

@c 7.2.13 igraph_preference_game -- Generates a graph with vertex types and connection preferences
@c -----------------------------------------------------------------------------------------------


@c      int igraph_preference_game(igraph_t *graph, igraph_integer_t nodes,
@c      			   igraph_integer_t types,
@c      			   igraph_vector_t *type_dist,
@c      			   igraph_matrix_t *pref_matrix,
@c      			   igraph_vector_t *node_type_vec,
@c      			   igraph_bool_t directed,
@c      			   igraph_bool_t loops);

@c    This is practically the nongrowing variant of
@c `igraph_establishment_game' (*note igraph_establishment_game ---
@c Generates a graph with a simple growing model with vertex types_::) .
@c A given number of vertices are generated. Every vertex is assigned to a
@c vertex type according to the given type probabilities. Finally, every
@c vertex pair is evaluated and an edge is created between them with a
@c probability depending on the types of the vertices involved.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph.

@c `nodes':
@c      The number of vertices in the graph.

@c `types':
@c      The number of vertex types.

@c `type_dist':
@c      Vector giving the distribution of vertex types. If `NULL' , all
@c      vertex types will have equal probability.

@c `pref_matrix':
@c      Matrix giving the connection probabilities for different vertex
@c      types. This should be symmetric if the requested graph is
@c      undirected.

@c `node_type_vec':
@c      A vector where the individual generated vertex types will be
@c      stored. If `NULL' , the vertex types won't be saved.

@c `directed':
@c      Logical, whether to generate a directed graph. If undirected
@c      graphs are requested, only the lower left triangle of the
@c      preference matrix is considered.

@c `loops':
@c      Logical, whether loop edges are allowed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.3.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph.

@c    *See also:. *

@c `'
@c      igraph_establishment_game()

@c
@c File: igraph_reference_manual.info,  Node: igraph_asymmetric_preference_game --- Generates a graph with asymmetric vertex types and connection preferences,  Next: igraph_recent_degree_game --- Stochastic graph generator based on the number of adjacent edges a node has gained recently,  Prev: igraph_preference_game --- Generates a graph with vertex types and connection preferences,  Up: Games; Randomized Graph Generators

@c 7.2.14 igraph_asymmetric_preference_game -- Generates a graph with asymmetric vertex types and connection preferences
@c ---------------------------------------------------------------------------------------------------------------------


@c      int igraph_asymmetric_preference_game(igraph_t *graph, igraph_integer_t nodes,
@c      				      igraph_integer_t types,
@c      				      igraph_matrix_t *type_dist_matrix,
@c      				      igraph_matrix_t *pref_matrix,
@c      				      igraph_vector_t *node_type_in_vec,
@c      				      igraph_vector_t *node_type_out_vec,
@c      				      igraph_bool_t loops);

@c    This is the asymmetric variant of `igraph_preference_game()' (*note
@c igraph_preference_game --- Generates a graph with vertex types and
@c connection preferences::) .  A given number of vertices are generated.
@c Every vertex is assigned to an "incoming" and an "outgoing" vertex type
@c according to the given joint type probabilities. Finally, every vertex
@c pair is evaluated and a directed edge is created between them with a
@c probability depending on the "outgoing" type of the source vertex and
@c the "incoming" type of the target vertex.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph.

@c `nodes':
@c      The number of vertices in the graph.

@c `types':
@c      The number of vertex types.

@c `type_dist_matrix':
@c      Matrix giving the joint distribution of vertex types.  If null,
@c      incoming and outgoing vertex types are independent and uniformly
@c      distributed.

@c `pref_matrix':
@c      Matrix giving the connection probabilities for different vertex
@c      types.

@c `node_type_in_vec':
@c      A vector where the individual generated "incoming" vertex types
@c      will be stored. If NULL, the vertex types won't be saved.

@c `node_type_out_vec':
@c      A vector where the individual generated "outgoing" vertex types
@c      will be stored. If NULL, the vertex types won't be saved.

@c `loops':
@c      Logical, whether loop edges are allowed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.3.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph.

@c    *See also:. *

@c `'
@c      `igraph_preference_game()' (*note igraph_preference_game ---
@c      Generates a graph with vertex types and connection preferences::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_recent_degree_game --- Stochastic graph generator based on the number of adjacent edges a node has gained recently,  Next: igraph_barabasi_aging_game --- Preferential attachment with aging of vertices,  Prev: igraph_asymmetric_preference_game --- Generates a graph with asymmetric vertex types and connection preferences,  Up: Games; Randomized Graph Generators

@c 7.2.15 igraph_recent_degree_game -- Stochastic graph generator based on the number of adjacent edges a node has gained recently
@c -------------------------------------------------------------------------------------------------------------------------------


@c      int igraph_recent_degree_game(igraph_t *graph, igraph_integer_t n,
@c      			      igraph_real_t power,
@c      			      igraph_integer_t window,
@c      			      igraph_integer_t m,
@c      			      const igraph_vector_t *outseq,
@c      			      igraph_bool_t outpref,
@c      			      igraph_real_t zero_appeal,
@c      			      igraph_bool_t directed);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `n':
@c      The number of vertices in the graph, this is the same as the
@c      number of time steps.

@c `power':
@c      The exponent, the probability that a node gains a new edge is
@c      proportional to the number of edges it has gained recently (in the
@c      last `window' time steps) to `power'.

@c `window':
@c      Integer constant, the size of the time window to use to count the
@c      number of recent edges.

@c `m':
@c      Integer constant, the number of edges to add per time step if the
@c      `outseq' parameter is a null pointer or a zero-length vector.

@c `outseq':
@c      The number of edges to add in each time step. This argument is
@c      ignored if it is a null pointer or a zero length vector, is this
@c      case the constant `m' parameter is used.

@c `outpref':
@c      Logical constant, if true the edges originated by a vertex also
@c      count as recent adjacent edges. It is false in most cases.

@c `zero_appeal':
@c      Constant giving the attractiveness of the vertices which haven't
@c      gained any edge recently.

@c `directed':
@c      Logical constant, whether to generate a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|*log(|V|)+|E|), |V| is the number of vertices,
@c |E| is the number of edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_barabasi_aging_game --- Preferential attachment with aging of vertices,  Next: igraph_recent_degree_aging_game --- Preferential attachment based on the number of edges gained recently; with aging of vertices,  Prev: igraph_recent_degree_game --- Stochastic graph generator based on the number of adjacent edges a node has gained recently,  Up: Games; Randomized Graph Generators

@c 7.2.16 igraph_barabasi_aging_game -- Preferential attachment with aging of vertices
@c -----------------------------------------------------------------------------------


@c      int igraph_barabasi_aging_game(igraph_t *graph,
@c      			       igraph_integer_t nodes,
@c      			       igraph_integer_t m,
@c      			       const igraph_vector_t *outseq,
@c      			       igraph_bool_t outpref,
@c      			       igraph_real_t pa_exp,
@c      			       igraph_real_t aging_exp,
@c      			       igraph_integer_t aging_bin,
@c      			       igraph_real_t zero_deg_appeal,
@c      			       igraph_real_t zero_age_appeal,
@c      			       igraph_real_t deg_coef,
@c      			       igraph_real_t age_coef,
@c      			       igraph_bool_t directed);

@c    In this game, the probability that a node gains a new edge is given
@c by its (in-)degree (k) and age (l). This probability has a degree
@c dependent component multiplied by an age dependent component. The
@c degree dependent part is: `deg_coef' times k to the power of `pa_exp'
@c plus `zero_deg_appeal'; and the age dependent part is `age_coef' times
@c l to the power of `aging_exp' plus `zero_age_appeal'.

@c    The age is based on the number of vertices in the network and the
@c `aging_bin' argument: vertices grew one unit older after each
@c `aging_bin' vertices added to the network.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `nodes':
@c      The number of vertices in the graph.

@c `m':
@c      The number of edges to add in each time step. If the `outseq'
@c      argument is not a null vector and not a zero-length vector.

@c `outseq':
@c      The number of edges to add in each time step. If it is a null
@c      pointer or a zero-length vector then it is ignored and the `m'
@c      argument is used instead.

@c `outpref':
@c      Logical constant, whether the edges initiated by a vertex
@c      contribute to the probability to gain a new edge.

@c `pa_exp':
@c      The exponent of the preferential attachment, a small positive
@c      number usually, the value 1 yields the classic linear preferential
@c      attachment.

@c `aging_exp':
@c      The exponent of the aging, this is a negative number usually.

@c `aging_bin':
@c      Integer constant, the number of vertices to add before vertices in
@c      the network grew one unit older.

@c `zero_deg_appeal':
@c      The degree dependent part of the attractiveness of the zero degree
@c      vertices.

@c `zero_age_appeal':
@c      The age dependent part of the attractiveness of the vertices of
@c      age zero. This parameter is usually zero.

@c `deg_coef':
@c      The coefficient for the degree.

@c `age_coef':
@c      The coefficient for the age.

@c `directed':
@c      Logical constant, whether to generate a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O((|V|+|V|/aging_bin)*log(|V|)+|E|). |V| is the
@c number of vertices, |E| the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_recent_degree_aging_game --- Preferential attachment based on the number of edges gained recently; with aging of vertices,  Next: igraph_cited_type_game --- Simulate a citation based on vertex types_,  Prev: igraph_barabasi_aging_game --- Preferential attachment with aging of vertices,  Up: Games; Randomized Graph Generators

@c 7.2.17 igraph_recent_degree_aging_game -- Preferential attachment based on the number of edges gained recently, with aging of vertices
@c --------------------------------------------------------------------------------------------------------------------------------------


@c      int igraph_recent_degree_aging_game(igraph_t *graph,
@c      				    igraph_integer_t nodes,
@c      				    igraph_integer_t m,
@c      				    const igraph_vector_t *outseq,
@c      				    igraph_bool_t outpref,
@c      				    igraph_real_t pa_exp,
@c      				    igraph_real_t aging_exp,
@c      				    igraph_integer_t aging_bin,
@c      				    igraph_integer_t time_window,
@c      				    igraph_real_t zero_appeal,
@c      				    igraph_bool_t directed);

@c    This game is very similar to `igraph_barabasi_aging_game()' (*note
@c igraph_barabasi_aging_game --- Preferential attachment with aging of
@c vertices::), except that instead of the total number of adjacent edges
@c the number of edges gained in the last `time_window' time steps are
@c counted.

@c    The degree dependent part of the attractiveness is given by k to the
@c power of `pa_exp' plus `zero_appeal'; the age dependent part is l to
@c the power to `aging_exp'.  k is the number of edges gained in the last
@c `time_window' time steps, l is the age of the vertex.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `nodes':
@c      The number of vertices in the graph.

@c `m':
@c      The number of edges to add in each time step. If the `outseq'
@c      argument is not a null vector or a zero-length vector then it is
@c      ignored.

@c `outseq':
@c      Vector giving the number of edges to add in each time step. If it
@c      is a null pointer or a zero-length vector then it is ignored and
@c      the `m' argument is used.

@c `outpref':
@c      Logical constant, if true the edges initiated by a vertex are also
@c      counted. Normally it is false.

@c `pa_exp':
@c      The exponent for the preferential attachment.

@c `aging_exp':
@c      The exponent for the aging, normally it is negative: old vertices
@c      gain edges with less probability.

@c `aging_bin':
@c      Integer constant, gives the scale of the aging.  The age of the
@c      vertices is incremented by one after every `aging_bin' vertex
@c      added.

@c `time_window':
@c      The time window to use to count the number of adjacent edges for
@c      the vertices.

@c `zero_appeal':
@c      The degree dependent part of the attractiveness for zero degree
@c      vertices.

@c `directed':
@c      Logical constant, whether to create a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O((|V|+|V|/aging_bin)*log(|V|)+|E|). |V| is the
@c number of vertices, |E| the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cited_type_game --- Simulate a citation based on vertex types_,  Next: igraph_citing_cited_type_game --- Simulate a citation network based on vertex types_,  Prev: igraph_recent_degree_aging_game --- Preferential attachment based on the number of edges gained recently; with aging of vertices,  Up: Games; Randomized Graph Generators

@c 7.2.18 igraph_cited_type_game -- Simulate a citation based on vertex types.
@c ---------------------------------------------------------------------------


@c      int igraph_cited_type_game(igraph_t *graph, igraph_integer_t nodes,
@c      			   const igraph_vector_t *types,
@c      			   const igraph_vector_t *pref,
@c      			   igraph_integer_t edges_per_step,
@c      			   igraph_bool_t directed);

@c    Function to create a network based on some vertex categories. This
@c function creates a citation network, in each step a single vertex and
@c `edges_per_step' citating edges are added, nodes with different
@c categories (may) have different probabilities to get cited, as given by
@c the `pref' vector.

@c    Note that this function might generate networks with multiple edges
@c if `edges_per_step' is greater than one. You might want to call
@c `igraph_simplify()' (*note igraph_simplify --- Removes loop and/or
@c multiple edges from the graph_::) on the result to remove multiple
@c edges.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `nodes':
@c      The number of vertices in the network.

@c `types':
@c      Numeric vector giving the categories of the vertices, so it should
@c      contain `nodes' non-negative integer numbers. Types are numbered
@c      from zero.

@c `pref':
@c      The attractivity of the different vertex categories in a vector.
@c      Its length should be the maximum element in `types' plus one
@c      (types are numbered from zero).

@c `edges_per_step':
@c      Integer constant, the number of edges to add in each time step.

@c `directed':
@c      Logical constant, whether to create a directed network.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_citing_cited_type_game()' (*note
@c      igraph_citing_cited_type_game --- Simulate a citation network
@c      based on vertex types_::) for a bit more general game.

@c    Time complexity: O((|V|+|E|)log|V|), |V| and |E| are number of
@c vertices and edges, respectively.

@c
@c File: igraph_reference_manual.info,  Node: igraph_citing_cited_type_game --- Simulate a citation network based on vertex types_,  Prev: igraph_cited_type_game --- Simulate a citation based on vertex types_,  Up: Games; Randomized Graph Generators

@c 7.2.19 igraph_citing_cited_type_game -- Simulate a citation network based on vertex types.
@c ------------------------------------------------------------------------------------------


@c      int igraph_citing_cited_type_game(igraph_t *graph, igraph_integer_t nodes,
@c      				  const igraph_vector_t *types,
@c      				  const igraph_matrix_t *pref,
@c      				  igraph_integer_t edges_per_step,
@c      				  igraph_bool_t directed);

@c    This game is similar to `igraph_cited_type_game()' (*note
@c igraph_cited_type_game --- Simulate a citation based on vertex
@c types_::) but here the category of the citing vertex is also considered.

@c    An evolving citation network is modeled here, a single vertex and
@c its `edges_per_step' citation are added in each time step. The odds the
@c a given vertex is cited by the new vertex depends on the category of
@c both the citing and the cited vertex and is given in the `pref' matrix.
@c The categories of the citing vertex correspond to the rows, the
@c categories of the cited vertex to the columns of this matrix. Ie. the
@c element in row `i' and column `j' gives the probability that a `j'
@c vertex is cited, if the category of the citing vertex is `i'.

@c    Note that this function might generate networks with multiple edges
@c if `edges_per_step' is greater than one. You might want to call
@c `igraph_simplify()' (*note igraph_simplify --- Removes loop and/or
@c multiple edges from the graph_::) on the result to remove multiple
@c edges.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `nodes':
@c      The number of vertices in the network.

@c `types':
@c      A numeric matrix of length `nodes', containing the categories of
@c      the vertices. The categories are numbered from zero.

@c `pref':
@c      The preference matrix, a square matrix is required, both the
@c      number of rows and columns should be the maximum element in
@c      `types' plus one (types are numbered from zero).

@c `directed':
@c      Logical constant, whether to create a directed network.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O((|V|+|E|)log|V|), |V| and |E| are number of
@c vertices and edges, respectively.

@c
@c File: igraph_reference_manual.info,  Node: Vertex and Edge Selectors and Sequences; Iterators,  Next: Graph; Vertex and Edge Attributes,  Prev: Graph Generators,  Up: Top

@c 8 Vertex and Edge Selectors and Sequences, Iterators
@c ****************************************************

@c * Menu:

@c * About selectors, iterators: About selectors; iterators.
@c * Vertex selector constructors::
@c * Generic vertex selector operations::
@c * Immediate vertex selectors::
@c * Vertex iterators::
@c * Edge selector constructors::
@c * Immediate edge selectors::
@c * Generic edge selector operations::
@c * Edge iterators::

@c
@c File: igraph_reference_manual.info,  Node: About selectors; iterators,  Next: Vertex selector constructors,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.1 About selectors, iterators
@c ==============================

@c Everything about vertices and vertex selectors also applies to edges
@c and edge selectors unless explicitly noted otherwise.

@c    The vertex (and edge) selector notion was introduced in igraph 0.2,
@c and it is a way to reference to sequence of vertices or edges
@c independently of the graph.

@c    While this might sound quite mysterious, it is actually very simple.
@c For example all vertex of graph can be selected by `igraph_vs_all()'
@c (*note igraph_vs_all --- Vertex set; all vertices of a graph_::), and
@c the graph independence means that `igraph_vs_all()' (*note
@c igraph_vs_all --- Vertex set; all vertices of a graph_::) is not
@c parametrized by a graph object. Ie.  `igraph_vs_all()' (*note
@c igraph_vs_all --- Vertex set; all vertices of a graph_::) is the
@c _concept_ of selecting all vertices of a graph.

@c    This means that for determining the actual vertex id's implied by a
@c vertex selector it needs to be instantiated with a graph object, the
@c instantiation results a vertex iterator.

@c    Some vertex selectors have _immediate_ versions, these have prefix `
@c igraph_vss'  instead of ` igraph_vs' , eg.  `igraph_vss_all()' (*note
@c igraph_vss_all --- All vertices of a graph [immediate version]_::)
@c instead of `igraph_vs_all()' (*note igraph_vs_all --- Vertex set; all
@c vertices of a graph_::).  These immediate versions are to be used in
@c the parameter list of the igraph functions, like `igraph_degree()'
@c (*note igraph_degree --- The degree of some vertices in a graph_::).
@c These functions are not associated with any `igraph_vs_t' object, so
@c they have no separate constructors and destructors (destroy functions).

@c
@c File: igraph_reference_manual.info,  Node: Vertex selector constructors,  Next: Generic vertex selector operations,  Prev: About selectors; iterators,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.2 Vertex selector constructors
@c ================================

@c Vertex selectors are created by vertex selector constructors, can be
@c instantiated with `igraph_vit_create()' (*note igraph_vit_create ---
@c Creates a vertex iterator from a vertex selector_::), and are destroyed
@c with `igraph_vs_destroy()' (*note igraph_vs_destroy --- Destroy a
@c vertex set_::).

@c * Menu:

@c * igraph_vs_all --- Vertex set, all vertices of a graph.: igraph_vs_all --- Vertex set; all vertices of a graph_.
@c * igraph_vs_adj --- Adjacent vertices of a vertex.: igraph_vs_adj --- Adjacent vertices of a vertex_.
@c * igraph_vs_nonadj --- Non-adjacent vertices of a vertex::
@c * igraph_vs_none --- Empty vertex set.: igraph_vs_none --- Empty vertex set_.
@c * igraph_vs_1 --- Vertex set with a single vertex.: igraph_vs_1 --- Vertex set with a single vertex_.
@c * igraph_vs_vector --- Vertex set based on a vector.: igraph_vs_vector --- Vertex set based on a vector_.
@c * igraph_vs_vector_small --- Create a vertex set by giving its elements.: igraph_vs_vector_small --- Create a vertex set by giving its elements_.
@c * igraph_vs_seq --- Vertex set, an interval of vertices.: igraph_vs_seq --- Vertex set; an interval of vertices_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_all --- Vertex set; all vertices of a graph_,  Next: igraph_vs_adj --- Adjacent vertices of a vertex_,  Up: Vertex selector constructors

@c 8.2.1 igraph_vs_all -- Vertex set, all vertices of a graph.
@c -----------------------------------------------------------


@c      int igraph_vs_all(igraph_vs_t *vs);

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized `igraph_vs_t' object.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_vss_all()' (*note igraph_vss_all --- All vertices of a
@c      graph [immediate version]_::).

@c    This selector includes all vertices of a given graph in increasing
@c vertex id order.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_adj --- Adjacent vertices of a vertex_,  Next: igraph_vs_nonadj --- Non-adjacent vertices of a vertex,  Prev: igraph_vs_all --- Vertex set; all vertices of a graph_,  Up: Vertex selector constructors

@c 8.2.2 igraph_vs_adj -- Adjacent vertices of a vertex.
@c -----------------------------------------------------


@c      int igraph_vs_adj(igraph_vs_t *vs,
@c      		  igraph_integer_t vid, igraph_neimode_t mode);

@c    All neighboring vertices of a given vertex are selected by this
@c selector. The `mode' argument controls the type of the neighboring
@c vertices to be selected. The vertices are visited in increasing vertex
@c id order, as of igraph version 0.4.

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized vertex selector object.

@c `vid':
@c      Vertex id, the center of the neighborhood.

@c `mode':
@c      Decides the type of the neighborhood for directed graphs. Possible
@c      values: `IGRAPH_OUT',  all vertices to which there is a directed
@c      edge from `vid'.  `IGRAPH_IN', all vertices from which there is a
@c      directed edge from `vid'.  `IGRAPH_ALL', all vertices to which or
@c      from which there is a directed edge from/to `vid'.  This parameter
@c      is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_nonadj --- Non-adjacent vertices of a vertex,  Next: igraph_vs_none --- Empty vertex set_,  Prev: igraph_vs_adj --- Adjacent vertices of a vertex_,  Up: Vertex selector constructors

@c 8.2.3 igraph_vs_nonadj -- Non-adjacent vertices of a vertex
@c -----------------------------------------------------------


@c      int igraph_vs_nonadj(igraph_vs_t *vs, igraph_integer_t vid,
@c      		     igraph_neimode_t mode);

@c    All non-neighboring vertices of a given vertex. The `mode' argument
@c controls the type of neighboring vertics _not_ to select.

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized vertex selector object.

@c `vid':
@c      Vertex id, the `center' of the non-neighborhood.

@c `mode':
@c      The type of neighborhood not to select in directed graphs.
@c      Possible values: `IGRAPH_OUT', all vertices will be selected
@c      except those to which there is a directed edge from `vid'.
@c      `IGRAPH_IN', all vertices will be selected except those from which
@c      there is a directed edge to `vid'.  `IGRAPH_ALL', all vertices
@c      will be selected exvept those from or to which there is a directed
@c      edge to or from `vid'.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_none --- Empty vertex set_,  Next: igraph_vs_1 --- Vertex set with a single vertex_,  Prev: igraph_vs_nonadj --- Non-adjacent vertices of a vertex,  Up: Vertex selector constructors

@c 8.2.4 igraph_vs_none -- Empty vertex set.
@c -----------------------------------------


@c      int igraph_vs_none(igraph_vs_t *vs);

@c    Creates an empty vertex selector.

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized vertex selector object.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_vss_none' (*note igraph_vss_none --- Empty vertex set
@c      [immediate version]_::).

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_1 --- Vertex set with a single vertex_,  Next: igraph_vs_vector --- Vertex set based on a vector_,  Prev: igraph_vs_none --- Empty vertex set_,  Up: Vertex selector constructors

@c 8.2.5 igraph_vs_1 -- Vertex set with a single vertex.
@c -----------------------------------------------------


@c      int igraph_vs_1(igraph_vs_t *vs, igraph_integer_t vid);

@c    This vertex selector selects a single vertex.

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized vertex selector object.

@c `vid':
@c      The vertex id to be selected.

@c    *Returns:. *

@c `'
@c      Error Code.

@c    *See also:. *

@c `'
@c      `igraph_vss_1()' (*note igraph_vss_1 --- Vertex set with a single
@c      vertex [immediate version]::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_vector --- Vertex set based on a vector_,  Next: igraph_vs_vector_small --- Create a vertex set by giving its elements_,  Prev: igraph_vs_1 --- Vertex set with a single vertex_,  Up: Vertex selector constructors

@c 8.2.6 igraph_vs_vector -- Vertex set based on a vector.
@c -------------------------------------------------------


@c      int igraph_vs_vector(igraph_vs_t *vs,
@c      		     const igraph_vector_t *v);

@c    This function makes it possible to handle a `vector_t' temporarily
@c as a vertex selector. The vertex selector should be thought of like a
@c _view_ to the vector. If you make changes to the vector that also
@c affects the vertex selector. Destroying the vertex selector does not
@c destroy the vector. (Of course.) Do not destroy the vector before
@c destroying the vertex selector, or you might get strange behavior.

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized vertex selector.

@c `v':
@c      Pointer to a `igraph_vector_t' object.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_vss_vector()' (*note igraph_vss_vector --- Vertex set
@c      based on a vector [immediate version]_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_vector_small --- Create a vertex set by giving its elements_,  Next: igraph_vs_seq --- Vertex set; an interval of vertices_,  Prev: igraph_vs_vector --- Vertex set based on a vector_,  Up: Vertex selector constructors

@c 8.2.7 igraph_vs_vector_small -- Create a vertex set by giving its elements.
@c ---------------------------------------------------------------------------


@c      int igraph_vs_vector_small(igraph_vs_t *vs, ...);

@c    This function can be used to create a vertex selector with a couple
@c of vertices. Do not forget to include a ` -1'  after the last vertex
@c id, the behavior of the function is undefined if you don't use a ` -1'
@c properly.

@c    Note that the vertex ids supplied will be parsed as ` int' 's so you
@c cannot supply arbitrarily large (too large for int) vertex ids here.

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized vertex selector object.

@c `...':
@c      Additional parameters, these will be the vertex ids to be included
@c      in the vertex selector. Supply a ` -1' after the last vertex id.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), the number of vertex ids supplied.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_seq --- Vertex set; an interval of vertices_,  Prev: igraph_vs_vector_small --- Create a vertex set by giving its elements_,  Up: Vertex selector constructors

@c 8.2.8 igraph_vs_seq -- Vertex set, an interval of vertices.
@c -----------------------------------------------------------


@c      int igraph_vs_seq(igraph_vs_t *vs,
@c      		  igraph_integer_t from, igraph_integer_t to);

@c    Creates a vertex selector containing all vertices with vertex id
@c equal to or bigger than `from' and equal to or smaller than `to'.

@c    *Arguments:. *

@c `vs':
@c      Pointer to an uninitialized vertex selector object.

@c `from':
@c      The first vertex id to be included in the vertex selector.

@c `to':
@c      The last vertex id to be included in the vertex selector.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_vss_seq()' (*note igraph_vss_seq --- An interval of
@c      vertices [immediate version]_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Generic vertex selector operations,  Next: Immediate vertex selectors,  Prev: Vertex selector constructors,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.3 Generic vertex selector operations
@c ======================================

@c * Menu:

@c * igraph_vs_destroy --- Destroy a vertex set.: igraph_vs_destroy --- Destroy a vertex set_.
@c * igraph_vs_is_all --- Check whether all vertices are included.: igraph_vs_is_all --- Check whether all vertices are included_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_destroy --- Destroy a vertex set_,  Next: igraph_vs_is_all --- Check whether all vertices are included_,  Up: Generic vertex selector operations

@c 8.3.1 igraph_vs_destroy -- Destroy a vertex set.
@c ------------------------------------------------


@c      void igraph_vs_destroy(igraph_vs_t *vs);

@c    This function should be called for all vertex selectors when they
@c are not needed. The memory allocated for the vertex selector will be
@c deallocated. Do not call this function on vertex selectors created with
@c the immediate versions of the vertex selector constructors (starting
@c with ` igraph_vss' ).

@c    *Arguments:. *

@c `vs':
@c      Pointer to a vertex selector object.

@c    Time complecity: operating system dependent, usually O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vs_is_all --- Check whether all vertices are included_,  Prev: igraph_vs_destroy --- Destroy a vertex set_,  Up: Generic vertex selector operations

@c 8.3.2 igraph_vs_is_all -- Check whether all vertices are included.
@c ------------------------------------------------------------------


@c      igraph_bool_t igraph_vs_is_all(const igraph_vs_t *vs);

@c    This function checks whether the vertex selector object was created
@c by `igraph_vs_all()' (*note igraph_vs_all --- Vertex set; all vertices
@c of a graph_::) of `igraph_vss_all()' (*note igraph_vss_all --- All
@c vertices of a graph [immediate version]_::). Note that the vertex
@c selector might contain all vertices in a given graph but if it wasn't
@c created by the two constructors mentioned here the return value will be
@c FALSE.

@c    *Arguments:. *

@c `vs':
@c      Pointer to a vertex selector object.

@c    *Returns:. *

@c `'
@c      TRUE (1) if the vertex selector contains all vertices and FALSE
@c      (1) otherwise.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Immediate vertex selectors,  Next: Vertex iterators,  Prev: Generic vertex selector operations,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.4 Immediate vertex selectors
@c ==============================

@c * Menu:

@c * igraph_vss_all --- All vertices of a graph (immediate version).: igraph_vss_all --- All vertices of a graph [immediate version]_.
@c * igraph_vss_none --- Empty vertex set (immediate version).: igraph_vss_none --- Empty vertex set [immediate version]_.
@c * igraph_vss_1 --- Vertex set with a single vertex (immediate version): igraph_vss_1 --- Vertex set with a single vertex [immediate version].
@c * igraph_vss_vector --- Vertex set based on a vector (immediate version).: igraph_vss_vector --- Vertex set based on a vector [immediate version]_.
@c * igraph_vss_seq --- An interval of vertices (immediate version).: igraph_vss_seq --- An interval of vertices [immediate version]_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vss_all --- All vertices of a graph [immediate version]_,  Next: igraph_vss_none --- Empty vertex set [immediate version]_,  Up: Immediate vertex selectors

@c 8.4.1 igraph_vss_all -- All vertices of a graph (immediate version).
@c --------------------------------------------------------------------


@c      igraph_vs_t igraph_vss_all(void);

@c    Immediate vertex selector for all vertices in a graph. It can be
@c used conveniently when some vertex property (eg. betweenness, degree,
@c etc.) should be calculated for all vertices.

@c    *Returns:. *

@c `'
@c      A vertex selector for all vertices in a graph.

@c    *See also:. *

@c `'
@c      `igraph_vs_all()' (*note igraph_vs_all --- Vertex set; all
@c      vertices of a graph_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vss_none --- Empty vertex set [immediate version]_,  Next: igraph_vss_1 --- Vertex set with a single vertex [immediate version],  Prev: igraph_vss_all --- All vertices of a graph [immediate version]_,  Up: Immediate vertex selectors

@c 8.4.2 igraph_vss_none -- Empty vertex set (immediate version).
@c --------------------------------------------------------------


@c      igraph_vs_t igraph_vss_none(void);

@c    The immediate version of the empty vertex selector.

@c    *Returns:. *

@c `'
@c      An empty vertex selector.

@c    *See also:. *

@c `'
@c      `igraph_vs_none()' (*note igraph_vs_none --- Empty vertex set_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vss_1 --- Vertex set with a single vertex [immediate version],  Next: igraph_vss_vector --- Vertex set based on a vector [immediate version]_,  Prev: igraph_vss_none --- Empty vertex set [immediate version]_,  Up: Immediate vertex selectors

@c 8.4.3 igraph_vss_1 -- Vertex set with a single vertex (immediate version)
@c -------------------------------------------------------------------------


@c      igraph_vs_t igraph_vss_1(igraph_integer_t vid);

@c    The immediate version of the single-vertex selector.

@c    *Arguments:. *

@c `vid':
@c      The vertex to be selected.

@c    *Returns:. *

@c `'
@c      A vertex selector containing a single vertex.

@c    *See also:. *

@c `'
@c      `igraph_vs_1()' (*note igraph_vs_1 --- Vertex set with a single
@c      vertex_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vss_vector --- Vertex set based on a vector [immediate version]_,  Next: igraph_vss_seq --- An interval of vertices [immediate version]_,  Prev: igraph_vss_1 --- Vertex set with a single vertex [immediate version],  Up: Immediate vertex selectors

@c 8.4.4 igraph_vss_vector -- Vertex set based on a vector (immediate version).
@c ----------------------------------------------------------------------------


@c      igraph_vs_t igraph_vss_vector(const igraph_vector_t *v);

@c    This is the immediate version of `igraph_vs_vector' (*note
@c igraph_vs_vector --- Vertex set based on a vector_::).

@c    *Arguments:. *

@c `v':
@c      Pointer to a `igraph_vector_t' object.

@c    *Returns:. *

@c `'
@c      A vertex selector object containing the vertices in the vector.

@c    *See also:. *

@c `'
@c      `igraph_vs_vector()' (*note igraph_vs_vector --- Vertex set based
@c      on a vector_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vss_seq --- An interval of vertices [immediate version]_,  Prev: igraph_vss_vector --- Vertex set based on a vector [immediate version]_,  Up: Immediate vertex selectors

@c 8.4.5 igraph_vss_seq -- An interval of vertices (immediate version).
@c --------------------------------------------------------------------


@c      igraph_vs_t igraph_vss_seq(igraph_integer_t from, igraph_integer_t to);

@c    The immediate version of `igraph_vs_seq()' (*note igraph_vs_seq ---
@c Vertex set; an interval of vertices_::).

@c    *Arguments:. *

@c `from':
@c      The first vertex id to be included in the vertex selector.

@c `to':
@c      The last vertex id to be included in the vertex selector.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_vs_seq()' (*note igraph_vs_seq --- Vertex set; an interval
@c      of vertices_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Vertex iterators,  Next: Edge selector constructors,  Prev: Immediate vertex selectors,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.5 Vertex iterators
@c ====================

@c * Menu:

@c * igraph_vit_create --- Creates a vertex iterator from a vertex selector.: igraph_vit_create --- Creates a vertex iterator from a vertex selector_.
@c * igraph_vit_destroy --- Destroys a vertex iterator.: igraph_vit_destroy --- Destroys a vertex iterator_.
@c * Stepping over the vertices::
@c * IGRAPH_VIT_NEXT --- Next vertex.: IGRAPH_VIT_NEXT --- Next vertex_.
@c * IGRAPH_VIT_END --- Are we at the end?::
@c * IGRAPH_VIT_SIZE --- Size of a vertex iterator.: IGRAPH_VIT_SIZE --- Size of a vertex iterator_.
@c * IGRAPH_VIT_RESET --- Reset a vertex iterator.: IGRAPH_VIT_RESET --- Reset a vertex iterator_.
@c * IGRAPH_VIT_GET --- Query the current position.: IGRAPH_VIT_GET --- Query the current position_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vit_create --- Creates a vertex iterator from a vertex selector_,  Next: igraph_vit_destroy --- Destroys a vertex iterator_,  Up: Vertex iterators

@c 8.5.1 igraph_vit_create -- Creates a vertex iterator from a vertex selector.
@c ----------------------------------------------------------------------------


@c      int igraph_vit_create(const igraph_t *graph,
@c      		      igraph_vs_t vs, igraph_vit_t *vit);

@c    This function instantiates a vertex selector object with a given
@c graph. This is the step when the actual vertex ids are created from the
@c _logical_ notion of the vertex selector based on the graph.  Eg. a
@c vertex selector created with `igraph_vs_all()' (*note igraph_vs_all ---
@c Vertex set; all vertices of a graph_::) contains knowledge that _all_
@c vertices are included in a (yet indefinite) graph. When instantiating
@c it a vertex iterator object is created, this contains the actual vertex
@c ids in the graph supplied as a parameter.

@c    The same vertex selector object can be used to instantiate any
@c number vertex iterators.

@c    *Arguments:. *

@c `graph':
@c      An `igraph_t' object, a graph.

@c `vs':
@c      A vertex selector object.

@c `vit':
@c      Pointer to an uninitialized vertex iterator object.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_vit_destroy()' (*note igraph_vit_destroy --- Destroys a
@c      vertex iterator_::).

@c    Time complexity: it depends on the vertex selector type. O(1) for
@c vertex selectors created with `igraph_vs_all()' (*note igraph_vs_all
@c --- Vertex set; all vertices of a graph_::), `igraph_vs_none()' (*note
@c igraph_vs_none --- Empty vertex set_::), `igraph_vs_1' (*note
@c igraph_vs_1 --- Vertex set with a single vertex_::), `igraph_vs_vector'
@c (*note igraph_vs_vector --- Vertex set based on a vector_::),
@c `igraph_vs_seq()' (*note igraph_vs_seq --- Vertex set; an interval of
@c vertices_::), `igraph_vs_vector()' (*note igraph_vs_vector --- Vertex
@c set based on a vector_::), `igraph_vs_vector_small()' (*note
@c igraph_vs_vector_small --- Create a vertex set by giving its
@c elements_::). O(d) for `igraph_vs_adj()' (*note igraph_vs_adj ---
@c Adjacent vertices of a vertex_::), d is the number of vertex ids to be
@c included in the iterator. O(|V|) for `igraph_vs_nonadj()' (*note
@c igraph_vs_nonadj --- Non-adjacent vertices of a vertex::), |V| is the
@c number of vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_vit_destroy --- Destroys a vertex iterator_,  Next: Stepping over the vertices,  Prev: igraph_vit_create --- Creates a vertex iterator from a vertex selector_,  Up: Vertex iterators

@c 8.5.2 igraph_vit_destroy -- Destroys a vertex iterator.
@c -------------------------------------------------------


@c      void igraph_vit_destroy(const igraph_vit_t *vit);

@c    Deallocates memory allocated for a vertex iterator.

@c    *Arguments:. *

@c `vit':
@c      Pointer to an initialized vertex iterator object.

@c    *See also:. *

@c `'
@c      `igraph_vit_create()' (*note igraph_vit_create --- Creates a
@c      vertex iterator from a vertex selector_::)

@c    Time complexity: operating system dependent, usually O(1).

@c
@c File: igraph_reference_manual.info,  Node: Stepping over the vertices,  Next: IGRAPH_VIT_NEXT --- Next vertex_,  Prev: igraph_vit_destroy --- Destroys a vertex iterator_,  Up: Vertex iterators

@c 8.5.3 Stepping over the vertices
@c --------------------------------

@c After creating an iterator with `igraph_vit_create()' (*note
@c igraph_vit_create --- Creates a vertex iterator from a vertex
@c selector_::), it points to the first vertex in the vertex determined by
@c the vertex selector (if there is any). The `IGRAPH_VIT_NEXT()' (*note
@c IGRAPH_VIT_NEXT --- Next vertex_::) macro steps to the next vertex,
@c `IGRAPH_VIT_END()' (*note IGRAPH_VIT_END --- Are we at the end?::)
@c checks whether there are more vertices to visit, `IGRAPH_VIT_SIZE()'
@c (*note IGRAPH_VIT_SIZE --- Size of a vertex iterator_::) gives the
@c total size of the vertices visited so far and to be visited.
@c `IGRAPH_VIT_RESET()' (*note IGRAPH_VIT_RESET --- Reset a vertex
@c iterator_::) resets the iterator, it will point to the first vertex
@c again. Finally `IGRAPH_VIT_GET()' (*note IGRAPH_VIT_GET --- Query the
@c current position_::) gives the current vertex pointed by the iterator
@c (call this only if `IGRAPH_VIT_END()' (*note IGRAPH_VIT_END --- Are we
@c at the end?::) is false).

@c    Here is an example on how to step over the neighbors of vertex 0:


@c      igraph_vs_t vs;
@c      igraph_vit_t vit;
@c      ...
@c      igraph_vs_adj(&vs, 0, IGRAPH_ALL);
@c      igraph_vit_create(&graph, vs, &vit);
@c      while (!IGRAPH_VIT_END(vit)) {
@c        printf(" %li", (long int) IGRAPH_VIT_GET(vit));
@c        IGRAPH_VIT_NEXT(vit);
@c      }
@c      printf("\n");
@c      ...
@c      igraph_vit_destroy(&vit);
@c      igraph_vs_destroy(&vs);

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_VIT_NEXT --- Next vertex_,  Next: IGRAPH_VIT_END --- Are we at the end?,  Prev: Stepping over the vertices,  Up: Vertex iterators

@c 8.5.4 IGRAPH_VIT_NEXT -- Next vertex.
@c -------------------------------------


@c      #define IGRAPH_VIT_NEXT(vit)

@c    Steps the iterator to the next vertex. Only call this function if
@c `IGRAPH_VIT_END()' (*note IGRAPH_VIT_END --- Are we at the end?::)
@c returns false.

@c    *Arguments:. *

@c `vit':
@c      The vertex iterator to step.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_VIT_END --- Are we at the end?,  Next: IGRAPH_VIT_SIZE --- Size of a vertex iterator_,  Prev: IGRAPH_VIT_NEXT --- Next vertex_,  Up: Vertex iterators

@c 8.5.5 IGRAPH_VIT_END -- Are we at the end?
@c ------------------------------------------


@c      #define IGRAPH_VIT_END(vit)

@c    Checks whether there are more vertices to step to.

@c    *Arguments:. *

@c `vit':
@c      The vertex iterator to check.

@c    *Returns:. *

@c `'
@c      Logical value, if true there are no more vertices to step to.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_VIT_SIZE --- Size of a vertex iterator_,  Next: IGRAPH_VIT_RESET --- Reset a vertex iterator_,  Prev: IGRAPH_VIT_END --- Are we at the end?,  Up: Vertex iterators

@c 8.5.6 IGRAPH_VIT_SIZE -- Size of a vertex iterator.
@c ---------------------------------------------------


@c      #define IGRAPH_VIT_SIZE(vit)

@c    Gives the number of vertices in a vertex iterator.

@c    *Arguments:. *

@c `vit':
@c      The vertex iterator.

@c    *Returns:. *

@c `'
@c      The number of vertices.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_VIT_RESET --- Reset a vertex iterator_,  Next: IGRAPH_VIT_GET --- Query the current position_,  Prev: IGRAPH_VIT_SIZE --- Size of a vertex iterator_,  Up: Vertex iterators

@c 8.5.7 IGRAPH_VIT_RESET -- Reset a vertex iterator.
@c --------------------------------------------------


@c      #define IGRAPH_VIT_RESET(vit)

@c    Resets a vertex iterator. After calling this macro the iterator will
@c point to the first vertex.

@c    *Arguments:. *

@c `vit':
@c      The vertex iterator.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_VIT_GET --- Query the current position_,  Prev: IGRAPH_VIT_RESET --- Reset a vertex iterator_,  Up: Vertex iterators

@c 8.5.8 IGRAPH_VIT_GET -- Query the current position.
@c ---------------------------------------------------


@c      #define IGRAPH_VIT_GET(vit)

@c    Gives the vertex id of the current vertex poited to by the iterator.

@c    *Arguments:. *

@c `vit':
@c      The vertex iterator.

@c    *Returns:. *

@c `'
@c      The vertex id of the current vertex.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Edge selector constructors,  Next: Immediate edge selectors,  Prev: Vertex iterators,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.6 Edge selector constructors
@c ==============================

@c * Menu:

@c * igraph_es_all --- Edge set, all edges.: igraph_es_all --- Edge set; all edges_.
@c * igraph_es_adj --- Adjacent edges of a vertex.: igraph_es_adj --- Adjacent edges of a vertex_.
@c * igraph_es_none --- Empty edge selector.: igraph_es_none --- Empty edge selector_.
@c * igraph_es_1 --- Edge selector containing a single edge.: igraph_es_1 --- Edge selector containing a single edge_.
@c * igraph_es_vector --- Handle a vector as an edge selector.: igraph_es_vector --- Handle a vector as an edge selector_.
@c * igraph_es_fromto --- Edge selector, all edges between two vertex sets.: igraph_es_fromto --- Edge selector; all edges between two vertex sets_.
@c * igraph_es_seq --- Edge selector, a sequence of edge ids.: igraph_es_seq --- Edge selector; a sequence of edge ids_.
@c * igraph_es_pairs --- Edge selector, multiple edges defined by their endpoints in a vector: igraph_es_pairs --- Edge selector; multiple edges defined by their endpoints in a vector.
@c * igraph_es_pairs_small --- Edge selector, multiple edges defined by their endpoints as arguments: igraph_es_pairs_small --- Edge selector; multiple edges defined by their endpoints as arguments.

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_all --- Edge set; all edges_,  Next: igraph_es_adj --- Adjacent edges of a vertex_,  Up: Edge selector constructors

@c 8.6.1 igraph_es_all -- Edge set, all edges.
@c -------------------------------------------


@c      int igraph_es_all(igraph_es_t *es,
@c      		  igraph_edgeorder_type_t order);

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector object.

@c `order':
@c      Constant giving the order in which the edges will be included in
@c      the selector. Possible values: `IGRAPH_EDGEORDER_ID', edge id
@c      order.  `IGRAPH_EDGEORDER_FROM', vertex id order, the id of the
@c      _source_ vertex counts for directed graphs. The order of the
@c      adjacent edges of a given vertex is arbitrary.
@c      `IGRAPH_EDGEORDER_TO', vertex id order, the id of the _target_
@c      vertex counts for directed graphs. The order of the adjacent edges
@c      of a given vertex is arbitrary.  For undirected graph the latter
@c      two is the same.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_ess_all()' (*note igraph_ess_all --- Edge set; all edges
@c      [immediate version]::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_adj --- Adjacent edges of a vertex_,  Next: igraph_es_none --- Empty edge selector_,  Prev: igraph_es_all --- Edge set; all edges_,  Up: Edge selector constructors

@c 8.6.2 igraph_es_adj -- Adjacent edges of a vertex.
@c --------------------------------------------------


@c      int igraph_es_adj(igraph_es_t *es,
@c      		  igraph_integer_t vid, igraph_neimode_t mode);

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector object.

@c `vid':
@c      Vertex id, of which the adjacent edges will be selected.

@c `mode':
@c      Constant giving the type of the adjacent edges to select. This is
@c      ignored for undirected graphs. Possible values: `IGRAPH_OUT',
@c      outgoing edges `IGRAPH_IN', incoming edges `IGRAPH_ALL', all edges

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_none --- Empty edge selector_,  Next: igraph_es_1 --- Edge selector containing a single edge_,  Prev: igraph_es_adj --- Adjacent edges of a vertex_,  Up: Edge selector constructors

@c 8.6.3 igraph_es_none -- Empty edge selector.
@c --------------------------------------------


@c      int igraph_es_none(igraph_es_t *es);

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector object to initialize.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_ess_none()' (*note igraph_ess_none --- Immediate empty
@c      edge selector_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_1 --- Edge selector containing a single edge_,  Next: igraph_es_vector --- Handle a vector as an edge selector_,  Prev: igraph_es_none --- Empty edge selector_,  Up: Edge selector constructors

@c 8.6.4 igraph_es_1 -- Edge selector containing a single edge.
@c ------------------------------------------------------------


@c      int igraph_es_1(igraph_es_t *es, igraph_integer_t eid);

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector object.

@c `eid':
@c      Edge id of the edge to select.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_ess_1()' (*note igraph_ess_1 --- Immediate version of the
@c      single edge edge selector_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_vector --- Handle a vector as an edge selector_,  Next: igraph_es_fromto --- Edge selector; all edges between two vertex sets_,  Prev: igraph_es_1 --- Edge selector containing a single edge_,  Up: Edge selector constructors

@c 8.6.5 igraph_es_vector -- Handle a vector as an edge selector.
@c --------------------------------------------------------------


@c      int igraph_es_vector(igraph_es_t *es,
@c      		     const igraph_vector_t *v);

@c    Creates an edge selector which serves as a view to a vector
@c containing edge ids. Do not destroy the vector before destroying the
@c view.  Many views can be created to the same vector.

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector.

@c `v':
@c      Vector containing edge ids.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_ess_vector()' (*note igraph_ess_vector --- Immediate
@c      vector view edge selector_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_fromto --- Edge selector; all edges between two vertex sets_,  Next: igraph_es_seq --- Edge selector; a sequence of edge ids_,  Prev: igraph_es_vector --- Handle a vector as an edge selector_,  Up: Edge selector constructors

@c 8.6.6 igraph_es_fromto -- Edge selector, all edges between two vertex sets.
@c ---------------------------------------------------------------------------


@c      int igraph_es_fromto(igraph_es_t *es,
@c      		     igraph_vs_t from, igraph_vs_t to);

@c    This function is not implemented yet.

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector.

@c `from':
@c      Vertex selector, their outgoing edges will be selected.

@c `to':
@c      Vertex selector, their incoming edges will be selected from the
@c      previous selection.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_seq --- Edge selector; a sequence of edge ids_,  Next: igraph_es_pairs --- Edge selector; multiple edges defined by their endpoints in a vector,  Prev: igraph_es_fromto --- Edge selector; all edges between two vertex sets_,  Up: Edge selector constructors

@c 8.6.7 igraph_es_seq -- Edge selector, a sequence of edge ids.
@c -------------------------------------------------------------


@c      int igraph_es_seq(igraph_es_t *es,
@c      		  igraph_integer_t from, igraph_integer_t to);

@c    All edge ids between ` from'  and ` to'  will be included in the
@c edge selection.

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector object.

@c `from':
@c      The first edge id to be included.

@c `to':
@c      The last edge id to be included.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_ess_seq()' (*note igraph_ess_seq --- Immediate version of
@c      the sequence edge selector_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_pairs --- Edge selector; multiple edges defined by their endpoints in a vector,  Next: igraph_es_pairs_small --- Edge selector; multiple edges defined by their endpoints as arguments,  Prev: igraph_es_seq --- Edge selector; a sequence of edge ids_,  Up: Edge selector constructors

@c 8.6.8 igraph_es_pairs -- Edge selector, multiple edges defined by their endpoints in a vector
@c ---------------------------------------------------------------------------------------------


@c      int igraph_es_pairs(igraph_es_t *es, const igraph_vector_t *v,
@c      		    igraph_bool_t directed);

@c    The edges between the given pairs of vertices will be included in the
@c edge selection. The vertex pairs must be defined in the vector ` v' ,
@c the first element of the vector is the first vertex of the first edge
@c to be selected, the second element is the second vertex of the first
@c edge, the third element is the first vertex of the second edge and so
@c on.

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector object.

@c `v':
@c      The vector containing the endpoints of the edges.

@c `directed':
@c      Whether the graph is directed or not.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_es_pairs_small()' (*note igraph_es_pairs_small --- Edge
@c      selector; multiple edges defined by their endpoints as arguments::)

@c    Time complexity: O(n), the number of edges being selected.

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_pairs_small --- Edge selector; multiple edges defined by their endpoints as arguments,  Prev: igraph_es_pairs --- Edge selector; multiple edges defined by their endpoints in a vector,  Up: Edge selector constructors

@c 8.6.9 igraph_es_pairs_small -- Edge selector, multiple edges defined by their endpoints as arguments
@c ----------------------------------------------------------------------------------------------------


@c      int igraph_es_pairs_small(igraph_es_t *es, igraph_bool_t directed, ...);

@c    The edges between the given pairs of vertices will be included in the
@c edge selection. The vertex pairs must be given as the arguments of the
@c function call, the third argument is the first vertex of the first edge,
@c the fourth argument is the second vertex of the first edge, the fifth
@c is the first vertex of the second edge and so on. The last element of
@c the argument list must be -1 to denote the end of the argument list.

@c    *Arguments:. *

@c `es':
@c      Pointer to an uninitialized edge selector object.

@c `directed':
@c      Whether the graph is directed or not.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_es_pairs()' (*note igraph_es_pairs --- Edge selector;
@c      multiple edges defined by their endpoints in a vector::)

@c    Time complexity: O(n), the number of edges being selected.

@c
@c File: igraph_reference_manual.info,  Node: Immediate edge selectors,  Next: Generic edge selector operations,  Prev: Edge selector constructors,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.7 Immediate edge selectors
@c ============================

@c * Menu:

@c * igraph_ess_all --- Edge set, all edges (immediate version): igraph_ess_all --- Edge set; all edges [immediate version].
@c * igraph_ess_none --- Immediate empty edge selector.: igraph_ess_none --- Immediate empty edge selector_.
@c * igraph_ess_1 --- Immediate version of the single edge edge selector.: igraph_ess_1 --- Immediate version of the single edge edge selector_.
@c * igraph_ess_vector --- Immediate vector view edge selector.: igraph_ess_vector --- Immediate vector view edge selector_.
@c * igraph_ess_seq --- Immediate version of the sequence edge selector.: igraph_ess_seq --- Immediate version of the sequence edge selector_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_ess_all --- Edge set; all edges [immediate version],  Next: igraph_ess_none --- Immediate empty edge selector_,  Up: Immediate edge selectors

@c 8.7.1 igraph_ess_all -- Edge set, all edges (immediate version)
@c ---------------------------------------------------------------


@c      igraph_es_t igraph_ess_all(igraph_edgeorder_type_t order);

@c    The immediate version of the all-vertices selector.

@c    *Arguments:. *

@c `order':
@c      Constant giving the order of the edges in the edge selector. See
@c      `igraph_es_all()' (*note igraph_es_all --- Edge set; all edges_::)
@c      for the possible values.

@c    *Returns:. *

@c `'
@c      The edge selector.

@c    *See also:. *

@c `'
@c      `igraph_es_all()' (*note igraph_es_all --- Edge set; all edges_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_ess_none --- Immediate empty edge selector_,  Next: igraph_ess_1 --- Immediate version of the single edge edge selector_,  Prev: igraph_ess_all --- Edge set; all edges [immediate version],  Up: Immediate edge selectors

@c 8.7.2 igraph_ess_none -- Immediate empty edge selector.
@c -------------------------------------------------------


@c      igraph_es_t igraph_ess_none(void);

@c    Immediate version of the empty edge selector.

@c    *Returns:. *

@c `'
@c      Initialized empty edge selector.

@c    *See also:. *

@c `'
@c      `igraph_es_none()' (*note igraph_es_none --- Empty edge
@c      selector_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_ess_1 --- Immediate version of the single edge edge selector_,  Next: igraph_ess_vector --- Immediate vector view edge selector_,  Prev: igraph_ess_none --- Immediate empty edge selector_,  Up: Immediate edge selectors

@c 8.7.3 igraph_ess_1 -- Immediate version of the single edge edge selector.
@c -------------------------------------------------------------------------


@c      igraph_es_t igraph_ess_1(igraph_integer_t eid);

@c    *Arguments:. *

@c `eid':
@c      The id of the edge.

@c    *Returns:. *

@c `'
@c      The edge selector.

@c    *See also:. *

@c `'
@c      `igraph_es_1()' (*note igraph_es_1 --- Edge selector containing a
@c      single edge_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_ess_vector --- Immediate vector view edge selector_,  Next: igraph_ess_seq --- Immediate version of the sequence edge selector_,  Prev: igraph_ess_1 --- Immediate version of the single edge edge selector_,  Up: Immediate edge selectors

@c 8.7.4 igraph_ess_vector -- Immediate vector view edge selector.
@c ---------------------------------------------------------------


@c      igraph_es_t igraph_ess_vector(const igraph_vector_t *v);

@c    This is the immediate version of the vector of edge ids edge
@c selector.

@c    *Arguments:. *

@c `v':
@c      The vector of edge ids.

@c    *Returns:. *

@c `'
@c      Edge selector, initialized.

@c    *See also:. *

@c `'
@c      `igraph_es_vector()' (*note igraph_es_vector --- Handle a vector
@c      as an edge selector_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_ess_seq --- Immediate version of the sequence edge selector_,  Prev: igraph_ess_vector --- Immediate vector view edge selector_,  Up: Immediate edge selectors

@c 8.7.5 igraph_ess_seq -- Immediate version of the sequence edge selector.
@c ------------------------------------------------------------------------


@c      igraph_es_t igraph_ess_seq(igraph_integer_t from, igraph_integer_t to);

@c    *Arguments:. *

@c `from':
@c      The first edge id to include.

@c `to':
@c      The last edge id to include.

@c    *Returns:. *

@c `'
@c      The initialized edge selector.

@c    *See also:. *

@c `'
@c      `igraph_es_seq()' (*note igraph_es_seq --- Edge selector; a
@c      sequence of edge ids_::)

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Generic edge selector operations,  Next: Edge iterators,  Prev: Immediate edge selectors,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.8 Generic edge selector operations
@c ====================================

@c * Menu:

@c * igraph_es_destroy --- Destroys an edge selector object.: igraph_es_destroy --- Destroys an edge selector object_.
@c * igraph_es_is_all --- Check whether an edge selector includes all edges.: igraph_es_is_all --- Check whether an edge selector includes all edges_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_destroy --- Destroys an edge selector object_,  Next: igraph_es_is_all --- Check whether an edge selector includes all edges_,  Up: Generic edge selector operations

@c 8.8.1 igraph_es_destroy -- Destroys an edge selector object.
@c ------------------------------------------------------------


@c      void igraph_es_destroy(igraph_es_t *es);

@c    Call this function on an edge selector when it is not needed any
@c more. Do _not_ call this function on edge selectors created by
@c immediate constructors, those don't need to be destroyed.

@c    *Arguments:. *

@c `es':
@c      Pointer to an edge selector object.

@c    Time complexity: operating system dependent, usually O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_es_is_all --- Check whether an edge selector includes all edges_,  Prev: igraph_es_destroy --- Destroys an edge selector object_,  Up: Generic edge selector operations

@c 8.8.2 igraph_es_is_all -- Check whether an edge selector includes all edges.
@c ----------------------------------------------------------------------------


@c      igraph_bool_t igraph_es_is_all(const igraph_es_t *es);

@c    *Arguments:. *

@c `es':
@c      Pointer to an edge selector object.

@c    *Returns:. *

@c `'
@c      TRUE (1) if ` es'  was created with `igraph_es_all()' (*note
@c      igraph_es_all --- Edge set; all edges_::) or `igraph_ess_all()'
@c      (*note igraph_ess_all --- Edge set; all edges [immediate
@c      version]::), and FALSE (0) otherwise.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Edge iterators,  Prev: Generic edge selector operations,  Up: Vertex and Edge Selectors and Sequences; Iterators

@c 8.9 Edge iterators
@c ==================

@c * Menu:

@c * igraph_eit_create --- Creates an edge iterator from an edge selector.: igraph_eit_create --- Creates an edge iterator from an edge selector_.
@c * igraph_eit_destroy --- Destroys an edge iterator::
@c * Stepping over the edges::
@c * IGRAPH_EIT_NEXT --- Next edge.: IGRAPH_EIT_NEXT --- Next edge_.
@c * IGRAPH_EIT_END --- Are we at the end?::
@c * IGRAPH_EIT_SIZE --- Number of edges in the iterator.: IGRAPH_EIT_SIZE --- Number of edges in the iterator_.
@c * IGRAPH_EIT_RESET --- Reset an edge iterator.: IGRAPH_EIT_RESET --- Reset an edge iterator_.
@c * IGRAPH_EIT_GET --- Query an edge iterator.: IGRAPH_EIT_GET --- Query an edge iterator_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_eit_create --- Creates an edge iterator from an edge selector_,  Next: igraph_eit_destroy --- Destroys an edge iterator,  Up: Edge iterators

@c 8.9.1 igraph_eit_create -- Creates an edge iterator from an edge selector.
@c --------------------------------------------------------------------------


@c      int igraph_eit_create(const igraph_t *graph,
@c      		      igraph_es_t es, igraph_eit_t *eit);

@c    This function creates an edge iterator based on an edge selector and
@c a graph.

@c    The same edge selector can be used to create many edge iterators,
@c also for different graphs.

@c    *Arguments:. *

@c `graph':
@c      An `igraph_t' object for which the edge selector will be
@c      instantiated.

@c `es':
@c      The edge selector to instantiate.

@c `eit':
@c      Pointer to an uninitialized edge iterator.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: depends on the type of the edge selector. For edge
@c selectors created by `igraph_es_all()' (*note igraph_es_all --- Edge
@c set; all edges_::), `igraph_es_none()' (*note igraph_es_none --- Empty
@c edge selector_::), `igraph_es_1()' (*note igraph_es_1 --- Edge selector
@c containing a single edge_::), igraph_es_vector(), igraph_es_seq() it is
@c O(1). For `igraph_es_adj()' (*note igraph_es_adj --- Adjacent edges of
@c a vertex_::) it is O(d) where d is the number of adjacent edges of the
@c vertex.

@c
@c File: igraph_reference_manual.info,  Node: igraph_eit_destroy --- Destroys an edge iterator,  Next: Stepping over the edges,  Prev: igraph_eit_create --- Creates an edge iterator from an edge selector_,  Up: Edge iterators

@c 8.9.2 igraph_eit_destroy -- Destroys an edge iterator
@c -----------------------------------------------------


@c      void igraph_eit_destroy(const igraph_eit_t *eit);

@c    *Arguments:. *

@c `eit':
@c      Pointer to an edge iterator to destroy.

@c    *See also:. *

@c `'
@c      `igraph_eit_create()' (*note igraph_eit_create --- Creates an edge
@c      iterator from an edge selector_::)

@c    Time complexity: operating system dependent, usually O(1).

@c
@c File: igraph_reference_manual.info,  Node: Stepping over the edges,  Next: IGRAPH_EIT_NEXT --- Next edge_,  Prev: igraph_eit_destroy --- Destroys an edge iterator,  Up: Edge iterators

@c 8.9.3 Stepping over the edges
@c -----------------------------

@c Just like for vertex iterators, macros are provided for stepping over a
@c sequence of edges: `IGRAPH_EIT_NEXT()' (*note IGRAPH_EIT_NEXT --- Next
@c edge_::) goes to the next edge, `IGRAPH_EIT_END()' (*note
@c IGRAPH_EIT_END --- Are we at the end?::) checks whether there are more
@c edges to visit, `IGRAPH_EIT_SIZE()' (*note IGRAPH_EIT_SIZE --- Number
@c of edges in the iterator_::) gives the number of edges in the edge
@c sequence, `IGRAPH_EIT_RESET()' (*note IGRAPH_EIT_RESET --- Reset an
@c edge iterator_::) resets the iterator to the first edge and
@c `IGRAPH_EIT_GET()' (*note IGRAPH_EIT_GET --- Query an edge iterator_::)
@c returns the id of the current edge.

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_EIT_NEXT --- Next edge_,  Next: IGRAPH_EIT_END --- Are we at the end?,  Prev: Stepping over the edges,  Up: Edge iterators

@c 8.9.4 IGRAPH_EIT_NEXT -- Next edge.
@c -----------------------------------


@c      #define IGRAPH_EIT_NEXT(eit)

@c    Steps the iterator to the next edge. Call this function only if
@c `IGRAPH_EIT_END()' (*note IGRAPH_EIT_END --- Are we at the end?::)
@c returns false.

@c    *Arguments:. *

@c `eit':
@c      The edge iterator to step.

@c    Time complecity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_EIT_END --- Are we at the end?,  Next: IGRAPH_EIT_SIZE --- Number of edges in the iterator_,  Prev: IGRAPH_EIT_NEXT --- Next edge_,  Up: Edge iterators

@c 8.9.5 IGRAPH_EIT_END -- Are we at the end?
@c ------------------------------------------


@c      #define IGRAPH_EIT_END(eit)

@c    Checks whether there are more edges to step to.

@c    *Arguments:. *

@c `wit':
@c      The edge iterator to check.

@c    *Returns:. *

@c `'
@c      Logical value, if true there are no more edges to step to.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_EIT_SIZE --- Number of edges in the iterator_,  Next: IGRAPH_EIT_RESET --- Reset an edge iterator_,  Prev: IGRAPH_EIT_END --- Are we at the end?,  Up: Edge iterators

@c 8.9.6 IGRAPH_EIT_SIZE -- Number of edges in the iterator.
@c ---------------------------------------------------------


@c      #define IGRAPH_EIT_SIZE(eit)

@c    Gives the number of edges in an edge iterator.

@c    *Arguments:. *

@c `eit':
@c      The edge iterator.

@c    *Returns:. *

@c `'
@c      The number of edges.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_EIT_RESET --- Reset an edge iterator_,  Next: IGRAPH_EIT_GET --- Query an edge iterator_,  Prev: IGRAPH_EIT_SIZE --- Number of edges in the iterator_,  Up: Edge iterators

@c 8.9.7 IGRAPH_EIT_RESET -- Reset an edge iterator.
@c -------------------------------------------------


@c      #define IGRAPH_EIT_RESET(eit)

@c    Resets an ege iterator. After calling this macro the iterator will
@c point to the first edge.

@c    *Arguments:. *

@c `eit':
@c      The edge iterator.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: IGRAPH_EIT_GET --- Query an edge iterator_,  Prev: IGRAPH_EIT_RESET --- Reset an edge iterator_,  Up: Edge iterators

@c 8.9.8 IGRAPH_EIT_GET -- Query an edge iterator.
@c -----------------------------------------------


@c      #define IGRAPH_EIT_GET(eit)

@c    Gives the edge id of the current edge pointed to by an iterator.

@c    *Arguments:. *

@c `eit':
@c      The edge iterator.

@c    *Returns:. *

@c `'
@c      The id of the current edge.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: Graph; Vertex and Edge Attributes,  Next: Structural Properties of Graphs,  Prev: Vertex and Edge Selectors and Sequences; Iterators,  Up: Top

@c 9 Graph, Vertex and Edge Attributes
@c ***********************************

@c Attributes are numbers or strings (or basically any kind of data)
@c associated with the vertices or edges of a graph, or with the graph
@c itself. Eg. you may label vertices with symbolic names or attach
@c numeric weights to the edges of a graph.

@c    igraph attributes are designed to be flexible and extensible.  In
@c igraph attributes are implemented via an interface abstraction: any
@c type implementing the functions in the interface, can be used for
@c storing vertex, edge and graph attributes. This means that different
@c attribute implementations can be used together with igraph. This is
@c reasonable: if igraph is used from Python attributes can be of any
@c Python type, from GNU R all R types are allowed. There is an
@c experimental attribute implementation to be used when programming in C,
@c but by default it is currently turned off.

@c    First we briefly look over how attribute handlers can be
@c implemented. This is not something a user does every day. It is rather
@c typically the job of the high level interface writers. (But it is
@c possible to write an interface without implementing attributes.) Then
@c we show the experimental C attribute handler.

@c * Menu:

@c * The Attribute Handler Interface::
@c * Accessing attributes from C::

@c
@c File: igraph_reference_manual.info,  Node: The Attribute Handler Interface,  Next: Accessing attributes from C,  Up: Graph; Vertex and Edge Attributes

@c 9.1 The Attribute Handler Interface
@c ===================================

@c It is possible to attach an attribute handling interface to `igraph'.
@c This is simply a table of functions, of type `igraph_attribute_table_t'
@c (*note igraph_attribute_table_t --- Table of functions to perform
@c operations on attributes::). These functions are invoked to notify the
@c attribute handling code about the structural changes in a graph. See
@c the documentation of this type for details.

@c    By default there is no attribute interface attached to `igraph', to
@c attach one, call `igraph_i_set_attribute_table' (*note
@c igraph_i_set_attribute_table --- Attach an attribute table_::) with
@c your new table.

@c * Menu:

@c * igraph_attribute_table_t --- Table of functions to perform operations on attributes::
@c * igraph_i_set_attribute_table --- Attach an attribute table.: igraph_i_set_attribute_table --- Attach an attribute table_.
@c * igraph_attribute_type_t --- The possible types of the attributes. : igraph_attribute_type_t --- The possible types of the attributes_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_attribute_table_t --- Table of functions to perform operations on attributes,  Next: igraph_i_set_attribute_table --- Attach an attribute table_,  Up: The Attribute Handler Interface

@c 9.1.1 igraph_attribute_table_t -- Table of functions to perform operations on attributes
@c ----------------------------------------------------------------------------------------


@c      typedef struct igraph_attribute_table_t {
@c        int (*init)(igraph_t *graph, igraph_vector_ptr_t *attr);
@c        void (*destroy)(igraph_t *graph);
@c        int (*copy)(igraph_t *to, const igraph_t *from, igraph_bool_t ga,
@c      	      igraph_bool_t va, igraph_bool_t ea);
@c        int (*add_vertices)(igraph_t *graph, long int nv, igraph_vector_ptr_t *attr);
@c        void (*delete_vertices)(igraph_t *graph, const igraph_vector_t *eidx,
@c      			  const igraph_vector_t *vidx);
@c        int (*add_edges)(igraph_t *graph, const igraph_vector_t *edges,
@c      		   igraph_vector_ptr_t *attr);
@c        void (*delete_edges)(igraph_t *graph, const igraph_vector_t *idx);
@c        int (*permute_edges)(igraph_t *graph, const igraph_vector_t *idx);
@c        int (*get_info)(const igraph_t *graph,
@c      		  igraph_strvector_t *gnames, igraph_vector_t *gtypes,
@c      		  igraph_strvector_t *vnames, igraph_vector_t *vtypes,
@c      		  igraph_strvector_t *enames, igraph_vector_t *etypes);
@c        igraph_bool_t (*has_attr)(const igraph_t *graph, igraph_attribute_elemtype_t type,
@c      			    const char *name);
@c        int (*gettype)(const igraph_t *graph, igraph_attribute_type_t *type,
@c      		 igraph_attribute_elemtype_t elemtype, const char *name);
@c        int (*get_numeric_graph_attr)(const igraph_t *graph, const char *name,
@c      				igraph_vector_t *value);
@c        int (*get_string_graph_attr)(const igraph_t *graph, const char *name,
@c      			       igraph_strvector_t *value);
@c        int (*get_numeric_vertex_attr)(const igraph_t *graph, const char *name,
@c      				 igraph_vs_t vs,
@c      				 igraph_vector_t *value);
@c        int (*get_string_vertex_attr)(const igraph_t *graph, const char *name,
@c      				igraph_vs_t vs,
@c      				igraph_strvector_t *value);
@c        int (*get_numeric_edge_attr)(const igraph_t *graph, const char *name,
@c      			       igraph_es_t es,
@c      			       igraph_vector_t *value);
@c        int (*get_string_edge_attr)(const igraph_t *graph, const char *name,
@c      			      igraph_es_t es,
@c      			      igraph_strvector_t *value);
@c      } igraph_attribute_table_t;

@c    This type collects the functions defining an attribute handler.  It
@c has the following members:

@c    *Values:. *

@c `init':
@c      This function is called whenever a new graph object is created,
@c      right after it is created but before any vertices or edges are
@c      added. It is supposed to set the `attr' member of the `igraph_t'
@c      object. It is expected to return an error code.

@c `destroy':
@c      This function is called whenever the graph object is destroyed,
@c      right before freeing the allocated memory.

@c `copy':
@c      This function is called when copying a graph with `igraph_copy'
@c      (*note igraph_copy --- Creates an exact [deep] copy of a
@c      graph_::), after the structure of the graph has been already
@c      copied. It is expected to return an error code.

@c `add_vertices':
@c      Called when vertices are added to a graph, before adding the
@c      vertices themselves.  The number of vertices to add is supplied as
@c      an argument. Expected to return an error code.

@c `delete_vertices':
@c      Called when vertices are deleted from the graph. Two additional
@c      parameters are supplied, the first is a recoding vector for edge
@c      ids, the second is one for the vertex ids. The edge recoding
@c      vector gives for each edge its id in the new graph. It contains
@c      one number for each edge (in the original graph): zero means that
@c      the edge has been deleted, otherwise the new id plus one is
@c      included. The vertex recoding vector contains the same for
@c      vertices.

@c `add_edges':
@c      Called when new edges have been added. The number of new edges are
@c      supplied as well. It is expected to return an error code.

@c `delete_edges':
@c      Called when edges were deleted. The edge recoding vector is
@c      supplied, in the same form as for the `delete_vertices' function.

@c `permute_edges':
@c      Typically called when a new graph is created and some of the new
@c      edges should carry the attributes of some of the old edges. The
@c      idx vector shows the mapping between the old edges and the new
@c      ones. Its length is the same as the number of edges in the new
@c      graph, and for each edge it gives the id of the old edge (the edge
@c      in the old graph).

@c `get_info':
@c      Query the attributes of a graph, the names and types should be
@c      returned.

@c `has_attr':
@c      Check whether a graph has the named graph/vertex/edge attribute.

@c `gettype':
@c      Query the type of a graph/vertex/edge attribute.

@c `get_numeric_graph_attr':
@c      Query a numeric graph attribute. The value should be placed as the
@c      first element of the `value' vector.

@c `get_string_graph_attr':
@c      Query a string graph attribute. The value should be placed as the
@c      first element of the `value' string vector.

@c `get_numeric_vertex_attr':
@c      Query a numeric vertex attribute, for the vertices included in
@c      `vs'.

@c `get_string_vertex_attr':
@c      Query a string vertex attribute, for the vertices included in `vs'.

@c `get_numeric_edge_attr':
@c      Query a numeric edge attribute, for the edges included in `es'.

@c `get_string_edge_attr':
@c      Query a string edge attribute, for the edge included in `es'.

@c    Note that the `get_*_*_attr' are allowed to convert the attributes
@c to numeric or string. E.g. if a vertex attribute is a GNU R complex
@c data type, then `get_string_vertex_attribute' may serialize it into a
@c string, but this probably makes sense only if `add_vertices' is able to
@c deserialize it.

@c
@c File: igraph_reference_manual.info,  Node: igraph_i_set_attribute_table --- Attach an attribute table_,  Next: igraph_attribute_type_t --- The possible types of the attributes_,  Prev: igraph_attribute_table_t --- Table of functions to perform operations on attributes,  Up: The Attribute Handler Interface

@c 9.1.2 igraph_i_set_attribute_table -- Attach an attribute table.
@c ----------------------------------------------------------------


@c      igraph_attribute_table_t *
@c      igraph_i_set_attribute_table(igraph_attribute_table_t * table);

@c    This function attaches attribute handling code to the igraph library.

@c    *Arguments:. *

@c `table':
@c      Pointer to an `igraph_attribute_table_t' (*note
@c      igraph_attribute_table_t --- Table of functions to perform
@c      operations on attributes::) object containing the functions for
@c      attribute manipulation. Supply `NULL' here if you don't want
@c      attributes.

@c    *Returns:. *

@c `'
@c      Pointer to the old attribute handling table.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_attribute_type_t --- The possible types of the attributes_,  Prev: igraph_i_set_attribute_table --- Attach an attribute table_,  Up: The Attribute Handler Interface

@c 9.1.3 igraph_attribute_type_t -- The possible types of the attributes.
@c ----------------------------------------------------------------------


@c      typedef enum { IGRAPH_ATTRIBUTE_DEFAULT=0,
@c      	       IGRAPH_ATTRIBUTE_NUMERIC=1,
@c      	       IGRAPH_ATTRIBUTE_STRING=2,
@c      	       IGRAPH_ATTRIBUTE_R_OBJECT=3,
@c      	       IGRAPH_ATTRIBUTE_PY_OBJECT=4 } igraph_attribute_type_t;

@c      typedef struct igraph_i_attribute_record_t {
@c        const char *name;
@c        igraph_attribute_type_t type;
@c        const void *value;
@c      } igraph_i_attribute_record_t;

@c      typedef enum { IGRAPH_ATTRIBUTE_GRAPH=0,
@c      	       IGRAPH_ATTRIBUTE_VERTEX,
@c      	       IGRAPH_ATTRIBUTE_EDGE } igraph_attribute_elemtype_t;

@c    Note that this is only the type communicated by the attribute
@c interface towards igraph functions. Eg. in the GNU R attribute handler,
@c it is safe to say that all complex R object attributes are strings, as
@c long as this interface is able to serialize them into strings. See also
@c `igraph_attribute_table_t' (*note igraph_attribute_table_t --- Table of
@c functions to perform operations on attributes::).

@c    *Values:. *

@c `IGRAPH_ATTRIBUTE_DEFAULT':
@c      Currently not used for anything.

@c `IGRAPH_ATTRIBUTE_NUMERIC':
@c      Numeric attribute.

@c `IGRAPH_ATTRIBUTE_STRING':
@c      Attribute that can be converted to a string.

@c `IGRAPH_ATTRIBUTE_R_OBJECT':
@c      An R object. This is usually ignored by the igraph functions.

@c `IGRAPH_ATTRIBUTE_PY_OBJECT':
@c      A Python object. Usually ignored by the igraph functions.

@c
@c File: igraph_reference_manual.info,  Node: Accessing attributes from C,  Prev: The Attribute Handler Interface,  Up: Graph; Vertex and Edge Attributes

@c 9.2 Accessing attributes from C
@c ===============================

@c There is an experimental attribute handler that can be used from C
@c code. In this section we show how this works. This attribute handler is
@c by default not attached (the default is no attribute handler), so we
@c first need to attach it:


@c      igraph_i_set_attribute_table(&igraph_cattribute_table);

@c    Now the attribute functions are available. Please note that the
@c attribute handler must be attached before you call any other igraph
@c functions, otherwise you might end up with graphs without attributes
@c and an active attribute handler, which might cause unexpected program
@c behaviour. The rule is that you attach the attribute handler in the
@c beginning of your `main()' and never touch it again. (Detaching the
@c attribute handler might lead to memory leaks.)

@c    It is not currently possible to have attribute handlers on a
@c per-graph basis. All graphs in an application must be managed with the
@c same attribute handler. (Including the default case when there is no
@c attribute handler at all.

@c    The C attribute handler supports attaching real numbers and
@c character strings as attributes. No vectors are allowed, ie. every
@c vertex might have an attribute called ` name' , but it is not possible
@c to have a ` coords'  graph (or other) attribute which is a vector of
@c numbers.

@c * Menu:

@c * Query attributes::
@c * Set attributes::
@c * Remove attributes::

@c
@c File: igraph_reference_manual.info,  Node: Query attributes,  Next: Set attributes,  Up: Accessing attributes from C

@c 9.2.1 Query attributes
@c ----------------------

@c * Menu:

@c * igraph_cattribute_list --- List all attributes::
@c * igraph_cattribute_GAN --- Query a numeric graph attribute.: igraph_cattribute_GAN --- Query a numeric graph attribute_.
@c * GAN --- Query a numeric graph attribute.: GAN --- Query a numeric graph attribute_.
@c * igraph_cattribute_GAS --- Query a string graph attribute.: igraph_cattribute_GAS --- Query a string graph attribute_.
@c * GAS --- Query a string graph attribute.: GAS --- Query a string graph attribute_.
@c * igraph_cattribute_VAN --- Query a numeric vertex attribute.: igraph_cattribute_VAN --- Query a numeric vertex attribute_.
@c * VAN --- Query a numeric vertex attribute.: VAN --- Query a numeric vertex attribute_.
@c * igraph_cattribute_VANV --- Query a numeric vertex attribute for many vertices::
@c * VANV --- Query a numeric vertex attribute for all vertices.: VANV --- Query a numeric vertex attribute for all vertices_.
@c * igraph_cattribute_VAS --- Query a string vertex attribute.: igraph_cattribute_VAS --- Query a string vertex attribute_.
@c * VAS --- Query a string vertex attribute.: VAS --- Query a string vertex attribute_.
@c * igraph_cattribute_VASV --- Query a string vertex attribute for many vertices::
@c * VASV --- Query a string vertex attribute for all vertices.: VASV --- Query a string vertex attribute for all vertices_.
@c * igraph_cattribute_EAN --- Query a numeric edge attribute.: igraph_cattribute_EAN --- Query a numeric edge attribute_.
@c * EAN --- Query a numeric edge attribute.: EAN --- Query a numeric edge attribute_.
@c * igraph_cattribute_EANV --- Query a numeric edge attribute for many edges::
@c * EANV --- Query a numeric edge attribute for all edges.: EANV --- Query a numeric edge attribute for all edges_.
@c * igraph_cattribute_EAS --- Query a string edge attribute.: igraph_cattribute_EAS --- Query a string edge attribute_.
@c * EAS --- Query a string edge attribute.: EAS --- Query a string edge attribute_.
@c * igraph_cattribute_EASV --- Query a string edge attribute for many edges::
@c * EASV --- Query a string edge attribute for all edges.: EASV --- Query a string edge attribute for all edges_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_list --- List all attributes,  Next: igraph_cattribute_GAN --- Query a numeric graph attribute_,  Up: Query attributes

@c 9.2.1.1 igraph_cattribute_list -- List all attributes
@c .....................................................


@c      int igraph_cattribute_list(const igraph_t *graph,
@c      			   igraph_strvector_t *gnames, igraph_vector_t *gtypes,
@c      			   igraph_strvector_t *vnames, igraph_vector_t *vtypes,
@c      			   igraph_strvector_t *enames, igraph_vector_t *etypes);

@c    See `igraph_attribute_type_t' (*note igraph_attribute_type_t --- The
@c possible types of the attributes_::) for the various attribute types.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `gnames':
@c      String vector, the names of the graph attributes.

@c `gtypes':
@c      Numeric vector, the types of the graph attributes.

@c `vnames':
@c      String vector, the names of the vertex attributes.

@c `vtypes':
@c      Numeric vector, the types of the vertex attributes.

@c `enames':
@c      String vector, the names of the edge attributes.

@c `etypes':
@c      Numeric vector, the types of the edge attributes.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Naturally, the string vector with the attribute names and the
@c numeric vector with the attribute types are in the right order, i.e.
@c the first name corresponds to the first type, etc.  Time complexity:
@c O(Ag+Av+Ae), the number of all attributes.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_GAN --- Query a numeric graph attribute_,  Next: GAN --- Query a numeric graph attribute_,  Prev: igraph_cattribute_list --- List all attributes,  Up: Query attributes

@c 9.2.1.2 igraph_cattribute_GAN -- Query a numeric graph attribute.
@c .................................................................


@c      igraph_real_t igraph_cattribute_GAN(const igraph_t *graph, const char *name);

@c    Returns the value of the given numeric graph attribute.  The
@c attribute must exist, otherwise an error is triggered.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute to query.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c    *See also:. *

@c `'
@c      `GAN' (*note GAN --- Query a numeric graph attribute_::) for a
@c      simpler interface.

@c    Time complexity: O(Ag), the number of graph attributes.

@c
@c File: igraph_reference_manual.info,  Node: GAN --- Query a numeric graph attribute_,  Next: igraph_cattribute_GAS --- Query a string graph attribute_,  Prev: igraph_cattribute_GAN --- Query a numeric graph attribute_,  Up: Query attributes

@c 9.2.1.3 GAN -- Query a numeric graph attribute.
@c ...............................................


@c      #define GAN(graph,n)

@c    This is shorthand for `igraph_cattribute_GAN()' (*note
@c igraph_cattribute_GAN --- Query a numeric graph attribute_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_GAS --- Query a string graph attribute_,  Next: GAS --- Query a string graph attribute_,  Prev: GAN --- Query a numeric graph attribute_,  Up: Query attributes

@c 9.2.1.4 igraph_cattribute_GAS -- Query a string graph attribute.
@c ................................................................


@c      const char* igraph_cattribute_GAS(const igraph_t *graph, const char *name);

@c    Returns a `const' pointer to the string graph attribute specified in
@c `name'.  The attribute must exist, otherwise an error is triggered.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute to query.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c    *See also:. *

@c `'
@c      `GAS' (*note GAS --- Query a string graph attribute_::) for a
@c      simpler interface.

@c    Time complexity: O(Ag), the number of graph attributes.

@c
@c File: igraph_reference_manual.info,  Node: GAS --- Query a string graph attribute_,  Next: igraph_cattribute_VAN --- Query a numeric vertex attribute_,  Prev: igraph_cattribute_GAS --- Query a string graph attribute_,  Up: Query attributes

@c 9.2.1.5 GAS -- Query a string graph attribute.
@c ..............................................


@c      #define GAS(graph,n)

@c    This is shorthand for `igraph_cattribute_GAS()' (*note
@c igraph_cattribute_GAS --- Query a string graph attribute_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VAN --- Query a numeric vertex attribute_,  Next: VAN --- Query a numeric vertex attribute_,  Prev: GAS --- Query a string graph attribute_,  Up: Query attributes

@c 9.2.1.6 igraph_cattribute_VAN -- Query a numeric vertex attribute.
@c ..................................................................


@c      igraph_real_t igraph_cattribute_VAN(const igraph_t *graph, const char *name,
@c      				      igraph_integer_t vid);

@c    The attribute must exist, otherwise an error is triggered.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `vid':
@c      The id of the queried vertex.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c    *See also:. *

@c `'
@c      `VAN' (*note VAN --- Query a numeric vertex attribute_::) macro
@c      for a simpler interface.

@c    Time complexity: O(Av), the number of vertex attributes.

@c
@c File: igraph_reference_manual.info,  Node: VAN --- Query a numeric vertex attribute_,  Next: igraph_cattribute_VANV --- Query a numeric vertex attribute for many vertices,  Prev: igraph_cattribute_VAN --- Query a numeric vertex attribute_,  Up: Query attributes

@c 9.2.1.7 VAN -- Query a numeric vertex attribute.
@c ................................................


@c      #define VAN(graph,n,v)

@c    This is shorthand for `igraph_cattribute_VAN()' (*note
@c igraph_cattribute_VAN --- Query a numeric vertex attribute_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `v':
@c      The id of the vertex.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VANV --- Query a numeric vertex attribute for many vertices,  Next: VANV --- Query a numeric vertex attribute for all vertices_,  Prev: VAN --- Query a numeric vertex attribute_,  Up: Query attributes

@c 9.2.1.8 igraph_cattribute_VANV -- Query a numeric vertex attribute for many vertices
@c ....................................................................................


@c      int igraph_cattribute_VANV(const igraph_t *graph, const char *name,
@c      			   igraph_vs_t vids, igraph_vector_t *result);

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `vids':
@c      The vertices to query.

@c `result':
@c      Pointer to an initialized vector, the result is stored here. It
@c      will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(v), where v is the number of vertices in 'vids'.

@c
@c File: igraph_reference_manual.info,  Node: VANV --- Query a numeric vertex attribute for all vertices_,  Next: igraph_cattribute_VAS --- Query a string vertex attribute_,  Prev: igraph_cattribute_VANV --- Query a numeric vertex attribute for many vertices,  Up: Query attributes

@c 9.2.1.9 VANV -- Query a numeric vertex attribute for all vertices.
@c ..................................................................


@c      #define VANV(graph,n,vec)

@c    This is a shorthand for `igraph_cattribute_VANV()' (*note
@c igraph_cattribute_VANV --- Query a numeric vertex attribute for many
@c vertices::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `vec':
@c      Pointer to an initialized vector, the result is stored here. It
@c      will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VAS --- Query a string vertex attribute_,  Next: VAS --- Query a string vertex attribute_,  Prev: VANV --- Query a numeric vertex attribute for all vertices_,  Up: Query attributes

@c 9.2.1.10 igraph_cattribute_VAS -- Query a string vertex attribute.
@c ..................................................................


@c      const char* igraph_cattribute_VAS(const igraph_t *graph, const char *name,
@c      				    igraph_integer_t vid);

@c    The attribute must exist, otherwise an error is triggered.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `vid':
@c      The id of the queried vertex.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c    *See also:. *

@c `'
@c      The macro `VAS' (*note VAS --- Query a string vertex attribute_::)
@c      for a simpler interface.

@c    Time complexity: O(Av), the number of vertex attributes.

@c
@c File: igraph_reference_manual.info,  Node: VAS --- Query a string vertex attribute_,  Next: igraph_cattribute_VASV --- Query a string vertex attribute for many vertices,  Prev: igraph_cattribute_VAS --- Query a string vertex attribute_,  Up: Query attributes

@c 9.2.1.11 VAS -- Query a string vertex attribute.
@c ................................................


@c      #define VAS(graph,n,v)

@c    This is shorthand for `igraph_cattribute_VAS()' (*note
@c igraph_cattribute_VAS --- Query a string vertex attribute_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `v':
@c      The id of the vertex.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VASV --- Query a string vertex attribute for many vertices,  Next: VASV --- Query a string vertex attribute for all vertices_,  Prev: VAS --- Query a string vertex attribute_,  Up: Query attributes

@c 9.2.1.12 igraph_cattribute_VASV -- Query a string vertex attribute for many vertices
@c ....................................................................................


@c      int igraph_cattribute_VASV(const igraph_t *graph, const char *name,
@c      			   igraph_vs_t vids, igraph_strvector_t *result);

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `vids':
@c      The vertices to query.

@c `result':
@c      Pointer to an initialized string vector, the result is stored
@c      here. It will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(v), where v is the number of vertices in 'vids'.
@c (We assume that the string attributes have a bounded length.)

@c
@c File: igraph_reference_manual.info,  Node: VASV --- Query a string vertex attribute for all vertices_,  Next: igraph_cattribute_EAN --- Query a numeric edge attribute_,  Prev: igraph_cattribute_VASV --- Query a string vertex attribute for many vertices,  Up: Query attributes

@c 9.2.1.13 VASV -- Query a string vertex attribute for all vertices.
@c ..................................................................


@c      #define VASV(graph,n,vec)

@c    This is a shorthand for `igraph_cattribute_VASV()' (*note
@c igraph_cattribute_VASV --- Query a string vertex attribute for many
@c vertices::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `vec':
@c      Pointer to an initialized string vector, the result is stored
@c      here. It will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EAN --- Query a numeric edge attribute_,  Next: EAN --- Query a numeric edge attribute_,  Prev: VASV --- Query a string vertex attribute for all vertices_,  Up: Query attributes

@c 9.2.1.14 igraph_cattribute_EAN -- Query a numeric edge attribute.
@c .................................................................


@c      igraph_real_t igraph_cattribute_EAN(const igraph_t *graph, const char *name,
@c      				      igraph_integer_t eid);

@c    The attribute must exist, otherwise an error is triggered.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `eid':
@c      The id of the queried edge.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c    *See also:. *

@c `'
@c      `EAN' (*note EAN --- Query a numeric edge attribute_::) for an
@c      easier interface.

@c    Time complexity: O(Ae), the number of edge attributes.

@c
@c File: igraph_reference_manual.info,  Node: EAN --- Query a numeric edge attribute_,  Next: igraph_cattribute_EANV --- Query a numeric edge attribute for many edges,  Prev: igraph_cattribute_EAN --- Query a numeric edge attribute_,  Up: Query attributes

@c 9.2.1.15 EAN -- Query a numeric edge attribute.
@c ...............................................


@c      #define EAN(graph,n,e)

@c    This is shorthand for `igraph_cattribute_EAN()' (*note
@c igraph_cattribute_EAN --- Query a numeric edge attribute_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `e':
@c      The id of the edge.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EANV --- Query a numeric edge attribute for many edges,  Next: EANV --- Query a numeric edge attribute for all edges_,  Prev: EAN --- Query a numeric edge attribute_,  Up: Query attributes

@c 9.2.1.16 igraph_cattribute_EANV -- Query a numeric edge attribute for many edges
@c ................................................................................


@c      int igraph_cattribute_EANV(const igraph_t *graph, const char *name,
@c      			   igraph_es_t eids, igraph_vector_t *result);

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `eids':
@c      The edges to query.

@c `result':
@c      Pointer to an initialized vector, the result is stored here. It
@c      will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(e), where e is the number of edges in 'eids'.

@c
@c File: igraph_reference_manual.info,  Node: EANV --- Query a numeric edge attribute for all edges_,  Next: igraph_cattribute_EAS --- Query a string edge attribute_,  Prev: igraph_cattribute_EANV --- Query a numeric edge attribute for many edges,  Up: Query attributes

@c 9.2.1.17 EANV -- Query a numeric edge attribute for all edges.
@c ..............................................................


@c      #define EANV(graph,n,vec)

@c    This is a shorthand for `igraph_cattribute_EANV()' (*note
@c igraph_cattribute_EANV --- Query a numeric edge attribute for many
@c edges::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `vec':
@c      Pointer to an initialized vector, the result is stored here. It
@c      will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EAS --- Query a string edge attribute_,  Next: EAS --- Query a string edge attribute_,  Prev: EANV --- Query a numeric edge attribute for all edges_,  Up: Query attributes

@c 9.2.1.18 igraph_cattribute_EAS -- Query a string edge attribute.
@c ................................................................


@c      const char* igraph_cattribute_EAS(const igraph_t *graph, const char *name,
@c      				    igraph_integer_t eid);

@c    The attribute must exist, otherwise an error is triggered.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `eid':
@c      The id of the queried edge.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c    \se `EAS' (*note EAS --- Query a string edge attribute_::) if you
@c want to type less.  Time complexity: O(Ae), the number of edge
@c attributes.

@c
@c File: igraph_reference_manual.info,  Node: EAS --- Query a string edge attribute_,  Next: igraph_cattribute_EASV --- Query a string edge attribute for many edges,  Prev: igraph_cattribute_EAS --- Query a string edge attribute_,  Up: Query attributes

@c 9.2.1.19 EAS -- Query a string edge attribute.
@c ..............................................


@c      #define EAS(graph,n,e)

@c    This is shorthand for `igraph_cattribute_EAS()' (*note
@c igraph_cattribute_EAS --- Query a string edge attribute_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `e':
@c      The id of the edge.

@c    *Returns:. *

@c `'
@c      The value of the attribute.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EASV --- Query a string edge attribute for many edges,  Next: EASV --- Query a string edge attribute for all edges_,  Prev: EAS --- Query a string edge attribute_,  Up: Query attributes

@c 9.2.1.20 igraph_cattribute_EASV -- Query a string edge attribute for many edges
@c ...............................................................................


@c      int igraph_cattribute_EASV(const igraph_t *graph, const char *name,
@c      			   igraph_es_t eids, igraph_strvector_t *result);

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `name':
@c      The name of the attribute.

@c `vids':
@c      The edges to query.

@c `result':
@c      Pointer to an initialized string vector, the result is stored
@c      here. It will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(e), where e is the number of edges in 'eids'. (We
@c assume that the string attributes have a bounded length.)

@c
@c File: igraph_reference_manual.info,  Node: EASV --- Query a string edge attribute for all edges_,  Prev: igraph_cattribute_EASV --- Query a string edge attribute for many edges,  Up: Query attributes

@c 9.2.1.21 EASV -- Query a string edge attribute for all edges.
@c .............................................................


@c      #define EASV(graph,n,vec)

@c    This is a shorthand for `igraph_cattribute_EASV()' (*note
@c igraph_cattribute_EASV --- Query a string edge attribute for many
@c edges::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `vec':
@c      Pointer to an initialized string vector, the result is stored
@c      here. It will be resized, if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: Set attributes,  Next: Remove attributes,  Prev: Query attributes,  Up: Accessing attributes from C

@c 9.2.2 Set attributes
@c --------------------

@c * Menu:

@c * igraph_cattribute_GAN_set --- Set a numeric graph attribute::
@c * SETGAN --- Set a numeric graph attribute::
@c * igraph_cattribute_GAS_set --- Set a string graph attribute.: igraph_cattribute_GAS_set --- Set a string graph attribute_.
@c * SETGAS --- Set a string graph attribute::
@c * igraph_cattribute_VAN_set --- Set a numeric vertex attribute::
@c * SETVAN --- Set a numeric vertex attribute::
@c * igraph_cattribute_VAS_set --- Set a string vertex attribute::
@c * SETVAS --- Set a string vertex attribute::
@c * igraph_cattribute_EAN_set --- Set a numeric edge attribute::
@c * SETEAN --- Set a numeric edge attribute::
@c * igraph_cattribute_EAS_set --- Set a string edge attribute::
@c * SETEAS --- Set a string edge attribute::
@c * igraph_cattribute_VAN_setv --- Set a numeric vertex attribute for all vertices.: igraph_cattribute_VAN_setv --- Set a numeric vertex attribute for all vertices_.
@c * SETVANV --- Set a numeric vertex attribute for all vertices::
@c * igraph_cattribute_VAS_setv --- Set a string vertex attribute for all vertices.: igraph_cattribute_VAS_setv --- Set a string vertex attribute for all vertices_.
@c * SETVASV --- Set a string vertex attribute for all vertices::
@c * igraph_cattribute_EAN_setv --- Set a numeric edge attribute for all vertices.: igraph_cattribute_EAN_setv --- Set a numeric edge attribute for all vertices_.
@c * SETEANV --- Set a numeric edge attribute for all vertices::
@c * igraph_cattribute_EAS_setv --- Set a string edge attribute for all vertices.: igraph_cattribute_EAS_setv --- Set a string edge attribute for all vertices_.
@c * SETEASV --- Set a string edge attribute for all vertices::

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_GAN_set --- Set a numeric graph attribute,  Next: SETGAN --- Set a numeric graph attribute,  Up: Set attributes

@c 9.2.2.1 igraph_cattribute_GAN_set -- Set a numeric graph attribute
@c ..................................................................


@c      int igraph_cattribute_GAN_set(igraph_t *graph, const char *name,
@c      			      igraph_real_t value);

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the graph attribute. If there is no such attribute yet,
@c      then it will be added.

@c `value':
@c      The (new) value of the graph attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c    \se `SETGAN' (*note SETGAN --- Set a numeric graph attribute::) if
@c you want to type less.  Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: SETGAN --- Set a numeric graph attribute,  Next: igraph_cattribute_GAS_set --- Set a string graph attribute_,  Prev: igraph_cattribute_GAN_set --- Set a numeric graph attribute,  Up: Set attributes

@c 9.2.2.2 SETGAN -- Set a numeric graph attribute
@c ...............................................


@c      #define SETGAN(graph,n,value)

@c    This is a shorthand for `igraph_cattribute_GAN_set()' (*note
@c igraph_cattribute_GAN_set --- Set a numeric graph attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `value':
@c      The new value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_GAS_set --- Set a string graph attribute_,  Next: SETGAS --- Set a string graph attribute,  Prev: SETGAN --- Set a numeric graph attribute,  Up: Set attributes

@c 9.2.2.3 igraph_cattribute_GAS_set -- Set a string graph attribute.
@c ..................................................................


@c      int igraph_cattribute_GAS_set(igraph_t *graph, const char *name,
@c      			      const char *value);

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the graph attribute. If there is no such attribute yet,
@c      then it will be added.

@c `value':
@c      The (new) value of the graph attribute. It will be copied.

@c    *Returns:. *

@c `'
@c      Error code.

@c    \se `SETGAS' (*note SETGAS --- Set a string graph attribute::) if
@c you want to type less.  Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: SETGAS --- Set a string graph attribute,  Next: igraph_cattribute_VAN_set --- Set a numeric vertex attribute,  Prev: igraph_cattribute_GAS_set --- Set a string graph attribute_,  Up: Set attributes

@c 9.2.2.4 SETGAS -- Set a string graph attribute
@c ..............................................


@c      #define SETGAS(graph,n,value)

@c    This is a shorthand for `igraph_cattribute_GAS_set()' (*note
@c igraph_cattribute_GAS_set --- Set a string graph attribute_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `value':
@c      The new value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VAN_set --- Set a numeric vertex attribute,  Next: SETVAN --- Set a numeric vertex attribute,  Prev: SETGAS --- Set a string graph attribute,  Up: Set attributes

@c 9.2.2.5 igraph_cattribute_VAN_set -- Set a numeric vertex attribute
@c ...................................................................


@c      int igraph_cattribute_VAN_set(igraph_t *graph, const char *name,
@c      			      igraph_integer_t vid, igraph_real_t value);

@c    The attribute will be added if not present already. If present it
@c will be overwritten. The same `value' is set for all vertices included
@c in `vid'.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `vid':
@c      Vertices for which to set the attribute.

@c `value':
@c      The (new) value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETVAN' (*note SETVAN --- Set a numeric vertex attribute::) for a
@c      simpler way.

@c    Time complexity: O(n), the number of vertices if the attribute is
@c new, O(|vid|) otherwise.

@c
@c File: igraph_reference_manual.info,  Node: SETVAN --- Set a numeric vertex attribute,  Next: igraph_cattribute_VAS_set --- Set a string vertex attribute,  Prev: igraph_cattribute_VAN_set --- Set a numeric vertex attribute,  Up: Set attributes

@c 9.2.2.6 SETVAN -- Set a numeric vertex attribute
@c ................................................


@c      #define SETVAN(graph,n,vid,value)

@c    This is a shorthand for `igraph_cattribute_VAN_set()' (*note
@c igraph_cattribute_VAN_set --- Set a numeric vertex attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `vid':
@c      Ids of the vertices to set.

@c `value':
@c      The new value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VAS_set --- Set a string vertex attribute,  Next: SETVAS --- Set a string vertex attribute,  Prev: SETVAN --- Set a numeric vertex attribute,  Up: Set attributes

@c 9.2.2.7 igraph_cattribute_VAS_set -- Set a string vertex attribute
@c ..................................................................


@c      int igraph_cattribute_VAS_set(igraph_t *graph, const char *name,
@c      			      igraph_integer_t vid, const char *value);

@c    The attribute will be added if not present already. If present it
@c will be overwritten. The same `value' is set for all vertices included
@c in `vid'.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `vid':
@c      Vertices for which to set the attribute.

@c `value':
@c      The (new) value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETVAS' (*note SETVAS --- Set a string vertex attribute::) for a
@c      simpler way.

@c    Time complexity: O(n*l), n is the number of vertices, l is the
@c length of the string to set. If the attribute if not new then only
@c O(|vid|*l).

@c
@c File: igraph_reference_manual.info,  Node: SETVAS --- Set a string vertex attribute,  Next: igraph_cattribute_EAN_set --- Set a numeric edge attribute,  Prev: igraph_cattribute_VAS_set --- Set a string vertex attribute,  Up: Set attributes

@c 9.2.2.8 SETVAS -- Set a string vertex attribute
@c ...............................................


@c      #define SETVAS(graph,n,vid,value)

@c    This is a shorthand for `igraph_cattribute_VAS_set()' (*note
@c igraph_cattribute_VAS_set --- Set a string vertex attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `vid':
@c      Ids of the vertices to set.

@c `value':
@c      The new value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EAN_set --- Set a numeric edge attribute,  Next: SETEAN --- Set a numeric edge attribute,  Prev: SETVAS --- Set a string vertex attribute,  Up: Set attributes

@c 9.2.2.9 igraph_cattribute_EAN_set -- Set a numeric edge attribute
@c .................................................................


@c      int igraph_cattribute_EAN_set(igraph_t *graph, const char *name,
@c      			      igraph_integer_t eid, igraph_real_t value);

@c    The attribute will be added if not present already. If present it
@c will be overwritten. The same `value' is set for all edges included in
@c `vid'.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `eid':
@c      Edges for which to set the attribute.

@c `value':
@c      The (new) value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETEAN' (*note SETEAN --- Set a numeric edge attribute::) for a
@c      simpler way.

@c    Time complexity: O(e), the number of edges if the attribute is new,
@c O(|eid|) otherwise.

@c
@c File: igraph_reference_manual.info,  Node: SETEAN --- Set a numeric edge attribute,  Next: igraph_cattribute_EAS_set --- Set a string edge attribute,  Prev: igraph_cattribute_EAN_set --- Set a numeric edge attribute,  Up: Set attributes

@c 9.2.2.10 SETEAN -- Set a numeric edge attribute
@c ...............................................


@c      #define SETEAN(graph,n,eid,value)

@c    This is a shorthand for `igraph_cattribute_EAN_set()' (*note
@c igraph_cattribute_EAN_set --- Set a numeric edge attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `eid':
@c      Ids of the edges to set.

@c `value':
@c      The new value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EAS_set --- Set a string edge attribute,  Next: SETEAS --- Set a string edge attribute,  Prev: SETEAN --- Set a numeric edge attribute,  Up: Set attributes

@c 9.2.2.11 igraph_cattribute_EAS_set -- Set a string edge attribute
@c .................................................................


@c      int igraph_cattribute_EAS_set(igraph_t *graph, const char *name,
@c      			      igraph_integer_t eid, const char *value);

@c    The attribute will be added if not present already. If present it
@c will be overwritten. The same `value' is set for all edges included in
@c `vid'.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `eid':
@c      Edges for which to set the attribute.

@c `value':
@c      The (new) value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETEAS' (*note SETEAS --- Set a string edge attribute::) for a
@c      simpler way.

@c    Time complexity: O(e*l), n is the number of edges, l is the length
@c of the string to set. If the attribute if not new then only O(|eid|*l).

@c
@c File: igraph_reference_manual.info,  Node: SETEAS --- Set a string edge attribute,  Next: igraph_cattribute_VAN_setv --- Set a numeric vertex attribute for all vertices_,  Prev: igraph_cattribute_EAS_set --- Set a string edge attribute,  Up: Set attributes

@c 9.2.2.12 SETEAS -- Set a string edge attribute
@c ..............................................


@c      #define SETEAS(graph,n,eid,value)

@c    This is a shorthand for `igraph_cattribute_EAS_set()' (*note
@c igraph_cattribute_EAS_set --- Set a string edge attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `eid':
@c      Ids of the edges to set.

@c `value':
@c      The new value of the attribute.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VAN_setv --- Set a numeric vertex attribute for all vertices_,  Next: SETVANV --- Set a numeric vertex attribute for all vertices,  Prev: SETEAS --- Set a string edge attribute,  Up: Set attributes

@c 9.2.2.13 igraph_cattribute_VAN_setv -- Set a numeric vertex attribute for all vertices.
@c .......................................................................................


@c      int igraph_cattribute_VAN_setv(igraph_t *graph, const char *name,
@c      			       const igraph_vector_t *v);

@c    The attribute will be added if not present yet.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `v':
@c      The new attribute values. The length of this vector must match the
@c      number of vertices.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETVANV' (*note SETVANV --- Set a numeric vertex attribute for
@c      all vertices::) for a simpler way.

@c    Time complexity: O(n), the number of vertices.

@c
@c File: igraph_reference_manual.info,  Node: SETVANV --- Set a numeric vertex attribute for all vertices,  Next: igraph_cattribute_VAS_setv --- Set a string vertex attribute for all vertices_,  Prev: igraph_cattribute_VAN_setv --- Set a numeric vertex attribute for all vertices_,  Up: Set attributes

@c 9.2.2.14 SETVANV -- Set a numeric vertex attribute for all vertices
@c ...................................................................


@c      #define SETVANV(graph,n,v)

@c    This is a shorthand for `igraph_cattribute_VAN_setv()' (*note
@c igraph_cattribute_VAN_setv --- Set a numeric vertex attribute for all
@c vertices_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `v':
@c      Vector containing the new values of the attributes.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_VAS_setv --- Set a string vertex attribute for all vertices_,  Next: SETVASV --- Set a string vertex attribute for all vertices,  Prev: SETVANV --- Set a numeric vertex attribute for all vertices,  Up: Set attributes

@c 9.2.2.15 igraph_cattribute_VAS_setv -- Set a string vertex attribute for all vertices.
@c ......................................................................................


@c      int igraph_cattribute_VAS_setv(igraph_t *graph, const char *name,
@c      			       const igraph_strvector_t *sv);

@c    The attribute will be added if not present yet.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `sv':
@c      String vector, the new attribute values. The length of this vector
@c      must match the number of vertices.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETVASV' (*note SETVASV --- Set a string vertex attribute for all
@c      vertices::) for a simpler way.

@c    Time complexity: O(n+l), n is the number of vertices, l is the total
@c length of the strings.

@c
@c File: igraph_reference_manual.info,  Node: SETVASV --- Set a string vertex attribute for all vertices,  Next: igraph_cattribute_EAN_setv --- Set a numeric edge attribute for all vertices_,  Prev: igraph_cattribute_VAS_setv --- Set a string vertex attribute for all vertices_,  Up: Set attributes

@c 9.2.2.16 SETVASV -- Set a string vertex attribute for all vertices
@c ..................................................................


@c      #define SETVASV(graph,n,v)

@c    This is a shorthand for `igraph_cattribute_VAS_setv()' (*note
@c igraph_cattribute_VAS_setv --- Set a string vertex attribute for all
@c vertices_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `v':
@c      Vector containing the new values of the attributes.

@c    *Returns:. *

@c `'
@c      Error code.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EAN_setv --- Set a numeric edge attribute for all vertices_,  Next: SETEANV --- Set a numeric edge attribute for all vertices,  Prev: SETVASV --- Set a string vertex attribute for all vertices,  Up: Set attributes

@c 9.2.2.17 igraph_cattribute_EAN_setv -- Set a numeric edge attribute for all vertices.
@c .....................................................................................


@c      int igraph_cattribute_EAN_setv(igraph_t *graph, const char *name,
@c      			       const igraph_vector_t *v);

@c    The attribute will be added if not present yet.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `v':
@c      The new attribute values. The length of this vector must match the
@c      number of edges.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETEANV' (*note SETEANV --- Set a numeric edge attribute for all
@c      vertices::) for a simpler way.

@c    Time complexity: O(e), the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: SETEANV --- Set a numeric edge attribute for all vertices,  Next: igraph_cattribute_EAS_setv --- Set a string edge attribute for all vertices_,  Prev: igraph_cattribute_EAN_setv --- Set a numeric edge attribute for all vertices_,  Up: Set attributes

@c 9.2.2.18 SETEANV -- Set a numeric edge attribute for all vertices
@c .................................................................


@c      #define SETEANV(graph,n,v)

@c    This is a shorthand for `igraph_cattribute_EAN_setv()' (*note
@c igraph_cattribute_EAN_setv --- Set a numeric edge attribute for all
@c vertices_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `v':
@c      Vector containing the new values of the attributes.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_EAS_setv --- Set a string edge attribute for all vertices_,  Next: SETEASV --- Set a string edge attribute for all vertices,  Prev: SETEANV --- Set a numeric edge attribute for all vertices,  Up: Set attributes

@c 9.2.2.19 igraph_cattribute_EAS_setv -- Set a string edge attribute for all vertices.
@c ....................................................................................


@c      int igraph_cattribute_EAS_setv(igraph_t *graph, const char *name,
@c      			       const igraph_strvector_t *sv);

@c    The attribute will be added if not present yet.

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `name':
@c      Name of the attribute.

@c `sv':
@c      String vector, the new attribute values. The length of this vector
@c      must match the number of edges.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `SETEASV' (*note SETEASV --- Set a string edge attribute for all
@c      vertices::) for a simpler way.

@c    Time complexity: O(e+l), e is the number of edges, l is the total
@c length of the strings.

@c
@c File: igraph_reference_manual.info,  Node: SETEASV --- Set a string edge attribute for all vertices,  Prev: igraph_cattribute_EAS_setv --- Set a string edge attribute for all vertices_,  Up: Set attributes

@c 9.2.2.20 SETEASV -- Set a string edge attribute for all vertices
@c ................................................................


@c      #define SETEASV(graph,n,v)

@c    This is a shorthand for `igraph_cattribute_EAS_setv()' (*note
@c igraph_cattribute_EAS_setv --- Set a string edge attribute for all
@c vertices_::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute.

@c `v':
@c      Vector containing the new values of the attributes.

@c
@c File: igraph_reference_manual.info,  Node: Remove attributes,  Prev: Set attributes,  Up: Accessing attributes from C

@c 9.2.3 Remove attributes
@c -----------------------

@c * Menu:

@c * igraph_cattribute_remove_g --- Remove a graph attribute::
@c * DELGA --- Remove a graph attribute.: DELGA --- Remove a graph attribute_.
@c * igraph_cattribute_remove_v --- Remove a vertex attribute::
@c * DELVA --- Remove a vertex attribute.: DELVA --- Remove a vertex attribute_.
@c * igraph_cattribute_remove_e --- Remove an edge attribute::
@c * DELEA --- Remove an edge attribute.: DELEA --- Remove an edge attribute_.
@c * igraph_cattribute_remove_all --- Remove all graph/vertex/edge attributes::
@c * DELGAS --- Remove all graph attributes.: DELGAS --- Remove all graph attributes_.
@c * DELVAS --- Remove all vertex attributes.: DELVAS --- Remove all vertex attributes_.
@c * DELEAS --- Remove all edge attributes.: DELEAS --- Remove all edge attributes_.
@c * DELALL --- Remove all attributes.: DELALL --- Remove all attributes_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_remove_g --- Remove a graph attribute,  Next: DELGA --- Remove a graph attribute_,  Up: Remove attributes

@c 9.2.3.1 igraph_cattribute_remove_g -- Remove a graph attribute
@c ..............................................................


@c      void igraph_cattribute_remove_g(igraph_t *graph, const char *name);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `name':
@c      Name of the graph attribute to remove.

@c    *See also:. *

@c `'
@c      `DELGA' (*note DELGA --- Remove a graph attribute_::) for a
@c      simpler way.

@c
@c File: igraph_reference_manual.info,  Node: DELGA --- Remove a graph attribute_,  Next: igraph_cattribute_remove_v --- Remove a vertex attribute,  Prev: igraph_cattribute_remove_g --- Remove a graph attribute,  Up: Remove attributes

@c 9.2.3.2 DELGA -- Remove a graph attribute.
@c ..........................................


@c      #define DELGA(graph,n)

@c    A shorthand for `igraph_cattribute_remove_g()' (*note
@c igraph_cattribute_remove_g --- Remove a graph attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute to remove.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_remove_v --- Remove a vertex attribute,  Next: DELVA --- Remove a vertex attribute_,  Prev: DELGA --- Remove a graph attribute_,  Up: Remove attributes

@c 9.2.3.3 igraph_cattribute_remove_v -- Remove a vertex attribute
@c ...............................................................


@c      void igraph_cattribute_remove_v(igraph_t *graph, const char *name);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `name':
@c      Name of the vertex attribute to remove.

@c    *See also:. *

@c `'
@c      `DELVA' (*note DELVA --- Remove a vertex attribute_::) for a
@c      simpler way.

@c
@c File: igraph_reference_manual.info,  Node: DELVA --- Remove a vertex attribute_,  Next: igraph_cattribute_remove_e --- Remove an edge attribute,  Prev: igraph_cattribute_remove_v --- Remove a vertex attribute,  Up: Remove attributes

@c 9.2.3.4 DELVA -- Remove a vertex attribute.
@c ...........................................


@c      #define DELVA(graph,n)

@c    A shorthand for `igraph_cattribute_remove_v()' (*note
@c igraph_cattribute_remove_v --- Remove a vertex attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute to remove.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_remove_e --- Remove an edge attribute,  Next: DELEA --- Remove an edge attribute_,  Prev: DELVA --- Remove a vertex attribute_,  Up: Remove attributes

@c 9.2.3.5 igraph_cattribute_remove_e -- Remove an edge attribute
@c ..............................................................


@c      void igraph_cattribute_remove_e(igraph_t *graph, const char *name);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `name':
@c      Name of the edge attribute to remove.

@c    *See also:. *

@c `'
@c      `DELEA' (*note DELEA --- Remove an edge attribute_::) for a
@c      simpler way.

@c
@c File: igraph_reference_manual.info,  Node: DELEA --- Remove an edge attribute_,  Next: igraph_cattribute_remove_all --- Remove all graph/vertex/edge attributes,  Prev: igraph_cattribute_remove_e --- Remove an edge attribute,  Up: Remove attributes

@c 9.2.3.6 DELEA -- Remove an edge attribute.
@c ..........................................


@c      #define DELEA(graph,n)

@c    A shorthand for `igraph_cattribute_remove_e()' (*note
@c igraph_cattribute_remove_e --- Remove an edge attribute::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c `n':
@c      The name of the attribute to remove.

@c
@c File: igraph_reference_manual.info,  Node: igraph_cattribute_remove_all --- Remove all graph/vertex/edge attributes,  Next: DELGAS --- Remove all graph attributes_,  Prev: DELEA --- Remove an edge attribute_,  Up: Remove attributes

@c 9.2.3.7 igraph_cattribute_remove_all -- Remove all graph/vertex/edge attributes
@c ...............................................................................


@c      void igraph_cattribute_remove_all(igraph_t *graph, igraph_bool_t g,
@c      				  igraph_bool_t v, igraph_bool_t e);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `g':
@c      Boolean, whether to remove graph attributes.

@c `v':
@c      Boolean, whether to remove vertex attributes.

@c `e':
@c      Boolean, whether to remove edge attributes.

@c    *See also:. *

@c `'
@c      `DELGAS' (*note DELGAS --- Remove all graph attributes_::),
@c      `DELVAS' (*note DELVAS --- Remove all vertex attributes_::),
@c      `DELEAS' (*note DELEAS --- Remove all edge attributes_::),
@c      `DELALL' (*note DELALL --- Remove all attributes_::) for simpler
@c      ways.

@c
@c File: igraph_reference_manual.info,  Node: DELGAS --- Remove all graph attributes_,  Next: DELVAS --- Remove all vertex attributes_,  Prev: igraph_cattribute_remove_all --- Remove all graph/vertex/edge attributes,  Up: Remove attributes

@c 9.2.3.8 DELGAS -- Remove all graph attributes.
@c ..............................................


@c      #define DELGAS(graph)

@c    Calls `igraph_cattribute_remove_all()' (*note
@c igraph_cattribute_remove_all --- Remove all graph/vertex/edge
@c attributes::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c
@c File: igraph_reference_manual.info,  Node: DELVAS --- Remove all vertex attributes_,  Next: DELEAS --- Remove all edge attributes_,  Prev: DELGAS --- Remove all graph attributes_,  Up: Remove attributes

@c 9.2.3.9 DELVAS -- Remove all vertex attributes.
@c ...............................................


@c      #define DELVAS(graph)

@c    Calls `igraph_cattribute_remove_all()' (*note
@c igraph_cattribute_remove_all --- Remove all graph/vertex/edge
@c attributes::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c
@c File: igraph_reference_manual.info,  Node: DELEAS --- Remove all edge attributes_,  Next: DELALL --- Remove all attributes_,  Prev: DELVAS --- Remove all vertex attributes_,  Up: Remove attributes

@c 9.2.3.10 DELEAS -- Remove all edge attributes.
@c ..............................................


@c      #define DELEAS(graph)

@c    Calls `igraph_cattribute_remove_all()' (*note
@c igraph_cattribute_remove_all --- Remove all graph/vertex/edge
@c attributes::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c
@c File: igraph_reference_manual.info,  Node: DELALL --- Remove all attributes_,  Prev: DELEAS --- Remove all edge attributes_,  Up: Remove attributes

@c 9.2.3.11 DELALL -- Remove all attributes.
@c .........................................


@c      #define DELALL(graph)

@c    All graph, vertex and edges attributes will be removed.  Calls
@c `igraph_cattribute_remove_all()' (*note igraph_cattribute_remove_all
@c --- Remove all graph/vertex/edge attributes::).

@c    *Arguments:. *

@c `graph':
@c      The graph.

@c
@c File: igraph_reference_manual.info,  Node: Structural Properties of Graphs,  Next: Cliques and Independent Vertex Sets,  Prev: Graph; Vertex and Edge Attributes,  Up: Top

@c 10 Structural Properties of Graphs
@c **********************************

@c These functions usually calculate some structural property of a graph,
@c like its diameter, the degree of the nodes, etc.

@c * Menu:

@c * Basic Properties::
@c * Shortest Path Related Functions::
@c * Neighborhood of a vertex::
@c * Graph Components::
@c * Centrality Measures::
@c * Estimating Centrality Measures::
@c * Similarity Measures::
@c * Spanning Tree::
@c * Transitivity or Clustering Coefficient::
@c * Directedness conversion::
@c * Spectral properties::
@c * Non-simple graphs; multiple and loop edges::
@c * K-Cores::
@c * Topological sorting::
@c * Line graphs::
@c * Unfolding a graph into a tree::
@c * Other Operations::

@c
@c File: igraph_reference_manual.info,  Node: Basic Properties,  Next: Shortest Path Related Functions,  Up: Structural Properties of Graphs

@c 10.1 Basic Properties
@c =====================

@c * Menu:

@c * igraph_are_connected --- Decides whether two vertices are connected : igraph_are_connected --- Decides whether two vertices are connected.

@c
@c File: igraph_reference_manual.info,  Node: igraph_are_connected --- Decides whether two vertices are connected,  Up: Basic Properties

@c 10.1.1 igraph_are_connected -- Decides whether two vertices are connected
@c -------------------------------------------------------------------------


@c      int igraph_are_connected(const igraph_t *graph,
@c      			 igraph_integer_t v1, igraph_integer_t v2,
@c      			 igraph_bool_t *res);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `v1':
@c      The first vertex.

@c `v2':
@c      The second vertex.

@c `res':
@c      Boolean, `TRUE' if there is an edge from `v1' to `v2', `FALSE'
@c      otherwise.

@c    *Returns:. *

@c `'
@c      Error code.

@c    The function is of course symmetric for undirected graphs.

@c    Time complexity: O( min(log(d1), log(d2)) ), d1 is the (out-)degree
@c of `v1' and d2 is the (in-)degree of `v2'.

@c
@c File: igraph_reference_manual.info,  Node: Shortest Path Related Functions,  Next: Neighborhood of a vertex,  Prev: Basic Properties,  Up: Structural Properties of Graphs

@c 10.2 Shortest Path Related Functions
@c ====================================

@c * Menu:

@c * igraph_shortest_paths --- The length of the shortest paths between vertices.: igraph_shortest_paths --- The length of the shortest paths between vertices_.
@c * igraph_shortest_paths_dijkstra --- Weighted shortest paths from some sources::
@c * igraph_shortest_paths_bellman_ford --- Weighted shortest paths from some sources allowing negative weights::
@c * igraph_shortest_paths_johnson --- Calculate shortest paths from some sources using Johnson's algorithm::
@c * igraph_get_shortest_paths --- Calculates the shortest paths from/to one vertex.: igraph_get_shortest_paths --- Calculates the shortest paths from/to one vertex_.
@c * igraph_get_shortest_paths_dijkstra --- Calculates the weighted shortest paths from/to one vertex.: igraph_get_shortest_paths_dijkstra --- Calculates the weighted shortest paths from/to one vertex_.
@c * igraph_get_all_shortest_paths --- Finds all shortest paths (geodesics) from a vertex to all other vertices : igraph_get_all_shortest_paths --- Finds all shortest paths [geodesics] from a vertex to all other vertices.
@c * igraph_average_path_length --- Calculates the average geodesic length in a graph.: igraph_average_path_length --- Calculates the average geodesic length in a graph_.
@c * igraph_path_length_hist --- Create a histogram of all shortest path lenghts::
@c * igraph_diameter --- Calculates the diameter of a graph (longest geodesic).: igraph_diameter --- Calculates the diameter of a graph [longest geodesic]_.
@c * igraph_girth --- The girth of a graph is the length of the shortest circle in it.: igraph_girth --- The girth of a graph is the length of the shortest circle in it_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_shortest_paths --- The length of the shortest paths between vertices_,  Next: igraph_shortest_paths_dijkstra --- Weighted shortest paths from some sources,  Up: Shortest Path Related Functions

@c 10.2.1 igraph_shortest_paths -- The length of the shortest paths between vertices.
@c ----------------------------------------------------------------------------------


@c      int igraph_shortest_paths(const igraph_t *graph, igraph_matrix_t *res,
@c      			  const igraph_vs_t from, igraph_neimode_t mode);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result of the calculation, a matrix. It has the same number of
@c      rows as the length of the `from' argument, and its number of
@c      columns is the number of vertices in the graph. One row of the
@c      matrix shows the distances from/to a given vertex to all the
@c      others in the graph, the order is fixed by the vertex ids. For the
@c      unreachable vertices IGRAPH_INFINITY is returned.

@c `from':
@c      Vector of the vertex ids for which the path length calculations
@c      are done.

@c `mode':
@c      The type of shortest paths to be use for the calculation in
@c      directed graphs. Possible values:

@c     `IGRAPH_OUT '
@c           the lengths of the outgoing paths are calculated.

@c     `IGRAPH_IN '
@c           the lengths of the incoming paths are calculated.

@c     `IGRAPH_ALL '
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM '
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           invalid vertex id passed.

@c     `IGRAPH_EINVMODE '
@c           invalid mode argument.

@c    Time complexity: O(n(|V|+|E|)), n is the number of vertices to
@c calculate, |V| and |E| are the number of vertices and edges in the
@c graph.

@c    *See also:. *

@c `'
@c      `igraph_get_shortest_paths()' (*note igraph_get_shortest_paths ---
@c      Calculates the shortest paths from/to one vertex_::) to get the
@c      paths themselves, `igraph_shortest_paths_dijkstra()' (*note
@c      igraph_shortest_paths_dijkstra --- Weighted shortest paths from
@c      some sources::) for the weighted version.

@c
@c File: igraph_reference_manual.info,  Node: igraph_shortest_paths_dijkstra --- Weighted shortest paths from some sources,  Next: igraph_shortest_paths_bellman_ford --- Weighted shortest paths from some sources allowing negative weights,  Prev: igraph_shortest_paths --- The length of the shortest paths between vertices_,  Up: Shortest Path Related Functions

@c 10.2.2 igraph_shortest_paths_dijkstra -- Weighted shortest paths from some sources
@c ----------------------------------------------------------------------------------


@c      int igraph_shortest_paths_dijkstra(const igraph_t *graph,
@c      				   igraph_matrix_t *res,
@c      				   const igraph_vs_t from,
@c      				   const igraph_vector_t *weights,
@c      				   igraph_neimode_t mode);

@c    This function is Dijkstra's algorithm to find the weighted shortest
@c paths to all vertices from a single source. (It is run independently
@c for the given sources.) It uses a binary heap for efficient
@c implementation.

@c    *Arguments:. *

@c `graph':
@c      The input graph, can be directed.

@c `res':
@c      The result, a matrix. Each row contains the distances from a
@c      single source, in the order of vertex ids.  Unreachable vertices
@c      has distance `IGRAPH_INFINITY'.

@c `from':
@c      The source vertices.

@c `weights':
@c      The edge weights. They must be all non-negative for Dijkstra's
@c      algorithm to work. An error code is returned if there is a
@c      negative edge weight in the weight vector. If this is a null
@c      pointer, then the unweighted version, `igraph_shortest_paths()'
@c      (*note igraph_shortest_paths --- The length of the shortest paths
@c      between vertices_::) is called.

@c `mode':
@c      For directed graphs; whether to follow paths along edge directions
@c      (`IGRAPH_OUT'), or the opposite (`IGRAPH_IN'), or ignore edge
@c      directions completely (`IGRAPH_ALL'). It is ignored for undirected
@c      graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(s*|E|log|E|+|V|), where |V| is the number of
@c vertices, |E| the number of edges and s the number of sources.

@c    *See also:. *

@c `'
@c      `igraph_shortest_paths()' (*note igraph_shortest_paths --- The
@c      length of the shortest paths between vertices_::) for a (slightly)
@c      faster unweighted version or
@c      `igraph_shortest_paths_bellman_ford()' (*note
@c      igraph_shortest_paths_bellman_ford --- Weighted shortest paths
@c      from some sources allowing negative weights::) for a weighted
@c      variant that works in the presence of negative edge weights (but no
@c      negative loops).

@c
@c File: igraph_reference_manual.info,  Node: igraph_shortest_paths_bellman_ford --- Weighted shortest paths from some sources allowing negative weights,  Next: igraph_shortest_paths_johnson --- Calculate shortest paths from some sources using Johnson's algorithm,  Prev: igraph_shortest_paths_dijkstra --- Weighted shortest paths from some sources,  Up: Shortest Path Related Functions

@c 10.2.3 igraph_shortest_paths_bellman_ford -- Weighted shortest paths from some sources allowing negative weights
@c ----------------------------------------------------------------------------------------------------------------


@c      int igraph_shortest_paths_bellman_ford(const igraph_t *graph,
@c      				       igraph_matrix_t *res,
@c      				       const igraph_vs_t from,
@c      				       const igraph_vector_t *weights,
@c      				       igraph_neimode_t mode);

@c    This function is the Bellman-Ford algorithm to find the weighted
@c shortest paths to all vertices from a single source. (It is run
@c independently for the given sources.). If there are no negative
@c weights, you are better off with `igraph_shortest_paths_dijkstra()'
@c (*note igraph_shortest_paths_dijkstra --- Weighted shortest paths from
@c some sources::) .

@c    *Arguments:. *

@c `graph':
@c      The input graph, can be directed.

@c `res':
@c      The result, a matrix. Each row contains the distances from a
@c      single source, in the order of vertex ids.  Unreachable vertices
@c      has distance `IGRAPH_INFINITY'.

@c `from':
@c      The source vertices.

@c `weights':
@c      The edge weights. There mustn't be any closed loop in the graph
@c      that has a negative total weight (since this would allow us to
@c      decrease the weight of any path containing at least a single
@c      vertex of this loop infinitely). If this is a null pointer, then
@c      the unweighted version, `igraph_shortest_paths()' (*note
@c      igraph_shortest_paths --- The length of the shortest paths between
@c      vertices_::) is called.

@c `mode':
@c      For directed graphs; whether to follow paths along edge directions
@c      (`IGRAPH_OUT'), or the opposite (`IGRAPH_IN'), or ignore edge
@c      directions completely (`IGRAPH_ALL'). It is ignored for undirected
@c      graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(s*|E|*|V|), where |V| is the number of vertices,
@c |E| the number of edges and s the number of sources.

@c    *See also:. *

@c `'
@c      `igraph_shortest_paths()' (*note igraph_shortest_paths --- The
@c      length of the shortest paths between vertices_::) for a faster
@c      unweighted version or `igraph_shortest_paths_dijkstra()' (*note
@c      igraph_shortest_paths_dijkstra --- Weighted shortest paths from
@c      some sources::) if you do not have negative edge weights.

@c
@c File: igraph_reference_manual.info,  Node: igraph_shortest_paths_johnson --- Calculate shortest paths from some sources using Johnson's algorithm,  Next: igraph_get_shortest_paths --- Calculates the shortest paths from/to one vertex_,  Prev: igraph_shortest_paths_bellman_ford --- Weighted shortest paths from some sources allowing negative weights,  Up: Shortest Path Related Functions

@c 10.2.4 igraph_shortest_paths_johnson -- Calculate shortest paths from some sources using Johnson's algorithm
@c ------------------------------------------------------------------------------------------------------------


@c      int igraph_shortest_paths_johnson(const igraph_t *graph,
@c      				  igraph_matrix_t *res,
@c      				  const igraph_vs_t from,
@c      				  const igraph_vector_t *weights);

@c    See Wikipedia at http://en.wikipedia.org/wiki/Johnson's_algorithm
@c (http://en.wikipedia.org/wiki/Johnson's_algorithm) for Johnson's
@c algorithm. This algorithm works even if the graph contains negative
@c edge weights, and it is worth using it if we calculate the shortest
@c paths from many sources.

@c    If no edge weights are supplied, then the unweighted version,
@c `igraph_shortest_paths()' (*note igraph_shortest_paths --- The length
@c of the shortest paths between vertices_::) is called.

@c    If all the supplied edge weights are non-negative, then Dijkstra's
@c algorithm is used by calling `igraph_shortest_paths_dijkstra()' (*note
@c igraph_shortest_paths_dijkstra --- Weighted shortest paths from some
@c sources::).

@c    *Arguments:. *

@c `graph':
@c      The input graph, typically it is directed.

@c `res':
@c      Pointer to an initialized matrix, the result will be stored here,
@c      one line for each source vertex.

@c `from':
@c      The source vertices.

@c `weights':
@c      Optional edge weights. If it is a null-pointer, then the
@c      unweighted breadth-first search based `igraph_shortest_paths()'
@c      (*note igraph_shortest_paths --- The length of the shortest paths
@c      between vertices_::) will be called.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(s|V|log|V|+|V||E|), |V| and |E| are the number of
@c vertices and edges, s is the number of source vertices.

@c    *See also:. *

@c `'
@c      `igraph_shortest_paths()' (*note igraph_shortest_paths --- The
@c      length of the shortest paths between vertices_::) for a faster
@c      unweighted version or `igraph_shortest_paths_dijkstra()' (*note
@c      igraph_shortest_paths_dijkstra --- Weighted shortest paths from
@c      some sources::) if you do not have negative edge weights,
@c      `igraph_shortest_paths_bellman_ford()' (*note
@c      igraph_shortest_paths_bellman_ford --- Weighted shortest paths
@c      from some sources allowing negative weights::) if you only need to
@c      calculate shortest paths from a couple of sources.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_shortest_paths --- Calculates the shortest paths from/to one vertex_,  Next: igraph_get_shortest_paths_dijkstra --- Calculates the weighted shortest paths from/to one vertex_,  Prev: igraph_shortest_paths_johnson --- Calculate shortest paths from some sources using Johnson's algorithm,  Up: Shortest Path Related Functions

@c 10.2.5 igraph_get_shortest_paths -- Calculates the shortest paths from/to one vertex.
@c -------------------------------------------------------------------------------------


@c      int igraph_get_shortest_paths(const igraph_t *graph, igraph_vector_ptr_t *res,
@c      			      igraph_integer_t from, const igraph_vs_t to,
@c      			      igraph_neimode_t mode);

@c    If there is more than one geodesic between two vertices, this
@c function gives only one of them.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result, this is a pointer vector, each element points to a
@c      vector object. These should be initialized before passing them to
@c      the function, which will properly clear and/or resize them and
@c      fill the ids of the vertices along the geodesics from/to the
@c      vertices.

@c `from':
@c      The id of the vertex from/to which the geodesics are calculated.

@c `to':
@c      Vertex sequence with the ids of the vertices to/from which the
@c      shortest paths will be calculated. A vertex might be given multiple
@c      times.

@c `mode':
@c      The type of shortest paths to be use for the calculation in
@c      directed graphs. Possible values:

@c     `IGRAPH_OUT '
@c           the outgoing paths are calculated.

@c     `IGRAPH_IN '
@c           the incoming paths are calculated.

@c     `IGRAPH_ALL '
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM '
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           `from' is invalid vertex id, or the length of `to' is not the
@c           same as the length of `res'.

@c     `IGRAPH_EINVMODE '
@c           invalid mode argument.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| the
@c number of edges in the graph.

@c    *See also:. *

@c `'
@c      `igraph_shortest_paths()' (*note igraph_shortest_paths --- The
@c      length of the shortest paths between vertices_::) if you only need
@c      the path length but not the paths themselves.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_shortest_paths_dijkstra --- Calculates the weighted shortest paths from/to one vertex_,  Next: igraph_get_all_shortest_paths --- Finds all shortest paths [geodesics] from a vertex to all other vertices,  Prev: igraph_get_shortest_paths --- Calculates the shortest paths from/to one vertex_,  Up: Shortest Path Related Functions

@c 10.2.6 igraph_get_shortest_paths_dijkstra -- Calculates the weighted shortest paths from/to one vertex.
@c -------------------------------------------------------------------------------------------------------


@c      int igraph_get_shortest_paths_dijkstra(const igraph_t *graph,
@c                                             igraph_vector_ptr_t *res,
@c      				       igraph_integer_t from,
@c      				       igraph_vs_t to,
@c      				       const igraph_vector_t *weights,
@c      				       igraph_neimode_t mode);

@c    If there is more than one path with the smallest weight between two
@c vertices, this function gives only one of them.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result, this is a pointer vector, each element points to a
@c      vector object. These should be initialized before passing them to
@c      the function, which will properly clear and/or resize them and
@c      fill the ids of the vertices along the geodesics from/to the
@c      vertices.

@c `from':
@c      The id of the vertex from/to which the geodesics are calculated.

@c `to':
@c      Vertex sequence with the ids of the vertices to/from which the
@c      shortest paths will be calculated. A vertex might be given multiple
@c      times.

@c `weights':
@c      a vector holding the edge weights. All weights must be positive.

@c `mode':
@c      The type of shortest paths to be use for the calculation in
@c      directed graphs. Possible values:

@c     `IGRAPH_OUT '
@c           the outgoing paths are calculated.

@c     `IGRAPH_IN '
@c           the incoming paths are calculated.

@c     `IGRAPH_ALL '
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM '
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           `from' is invalid vertex id, or the length of `to' is not the
@c           same as the length of `res'.

@c     `IGRAPH_EINVMODE '
@c           invalid mode argument.

@c    Time complexity: O(|E|log|E|+|V|), where |V| is the number of
@c vertices and |E| is the number of edges

@c    *See also:. *

@c `'
@c      `igraph_shortest_paths_dijkstra()' (*note
@c      igraph_shortest_paths_dijkstra --- Weighted shortest paths from
@c      some sources::) if you only need the path length but not the paths
@c      themselves, `igraph_get_shortest_paths()' (*note
@c      igraph_get_shortest_paths --- Calculates the shortest paths
@c      from/to one vertex_::) if all edge weights are equal.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_all_shortest_paths --- Finds all shortest paths [geodesics] from a vertex to all other vertices,  Next: igraph_average_path_length --- Calculates the average geodesic length in a graph_,  Prev: igraph_get_shortest_paths_dijkstra --- Calculates the weighted shortest paths from/to one vertex_,  Up: Shortest Path Related Functions

@c 10.2.7 igraph_get_all_shortest_paths -- Finds all shortest paths (geodesics) from a vertex to all other vertices
@c ----------------------------------------------------------------------------------------------------------------


@c      int igraph_get_all_shortest_paths(const igraph_t *graph,
@c      				  igraph_vector_ptr_t *res,
@c      				  igraph_vector_t *nrgeo,
@c      				  igraph_integer_t from, const igraph_vs_t to,
@c      				  igraph_neimode_t mode);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      Pointer to an initialized pointer vector, the result will be
@c      stored here in igraph_vector_t objects. Each vector object
@c      contains the vertices along a shortest path from `from' to another
@c      vertex. The vectors are ordered according to their target vertex:
@c      first the shortest paths to vertex 0, then to vertex 1, etc. No
@c      data is included for unreachable vertices.

@c `nrgeo':
@c      Pointer to an initialized igraph_vector_t object or NULL. If not
@c      NULL the number of shortest paths from `from' are is stored here
@c      for every vertex in the graph.

@c `from':
@c      The id of the vertex from/to which the geodesics are calculated.

@c `mode':
@c      The type of shortest paths to be use for the calculation in
@c      directed graphs. Possible values:

@c     `IGRAPH_OUT '
@c           the lengths of the outgoing paths are calculated.

@c     `IGRAPH_IN '
@c           the lengths of the incoming paths are calculated.

@c     `IGRAPH_ALL '
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM '
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           `from' is invalid vertex id.

@c     `IGRAPH_EINVMODE '
@c           invalid mode argument.

@c    Added in version 0.2.

@c    Time complexity: O(|V|+|E|) for most graphs, O(|V|^2) in the worst
@c case.

@c
@c File: igraph_reference_manual.info,  Node: igraph_average_path_length --- Calculates the average geodesic length in a graph_,  Next: igraph_path_length_hist --- Create a histogram of all shortest path lenghts,  Prev: igraph_get_all_shortest_paths --- Finds all shortest paths [geodesics] from a vertex to all other vertices,  Up: Shortest Path Related Functions

@c 10.2.8 igraph_average_path_length -- Calculates the average geodesic length in a graph.
@c ---------------------------------------------------------------------------------------


@c      int igraph_average_path_length(const igraph_t *graph, igraph_real_t *res,
@c      			       igraph_bool_t directed, igraph_bool_t unconn);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      Pointer to a real number, this will contain the result.

@c `directed':
@c      Boolean, whether to consider directed paths. Ignored for
@c      undirected graphs.

@c `unconn':
@c      What to do if the graph is not connected. If `TRUE' the average of
@c      thr geodesics within the components will be returned, otherwise
@c      the number of vertices is used for the length of non-existing
@c      geodesics. (The rationale behind this is that this is always
@c      longer than the longest possible geodesic in a graph.)

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for data structures

@c    Time complexity: O(|V||E|), the number of vertices times the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_path_length_hist --- Create a histogram of all shortest path lenghts,  Next: igraph_diameter --- Calculates the diameter of a graph [longest geodesic]_,  Prev: igraph_average_path_length --- Calculates the average geodesic length in a graph_,  Up: Shortest Path Related Functions

@c 10.2.9 igraph_path_length_hist -- Create a histogram of all shortest path lenghts
@c ---------------------------------------------------------------------------------


@c      int igraph_path_length_hist(const igraph_t *graph, igraph_vector_t *res,
@c      			    igraph_real_t *unconnected, igraph_bool_t directed);

@c    This function calculates a histogram, by calculating the shortest
@c path length between each pair of vertices. For directed graphs both
@c directions might be considered and then every pair of vertices appears
@c twice in the histogram.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized vector, the result is stored here. The
@c      first (i.e. zeroth) element contains the number of shortest paths
@c      of length 1, etc. The supplied vector is resized as needed.

@c `unconnected':
@c      Pointer to a real number, the number of pairs for which the second
@c      vertex is not reachable from the first is stored here.

@c `directed':
@c      Whether to consider directed paths in a directed graph (if not
@c      zero). This argument is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V||E|), the number of vertices times the number
@c of edges.

@c    *See also:. *

@c `'
@c      `igraph_average_path_length()' (*note igraph_average_path_length
@c      --- Calculates the average geodesic length in a graph_::) and
@c      `igraph_shortest_paths()' (*note igraph_shortest_paths --- The
@c      length of the shortest paths between vertices_::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_diameter --- Calculates the diameter of a graph [longest geodesic]_,  Next: igraph_girth --- The girth of a graph is the length of the shortest circle in it_,  Prev: igraph_path_length_hist --- Create a histogram of all shortest path lenghts,  Up: Shortest Path Related Functions

@c 10.2.10 igraph_diameter -- Calculates the diameter of a graph (longest geodesic).
@c ---------------------------------------------------------------------------------


@c      int igraph_diameter(const igraph_t *graph, igraph_integer_t *pres,
@c      		    igraph_integer_t *pfrom, igraph_integer_t *pto,
@c      		    igraph_vector_t *path,
@c      		    igraph_bool_t directed, igraph_bool_t unconn);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `pres':
@c      Pointer to an integer, if not `NULL' then it will contain the
@c      diameter (the actual distance).

@c `pfrom':
@c      Pointer to an integer, if not `NULL' it will be set to the source
@c      vertex of the diameter path.

@c `pto':
@c      Pointer to an integer, if not `NULL' it will be set to the target
@c      vertex of the diameter path.

@c `path':
@c      Pointer to an initialized vector. If not `NULL' the actual longest
@c      geodesic path will be stored here. The vector will be resized as
@c      needed.

@c `directed':
@c      Boolean, whether to consider directed paths. Ignored for
@c      undirected graphs.

@c `unconn':
@c      What to do if the graph is not connected. If `TRUE' the longest
@c      geodesic within a component will be returned, otherwise the number
@c      of vertices is returned. (The rationale behind the latter is that
@c      this is always longer than the longest possible diameter in a
@c      graph.)

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.

@c    Time complexity: O(|V||E|), the number of vertices times the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_girth --- The girth of a graph is the length of the shortest circle in it_,  Prev: igraph_diameter --- Calculates the diameter of a graph [longest geodesic]_,  Up: Shortest Path Related Functions

@c 10.2.11 igraph_girth -- The girth of a graph is the length of the shortest circle in it.
@c ----------------------------------------------------------------------------------------


@c      int igraph_girth(const igraph_t *graph, igraph_integer_t *girth,
@c      		 igraph_vector_t *circle);

@c    The current implementation works for undirected graphs only,
@c directed graphs are treated as undirected graphs. Loop edges and
@c multiple edges are ignored.

@c    If the graph is a forest (ie. acyclic), then zero is returned.

@c    This implementation is based on Alon Itai and Michael Rodeh: Finding
@c a minimum circuit in a graph _ Proceedings of the ninth annual ACM
@c symposium on Theory of computing _, 1-10, 1977. The first
@c implementation of this function was done by Keith Briggs, thanks Keith.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `girth':
@c      Pointer to an integer, if not `NULL' then the result will be
@c      stored here.

@c `circle':
@c      Pointer to an initialized vector, the vertex ids in the shortest
@c      circle will be stored here. If `NULL' then it is ignored.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O((|V|+|E|)^2), |V| is the number of vertices, |E|
@c is the number of edges in the general case. If the graph has no circles
@c at all then the function needs O(|V|+|E|) time to realize this and then
@c it stops.

@c
@c File: igraph_reference_manual.info,  Node: Neighborhood of a vertex,  Next: Graph Components,  Prev: Shortest Path Related Functions,  Up: Structural Properties of Graphs

@c 10.3 Neighborhood of a vertex
@c =============================

@c * Menu:

@c * igraph_neighborhood_size --- Calculates the size of the neighborhood of a given vertex::
@c * igraph_neighborhood --- Calculate the neighborhood of vertices::
@c * igraph_neighborhood_graphs --- Create graphs from the neighborhood(s) of some vertex/vertices: igraph_neighborhood_graphs --- Create graphs from the neighborhood[s] of some vertex/vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_neighborhood_size --- Calculates the size of the neighborhood of a given vertex,  Next: igraph_neighborhood --- Calculate the neighborhood of vertices,  Up: Neighborhood of a vertex

@c 10.3.1 igraph_neighborhood_size -- Calculates the size of the neighborhood of a given vertex
@c --------------------------------------------------------------------------------------------


@c      int igraph_neighborhood_size(const igraph_t *graph, igraph_vector_t *res,
@c      			     igraph_vs_t vids, igraph_integer_t order,
@c      			     igraph_neimode_t mode);

@c    The neighborhood of a given order of a vertex includes all vertices
@c which are closer to the vertex than the order. Ie. order 0 is always
@c the vertex itself, order 1 is the vertex plus its immediate neighbors,
@c order 2 is order 1 plus the immediate neighbors of the vertices in
@c order 1, etc.

@c    This function calculates the size of the neighborhood of the given
@c order for the given vertices.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized vector, the result will be stored here.
@c      It will be resized as needed.

@c `vids':
@c      The vertices for which the calculation is performed.

@c `order':
@c      Integer giving the order of the neighborhood.

@c `mode':
@c      Specifies how to use the direction of the edges if a directed
@c      graph is analyzed. For `IGRAPH_OUT' only the outgoing edges are
@c      followed, so all vertices reachable from the source vertex in at
@c      most `order' steps are counted. For `IGRAPH_IN' all vertices from
@c      which the source vertex is reachable in at most `order' steps are
@c      counted. `IGRAPH_ALL' ignores the direction of the edges. This
@c      argument is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_neighborhood()' (*note igraph_neighborhood --- Calculate
@c      the neighborhood of vertices::) for calculating the actual
@c      neighborhood, `igraph_neighborhood_graphs()' (*note
@c      igraph_neighborhood_graphs --- Create graphs from the
@c      neighborhood[s] of some vertex/vertices::) for creating separate
@c      graphs from the neighborhoods.

@c    Time complexity: O(n*d*o), where n is the number vertices for which
@c the calculation is performed, d is the average degree, o is the order.

@c
@c File: igraph_reference_manual.info,  Node: igraph_neighborhood --- Calculate the neighborhood of vertices,  Next: igraph_neighborhood_graphs --- Create graphs from the neighborhood[s] of some vertex/vertices,  Prev: igraph_neighborhood_size --- Calculates the size of the neighborhood of a given vertex,  Up: Neighborhood of a vertex

@c 10.3.2 igraph_neighborhood -- Calculate the neighborhood of vertices
@c --------------------------------------------------------------------


@c      int igraph_neighborhood(const igraph_t *graph, igraph_vector_ptr_t *res,
@c      			igraph_vs_t vids, igraph_integer_t order,
@c      			igraph_neimode_t mode);

@c    The neighborhood of a given order of a vertex includes all vertices
@c which are closer to the vertex than the order. Ie. order 0 is always
@c the vertex itself, order 1 is the vertex plus its immediate neighbors,
@c order 2 is order 1 plus the immediate neighbors of the vertices in
@c order 1, etc.

@c    This function calculates the vertices within the neighborhood of the
@c specified vertices.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      An initialized pointer vector. Note that the objects (pointers) in
@c      the vector will _not_ be freed, but the pointer vector will be
@c      resized as needed. The result of the calculation will be stored
@c      here in `vector_t' objects.

@c `vids':
@c      The vertices for which the calculation is performed.

@c `order':
@c      Integer giving the order of the neighborhood.

@c `mode':
@c      Specifies how to use the direction of the edges if a directed
@c      graph is analyzed. For `IGRAPH_OUT' only the outgoing edges are
@c      followed, so all vertices reachable from the source vertex in at
@c      most `order' steps are included. For `IGRAPH_IN' all vertices from
@c      which the source vertex is reachable in at most `order' steps are
@c      included. `IGRAPH_ALL' ignores the direction of the edges. This
@c      argument is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_neighborhood_size()' (*note igraph_neighborhood_size ---
@c      Calculates the size of the neighborhood of a given vertex::) to
@c      calculate the size of the neighborhood,
@c      `igraph_neighborhood_graphs()' (*note igraph_neighborhood_graphs
@c      --- Create graphs from the neighborhood[s] of some
@c      vertex/vertices::) for creating graphs from the neighborhoods.

@c    Time complexity: O(n*d*o), n is the number of vertices for which the
@c calculation is performed, d is the average degree, o is the order.

@c
@c File: igraph_reference_manual.info,  Node: igraph_neighborhood_graphs --- Create graphs from the neighborhood[s] of some vertex/vertices,  Prev: igraph_neighborhood --- Calculate the neighborhood of vertices,  Up: Neighborhood of a vertex

@c 10.3.3 igraph_neighborhood_graphs -- Create graphs from the neighborhood(s) of some vertex/vertices
@c ---------------------------------------------------------------------------------------------------


@c      int igraph_neighborhood_graphs(const igraph_t *graph, igraph_vector_ptr_t *res,
@c      			       igraph_vs_t vids, igraph_integer_t order,
@c      			       igraph_neimode_t mode);

@c    The neighborhood of a given order of a vertex includes all vertices
@c which are closer to the vertex than the order. Ie. order 0 is always
@c the vertex itself, order 1 is the vertex plus its immediate neighbors,
@c order 2 is order 1 plus the immediate neighbors of the vertices in
@c order 1, etc.

@c    This function finds every vertex in the neighborhood of a given
@c parameter vertex and creates a graph from these vertices.

@c    The first version of this function was written by Vincent Matossian,
@c thanks Vincent.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a pointer vector, the result will be stored here, ie.
@c      `res' will contain pointers to `igraph_t' objects. It will be
@c      resized if needed but note that the objects in the pointer vector
@c      will not be freed.

@c `vids':
@c      The vertices for which the calculation is performed.

@c `order':
@c      Integer giving the order of the neighborhood.

@c `mode':
@c      Specifies how to use the direction of the edges if a directed
@c      graph is analyzed. For `IGRAPH_OUT' only the outgoing edges are
@c      followed, so all vertices reachable from the source vertex in at
@c      most `order' steps are counted. For `IGRAPH_IN' all vertices from
@c      which the source vertex is reachable in at most `order' steps are
@c      counted. `IGRAPH_ALL' ignores the direction of the edges. This
@c      argument is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_neighborhood_size()' (*note igraph_neighborhood_size ---
@c      Calculates the size of the neighborhood of a given vertex::) for
@c      calculating the neighborhood sizes only, `igraph_neighborhood()'
@c      (*note igraph_neighborhood --- Calculate the neighborhood of
@c      vertices::) for calculating the neighborhoods (but not creating
@c      graphs).

@c    Time complexity: O(n*(|V|+|E|)), where n is the number vertices for
@c which the calculation is performed, |V| and |E| are the number of
@c vertices and edges in the original input graph.

@c
@c File: igraph_reference_manual.info,  Node: Graph Components,  Next: Centrality Measures,  Prev: Neighborhood of a vertex,  Up: Structural Properties of Graphs

@c 10.4 Graph Components
@c =====================

@c * Menu:

@c * igraph_subcomponent --- The vertices in the same component as a given vertex.: igraph_subcomponent --- The vertices in the same component as a given vertex_.
@c * igraph_subgraph --- Creates a subgraph with the specified vertices.: igraph_subgraph --- Creates a subgraph with the specified vertices_.
@c * igraph_clusters --- Calculates the (weakly or strongly) connected components in a graph. : igraph_clusters --- Calculates the [weakly or strongly] connected components in a graph_.
@c * igraph_is_connected --- Decides whether the graph is (weakly or strongly) connected.: igraph_is_connected --- Decides whether the graph is [weakly or strongly] connected_.
@c * igraph_decompose --- Decompose a graph into connected components.: igraph_decompose --- Decompose a graph into connected components_.
@c * igraph_biconnected_components --- Calculate biconnected components::
@c * igraph_articulation_points --- Find the articulation points in a graph.: igraph_articulation_points --- Find the articulation points in a graph_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_subcomponent --- The vertices in the same component as a given vertex_,  Next: igraph_subgraph --- Creates a subgraph with the specified vertices_,  Up: Graph Components

@c 10.4.1 igraph_subcomponent -- The vertices in the same component as a given vertex.
@c -----------------------------------------------------------------------------------


@c      int igraph_subcomponent(const igraph_t *graph, igraph_vector_t *res, igraph_real_t vertex,
@c      			igraph_neimode_t mode);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result, vector with the ids of the vertices in the same
@c      component.

@c `vertex':
@c      The id of the vertex of which the component is searched.

@c `mode':
@c      Type of the component for directed graphs, possible values:

@c     `IGRAPH_OUT '
@c           the set of vertices reachable _from_ the `vertex',

@c     `IGRAPH_IN'
@c           the set of vertices from which the `vertex' is reachable.

@c     `IGRAPH_ALL '
@c           the graph is considered as an undirected graph. Note that
@c           this is _not_ the same as the union of the previous two.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM '
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID '
@c           `vertex' is an invalid vertex id

@c     `IGRAPH_EINVMODE'
@c           invalid mode argument passed.

@c    Time complexity: O(|V|+|E|), |V| and |E| are the number of vertices
@c and edges in the graph.

@c    *See also:. *

@c `'
@c      `igraph_subgraph()' (*note igraph_subgraph --- Creates a subgraph
@c      with the specified vertices_::) if you want a graph object
@c      consisting only a given set of vertices and the edges between them.

@c
@c File: igraph_reference_manual.info,  Node: igraph_subgraph --- Creates a subgraph with the specified vertices_,  Next: igraph_clusters --- Calculates the [weakly or strongly] connected components in a graph_,  Prev: igraph_subcomponent --- The vertices in the same component as a given vertex_,  Up: Graph Components

@c 10.4.2 igraph_subgraph -- Creates a subgraph with the specified vertices.
@c -------------------------------------------------------------------------


@c      int igraph_subgraph(const igraph_t *graph, igraph_t *res,
@c      		    const igraph_vs_t vids);

@c    This function collects the specified vertices and all edges between
@c them to a new graph.  As the vertex ids in a graph always start with
@c one, this function very likely needs to reassign ids to the vertices.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The subgraph, another graph object will be stored here, do _not_
@c      initialize this object before calling this function, and call
@c      `igraph_destroy()' (*note igraph_destroy --- Frees the memory
@c      allocated for a graph object_::) on it if you don't need it any
@c      more.

@c `vids':
@c      Vector with the vertex ids to put in the subgraph.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.
@c      `IGRAPH_EINVVID', invalid vertex id in `vids'.

@c    Time complexity: O(|V|+|E|), |V| and |E| are the number of vertices
@c and edges in the original graph.

@c    *See also:. *

@c `'
@c      `igraph_delete_vertices()' (*note igraph_delete_vertices ---
@c      Removes vertices [with all their edges] from the graph_::) to
@c      delete the specified set of vertices from a graph, the opposite of
@c      this function.

@c
@c File: igraph_reference_manual.info,  Node: igraph_clusters --- Calculates the [weakly or strongly] connected components in a graph_,  Next: igraph_is_connected --- Decides whether the graph is [weakly or strongly] connected_,  Prev: igraph_subgraph --- Creates a subgraph with the specified vertices_,  Up: Graph Components

@c 10.4.3 igraph_clusters -- Calculates the (weakly or strongly) connected components in a graph.
@c ----------------------------------------------------------------------------------------------


@c      int igraph_clusters(const igraph_t *graph, igraph_vector_t *membership,
@c      		    igraph_vector_t *csize, igraph_integer_t *no,
@c      		    igraph_connectedness_t mode);

@c    *Arguments:. *

@c `graph':
@c      The graph object to analyze.

@c `membership':
@c      First half of the result will be stored here. For every vertex the
@c      id of its component is given. The vector has to be preinitialized
@c      and will be resized. Alternatively this argument can be `NULL', in
@c      which case it is ignored.

@c `csize':
@c      The second half of the result. For every component it gives its
@c      size, the order is defined by the component ids.  The vector has
@c      to be preinitialized and will be resized.  Alternatively this
@c      argument can be `NULL', in which case it is ignored.

@c `no':
@c      Pointer to an integer, if not `NULL' then the number of clusters
@c      will be stored here.

@c `mode':
@c      For directed graph this specifies whether to calculate weakly or
@c      strongly connected components. Possible values: `IGRAPH_WEAK',
@c      `IGRAPH_STRONG'. This argument is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid mode argument.

@c    Time complexity: O(|V|+|E|), |V| and |E| are the number of vertices
@c and edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_is_connected --- Decides whether the graph is [weakly or strongly] connected_,  Next: igraph_decompose --- Decompose a graph into connected components_,  Prev: igraph_clusters --- Calculates the [weakly or strongly] connected components in a graph_,  Up: Graph Components

@c 10.4.4 igraph_is_connected -- Decides whether the graph is (weakly or strongly) connected.
@c ------------------------------------------------------------------------------------------


@c      int igraph_is_connected(const igraph_t *graph, igraph_bool_t *res,
@c      			igraph_connectedness_t mode);

@c    *Arguments:. *

@c `graph':
@c      The graph object to analyze.

@c `res':
@c      Pointer to a logical variable, the result will be stored here.

@c `mode':
@c      For directed graph this specifies whether to calculate weak or
@c      strong connectedness. Possible values: `IGRAPH_WEAK',
@c      `IGRAPH_STRONG'. This argument is igrored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': invalid mode argument.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_decompose --- Decompose a graph into connected components_,  Next: igraph_biconnected_components --- Calculate biconnected components,  Prev: igraph_is_connected --- Decides whether the graph is [weakly or strongly] connected_,  Up: Graph Components

@c 10.4.5 igraph_decompose -- Decompose a graph into connected components.
@c -----------------------------------------------------------------------


@c      int igraph_decompose(const igraph_t *graph, igraph_vector_ptr_t *components,
@c      		     igraph_connectedness_t mode,
@c      		     long int maxcompno, long int minelements);

@c    Create separate graph for each component of a graph. Note that the
@c vertex ids in the new graphs will be different than in the original
@c graph. (Except if there is only one component in the original graph.)

@c    *Arguments:. *

@c `graph':
@c      The original graph.

@c `components':
@c      This pointer vector will contain pointers to the subcomponent
@c      graphs. It should be initialized before calling this function and
@c      will be resized to hold the graphs. Don't forget to call
@c      `igraph_destroy()' (*note igraph_destroy --- Frees the memory
@c      allocated for a graph object_::) and igraph_free() on the elements
@c      of this pointer vector to free unneeded memory.

@c `mode':
@c      Either `IGRAPH_WEAK' or `IGRAPH_STRONG' for weakly and strongly
@c      connected components respectively. Right now only the former is
@c      implemented.

@c `maxcompno':
@c      The maximum number of components to return. The first `maxcompno'
@c      components will be returned (which hold at least `minelements'
@c      vertices, see the next parameter), the others will be ignored.
@c      Supply -1 here if you don't want to limit the number of components.

@c `minelements':
@c      The minimum number of vertices a component should contain in order
@c      to place it in the `components' vector. Eg. supply 2 here to
@c      ignore isolate vertices.

@c    *Returns:. *

@c `'
@c      Error code, `IGRAPH_ENOMEM' if there is not enough memory to
@c      perform the operation.

@c    Added in version 0.2.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_biconnected_components --- Calculate biconnected components,  Next: igraph_articulation_points --- Find the articulation points in a graph_,  Prev: igraph_decompose --- Decompose a graph into connected components_,  Up: Graph Components

@c 10.4.6 igraph_biconnected_components -- Calculate biconnected components
@c ------------------------------------------------------------------------


@c      int igraph_biconnected_components(const igraph_t *graph,
@c      				  igraph_integer_t *no,
@c      				  igraph_vector_ptr_t *components,
@c      				  igraph_vector_t *articulation_points);

@c    A graph is biconnected if the removal of any single vertex (and its
@c adjacent edges) does not disconnect it.

@c    A biconnected component of a graph is a maximal biconnected subgraph
@c of it. The biconnected components of a graph can be given by the
@c partition of its edges: every edge is a member of exactly one
@c biconnected component. Note that this is not true for vertices: the
@c same vertex can be part of many biconnected components.

@c    *Arguments:. *

@c `graph':
@c      The input graph

@c `no':
@c      The number of biconnected components will be stored here.

@c `components':
@c      If not a NULL points, then the found components are stored here,
@c      in a list of vectors. Every vector in the list is a biconnected
@c      component, represented by its edges. More precisely, a spanning
@c      tree of the biconnected component is returned.  Note you'll have to
@c      destroy each vector first by calling `igraph_vector_destroy()'
@c      (*note igraph_vector_destroy --- Destroys a vector object_::) and
@c      then ` free()'  on it, plus you need to call
@c      `igraph_vector_ptr_destroy()' (*note igraph_vector_ptr_destroy ---
@c      Destroys a pointer vector_::) on the list to regain all allocated
@c      memory.

@c `articulation_points':
@c      If not a NULL pointer, then the articulation points of the graph
@c      are stored in this vector.  A vertex is an articulation point if
@c      its removal increases the number of (weakly) connected components
@c      in the graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c    *See also:. *

@c `'
@c      `igraph_articulation_points()' (*note igraph_articulation_points
@c      --- Find the articulation points in a graph_::),
@c      `igraph_clusters()' (*note igraph_clusters --- Calculates the
@c      [weakly or strongly] connected components in a graph_::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_articulation_points --- Find the articulation points in a graph_,  Prev: igraph_biconnected_components --- Calculate biconnected components,  Up: Graph Components

@c 10.4.7 igraph_articulation_points -- Find the articulation points in a graph.
@c -----------------------------------------------------------------------------


@c      int igraph_articulation_points(const igraph_t *graph,
@c      			       igraph_vector_t *res);

@c    A vertex is an articulation point if its removal increases the
@c number of connected components in the graph.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized vector, the articulation points will be
@c      stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c    *See also:. *

@c `'
@c      `igraph_biconnected_components()' (*note
@c      igraph_biconnected_components --- Calculate biconnected
@c      components::), `igraph_clusters()' (*note igraph_clusters ---
@c      Calculates the [weakly or strongly] connected components in a
@c      graph_::)

@c
@c File: igraph_reference_manual.info,  Node: Centrality Measures,  Next: Estimating Centrality Measures,  Prev: Graph Components,  Up: Structural Properties of Graphs

@c 10.5 Centrality Measures
@c ========================

@c * Menu:

@c * igraph_closeness --- Closeness centrality calculations for some vertices.: igraph_closeness --- Closeness centrality calculations for some vertices_.
@c * igraph_betweenness --- Betweenness centrality of some vertices.: igraph_betweenness --- Betweenness centrality of some vertices_.
@c * igraph_edge_betweenness --- Betweenness centrality of the edges.: igraph_edge_betweenness --- Betweenness centrality of the edges_.
@c * igraph_pagerank --- Calculates the Google PageRank for the specified vertices.: igraph_pagerank --- Calculates the Google PageRank for the specified vertices_.
@c * igraph_pagerank_old --- Calculates the Google PageRank for the specified vertices.: igraph_pagerank_old --- Calculates the Google PageRank for the specified vertices_.
@c * igraph_constraint --- Burt's constraint scores::
@c * igraph_maxdegree --- Calculate the maximum degree in a graph (or set of vertices).: igraph_maxdegree --- Calculate the maximum degree in a graph [or set of vertices]_.
@c * igraph_strength --- Strength of the vertices, weighted vertex degree in other words: igraph_strength --- Strength of the vertices; weighted vertex degree in other words.
@c * igraph_eigenvector_centrality --- Eigenvector centrality of the verices::
@c * igraph_hub_score --- Kleinberg's hub scores::
@c * igraph_authority_score --- Kleinerg's authority scores::

@c
@c File: igraph_reference_manual.info,  Node: igraph_closeness --- Closeness centrality calculations for some vertices_,  Next: igraph_betweenness --- Betweenness centrality of some vertices_,  Up: Centrality Measures

@c 10.5.1 igraph_closeness -- Closeness centrality calculations for some vertices.
@c -------------------------------------------------------------------------------


@c      int igraph_closeness(const igraph_t *graph, igraph_vector_t *res,
@c                           const igraph_vs_t vids, igraph_neimode_t mode);

@c    The closeness centrality of a vertex measures how easily other
@c vertices can be reached from it (or the other way: how easily it can be
@c reached from the other vertices). It is defined as the number of the
@c number of vertices minus one divided by the sum of the lengths of all
@c geodesics from/to the given vertex.

@c    If the graph is not connected, and there is no path between two
@c vertices, the number of vertices is used instead the length of the
@c geodesic. This is always longer than the longest possible geodesic.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result of the computation, a vector containing the closeness
@c      centrality scores for the given vertices.

@c `vids':
@c      Vector giving the vertices for which the closeness centrality
@c      scores will be computed.

@c `mode':
@c      The type of shortest paths to be used for the calculation in
@c      directed graphs. Possible values:

@c     `IGRAPH_OUT '
@c           the lengths of the outgoing paths are calculated.

@c     `IGRAPH_IN '
@c           the lengths of the incoming paths are calculated.

@c     `IGRAPH_ALL'
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM'
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           invalid vertex id passed.

@c     `IGRAPH_EINVMODE'
@c           invalid mode argument.

@c    Time complexity: O(n|E|), n is the number of vertices for which the
@c calculation is done and |E| is the number of edges in the graph.

@c    *See also:. *

@c `'
@c      Other centrality types: `igraph_degree()' (*note igraph_degree ---
@c      The degree of some vertices in a graph_::), `igraph_betweenness()'
@c      (*note igraph_betweenness --- Betweenness centrality of some
@c      vertices_::).  See `igraph_closeness_estimate()' (*note
@c      igraph_closeness_estimate --- Closeness centrality estimations for
@c      some vertices_::) to estimate closeness values.

@c
@c File: igraph_reference_manual.info,  Node: igraph_betweenness --- Betweenness centrality of some vertices_,  Next: igraph_edge_betweenness --- Betweenness centrality of the edges_,  Prev: igraph_closeness --- Closeness centrality calculations for some vertices_,  Up: Centrality Measures

@c 10.5.2 igraph_betweenness -- Betweenness centrality of some vertices.
@c ---------------------------------------------------------------------


@c      int igraph_betweenness(const igraph_t *graph, igraph_vector_t *res,
@c        const igraph_vs_t vids, igraph_bool_t directed);

@c    The betweenness centrality of a vertex is the number of geodesics
@c going through it. If there are more than one geodesic between two
@c vertices, the value of these geodesics are weighted by one over the
@c number of geodesics.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result of the computation, a vector containing the betweenness
@c      scores for the specified vertices.

@c `vids':
@c      The vertices of which the betweenness centrality scores will be
@c      calculated.

@c `directed':
@c      Logical, if true directed paths will be considered for directed
@c      graphs. It is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.
@c      `IGRAPH_EINVVID', invalid vertex id passed in `vids'.

@c    Time complexity: O(|V||E|), |V| and |E| are the number of vertices
@c and edges in the graph.  Note that the time complexity is independent
@c of the number of vertices for which the score is calculated.

@c    *See also:. *

@c `'
@c      Other centrality types: `igraph_degree()' (*note igraph_degree ---
@c      The degree of some vertices in a graph_::), `igraph_closeness()'
@c      (*note igraph_closeness --- Closeness centrality calculations for
@c      some vertices_::).  See `igraph_edge_betweenness()' (*note
@c      igraph_edge_betweenness --- Betweenness centrality of the
@c      edges_::) for calculating the betweenness score of the edges in a
@c      graph. See `igraph_betweenness_estimate()' (*note
@c      igraph_betweenness_estimate --- Estimated betweenness centrality
@c      of some vertices_::) to estimate the betweenness score of the
@c      vertices in a graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_edge_betweenness --- Betweenness centrality of the edges_,  Next: igraph_pagerank --- Calculates the Google PageRank for the specified vertices_,  Prev: igraph_betweenness --- Betweenness centrality of some vertices_,  Up: Centrality Measures

@c 10.5.3 igraph_edge_betweenness -- Betweenness centrality of the edges.
@c ----------------------------------------------------------------------


@c      int igraph_edge_betweenness(const igraph_t *graph, igraph_vector_t *result,
@c                                  igraph_bool_t directed);

@c    The betweenness centrality of an edge is the number of geodesics
@c going through it. If there are more than one geodesics between two
@c vertices, the value of these geodesics are weighted by one over the
@c number of geodesics.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `result':
@c      The result of the computation, vector containing the betweenness
@c      scores for the edges.

@c `directed':
@c      Logical, if true directed paths will be considered for directed
@c      graphs. It is ignored for undirected graphs.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.

@c    Time complexity: O(|V||E|), |V| and |E| are the number of vertices
@c and edges in the graph.

@c    *See also:. *

@c `'
@c      Other centrality types: `igraph_degree()' (*note igraph_degree ---
@c      The degree of some vertices in a graph_::), `igraph_closeness()'
@c      (*note igraph_closeness --- Closeness centrality calculations for
@c      some vertices_::).  See `igraph_edge_betweenness()' (*note
@c      igraph_edge_betweenness --- Betweenness centrality of the
@c      edges_::) for calculating the betweenness score of the edges in a
@c      graph. See `igraph_edge_betweenness_estimate()' (*note
@c      igraph_edge_betweenness_estimate --- Estimated betweenness
@c      centrality of the edges_::) to estimate the betweenness score of
@c      the edges in a graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_pagerank --- Calculates the Google PageRank for the specified vertices_,  Next: igraph_pagerank_old --- Calculates the Google PageRank for the specified vertices_,  Prev: igraph_edge_betweenness --- Betweenness centrality of the edges_,  Up: Centrality Measures

@c 10.5.4 igraph_pagerank -- Calculates the Google PageRank for the specified vertices.
@c ------------------------------------------------------------------------------------


@c      int igraph_pagerank(const igraph_t *graph, igraph_vector_t *vector,
@c      		    igraph_real_t *value, const igraph_vs_t vids,
@c      		    igraph_bool_t directed, igraph_real_t damping,
@c      		    const igraph_vector_t *weights,
@c      		    igraph_arpack_options_t *options);

@c    This is the new PageRank implementation, based on the ARPACK
@c library. The old, power-method based implementation can be used as
@c well, it is kept under the name `igraph_pagerank_old()' (*note
@c igraph_pagerank_old --- Calculates the Google PageRank for the
@c specified vertices_::).

@c    Please note that the PageRank of a given vertex depends on the
@c PageRank of all other vertices, so even if you want to calculate the
@c PageRank for only some of the vertices, all of them must be calculated.
@c Requesting the PageRank for only some of the vertices does not result
@c in any performance increase at all.

@c    Since the calculation is an iterative process, the algorithm is
@c stopped after a given count of iterations or if the PageRank value
@c differences between iterations are less than a predefined value.

@c    For the explanation of the PageRank algorithm, see the following
@c webpage: http://www-db.stanford.edu/~backrub/google.html, or the
@c following reference:

@c    Sergey Brin and Larry Page: The Anatomy of a Large-Scale Hypertextual
@c Web Search Engine. Proceedings of the 7th World-Wide Web Conference,
@c Brisbane, Australia, April 1998.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `vector':
@c      Pointer to an initialized vector, the result is stored here. It is
@c      resized as needed.

@c `value':
@c      Pointer to a real variable, the eigenvalue corresponding to the
@c      PageRank vector is stored here. It should be always exactly one.

@c `vids':
@c      The vertex ids for which the PageRank is returned.

@c `directed':
@c      Boolean, whether to consider the directedness of the edges. This
@c      is ignored for undirected graphs.

@c `damping':
@c      The damping factor ("d" in the original paper)

@c `weights':
@c      Optional edge weights, it is either a null pointer, then the edges
@c      are not weighted, or a vector of the same length as the number of
@c      edges.

@c `options':
@c      Options to ARPACK. See `igraph_arpack_options_t' (*note
@c      igraph_arpack_options_t --- Options for ARPACK::) for details.
@c      Note that the function overwrites the ` n'  (number of vertices),
@c      ` nev'  (1), ` ncv'  (3) and ` which'  (LM) parameters and it
@c      always starts the calculation from a non-random vector calculated
@c      based on the degree of the vertices.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.
@c      `IGRAPH_EINVVID', invalid vertex id in `vids'.

@c    Time complexity: TODO.

@c    *See also:. *

@c `'
@c      `igraph_pagerank_old()' (*note igraph_pagerank_old --- Calculates
@c      the Google PageRank for the specified vertices_::) for the old
@c      implementation, `igraph_arpack_rssolve()' (*note
@c      igraph_arpack_rssolve --- ARPACK solver for symmetric matrices::)
@c      and `igraph_arpack_rnsolve()' (*note igraph_arpack_rnsolve ---
@c      ARPACK solver for non-symmetric matrices::) for the underlying
@c      machinery.

@c
@c File: igraph_reference_manual.info,  Node: igraph_pagerank_old --- Calculates the Google PageRank for the specified vertices_,  Next: igraph_constraint --- Burt's constraint scores,  Prev: igraph_pagerank --- Calculates the Google PageRank for the specified vertices_,  Up: Centrality Measures

@c 10.5.5 igraph_pagerank_old -- Calculates the Google PageRank for the specified vertices.
@c ----------------------------------------------------------------------------------------


@c      int igraph_pagerank_old(const igraph_t *graph, igraph_vector_t *res,
@c      			const igraph_vs_t vids, igraph_bool_t directed,
@c      			igraph_integer_t niter, igraph_real_t eps,
@c      			igraph_real_t damping, igraph_bool_t old);

@c    This is an old implementation, it is provided for compatibility with
@c igraph versions earlier than 0.5. Please use the new implementation
@c `igraph_pagerank()' (*note igraph_pagerank --- Calculates the Google
@c PageRank for the specified vertices_::) in new projects.

@c    Please note that the PageRank of a given vertex depends on the
@c PageRank of all other vertices, so even if you want to calculate the
@c PageRank for only some of the vertices, all of them must be calculated.
@c Requesting the PageRank for only some of the vertices does not result
@c in any performance increase at all.

@c    Since the calculation is an iterative process, the algorithm is
@c stopped after a given count of iterations or if the PageRank value
@c differences between iterations are less than a predefined value.

@c    For the explanation of the PageRank algorithm, see the following
@c webpage: http://www-db.stanford.edu/~backrub/google.html, or the
@c following reference:

@c    Sergey Brin and Larry Page: The Anatomy of a Large-Scale Hypertextual
@c Web Search Engine. Proceedings of the 7th World-Wide Web Conference,
@c Brisbane, Australia, April 1998.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result vector containing the PageRank values for the given
@c      nodes.

@c `vids':
@c      Vector with the vertex ids

@c `directed':
@c      Logical, if true directed paths will be considered for directed
@c      graphs. It is ignored for undirected graphs.

@c `niter':
@c      The maximum number of iterations to perform

@c `eps':
@c      The algorithm will consider the calculation as complete if the
@c      difference of PageRank values between iterations change less than
@c      this value for every node

@c `damping':
@c      The damping factor ("d" in the original paper)

@c `old':
@c      Boolean, whether to use the pre-igraph 0.5 way to calculate page
@c      rank. Not recommended for new applications, only included for
@c      compatibility. If this is non-zero then the damping factor is not
@c      divided by the number of vertices before adding it to the weighted
@c      page rank scores to calculate the new scores. I.e. the formula in
@c      the original PageRank paper is used. Furthermore, if this is
@c      non-zero then the PageRank vector is renormalized after each
@c      iteration.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.
@c      `IGRAPH_EINVVID', invalid vertex id in `vids'.

@c    Time complexity: O(|V|+|E|) per iteration. A handful iterations
@c should be enough. Note that if the old-style dumping is used then the
@c iteration might not converge at all.

@c    *See also:. *

@c `'
@c      `igraph_pagerank()' (*note igraph_pagerank --- Calculates the
@c      Google PageRank for the specified vertices_::) for the new
@c      implementation.

@c
@c File: igraph_reference_manual.info,  Node: igraph_constraint --- Burt's constraint scores,  Next: igraph_maxdegree --- Calculate the maximum degree in a graph [or set of vertices]_,  Prev: igraph_pagerank_old --- Calculates the Google PageRank for the specified vertices_,  Up: Centrality Measures

@c 10.5.6 igraph_constraint -- Burt's constraint scores
@c ----------------------------------------------------


@c      int igraph_constraint(const igraph_t *graph, igraph_vector_t *res,
@c      		      igraph_vs_t vids, const igraph_vector_t *weights);

@c    This function calculates Burt's constraint scores for the given
@c vertices, also known as structural holes.

@c    Burt's constraint is higher if ego has less, or mutually stronger
@c related (i.e. more redundant) contacts. Burt's measure of constraint,
@c C[i], of vertex i's ego network V[i], is defined for directed and
@c valued graphs,

@c      C[i] = sum( sum( (p[i,q] p[q,j])^2, q in V[i], q != i,j ), j in
@c      V[], j != i)

@c for a graph of order (ie. number od vertices) N, where proportional tie
@c strengths are defined as

@c      p[i,j]=(a[i,j]+a[j,i]) / sum(a[i,k]+a[k,i], k in V[i], k != i),

@c a[i,j] are elements of A and the latter being the graph adjacency
@c matrix. For isolated vertices, constraint is undefined.

@c    Burt, R.S. (2004). Structural holes and good ideas. American Journal
@c of Sociology 110, 349-399.

@c    The first R version of this function was contributed by Jeroen
@c Bruggeman.

@c    *Arguments:. *

@c `graph':
@c      A graph object.

@c `res':
@c      Pointer to an initialized vector, the result will be stored here.
@c      The vector will be resized to have the appropriate size for
@c      holding the result.

@c `vids':
@c      Vertex selector containing the vertices for which the constraint
@c      should be calculated.

@c `weights':
@c      Vector giving the weights of the edges. If it is `NULL' then each
@c      edge is supposed to have the same weight.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+E|+n*d^2), n is the number of vertices for
@c which the constraint is calculated and d is the average degree, |V| is
@c the number of vertices, |E| the number of edges in the graph. If the
@c weights argument is `NULL' then the time complexity is O(|V|+n*d^2).

@c
@c File: igraph_reference_manual.info,  Node: igraph_maxdegree --- Calculate the maximum degree in a graph [or set of vertices]_,  Next: igraph_strength --- Strength of the vertices; weighted vertex degree in other words,  Prev: igraph_constraint --- Burt's constraint scores,  Up: Centrality Measures

@c 10.5.7 igraph_maxdegree -- Calculate the maximum degree in a graph (or set of vertices).
@c ----------------------------------------------------------------------------------------


@c      int igraph_maxdegree(const igraph_t *graph, igraph_integer_t *res,
@c      		     igraph_vs_t vids, igraph_neimode_t mode,
@c      		     igraph_bool_t loops);

@c    The largest in-, out- or total degree of the specified vertices is
@c calculated.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an integer (`igraph_integer_t'), the result will be
@c      stored here.

@c `mode':
@c      Defines the type of the degree.  `IGRAPH_OUT', out-degree,
@c      `IGRAPH_IN', in-degree, `IGRAPH_ALL', total degree (sum of the in-
@c      and out-degree).  This parameter is ignored for undirected graphs.

@c `loops':
@c      Boolean, gives whether the self-loops should be counted.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVVID': invalid vertex id.
@c      `IGRAPH_EINVMODE': invalid mode argument.

@c    Time complexity: O(v) if loops is TRUE, and O(v*d) otherwise. v is
@c the number vertices for which the degree will be calculated, and d is
@c their (average) degree.

@c
@c File: igraph_reference_manual.info,  Node: igraph_strength --- Strength of the vertices; weighted vertex degree in other words,  Next: igraph_eigenvector_centrality --- Eigenvector centrality of the verices,  Prev: igraph_maxdegree --- Calculate the maximum degree in a graph [or set of vertices]_,  Up: Centrality Measures

@c 10.5.8 igraph_strength -- Strength of the vertices, weighted vertex degree in other words
@c -----------------------------------------------------------------------------------------


@c      int igraph_strength(const igraph_t *graph, igraph_vector_t *res,
@c      		    const igraph_vs_t vids, igraph_neimode_t mode,
@c      		    igraph_bool_t loops, const igraph_vector_t *weights);

@c    In an weighted network the strength of a vertex is the sum of the
@c weights of all adjacent edges. In a non-weighted networks this is
@c exactly the vertex degree.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized vector, the result is stored here. It
@c      will be resized as needed.

@c `vids':
@c      The vertices for which the calculation is performed.

@c `mode':
@c      Gives whether to count only outgoing (`IGRAPH_OUT'), incoming
@c      (`IGRAPH_IN') edges or both (`IGRAPH_ALL').

@c `loops':
@c      A logical scalar, whether to count loop edges as well.

@c `weights':
@c      A vector giving the edge weights. If this is a NULL pointer, then
@c      `igraph_degree()' (*note igraph_degree --- The degree of some
@c      vertices in a graph_::) is called to perform the calculation.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number vertices and edges.

@c    *See also:. *

@c `'
@c      `igraph_degree()' (*note igraph_degree --- The degree of some
@c      vertices in a graph_::) for the traditional, non-weighted version.

@c
@c File: igraph_reference_manual.info,  Node: igraph_eigenvector_centrality --- Eigenvector centrality of the verices,  Next: igraph_hub_score --- Kleinberg's hub scores,  Prev: igraph_strength --- Strength of the vertices; weighted vertex degree in other words,  Up: Centrality Measures

@c 10.5.9 igraph_eigenvector_centrality -- Eigenvector centrality of the verices
@c -----------------------------------------------------------------------------


@c      int igraph_eigenvector_centrality(const igraph_t *graph, igraph_vector_t *vector,
@c      				  igraph_real_t *value, igraph_bool_t scale,
@c      				  const igraph_vector_t *weights,
@c      				  igraph_arpack_options_t *options);

@c    Eigenvector centrality is a measure of the importance of a node in a
@c network. It assigns relative scores to all nodes in the network based
@c on the principle that connections to high-scoring nodes contribute more
@c to the score of the node in question than equal connections to
@c low-scoring nodes.

@c    *Arguments:. *

@c `graph':
@c      The input graph. It might be directed, but it will be treated as
@c      undirected anyway.

@c `vector':
@c      Pointer to an initialized vector, it will be resized as needed.
@c      The result of the computation is stored here. It can be a null
@c      pointer, then it is ignored.

@c `value':
@c      If not a null pointer, then the eigenvalue corresponding to the
@c      found eigenvector is stored here.

@c `scale':
@c      If not zero then the result will be scaled, such that the absolute
@c      value of the maximum centrality is one.

@c `weights':
@c      A null pointer (=no edge weights), or a vector giving the weights
@c      of the edges.

@c `options':
@c      Options to ARPACK. See `igraph_arpack_options_t' (*note
@c      igraph_arpack_options_t --- Options for ARPACK::) for details.
@c      Note that the function overwrites the ` n'  (number of vertices)
@c      parameter and it always starts the calculation from a non-random
@c      vector calculated based on the degree of the vertices.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: depends on the input graph, usually it is O(|V|),
@c the number of vertices.

@c    *See also:. *

@c `'
@c      `igraph_pagerank' (*note igraph_pagerank --- Calculates the Google
@c      PageRank for the specified vertices_::) for a modification of
@c      eigenvector centrality.

@c
@c File: igraph_reference_manual.info,  Node: igraph_hub_score --- Kleinberg's hub scores,  Next: igraph_authority_score --- Kleinerg's authority scores,  Prev: igraph_eigenvector_centrality --- Eigenvector centrality of the verices,  Up: Centrality Measures

@c 10.5.10 igraph_hub_score -- Kleinberg's hub scores
@c --------------------------------------------------


@c      int igraph_hub_score(const igraph_t *graph, igraph_vector_t *vector,
@c      		     igraph_real_t *value, igraph_bool_t scale,
@c      		     igraph_arpack_options_t *options);

@c    The hub scores of the vertices are defined as the principal
@c eigenvector of ` A*A^T' , where ` A'  is the adjacency matrix of the
@c graph, ` A^T'  is its transposed.

@c    See the following reference on the meaning of this score: J.
@c Kleinberg. Authoritative sources in a hyperlinked environment. _ Proc.
@c 9th ACM-SIAM Symposium on Discrete Algorithms, _ 1998. Extended version
@c in _ Journal of the ACM _ 46(1999). Also appears as IBM Research Report
@c RJ 10076, May 1997.

@c    *Arguments:. *

@c `graph':
@c      The input graph. Can be directed and undirected.

@c `vector':
@c      Pointer to an initialized vector, the result is stored here. If a
@c      null pointer then it is ignored.

@c `value':
@c      If not a null pointer then the eigenvalue corresponding to the
@c      calculated eigenvector is stored here.

@c `scale':
@c      If not zero then the result will be scaled, such that the absolute
@c      value of the maximum centrality is one.

@c `options':
@c      Options to ARPACK. See `igraph_arpack_options_t' (*note
@c      igraph_arpack_options_t --- Options for ARPACK::) for details.
@c      Note that the function overwrites the ` n'  (number of vertices)
@c      parameter and it always starts the calculation from a non-random
@c      vector calculated based on the degree of the vertices.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: depends on the input graph, usually it is O(|V|),
@c the number of vertices.

@c    *See also:. *

@c `'
@c      `igraph_authority_score()' (*note igraph_authority_score ---
@c      Kleinerg's authority scores::) for the companion measure,
@c      `igraph_pagerank()' (*note igraph_pagerank --- Calculates the
@c      Google PageRank for the specified vertices_::),
@c      `igraph_eigenvector_centrality()' (*note
@c      igraph_eigenvector_centrality --- Eigenvector centrality of the
@c      verices::) for similar measures.

@c
@c File: igraph_reference_manual.info,  Node: igraph_authority_score --- Kleinerg's authority scores,  Prev: igraph_hub_score --- Kleinberg's hub scores,  Up: Centrality Measures

@c 10.5.11 igraph_authority_score -- Kleinerg's authority scores
@c -------------------------------------------------------------


@c      int igraph_authority_score(const igraph_t *graph, igraph_vector_t *vector,
@c      			   igraph_real_t *value, igraph_bool_t scale,
@c      			   igraph_arpack_options_t *options);

@c    The authority scores of the vertices are defined as the principal
@c eigenvector of ` A^T*A' , where ` A'  is the adjacency matrix of the
@c graph, ` A^T'  is its transposed.

@c    See the following reference on the meaning of this score: J.
@c Kleinberg. Authoritative sources in a hyperlinked environment. _ Proc.
@c 9th ACM-SIAM Symposium on Discrete Algorithms, _ 1998. Extended version
@c in _ Journal of the ACM _ 46(1999). Also appears as IBM Research Report
@c RJ 10076, May 1997.

@c    *Arguments:. *

@c `graph':
@c      The input graph. Can be directed and undirected.

@c `vector':
@c      Pointer to an initialized vector, the result is stored here. If a
@c      null pointer then it is ignored.

@c `value':
@c      If not a null pointer then the eigenvalue corresponding to the
@c      calculated eigenvector is stored here.

@c `scale':
@c      If not zero then the result will be scaled, such that the absolute
@c      value of the maximum centrality is one.

@c `options':
@c      Options to ARPACK. See `igraph_arpack_options_t' (*note
@c      igraph_arpack_options_t --- Options for ARPACK::) for details.
@c      Note that the function overwrites the ` n'  (number of vertices)
@c      parameter and it always starts the calculation from a non-random
@c      vector calculated based on the degree of the vertices.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: depends on the input graph, usually it is O(|V|),
@c the number of vertices.

@c    *See also:. *

@c `'
@c      `igraph_hub_score()' (*note igraph_hub_score --- Kleinberg's hub
@c      scores::) for the companion measure, `igraph_pagerank()' (*note
@c      igraph_pagerank --- Calculates the Google PageRank for the
@c      specified vertices_::), `igraph_eigenvector_centrality()' (*note
@c      igraph_eigenvector_centrality --- Eigenvector centrality of the
@c      verices::) for similar measures.

@c
@c File: igraph_reference_manual.info,  Node: Estimating Centrality Measures,  Next: Similarity Measures,  Prev: Centrality Measures,  Up: Structural Properties of Graphs

@c 10.6 Estimating Centrality Measures
@c ===================================

@c * Menu:

@c * igraph_closeness_estimate --- Closeness centrality estimations for some vertices.: igraph_closeness_estimate --- Closeness centrality estimations for some vertices_.
@c * igraph_betweenness_estimate --- Estimated betweenness centrality of some vertices.: igraph_betweenness_estimate --- Estimated betweenness centrality of some vertices_.
@c * igraph_edge_betweenness_estimate --- Estimated betweenness centrality of the edges.: igraph_edge_betweenness_estimate --- Estimated betweenness centrality of the edges_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_closeness_estimate --- Closeness centrality estimations for some vertices_,  Next: igraph_betweenness_estimate --- Estimated betweenness centrality of some vertices_,  Up: Estimating Centrality Measures

@c 10.6.1 igraph_closeness_estimate -- Closeness centrality estimations for some vertices.
@c ---------------------------------------------------------------------------------------


@c      int igraph_closeness_estimate(const igraph_t *graph, igraph_vector_t *res,
@c      		              const igraph_vs_t vids, igraph_neimode_t mode,
@c                                    igraph_integer_t cutoff);

@c    The closeness centrality of a vertex measures how easily other
@c vertices can be reached from it (or the other way: how easily it can be
@c reached from the other vertices). It is defined as the number of the
@c number of vertices minus one divided by the sum of the lengths of all
@c geodesics from/to the given vertex. When estimating closeness
@c centrality, igraph considers paths having a length less than or equal
@c to a prescribed cutoff value.

@c    If the graph is not connected, and there is no such path between two
@c vertices, the number of vertices is used instead the length of the
@c geodesic. This is always longer than the longest possible geodesic.

@c    Since the estimation considers vertex pairs with a distance greater
@c than the given value as disconnected, the resulting estimation will
@c always be lower than the actual closeness centrality.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result of the computation, a vector containing the closeness
@c      centrality scores for the given vertices.

@c `vids':
@c      Vector giving the vertices for which the closeness centrality
@c      scores will be computed.

@c `mode':
@c      The type of shortest paths to be used for the calculation in
@c      directed graphs. Possible values:

@c     `IGRAPH_OUT '
@c           the lengths of the outgoing paths are calculated.

@c     `IGRAPH_IN '
@c           the lengths of the incoming paths are calculated.

@c     `IGRAPH_ALL'
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c `cutoff':
@c      The maximal length of paths that will be considered.  If zero or
@c      negative, the exact closeness will be calculated (no upper limit
@c      on path lengths).

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM'
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           invalid vertex id passed.

@c     `IGRAPH_EINVMODE'
@c           invalid mode argument.

@c    Time complexity: O(n|E|), n is the number of vertices for which the
@c calculation is done and |E| is the number of edges in the graph.

@c    *See also:. *

@c `'
@c      Other centrality types: `igraph_degree()' (*note igraph_degree ---
@c      The degree of some vertices in a graph_::), `igraph_betweenness()'
@c      (*note igraph_betweenness --- Betweenness centrality of some
@c      vertices_::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_betweenness_estimate --- Estimated betweenness centrality of some vertices_,  Next: igraph_edge_betweenness_estimate --- Estimated betweenness centrality of the edges_,  Prev: igraph_closeness_estimate --- Closeness centrality estimations for some vertices_,  Up: Estimating Centrality Measures

@c 10.6.2 igraph_betweenness_estimate -- Estimated betweenness centrality of some vertices.
@c ----------------------------------------------------------------------------------------


@c      int igraph_betweenness_estimate(const igraph_t *graph, igraph_vector_t *res,
@c      			const igraph_vs_t vids, igraph_bool_t directed,
@c                              igraph_integer_t cutoff);

@c    The betweenness centrality of a vertex is the number of geodesics
@c going through it. If there are more than one geodesic between two
@c vertices, the value of these geodesics are weighted by one over the
@c number of geodesics. When estimating betweenness centrality, igraph
@c takes into consideration only those paths that are shorter than or
@c equal to a prescribed length. Note that the estimated centrality will
@c always be less than the real one.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result of the computation, a vector containing the estimated
@c      betweenness scores for the specified vertices.

@c `vids':
@c      The vertices of which the betweenness centrality scores will be
@c      estimated.

@c `directed':
@c      Logical, if true directed paths will be considered for directed
@c      graphs. It is ignored for undirected graphs.

@c `cutoff':
@c      The maximal length of paths that will be considered.  If zero or
@c      negative, the exact betweenness will be calculated (no upper limit
@c      on path lengths).

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.
@c      `IGRAPH_EINVVID', invalid vertex id passed in `vids'.

@c    Time complexity: O(|V||E|), |V| and |E| are the number of vertices
@c and edges in the graph.  Note that the time complexity is independent
@c of the number of vertices for which the score is calculated.

@c    *See also:. *

@c `'
@c      Other centrality types: `igraph_degree()' (*note igraph_degree ---
@c      The degree of some vertices in a graph_::), `igraph_closeness()'
@c      (*note igraph_closeness --- Closeness centrality calculations for
@c      some vertices_::).  See `igraph_edge_betweenness()' (*note
@c      igraph_edge_betweenness --- Betweenness centrality of the
@c      edges_::) for calculating the betweenness score of the edges in a
@c      graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_edge_betweenness_estimate --- Estimated betweenness centrality of the edges_,  Prev: igraph_betweenness_estimate --- Estimated betweenness centrality of some vertices_,  Up: Estimating Centrality Measures

@c 10.6.3 igraph_edge_betweenness_estimate -- Estimated betweenness centrality of the edges.
@c -----------------------------------------------------------------------------------------


@c      int igraph_edge_betweenness_estimate(const igraph_t *graph, igraph_vector_t *result,
@c                                           igraph_bool_t directed, igraph_integer_t cutoff);

@c    The betweenness centrality of an edge is the number of geodesics
@c going through it. If there are more than one geodesics between two
@c vertices, the value of these geodesics are weighted by one over the
@c number of geodesics. When estimating betweenness centrality, igraph
@c takes into consideration only those paths that are shorter than or
@c equal to a prescribed length. Note that the estimated centrality will
@c always be less than the real one.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `result':
@c      The result of the computation, vector containing the betweenness
@c      scores for the edges.

@c `directed':
@c      Logical, if true directed paths will be considered for directed
@c      graphs. It is ignored for undirected graphs.

@c `cutoff':
@c      The maximal length of paths that will be considered.  If zero or
@c      negative, the exact betweenness will be calculated (no upper limit
@c      on path lengths).

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.

@c    Time complexity: O(|V||E|), |V| and |E| are the number of vertices
@c and edges in the graph.

@c    *See also:. *

@c `'
@c      Other centrality types: `igraph_degree()' (*note igraph_degree ---
@c      The degree of some vertices in a graph_::), `igraph_closeness()'
@c      (*note igraph_closeness --- Closeness centrality calculations for
@c      some vertices_::).  See `igraph_betweenness()' (*note
@c      igraph_betweenness --- Betweenness centrality of some vertices_::)
@c      for calculating the betweenness score of the vertices in a graph.

@c
@c File: igraph_reference_manual.info,  Node: Similarity Measures,  Next: Spanning Tree,  Prev: Estimating Centrality Measures,  Up: Structural Properties of Graphs

@c 10.7 Similarity Measures
@c ========================

@c * Menu:

@c * igraph_bibcoupling --- Bibliographic coupling.: igraph_bibcoupling --- Bibliographic coupling_.
@c * igraph_cocitation --- Cocitation coupling.: igraph_cocitation --- Cocitation coupling_.
@c * igraph_similarity_jaccard --- Jaccard similarity coefficient.: igraph_similarity_jaccard --- Jaccard similarity coefficient_.
@c * igraph_similarity_dice --- Dice similarity coefficient.: igraph_similarity_dice --- Dice similarity coefficient_.
@c * igraph_similarity_inverse_log_weighted --- Vertex similarity based on the inverse logarithm of vertex degrees. : igraph_similarity_inverse_log_weighted --- Vertex similarity based on the inverse logarithm of vertex degrees_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_bibcoupling --- Bibliographic coupling_,  Next: igraph_cocitation --- Cocitation coupling_,  Up: Similarity Measures

@c 10.7.1 igraph_bibcoupling -- Bibliographic coupling.
@c ----------------------------------------------------


@c      int igraph_bibcoupling(const igraph_t *graph, igraph_matrix_t *res,
@c                             const igraph_vs_t vids);

@c    The bibliographic coupling of two vertices is the number of other
@c vertices they both cite, `igraph_bibcoupling()' (*note
@c igraph_bibcoupling --- Bibliographic coupling_::) calculates this.  The
@c bibliographic coupling  score for each given vertex and all other
@c vertices in the graph will be calculated.

@c    *Arguments:. *

@c `graph':
@c      The graph object to analyze.

@c `res':
@c      Pointer to a matrix, the result of the calculation will be stored
@c      here. The number of its rows is the same as the number of vertex
@c      ids in `vids', the number of columns is the number of vertices in
@c      the graph.

@c `vids':
@c      The vertex ids of the vertices for which the calculation will be
@c      done.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVVID': invalid vertex id.

@c    Time complexity: O(|V|d^2), |V| is the number of vertices in the
@c graph, d is the (maximum) degree of the vertices in the graph.

@c    *See also:. *

@c `'
@c      `igraph_cocitation()' (*note igraph_cocitation --- Cocitation
@c      coupling_::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_cocitation --- Cocitation coupling_,  Next: igraph_similarity_jaccard --- Jaccard similarity coefficient_,  Prev: igraph_bibcoupling --- Bibliographic coupling_,  Up: Similarity Measures

@c 10.7.2 igraph_cocitation -- Cocitation coupling.
@c ------------------------------------------------


@c      int igraph_cocitation(const igraph_t *graph, igraph_matrix_t *res,
@c                            const igraph_vs_t vids);

@c    Two vertices are cocited if there is another vertex citing both of
@c them. `igraph_cocitation()' (*note igraph_cocitation --- Cocitation
@c coupling_::) simply counts how many times two vertices are cocited.
@c The cocitation score for each given vertex and all other vertices in
@c the graph will be calculated.

@c    *Arguments:. *

@c `graph':
@c      The graph object to analyze.

@c `res':
@c      Pointer to a matrix, the result of the calculation will be stored
@c      here. The number of its rows is the same as the number of vertex
@c      ids in `vids', the number of columns is the number of vertices in
@c      the graph.

@c `vids':
@c      The vertex ids of the vertices for which the calculation will be
@c      done.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVVID': invalid vertex id.

@c    Time complexity: O(|V|d^2), |V| is the number of vertices in the
@c graph, d is the (maximum) degree of the vertices in the graph.

@c    *See also:. *

@c `'
@c      `igraph_bibcoupling()' (*note igraph_bibcoupling --- Bibliographic
@c      coupling_::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_similarity_jaccard --- Jaccard similarity coefficient_,  Next: igraph_similarity_dice --- Dice similarity coefficient_,  Prev: igraph_cocitation --- Cocitation coupling_,  Up: Similarity Measures

@c 10.7.3 igraph_similarity_jaccard -- Jaccard similarity coefficient.
@c -------------------------------------------------------------------


@c      int igraph_similarity_jaccard(const igraph_t *graph, igraph_matrix_t *res,
@c          const igraph_vs_t vids, igraph_neimode_t mode, igraph_bool_t loops);

@c    The Jaccard similarity coefficient of two vertices is the number of
@c common neighbors divided by the number of vertices that are neighbors
@c of at least one of the two vertices being considered. This function
@c calculates the pairwise Jaccard similarities for some (or all) of the
@c vertices.

@c    *Arguments:. *

@c `graph':
@c      The graph object to analyze

@c `res':
@c      Pointer to a matrix, the result of the calculation will be stored
@c      here. The number of its rows and columns is the same as the number
@c      of vertex ids in `vids'.

@c `vids':
@c      The vertex ids of the vertices for which the calculation will be
@c      done.

@c `mode':
@c      The type of neighbors to be used for the calculation in directed
@c      graphs. Possible values:

@c     `IGRAPH_OUT'
@c           the outgoing edges will be considered for each node.

@c     `IGRAPH_IN'
@c           the incoming edges will be considered for each node.

@c     `IGRAPH_ALL'
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c `loops':
@c      Whether to include the vertices themselves in the neighbor sets.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM'
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           invalid vertex id passed.

@c     `IGRAPH_EINVMODE'
@c           invalid mode argument.

@c    Time complexity: O(|V|^2 d), |V| is the number of vertices in the
@c vertex iterator given, d is the (maximum) degree of the vertices in the
@c graph.

@c    *See also:. *

@c `'
@c      `igraph_similarity_dice()' (*note igraph_similarity_dice --- Dice
@c      similarity coefficient_::), a measure very similar to the Jaccard
@c      coefficient

@c
@c File: igraph_reference_manual.info,  Node: igraph_similarity_dice --- Dice similarity coefficient_,  Next: igraph_similarity_inverse_log_weighted --- Vertex similarity based on the inverse logarithm of vertex degrees_,  Prev: igraph_similarity_jaccard --- Jaccard similarity coefficient_,  Up: Similarity Measures

@c 10.7.4 igraph_similarity_dice -- Dice similarity coefficient.
@c -------------------------------------------------------------


@c      int igraph_similarity_dice(const igraph_t *graph, igraph_matrix_t *res,
@c          const igraph_vs_t vids, igraph_neimode_t mode, igraph_bool_t loops);

@c    The Dice similarity coefficient of two vertices is twice the number
@c of common neighbors divided by the sum of the degrees of the vertices.
@c This function calculates the pairwise Dice similarities for some (or
@c all) of the vertices.

@c    *Arguments:. *

@c `graph':
@c      The graph object to analyze

@c `res':
@c      Pointer to a matrix, the result of the calculation will be stored
@c      here. The number of its rows and columns is the same as the number
@c      of vertex ids in `vids'.

@c `vids':
@c      The vertex ids of the vertices for which the calculation will be
@c      done.

@c `mode':
@c      The type of neighbors to be used for the calculation in directed
@c      graphs. Possible values:

@c     `IGRAPH_OUT'
@c           the outgoing edges will be considered for each node.

@c     `IGRAPH_IN'
@c           the incoming edges will be considered for each node.

@c     `IGRAPH_ALL'
@c           the directed graph is considered as an undirected one for the
@c           computation.

@c `loops':
@c      Whether to include the vertices themselves as their own neighbors.

@c    *Returns:. *

@c `'
@c      Error code:

@c     `IGRAPH_ENOMEM'
@c           not enough memory for temporary data.

@c     `IGRAPH_EINVVID'
@c           invalid vertex id passed.

@c     `IGRAPH_EINVMODE'
@c           invalid mode argument.

@c    Time complexity: O(|V|^2 d), |V| is the number of vertices in the
@c vertex iterator given, d is the (maximum) degree of the vertices in the
@c graph.

@c    *See also:. *

@c `'
@c      `igraph_similarity_jaccard()' (*note igraph_similarity_jaccard ---
@c      Jaccard similarity coefficient_::), a measure very similar to the
@c      Dice coefficient

@c
@c File: igraph_reference_manual.info,  Node: igraph_similarity_inverse_log_weighted --- Vertex similarity based on the inverse logarithm of vertex degrees_,  Prev: igraph_similarity_dice --- Dice similarity coefficient_,  Up: Similarity Measures

@c 10.7.5 igraph_similarity_inverse_log_weighted -- Vertex similarity based on the inverse logarithm of vertex degrees.
@c --------------------------------------------------------------------------------------------------------------------


@c      int igraph_similarity_inverse_log_weighted(const igraph_t *graph,
@c        igraph_matrix_t *res, const igraph_vs_t vids, igraph_neimode_t mode);

@c    The inverse log-weighted similarity of two vertices is the number of
@c their common neighbors, weighted by the inverse logarithm of their
@c degrees.  It is based on the assumption that two vertices should be
@c considered more similar if they share a low-degree common neighbor,
@c since high-degree common neighbors are more likely to appear even by
@c pure chance.

@c    Isolated vertices will have zero similarity to any other vertex.
@c Self-similarities are not calculated.

@c    See the following paper for more details: Lada A. Adamic and Eytan
@c Adar: Friends and neighbors on the Web. Social Networks, 25(3):211-230,
@c 2003.

@c    *Arguments:. *

@c `graph':
@c      The graph object to analyze.

@c `res':
@c      Pointer to a matrix, the result of the calculation will be stored
@c      here. The number of its rows is the same as the number of vertex
@c      ids in `vids', the number of columns is the number of vertices in
@c      the graph.

@c `vids':
@c      The vertex ids of the vertices for which the calculation will be
@c      done.

@c `mode':
@c      The type of neighbors to be used for the calculation in directed
@c      graphs. Possible values:

@c     `IGRAPH_OUT'
@c           the outgoing edges will be considered for each node. Nodes
@c           will be weighted according to their in-degree.

@c     `IGRAPH_IN'
@c           the incoming edges will be considered for each node. Nodes
@c           will be weighted according to their out-degree.

@c     `IGRAPH_ALL'
@c           the directed graph is considered as an undirected one for the
@c           computation. Every node is weighted according to its
@c           undirected degree.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVVID': invalid vertex id.

@c    Time complexity: O(|V|d^2), |V| is the number of vertices in the
@c graph, d is the (maximum) degree of the vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: Spanning Tree,  Next: Transitivity or Clustering Coefficient,  Prev: Similarity Measures,  Up: Structural Properties of Graphs

@c 10.8 Spanning Tree
@c ==================

@c * Menu:

@c * igraph_minimum_spanning_tree_unweighted --- Calculates one minimum spanning tree of an unweighted graph.: igraph_minimum_spanning_tree_unweighted --- Calculates one minimum spanning tree of an unweighted graph_.
@c * igraph_minimum_spanning_tree_prim --- Calculates one minimum spanning tree of a weighted graph.: igraph_minimum_spanning_tree_prim --- Calculates one minimum spanning tree of a weighted graph_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_minimum_spanning_tree_unweighted --- Calculates one minimum spanning tree of an unweighted graph_,  Next: igraph_minimum_spanning_tree_prim --- Calculates one minimum spanning tree of a weighted graph_,  Up: Spanning Tree

@c 10.8.1 igraph_minimum_spanning_tree_unweighted -- Calculates one minimum spanning tree of an unweighted graph.
@c --------------------------------------------------------------------------------------------------------------


@c      int igraph_minimum_spanning_tree_unweighted(const igraph_t *graph,
@c      					    igraph_t *mst);

@c    If the graph has more minimum spanning trees (this is always the
@c case, except if it is a forest) this implementation returns only the
@c same one.

@c    Directed graphs are considered as undirected for this computation.

@c    If the graph is not connected then its minimum spanning forest is
@c returned. This is the set of the minimum spanning trees of each
@c component.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `mst':
@c      The minimum spanning tree, another graph object. Do _not_
@c      initialize this object before passing it to this function, but be
@c      sure to call `igraph_destroy()' (*note igraph_destroy --- Frees
@c      the memory allocated for a graph object_::) on it if you don't
@c      need it any more.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory for temporary data.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| the
@c number of edges in the graph.

@c    *See also:. *

@c `'
@c      `igraph_minimum_spanning_tree_prim()' (*note
@c      igraph_minimum_spanning_tree_prim --- Calculates one minimum
@c      spanning tree of a weighted graph_::) for weighted graphs.

@c
@c File: igraph_reference_manual.info,  Node: igraph_minimum_spanning_tree_prim --- Calculates one minimum spanning tree of a weighted graph_,  Prev: igraph_minimum_spanning_tree_unweighted --- Calculates one minimum spanning tree of an unweighted graph_,  Up: Spanning Tree

@c 10.8.2 igraph_minimum_spanning_tree_prim -- Calculates one minimum spanning tree of a weighted graph.
@c -----------------------------------------------------------------------------------------------------


@c      int igraph_minimum_spanning_tree_prim(const igraph_t *graph, igraph_t *mst,
@c      				      const igraph_vector_t *weights);

@c    This function uses Prim's method for carrying out the computation,
@c see Prim, R.C.: Shortest connection networks and some generalizations,
@c Bell System Technical Journal, Vol. 36, 1957, 1389-1401.

@c    If the graph has more than one minimum spanning tree, the current
@c implementation returns always the same one.

@c    Directed graphs are considered as undirected for this computation.

@c    If the graph is not connected then its minimum spanning forest is
@c returned. This is the set of the minimum spanning trees of each
@c component.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `mst':
@c      The result of the computation, a graph object containing the
@c      minimum spanning tree of the graph.  Do _not_ initialize this
@c      object before passing it to this function, but be sure to call
@c      `igraph_destroy()' (*note igraph_destroy --- Frees the memory
@c      allocated for a graph object_::) on it if you don't need it any
@c      more.

@c `weights':
@c      A vector containing the weights of the the edges.  in the same
@c      order as the simple edge iterator visits them.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM', not enough memory.  `IGRAPH_EINVAL',
@c      length of weight vector does not match number of edges.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| the
@c number of edges in the graph.

@c    *See also:. *

@c `'
@c      `igraph_minimum_spanning_tree_unweighted()' (*note
@c      igraph_minimum_spanning_tree_unweighted --- Calculates one minimum
@c      spanning tree of an unweighted graph_::) for unweighted graphs.

@c
@c File: igraph_reference_manual.info,  Node: Transitivity or Clustering Coefficient,  Next: Directedness conversion,  Prev: Spanning Tree,  Up: Structural Properties of Graphs

@c 10.9 Transitivity or Clustering Coefficient
@c ===========================================

@c * Menu:

@c * igraph_transitivity_undirected --- Calculates the transitivity (clustering coefficient) of a graph.: igraph_transitivity_undirected --- Calculates the transitivity [clustering coefficient] of a graph_.
@c * igraph_transitivity_local_undirected --- Calculates the local transitivity (clustering coefficient) of a graph: igraph_transitivity_local_undirected --- Calculates the local transitivity [clustering coefficient] of a graph.
@c * igraph_transitivity_avglocal_undirected --- Average local transitivity (clustering coefficient): igraph_transitivity_avglocal_undirected --- Average local transitivity [clustering coefficient].

@c
@c File: igraph_reference_manual.info,  Node: igraph_transitivity_undirected --- Calculates the transitivity [clustering coefficient] of a graph_,  Next: igraph_transitivity_local_undirected --- Calculates the local transitivity [clustering coefficient] of a graph,  Up: Transitivity or Clustering Coefficient

@c 10.9.1 igraph_transitivity_undirected -- Calculates the transitivity (clustering coefficient) of a graph.
@c ---------------------------------------------------------------------------------------------------------


@c      int igraph_transitivity_undirected(const igraph_t *graph,
@c      				   igraph_real_t *res);

@c    The transitivity measures the probability that two neighbors of a
@c vertex are connected. More precisely this is the ratio of the triangles
@c and connected triples in the graph, the result is a single real number
@c or NaN (0/0) if there are no connected triples in the graph.  Directed
@c graphs are considered as undirected ones.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      Pointer to a real variable, the result will be stored here.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM': not enough memory for temporary data.

@c    *See also:. *

@c `'
@c      `igraph_transitivity_local_undirected()' (*note
@c      igraph_transitivity_local_undirected --- Calculates the local
@c      transitivity [clustering coefficient] of a graph::),
@c      `igraph_transitivity_avglocal_undirected()' (*note
@c      igraph_transitivity_avglocal_undirected --- Average local
@c      transitivity [clustering coefficient]::).

@c    Time complexity: O(|V|*d^2), |V| is the number of vertices in the
@c graph, d is the average node degree.

@c
@c File: igraph_reference_manual.info,  Node: igraph_transitivity_local_undirected --- Calculates the local transitivity [clustering coefficient] of a graph,  Next: igraph_transitivity_avglocal_undirected --- Average local transitivity [clustering coefficient],  Prev: igraph_transitivity_undirected --- Calculates the transitivity [clustering coefficient] of a graph_,  Up: Transitivity or Clustering Coefficient

@c 10.9.2 igraph_transitivity_local_undirected -- Calculates the local transitivity (clustering coefficient) of a graph
@c --------------------------------------------------------------------------------------------------------------------


@c      int igraph_transitivity_local_undirected(const igraph_t *graph,
@c      					 igraph_vector_t *res,
@c      					 const igraph_vs_t vids);

@c    The transitivity measures the probability that two neighbors of a
@c vertex are connected. In case of the local transitivity, this
@c probability is calculated separately for each vertex.

@c    *Arguments:. *

@c `graph':
@c      The input graph, it can be directed but direction of the edges
@c      will be ignored.

@c `res':
@c      Pointer to an initialized vector, the result will be stored here.
@c      It will be resized as needed.

@c `vids':
@c      Vertex set, the vertices for which the local transitivity will be
@c      calculated.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_transitivity_undirected()' (*note
@c      igraph_transitivity_undirected --- Calculates the transitivity
@c      [clustering coefficient] of a graph_::),
@c      `igraph_transitivity_avglocal_undirected()' (*note
@c      igraph_transitivity_avglocal_undirected --- Average local
@c      transitivity [clustering coefficient]::).

@c    Time complexity: O(n*d^2), n is the number of vertices for which the
@c transitivity is calculated, d is the average vertex degree.

@c
@c File: igraph_reference_manual.info,  Node: igraph_transitivity_avglocal_undirected --- Average local transitivity [clustering coefficient],  Prev: igraph_transitivity_local_undirected --- Calculates the local transitivity [clustering coefficient] of a graph,  Up: Transitivity or Clustering Coefficient

@c 10.9.3 igraph_transitivity_avglocal_undirected -- Average local transitivity (clustering coefficient)
@c -----------------------------------------------------------------------------------------------------


@c      int igraph_transitivity_avglocal_undirected(const igraph_t *graph,
@c      					    igraph_real_t *res);

@c    The transitivity measures the probability that two neighbors of a
@c vertex are connected. In case of the average local transitivity this
@c probability if calculated for each vertex and then the average is taken
@c for those vertices which have at least two neighbors. If there are no
@c such vertices then `NaN' is returned.

@c    *Arguments:. *

@c `graph':
@c      The input graph, directed graphs are considered as undirected ones.

@c `res':
@c      Pointer to a real variable, the result will be stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_transitivity_undirected()' (*note
@c      igraph_transitivity_undirected --- Calculates the transitivity
@c      [clustering coefficient] of a graph_::),
@c      `igraph_transitivity_local_undirected()' (*note
@c      igraph_transitivity_local_undirected --- Calculates the local
@c      transitivity [clustering coefficient] of a graph::).

@c    Time complexity: O(|V|*d^2), |V| is the number of vertices in the
@c graph and d is the average degree.

@c
@c File: igraph_reference_manual.info,  Node: Directedness conversion,  Next: Spectral properties,  Prev: Transitivity or Clustering Coefficient,  Up: Structural Properties of Graphs

@c 10.10 Directedness conversion
@c =============================

@c * Menu:

@c * igraph_to_directed --- Convert an undirected graph to a directed one::
@c * igraph_to_undirected --- Convert a directed graph to an undirected one.: igraph_to_undirected --- Convert a directed graph to an undirected one_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_to_directed --- Convert an undirected graph to a directed one,  Next: igraph_to_undirected --- Convert a directed graph to an undirected one_,  Up: Directedness conversion

@c 10.10.1 igraph_to_directed -- Convert an undirected graph to a directed one
@c ---------------------------------------------------------------------------


@c      int igraph_to_directed(igraph_t *graph,
@c      		       igraph_to_directed_t mode);

@c    If the supplied graph is directed, this function does nothing.

@c    *Arguments:. *

@c `graph':
@c      The graph object to convert.

@c `mode':
@c      Constant, specifies the details of how exactly the conversion is
@c      done. Possible values: `IGRAPH_TO_DIRECTED_ARBITRARY': the number
@c      of edges in the graph stays the same, an arbitrarily directed edge
@c      is created for each undirected edge; `IGRAPH_TO_DIRECTED_MUTUAL':
@c      two directed edges are created for each undirected edge, one in
@c      each direction.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_to_undirected --- Convert a directed graph to an undirected one_,  Prev: igraph_to_directed --- Convert an undirected graph to a directed one,  Up: Directedness conversion

@c 10.10.2 igraph_to_undirected -- Convert a directed graph to an undirected one.
@c ------------------------------------------------------------------------------


@c      int igraph_to_undirected(igraph_t *graph,
@c      			 igraph_to_undirected_t mode);

@c    If the supplied graph is undirected, this function does nothing.

@c    *Arguments:. *

@c `graph':
@c      The graph object to convert.

@c `mode':
@c      Constant, specifies the details of how exactly the convesion is
@c      done. Possible values: `IGRAPH_TO_UNDIRECTED_EACH': the number of
@c      edges remains constant, an undirected edge is created for each
@c      directed one, this version might create graphs with multiple edges;
@c      `IGRAPH_TO_UNDIRECTED_COLLAPSE': one undirected edge will be
@c      created for each pair of vertices which are connected with at
@c      least one directed edge, no multiple edges will be created.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: Spectral properties,  Next: Non-simple graphs; multiple and loop edges,  Prev: Directedness conversion,  Up: Structural Properties of Graphs

@c 10.11 Spectral properties
@c =========================

@c * Menu:

@c * igraph_laplacian --- Returns the Laplacian matrix of a graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_laplacian --- Returns the Laplacian matrix of a graph,  Up: Spectral properties

@c 10.11.1 igraph_laplacian -- Returns the Laplacian matrix of a graph
@c -------------------------------------------------------------------


@c      int igraph_laplacian(const igraph_t *graph, igraph_matrix_t *res,
@c      		     igraph_bool_t normalized);

@c    The graph Laplacian matrix is similar to an adjacency matrix but
@c contains -1's instead of 1's and the vertex degrees are included in the
@c diagonal. So the result for edge i-j is -1 if i!=j and is equal to the
@c degree of vertex i if i==j. igraph_laplacian will work on a directed
@c graph (although this does not seem to make much sense) and ignores
@c loops.

@c    The normalized version of the Laplacian matrix has 1 in the diagonal
@c and -1/sqrt(d[i]d[j]) if there is an edge from i to j.

@c    The first version of this function was written by Vincent Matossian.

@c    *Arguments:. *

@c `graph':
@c      Pointer to the graph to convert.

@c `res':
@c      Pointer to an initialized matrix object, it will be resized if
@c      needed.

@c `normalized':
@c      Whether to create a normalized Laplacian matrix.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V||V|), |V| is the number of vertices in the
@c graph.

@c
@c File: igraph_reference_manual.info,  Node: Non-simple graphs; multiple and loop edges,  Next: K-Cores,  Prev: Spectral properties,  Up: Structural Properties of Graphs

@c 10.12 Non-simple graphs: multiple and loop edges
@c ================================================

@c * Menu:

@c * igraph_is_simple --- Decides whether the input graph is a simple graph::
@c * igraph_is_loop --- Find the loop edges in a graph::
@c * igraph_is_multiple --- Find the multiple edges in a graph::
@c * igraph_count_multiple --- Count the number of appearance of the edges in a graph::
@c * igraph_simplify --- Removes loop and/or multiple edges from the graph.: igraph_simplify --- Removes loop and/or multiple edges from the graph_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_is_simple --- Decides whether the input graph is a simple graph,  Next: igraph_is_loop --- Find the loop edges in a graph,  Up: Non-simple graphs; multiple and loop edges

@c 10.12.1 igraph_is_simple -- Decides whether the input graph is a simple graph
@c -----------------------------------------------------------------------------


@c      int igraph_is_simple(const igraph_t *graph, igraph_bool_t *res);

@c    A graph is a simple graph if it does not contain loop edges and
@c multiple edges.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a boolean constant, the result is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_is_loop()' (*note igraph_is_loop --- Find the loop edges
@c      in a graph::) and `igraph_is_multiple()' (*note igraph_is_multiple
@c      --- Find the multiple edges in a graph::) to find the loops and
@c      multiple edges and `igraph_simplify()' (*note igraph_simplify ---
@c      Removes loop and/or multiple edges from the graph_::) to get rid
@c      of them.

@c    Time complexity: O(|V|+|E|).

@c
@c File: igraph_reference_manual.info,  Node: igraph_is_loop --- Find the loop edges in a graph,  Next: igraph_is_multiple --- Find the multiple edges in a graph,  Prev: igraph_is_simple --- Decides whether the input graph is a simple graph,  Up: Non-simple graphs; multiple and loop edges

@c 10.12.2 igraph_is_loop -- Find the loop edges in a graph
@c --------------------------------------------------------


@c      int igraph_is_loop(const igraph_t *graph, igraph_vector_bool_t *res,
@c      		   igraph_es_t es);

@c    A loop edge is an edge from a vertex to itself.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized boolean vector for storing the result,
@c      it will be resized as needed.

@c `es':
@c      The edges to check, for all edges supply `igraph_ess_all()' (*note
@c      igraph_ess_all --- Edge set; all edges [immediate version]::) here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_simplify()' (*note igraph_simplify --- Removes loop and/or
@c      multiple edges from the graph_::) to get rid of loop edges.

@c    Time complexity: O(e), the number of edges to check.

@c
@c File: igraph_reference_manual.info,  Node: igraph_is_multiple --- Find the multiple edges in a graph,  Next: igraph_count_multiple --- Count the number of appearance of the edges in a graph,  Prev: igraph_is_loop --- Find the loop edges in a graph,  Up: Non-simple graphs; multiple and loop edges

@c 10.12.3 igraph_is_multiple -- Find the multiple edges in a graph
@c ----------------------------------------------------------------


@c      int igraph_is_multiple(const igraph_t *graph, igraph_vector_bool_t *res,
@c      		       igraph_es_t es);

@c    An edge is a multiple edge if there is another edge with the same
@c head and tail vertices in the graph.

@c    Note that this function returns true only for the second or more
@c appereances of the multiple edges.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a boolean vector, the result will be stored here. It
@c      will be resized as needed.

@c `es':
@c      The edges to check. Supply `igraph_ess_all()' (*note
@c      igraph_ess_all --- Edge set; all edges [immediate version]::) if
@c      you want to check all edges.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_count_multiple()' (*note igraph_count_multiple --- Count
@c      the number of appearance of the edges in a graph::) and
@c      `igraph_simplify()' (*note igraph_simplify --- Removes loop and/or
@c      multiple edges from the graph_::).

@c    Time complexity: O(e*d), e is the number of edges to check and d is
@c the average degree (out-degree in directed graphs) of the vertices at
@c the tail of the edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_count_multiple --- Count the number of appearance of the edges in a graph,  Next: igraph_simplify --- Removes loop and/or multiple edges from the graph_,  Prev: igraph_is_multiple --- Find the multiple edges in a graph,  Up: Non-simple graphs; multiple and loop edges

@c 10.12.4 igraph_count_multiple -- Count the number of appearance of the edges in a graph
@c ---------------------------------------------------------------------------------------


@c      int igraph_count_multiple(const igraph_t *graph, igraph_vector_t *res, igraph_es_t es);

@c    If the graph has no multiple edges then the result vector will be
@c filled with ones.  (An edge is a multiple edge if there is another edge
@c with the same head and tail vertices in the graph.)

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a vector, the result will be stored here. It will be
@c      resized as needed.

@c `es':
@c      The edges to check. Supply `igraph_ess_all()' (*note
@c      igraph_ess_all --- Edge set; all edges [immediate version]::) if
@c      you want to check all edges.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_is_multiple()' (*note igraph_is_multiple --- Find the
@c      multiple edges in a graph::) and `igraph_simplify()' (*note
@c      igraph_simplify --- Removes loop and/or multiple edges from the
@c      graph_::).

@c    Time complexity: O(e*d), e is the number of edges to check and d is
@c the average degree (out-degree in directed graphs) of the vertices at
@c the tail of the edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_simplify --- Removes loop and/or multiple edges from the graph_,  Prev: igraph_count_multiple --- Count the number of appearance of the edges in a graph,  Up: Non-simple graphs; multiple and loop edges

@c 10.12.5 igraph_simplify -- Removes loop and/or multiple edges from the graph.
@c -----------------------------------------------------------------------------


@c      int igraph_simplify(igraph_t *graph, igraph_bool_t multiple, igraph_bool_t loops);

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `multiple':
@c      Logical, if true, multiple edges will be removed.

@c `loops':
@c      Logical, if true, loops (self edges) will be removed.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM' if we are out of memory.

@c    Time complexity: O(|V|+|E|).

@c
@c File: igraph_reference_manual.info,  Node: K-Cores,  Next: Topological sorting,  Prev: Non-simple graphs; multiple and loop edges,  Up: Structural Properties of Graphs

@c 10.13 K-Cores
@c =============

@c * Menu:

@c * igraph_coreness --- Finding the coreness of the vertices in a network.: igraph_coreness --- Finding the coreness of the vertices in a network_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_coreness --- Finding the coreness of the vertices in a network_,  Up: K-Cores

@c 10.13.1 igraph_coreness -- Finding the coreness of the vertices in a network.
@c -----------------------------------------------------------------------------


@c      int igraph_coreness(const igraph_t *graph, igraph_vector_t *cores,
@c      		    igraph_neimode_t mode);

@c    The k-core of a graph is a maximal subgraph in which each vertex has
@c at least degree k. (Degree here means the degree in the subgraph of
@c course.). The coreness of a vertex is the highest order of a k-core
@c containing the vertex.

@c    This function implements the algorithm presented in Vladimir
@c Batagelj, Matjaz Zaversnik: An O(m) Algorithm for Cores Decomposition
@c of Networks.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `cores':
@c      Pointer to an initialized vector, the result of the computation
@c      will be stored here. It will be resized as needed. For each vertex
@c      it contains the highest order of a core containing the vertex.

@c `mode':
@c      For directed graph it specifies whether to calculate in-cores,
@c      out-cores or the undirected version. It is ignored for undirected
@c      graphs. Possible values: `IGRAPH_ALL' undirected version,
@c      `IGRAPH_IN' in-cores, `IGRAPH_OUT' out-cores.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|E|), the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: Topological sorting,  Next: Line graphs,  Prev: K-Cores,  Up: Structural Properties of Graphs

@c 10.14 Topological sorting
@c =========================

@c * Menu:

@c * igraph_topological_sorting --- Calculate a possible topological sorting of the graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_topological_sorting --- Calculate a possible topological sorting of the graph,  Up: Topological sorting

@c 10.14.1 igraph_topological_sorting -- Calculate a possible topological sorting of the graph
@c -------------------------------------------------------------------------------------------


@c      int igraph_topological_sorting(const igraph_t* graph, igraph_vector_t *res,
@c      			       igraph_neimode_t mode);

@c    A topological sorting of a directed acyclic graph is a linear
@c ordering of its nodes where each node comes before all nodes to which
@c it has edges. Every DAG has at least one topological sort, and may have
@c many.  This function returns a possible topological sort among them. If
@c the graph is not acyclic (it has at least one cycle), a partial
@c topological sort is returned and a warning is issued.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a vector, the result will be stored here.  It will be
@c      resized if needed.

@c `mode':
@c      Specifies how to use the direction of the edges.  For
@c      `IGRAPH_OUT', the sorting order ensures that each node comes
@c      before all nodes to which it has edges, so nodes with no incoming
@c      edges go first. For `IGRAPH_IN', it is quite the opposite: each
@c      node comes before all nodes from which it receives edges. Nodes
@c      with no outgoing edges go first.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), where |V| and |E| are the number of
@c vertices and edges in the original input graph.

@c
@c File: igraph_reference_manual.info,  Node: Line graphs,  Next: Unfolding a graph into a tree,  Prev: Topological sorting,  Up: Structural Properties of Graphs

@c 10.15 Line graphs
@c =================

@c * Menu:

@c * igraph_linegraph --- Create the line graph of a graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_linegraph --- Create the line graph of a graph,  Up: Line graphs

@c 10.15.1 igraph_linegraph -- Create the line graph of a graph
@c ------------------------------------------------------------


@c      int igraph_linegraph(const igraph_t *graph, igraph_t *linegraph);

@c    The line graph L(G) of a G undirected graph is defined as follows.
@c L(G) has one vertex for each edge in G and two vertices in L(G) are
@c connected by an edge if their corresponding edges share an end point.

@c    The line graph L(G) of a G directed graph is slightly different,
@c L(G) has one vertex for each edge in G and two vertices in L(G) are
@c connected by a directed edge if the target of the first vertex's
@c corresponding edge is the same as the source of the second vertex's
@c corresponding edge.

@c    The first version of this function was contributed by Vincent
@c Matossian, thanks.

@c    *Arguments:. *

@c `graph':
@c      The input graph, may be directed or undirected.

@c `linegraph':
@c      Pointer to an uninitialized graph object, the result is stored
@c      here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), the number of edges plus the number of
@c vertices.

@c
@c File: igraph_reference_manual.info,  Node: Unfolding a graph into a tree,  Next: Other Operations,  Prev: Line graphs,  Up: Structural Properties of Graphs

@c 10.16 Unfolding a graph into a tree
@c ===================================

@c * Menu:

@c * igraph_unfold_tree --- Unfolding a graph into a tree, by possibly multiplicating its vertices: igraph_unfold_tree --- Unfolding a graph into a tree; by possibly multiplicating its vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_unfold_tree --- Unfolding a graph into a tree; by possibly multiplicating its vertices,  Up: Unfolding a graph into a tree

@c 10.16.1 igraph_unfold_tree -- Unfolding a graph into a tree, by possibly multiplicating its vertices
@c ----------------------------------------------------------------------------------------------------


@c      int igraph_unfold_tree(const igraph_t *graph, igraph_t *tree,
@c      		       igraph_neimode_t mode, const igraph_vector_t *roots,
@c      		       igraph_vector_t *vertex_index);

@c    A graph is converted into a tree (or forest, if it is unconnected),
@c by performing a breadth-first search on it, and replicating vertices
@c that were found a second, third, etc. time.

@c    *Arguments:. *

@c `graph':
@c      The input graph, it can be either directed or undirected.

@c `tree':
@c      Pointer to an uninitialized graph object, the result is stored
@c      here.

@c `mode':
@c      For directed graphs; whether to follow paths along edge directions
@c      (`IGRAPH_OUT'), or the opposite (`IGRAPH_IN'), or ignore edge
@c      directions completely (`IGRAPH_ALL'). It is ignored for undirected
@c      graphs.

@c `roots':
@c      A numeric vector giving the root vertex, or vertices (if the graph
@c      is not connected), to start from.

@c `vertex_index':
@c      Pointer to an initialized vector, or a null pointer. If not a null
@c      pointer, then a mapping from the vertices in the new graph to the
@c      ones in the original is created here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n+m), linear in the number vertices and edges.

@c
@c File: igraph_reference_manual.info,  Node: Other Operations,  Prev: Unfolding a graph into a tree,  Up: Structural Properties of Graphs

@c 10.17 Other Operations
@c ======================

@c * Menu:

@c * igraph_density --- Calculate the density of a graph.: igraph_density --- Calculate the density of a graph_.
@c * igraph_reciprocity --- Calculates the reciprocity of a directed graph.: igraph_reciprocity --- Calculates the reciprocity of a directed graph_.
@c * igraph_is_mutual --- Check whether the edges of a directed graph are mutual::
@c * igraph_avg_nearest_neighbor_degree --- Average nearest neighbor degree::
@c * igraph_get_adjacency --- Returns the adjacency matrix of a graph::
@c * igraph_get_edgelist --- Returns the list of edges in a graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_density --- Calculate the density of a graph_,  Next: igraph_reciprocity --- Calculates the reciprocity of a directed graph_,  Up: Other Operations

@c 10.17.1 igraph_density -- Calculate the density of a graph.
@c -----------------------------------------------------------


@c      int igraph_density(const igraph_t *graph, igraph_real_t *res,
@c      		   igraph_bool_t loops);

@c    The density of a graph is simply the ratio number of edges and the
@c number of possible edges. Note that density is ill-defined for graphs
@c with multiple and/or loop edges, so consider calling
@c `igraph_simplify()' (*note igraph_simplify --- Removes loop and/or
@c multiple edges from the graph_::) on the graph if you know that it
@c contains multiple or loop edges.

@c    *Arguments:. *

@c `graph':
@c      The input graph object.

@c `res':
@c      Pointer to a real number, the result will be stored here.

@c `loops':
@c      Logical constant, whether to include loops in the calculation. If
@c      this constant is TRUE then loop edges are thought to be possible
@c      in the graph (this does not neccessary means that the graph really
@c      contains any loops). If this FALSE then the result is only correct
@c      if the graph does not contain loops.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_reciprocity --- Calculates the reciprocity of a directed graph_,  Next: igraph_is_mutual --- Check whether the edges of a directed graph are mutual,  Prev: igraph_density --- Calculate the density of a graph_,  Up: Other Operations

@c 10.17.2 igraph_reciprocity -- Calculates the reciprocity of a directed graph.
@c -----------------------------------------------------------------------------


@c      int igraph_reciprocity(const igraph_t *graph, igraph_real_t *res,
@c      		       igraph_bool_t ignore_loops);

@c    A vertex pair (A, B) is said to be reciprocal if there are edges
@c between them in both directions. The reciprocity of a directed graph is
@c the proportion of all possible (A, B) pairs which are reciprocal,
@c provided there is at least one edge between A and B. The reciprocity of
@c an empty graph is undefined (results in an error code). Undirected
@c graphs always have a reciprocity of 1.0 unless they are empty.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      Pointer to an `igraph_real_t' which will contain the result.

@c `ignore_loops':
@c      Whether to ignore loop edges.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL': graph has no edges `IGRAPH_ENOMEM':
@c      not enough memory for temporary data.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| is
@c the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_is_mutual --- Check whether the edges of a directed graph are mutual,  Next: igraph_avg_nearest_neighbor_degree --- Average nearest neighbor degree,  Prev: igraph_reciprocity --- Calculates the reciprocity of a directed graph_,  Up: Other Operations

@c 10.17.3 igraph_is_mutual -- Check whether the edges of a directed graph are mutual
@c ----------------------------------------------------------------------------------


@c      int igraph_is_mutual(igraph_t *graph, igraph_vector_bool_t *res, igraph_es_t es);

@c    An (A,B) edge is mutual if the graph contains the (B,A) edge, too.

@c    An undirected graph only has mutual edges, by definition.

@c    Edge multiplicity is not considered here, e.g. if there are two
@c (A,B) edges and one (B,A) edge, then all three are considered to be
@c mutual.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized vector, the result is stored here.

@c `es':
@c      The sequence of edges to check. Supply ` igraph_ess_all()'  for
@c      all edges, see `igraph_ess_all()' (*note igraph_ess_all --- Edge
@c      set; all edges [immediate version]::).

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n log(d)), n is the number of edges supplied, d
@c is the maximum in-degree of the vertices that are targets of the
@c supplied edges. An upper limit of the time complexity is O(n log(|E|)),
@c |E| is the number of edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_avg_nearest_neighbor_degree --- Average nearest neighbor degree,  Next: igraph_get_adjacency --- Returns the adjacency matrix of a graph,  Prev: igraph_is_mutual --- Check whether the edges of a directed graph are mutual,  Up: Other Operations

@c 10.17.4 igraph_avg_nearest_neighbor_degree -- Average nearest neighbor degree
@c -----------------------------------------------------------------------------


@c      int igraph_avg_nearest_neighbor_degree(const igraph_t *graph,
@c      				       igraph_vs_t vids,
@c      				       igraph_vector_t *knn,
@c      				       igraph_vector_t *knnk,
@c      				       const igraph_vector_t *weights);

@c    Calculates the average degree of the neighbors for each vertex, and
@c optionally, the same quantity in the function of vertex degree.

@c    For isolate vertices `knn' is set to `IGRAPH_NAN'. The same is done
@c in `knnk' for vertex degrees that don't appear in the graph.

@c    *Arguments:. *

@c `graph':
@c      The input graph, it can be directed but the directedness of the
@c      edges is ignored.

@c `vids':
@c      The vertices for which the calculation is permformed.

@c `knn':
@c      Pointer to an initialized vector, the result will be stored here.
@c      It will be resized as needed. Supply a NULL pointer here, if you
@c      only want to calculate `knnk'.

@c `knnk':
@c      Pointer to an initialized vector, the average nearest neighbor
@c      degree in the function of vertex degree is stored here. The first
@c      (zeroth) element is for degree one vertices, etc. Supply a NULL
@c      pointer here if you don't want to calculate this.

@c `weights':
@c      Optional edge weights. Supply a null pointer here for the
@c      non-weighted version. If this is not a null pointer, then the
@c      strength of the vertices is used instead of the normal vertex
@c      degree, see `igraph_strength()' (*note igraph_strength ---
@c      Strength of the vertices; weighted vertex degree in other words::).

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_adjacency --- Returns the adjacency matrix of a graph,  Next: igraph_get_edgelist --- Returns the list of edges in a graph,  Prev: igraph_avg_nearest_neighbor_degree --- Average nearest neighbor degree,  Up: Other Operations

@c 10.17.5 igraph_get_adjacency -- Returns the adjacency matrix of a graph
@c -----------------------------------------------------------------------


@c      int igraph_get_adjacency(const igraph_t *graph, igraph_matrix_t *res,
@c      			 igraph_get_adjacency_t type);

@c    The result is an incidence matrix, it contains numbers greater than
@c one if there are multiple edges in the graph.

@c    *Arguments:. *

@c `graph':
@c      Pointer to the graph to convert

@c `res':
@c      Pointer to an initialized matrix object, it will be resized if
@c      needed.

@c `type':
@c      Constant giving the type of the adjacency matrix to create for
@c      undirected graphs. It is ignored for directed graphs. Possible
@c      values:

@c     `IGRAPH_GET_ADJACENCY_UPPER '
@c           the upper right triangle of the matrix is used.

@c     `IGRAPH_GET_ADJACENCY_LOWER '
@c           the lower left triangle of the matrix is used.

@c     `IGRAPH_GET_ADJACENCY_BOTH '
@c           the whole matrix is used, a symmetric matrix is returned.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EINVAL' invalid type argument.

@c    *See also:. *

@c `'
@c      igraph_get_adjacency_sparse if you want a sparse matrix
@c      representation

@c    Time complexity: O(|V||V|), |V| is the number of vertices in the
@c graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_edgelist --- Returns the list of edges in a graph,  Prev: igraph_get_adjacency --- Returns the adjacency matrix of a graph,  Up: Other Operations

@c 10.17.6 igraph_get_edgelist -- Returns the list of edges in a graph
@c -------------------------------------------------------------------


@c      int igraph_get_edgelist(const igraph_t *graph, igraph_vector_t *res, igraph_bool_t bycol);

@c    The order of the edges is given by the edge ids.

@c    *Arguments:. *

@c `graph':
@c      Pointer to the graph object

@c `res':
@c      Pointer to an initialized vector object, it will be resized.

@c `bycol':
@c      Logical, if true, the edges will be returned columnwise, eg. the
@c      first edge is ` res[0]->res[|E|]' , the second is `
@c      res[1]->res[|E|+1]' , etc.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|E|), the number of edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: Cliques and Independent Vertex Sets,  Next: Graph Isomorphism,  Prev: Structural Properties of Graphs,  Up: Top

@c 11 Cliques and Independent Vertex Sets
@c **************************************

@c These functions calculate various graph properties related to cliques
@c and independent vertex sets.

@c * Menu:

@c * Cliques::
@c * Independent Vertex Sets::

@c
@c File: igraph_reference_manual.info,  Node: Cliques,  Next: Independent Vertex Sets,  Up: Cliques and Independent Vertex Sets

@c 11.1 Cliques
@c ============

@c * Menu:

@c * igraph_cliques --- Find all or some cliques in a graph::
@c * igraph_largest_cliques --- Finds the largest clique(s) in a graph.: igraph_largest_cliques --- Finds the largest clique[s] in a graph_.
@c * igraph_maximal_cliques --- Find all maximal cliques of a graph::
@c * igraph_clique_number --- Find the clique number of the graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_cliques --- Find all or some cliques in a graph,  Next: igraph_largest_cliques --- Finds the largest clique[s] in a graph_,  Up: Cliques

@c 11.1.1 igraph_cliques -- Find all or some cliques in a graph
@c ------------------------------------------------------------


@c      int igraph_cliques(const igraph_t *graph, igraph_vector_ptr_t *res,
@c                         igraph_integer_t min_size, igraph_integer_t max_size);

@c    Cliques are fully connected subgraphs of a graph.

@c    If you are only interested in the size of the largest clique in the
@c graph, use `igraph_clique_number()' (*note igraph_clique_number ---
@c Find the clique number of the graph::) instead.

@c    The current implementation of this function searches for maximal
@c independent vertex sets (see `igraph_maximal_independent_vertex_sets()'
@c (*note igraph_maximal_independent_vertex_sets --- Find all maximal
@c independent vertex sets of a graph::)) in the complementer graph using
@c the algorithm published in: S. Tsukiyama, M. Ide, H. Ariyoshi and I.
@c Shirawaka. A new algorithm for generating all the maximal independent
@c sets. SIAM J Computing, 6:505-517, 1977.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a pointer vector, the result will be stored here, ie.
@c      `res' will contain pointers to `igraph_vector_t' objects which
@c      contain the indices of vertices involved in a clique.  The pointer
@c      vector will be resized if needed but note that the objects in the
@c      pointer vector will not be freed.

@c `min_size':
@c      Integer giving the minimum size of the cliques to be returned. If
@c      negative or zero, no lower bound will be used.

@c `max_size':
@c      Integer giving the maximum size of the cliques to be returned. If
@c      negative or zero, no upper bound will be used.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_largest_cliques()' (*note igraph_largest_cliques --- Finds
@c      the largest clique[s] in a graph_::) and `igraph_clique_number()'
@c      (*note igraph_clique_number --- Find the clique number of the
@c      graph::).

@c    Time complexity: TODO

@c
@c File: igraph_reference_manual.info,  Node: igraph_largest_cliques --- Finds the largest clique[s] in a graph_,  Next: igraph_maximal_cliques --- Find all maximal cliques of a graph,  Prev: igraph_cliques --- Find all or some cliques in a graph,  Up: Cliques

@c 11.1.2 igraph_largest_cliques -- Finds the largest clique(s) in a graph.
@c ------------------------------------------------------------------------


@c      int igraph_largest_cliques(const igraph_t *graph, igraph_vector_ptr_t *res);

@c    A clique is largest (quite intuitively) if there is no other clique
@c in the graph which contains more vertices.

@c    Note that this is not neccessarily the same as a maximal clique, ie.
@c the largest cliques are always maximal but a maximal clique is not
@c always largest.

@c    The current implementation of this function searches for maximal
@c independent vertex sets (see `igraph_maximal_independent_vertex_sets()'
@c (*note igraph_maximal_independent_vertex_sets --- Find all maximal
@c independent vertex sets of a graph::)) in the complementer graph using
@c the algorithm published in: S. Tsukiyama, M. Ide, H. Ariyoshi and I.
@c Shirawaka. A new algorithm for generating all the maximal independent
@c sets. SIAM J Computing, 6:505-517, 1977.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized pointer vector, the result will be
@c      stored here. It will be resized as needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_cliques()' (*note igraph_cliques --- Find all or some
@c      cliques in a graph::), `igraph_maximal_cliques()' (*note
@c      igraph_maximal_cliques --- Find all maximal cliques of a graph::)

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_maximal_cliques --- Find all maximal cliques of a graph,  Next: igraph_clique_number --- Find the clique number of the graph,  Prev: igraph_largest_cliques --- Finds the largest clique[s] in a graph_,  Up: Cliques

@c 11.1.3 igraph_maximal_cliques -- Find all maximal cliques of a graph
@c --------------------------------------------------------------------


@c      int igraph_maximal_cliques(const igraph_t *graph, igraph_vector_ptr_t *res);

@c    A maximal clique is a clique which can't be extended any more by
@c adding a new vertex to it. This is actually implemented by looking for
@c a maximal independent vertex set in the complementer of the graph.

@c    If you are only interested in the size of the largest clique in the
@c graph, use `igraph_clique_number()' (*note igraph_clique_number ---
@c Find the clique number of the graph::) instead.

@c    The current implementation was ported to igraph from the Very Nauty
@c Graph Library by Keith Briggs and uses the algorithm from the paper S.
@c Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm for
@c generating all the maximal independent sets. SIAM J Computing,
@c 6:505-517, 1977.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a pointer vector, the result will be stored here, ie.
@c      `res' will contain pointers to `igraph_vector_t' objects which
@c      contain the indices of vertices involved in a clique.  The pointer
@c      vector will be resized if needed but note that the objects in the
@c      pointer vector will not be freed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_maximal_independent_vertex_sets()' (*note
@c      igraph_maximal_independent_vertex_sets --- Find all maximal
@c      independent vertex sets of a graph::), `igraph_clique_number()'
@c      (*note igraph_clique_number --- Find the clique number of the
@c      graph::)

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_clique_number --- Find the clique number of the graph,  Prev: igraph_maximal_cliques --- Find all maximal cliques of a graph,  Up: Cliques

@c 11.1.4 igraph_clique_number -- Find the clique number of the graph
@c ------------------------------------------------------------------


@c      int igraph_clique_number(const igraph_t *graph, igraph_integer_t *no);

@c    The clique number of a graph is the size of the largest clique.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `no':
@c      The clique number will be returned to the `igraph_integer_t'
@c      pointed by this variable.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_cliques()' (*note igraph_cliques --- Find all or some
@c      cliques in a graph::), `igraph_largest_cliques()' (*note
@c      igraph_largest_cliques --- Finds the largest clique[s] in a
@c      graph_::).

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: Independent Vertex Sets,  Prev: Cliques,  Up: Cliques and Independent Vertex Sets

@c 11.2 Independent Vertex Sets
@c ============================

@c * Menu:

@c * igraph_independent_vertex_sets --- Find all independent vertex sets in a graph::
@c * igraph_largest_independent_vertex_sets --- Finds the largest independent vertex set(s) in a graph.: igraph_largest_independent_vertex_sets --- Finds the largest independent vertex set[s] in a graph_.
@c * igraph_maximal_independent_vertex_sets --- Find all maximal independent vertex sets of a graph::
@c * igraph_independence_number --- Find the independence number of the graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_independent_vertex_sets --- Find all independent vertex sets in a graph,  Next: igraph_largest_independent_vertex_sets --- Finds the largest independent vertex set[s] in a graph_,  Up: Independent Vertex Sets

@c 11.2.1 igraph_independent_vertex_sets -- Find all independent vertex sets in a graph
@c ------------------------------------------------------------------------------------


@c      int igraph_independent_vertex_sets(const igraph_t *graph,
@c      				   igraph_vector_ptr_t *res,
@c      				   igraph_integer_t min_size,
@c      				   igraph_integer_t max_size);

@c    A vertex set is considered independent if there are no edges between
@c them.

@c    If you are interested in the size of the largest independent vertex
@c set, use `igraph_independence_number()' (*note
@c igraph_independence_number --- Find the independence number of the
@c graph::) instead.

@c    The current implementation was ported to igraph from the Very Nauty
@c Graph Library by Keith Briggs and uses the algorithm from the paper S.
@c Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm for
@c generating all the maximal independent sets. SIAM J Computing,
@c 6:505-517, 1977.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a pointer vector, the result will be stored here, ie.
@c      `res' will contain pointers to `igraph_vector_t' objects which
@c      contain the indices of vertices involved in an independent vertex
@c      set. The pointer vector will be resized if needed but note that the
@c      objects in the pointer vector will not be freed.

@c `min_size':
@c      Integer giving the minimum size of the sets to be returned. If
@c      negative or zero, no lower bound will be used.

@c `max_size':
@c      Integer giving the maximum size of the sets to be returned. If
@c      negative or zero, no upper bound will be used.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_largest_independent_vertex_sets()' (*note
@c      igraph_largest_independent_vertex_sets --- Finds the largest
@c      independent vertex set[s] in a graph_::),
@c      `igraph_independence_number()' (*note igraph_independence_number
@c      --- Find the independence number of the graph::).

@c    Time complexity: TODO

@c
@c File: igraph_reference_manual.info,  Node: igraph_largest_independent_vertex_sets --- Finds the largest independent vertex set[s] in a graph_,  Next: igraph_maximal_independent_vertex_sets --- Find all maximal independent vertex sets of a graph,  Prev: igraph_independent_vertex_sets --- Find all independent vertex sets in a graph,  Up: Independent Vertex Sets

@c 11.2.2 igraph_largest_independent_vertex_sets -- Finds the largest independent vertex set(s) in a graph.
@c --------------------------------------------------------------------------------------------------------


@c      int igraph_largest_independent_vertex_sets(const igraph_t *graph,
@c      					   igraph_vector_ptr_t *res);

@c    An independent vertex set is largest if there is no other
@c independent vertex set with more vertices in the graph.

@c    The current implementation was ported to igraph from the Very Nauty
@c Graph Library by Keith Briggs and uses the algorithm from the paper S.
@c Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm for
@c generating all the maximal independent sets. SIAM J Computing,
@c 6:505-517, 1977.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a pointer vector, the result will be stored here. It
@c      will be resized as needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_independent_vertex_sets()' (*note
@c      igraph_independent_vertex_sets --- Find all independent vertex
@c      sets in a graph::), `igraph_maximal_independent_vertex_sets()'
@c      (*note igraph_maximal_independent_vertex_sets --- Find all maximal
@c      independent vertex sets of a graph::).

@c    Time complexity: TODO

@c
@c File: igraph_reference_manual.info,  Node: igraph_maximal_independent_vertex_sets --- Find all maximal independent vertex sets of a graph,  Next: igraph_independence_number --- Find the independence number of the graph,  Prev: igraph_largest_independent_vertex_sets --- Finds the largest independent vertex set[s] in a graph_,  Up: Independent Vertex Sets

@c 11.2.3 igraph_maximal_independent_vertex_sets -- Find all maximal independent vertex sets of a graph
@c ----------------------------------------------------------------------------------------------------


@c      int igraph_maximal_independent_vertex_sets(const igraph_t *graph,
@c      					   igraph_vector_ptr_t *res);

@c    A maximal independent vertex set is an independent vertex set which
@c can't be extended any more by adding a new vertex to it.

@c    The algorithm used here is based on the following paper: S.
@c Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm for
@c generating all the maximal independent sets. SIAM J Computing,
@c 6:505-517, 1977.

@c    The implementation was originally written by Kevin O'Neill and
@c modified by K M Briggs in the Very Nauty Graph Library. I simply
@c re-wrote it to use igraph's data structures.

@c    If you are interested in the size of the largest independent vertex
@c set, use `igraph_independence_number()' (*note
@c igraph_independence_number --- Find the independence number of the
@c graph::) instead.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a pointer vector, the result will be stored here, ie.
@c      `res' will contain pointers to `igraph_vector_t' objects which
@c      contain the indices of vertices involved in an independent vertex
@c      set. The pointer vector will be resized if needed but note that the
@c      objects in the pointer vector will not be freed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_maximal_cliques()' (*note igraph_maximal_cliques --- Find
@c      all maximal cliques of a graph::), `igraph_independence_number()'
@c      (*note igraph_independence_number --- Find the independence number
@c      of the graph::)

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_independence_number --- Find the independence number of the graph,  Prev: igraph_maximal_independent_vertex_sets --- Find all maximal independent vertex sets of a graph,  Up: Independent Vertex Sets

@c 11.2.4 igraph_independence_number -- Find the independence number of the graph
@c ------------------------------------------------------------------------------


@c      int igraph_independence_number(const igraph_t *graph, igraph_integer_t *no);

@c    The independence number of a graph is the cardinality of the largest
@c independent vertex set.

@c    The current implementation was ported to igraph from the Very Nauty
@c Graph Library by Keith Briggs and uses the algorithm from the paper S.
@c Tsukiyama, M. Ide, H. Ariyoshi and I. Shirawaka. A new algorithm for
@c generating all the maximal independent sets. SIAM J Computing,
@c 6:505-517, 1977.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `no':
@c      The independence number will be returned to the `igraph_integer_t'
@c      pointed by this variable.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_independent_vertex_sets()' (*note
@c      igraph_independent_vertex_sets --- Find all independent vertex
@c      sets in a graph::).

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: Graph Isomorphism,  Next: Graph Motifs; Dyad Census and Triad Census,  Prev: Cliques and Independent Vertex Sets,  Up: Top

@c 12 Graph Isomorphism
@c ********************

@c * Menu:

@c * The simple interface::
@c * The BLISS algorithm::
@c * The VF2 algorithm::
@c * Functions for graphs with 3 or 4 vertices::

@c
@c File: igraph_reference_manual.info,  Node: The simple interface,  Next: The BLISS algorithm,  Up: Graph Isomorphism

@c 12.1 The simple interface
@c =========================

@c igraph provides four set of functions to deal with graph isomorphism
@c problems.

@c    The `igraph_isomorphic()' (*note igraph_isomorphic --- Decides
@c whether two graphs are isomorphic::) and `igraph_subisomorphic()'
@c (*note igraph_subisomorphic --- Decide subgraph isomorphism::)
@c functions make up the first set (in addition with the
@c `igraph_permute_vertices()' (*note igraph_permute_vertices --- Permute
@c the vertices::) function). These functions choose the algorithm which
@c is best for the supplied input graph. (The choice is not very
@c sophisticated though, see their documentation for details.)

@c    The VF2 graph (and subgraph) isomorphism algorithm is implemented in
@c igraph, these functions are the second set. See
@c `igraph_isomorphic_vf2()' (*note igraph_isomorphic_vf2 --- Isomorphism
@c via VF2::) and `igraph_subisomorphic_vf2()' (*note
@c igraph_subisomorphic_vf2 --- Decide subgraph isomorphism using VF2::)
@c for starters.

@c    Functions for the BLISS algorithm constitute the third set, see
@c `igraph_isomorphic_bliss()' (*note igraph_isomorphic_bliss --- Graph
@c isomorphism via BLISS::). This implementation only works for undirected
@c graphs.

@c    Finally, the isomorphism classes of all graphs with three and four
@c vertices are precomputed and stored in igraph, so for these small
@c graphs there is a very simple fast way to decide isomorphism.  See
@c `igraph_isomorphic_34()' (*note igraph_isomorphic_34 --- Graph
@c isomorphism for 3-4 vertices::).

@c * Menu:

@c * igraph_permute_vertices --- Permute the vertices::
@c * igraph_isomorphic --- Decides whether two graphs are isomorphic::
@c * igraph_subisomorphic --- Decide subgraph isomorphism::

@c
@c File: igraph_reference_manual.info,  Node: igraph_permute_vertices --- Permute the vertices,  Next: igraph_isomorphic --- Decides whether two graphs are isomorphic,  Up: The simple interface

@c 12.1.1 igraph_permute_vertices -- Permute the vertices
@c ------------------------------------------------------


@c      int igraph_permute_vertices(const igraph_t *graph, igraph_t *res,
@c      			    const igraph_vector_t *permutation);

@c    This function creates a new graph from the input graph by permuting
@c its vertices according to the specified mapping. Call this function
@c with the output of `igraph_canonical_permutation()' (*note
@c igraph_canonical_permutation --- Canonical permutation using BLISS::)
@c to create the canonical form of a graph.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an uninitialized graph object. The new graph is created
@c      here.

@c `permutation':
@c      The permutation to apply. Vertex 0 is mapped to the first element
@c      of the vector, vertex 1 to the second, etc. Note that it is not
@c      checked that the vector contains every element only once, and no
@c      range checking is performed either.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in terms of the number of
@c vertices and edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_isomorphic --- Decides whether two graphs are isomorphic,  Next: igraph_subisomorphic --- Decide subgraph isomorphism,  Prev: igraph_permute_vertices --- Permute the vertices,  Up: The simple interface

@c 12.1.2 igraph_isomorphic -- Decides whether two graphs are isomorphic
@c ---------------------------------------------------------------------


@c      int igraph_isomorphic(const igraph_t *graph1, const igraph_t *graph2,
@c      		      igraph_bool_t *iso);

@c    From Wikipedia: The graph isomorphism problem or GI problem is the
@c graph theory problem of determining whether, given two graphs G1 and
@c G2, it is possible to permute (or relabel) the vertices of one graph so
@c that it is equal to the other. Such a permutation is called a graph
@c isomorphism.

@c    This function decides which graph isomorphism algorithm to be used
@c based on the input graphs. Right now it does the following:

@c   1. If one graph is directed and the other undirected then an error is
@c      triggered.

@c   2. If the two graphs does not have the same number of vertices and
@c      edges it returns with `FALSE'.

@c   3. Otherwise, if the graphs have three or four vertices then an O(1)
@c      algorithm is used with precomputed data.

@c   4. Otherwise, if the graphs are directed then VF2 is used, see
@c      `igraph_isomorphic_vf2()' (*note igraph_isomorphic_vf2 ---
@c      Isomorphism via VF2::).

@c   5. Otherwise BLISS is used, see `igraph_isomorphic_bliss()' (*note
@c      igraph_isomorphic_bliss --- Graph isomorphism via BLISS::).

@c    Please call the VF2 and BLISS functions directly if you need
@c something more sophisticated, e.g. you need the isomorphic mapping.

@c    *Arguments:. *

@c `graph1':
@c      The first graph.

@c `graph2':
@c      The second graph.

@c `iso':
@c      Pointer to a logical variable, will be set to TRUE (1) if the two
@c      graphs are isomorphic, and FALSE (0) otherwise.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_isoclass()' (*note igraph_isoclass --- Determine the
@c      isomorphism class of a graph with 3 or 4 vertices::),
@c      `igraph_isoclass_subgraph()' (*note igraph_isoclass_subgraph ---
@c      The isomorphism class of a subgraph of a graph_::),
@c      `igraph_isoclass_create()' (*note igraph_isoclass_create ---
@c      Creates a graph from the given isomorphism class_::).

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: igraph_subisomorphic --- Decide subgraph isomorphism,  Prev: igraph_isomorphic --- Decides whether two graphs are isomorphic,  Up: The simple interface

@c 12.1.3 igraph_subisomorphic -- Decide subgraph isomorphism
@c ----------------------------------------------------------


@c      int igraph_subisomorphic(const igraph_t *graph1, const igraph_t *graph2,
@c      			 igraph_bool_t *iso);

@c    Check whether `graph2' is isomorphic to a subgraph of `graph1'.
@c Currently this function just calls `igraph_subisomorphic_vf2()' (*note
@c igraph_subisomorphic_vf2 --- Decide subgraph isomorphism using VF2::)
@c for all graphs.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, may be directed or undirected. This is
@c      supposed to be the bigger graph.

@c `graph2':
@c      The second input graph, it must have the same directedness as
@c      `graph2', or an error is triggered. This is supposed to be the
@c      smaller graph.

@c `iso':
@c      Pointer to a boolean, the result is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: The BLISS algorithm,  Next: The VF2 algorithm,  Prev: The simple interface,  Up: Graph Isomorphism

@c 12.2 The BLISS algorithm
@c ========================

@c BLISS is a successor of the famous NAUTY algorithm and implementation.
@c While using the same ideas in general, with better heuristics and data
@c structure BLISS outperforms NAUTY on most graphs.

@c    BLISS was developed and implemented by Tommi Junttila and Petteri
@c Kaski at Helsinki University of Technology, Finland. See Tommi
@c Juntilla's homepage at http://www.tcs.hut.fi/~tjunttil/
@c (http://www.tcs.hut.fi/~tjunttil/) and the publication at
@c http://www.siam.org/proceedings/alenex/2007/alx07_013junttilat.pdf
@c (http://www.siam.org/proceedings/alenex/2007/alx07_013junttilat.pdf)
@c for more information.

@c    BLISS version 0.35 is included in igraph.

@c * Menu:

@c * igraph_bliss_sh_t --- Splitting heuristics for BLISS::
@c * igraph_bliss_info_t --- Information about a BLISS run::
@c * igraph_canonical_permutation --- Canonical permutation using BLISS::
@c * igraph_isomorphic_bliss --- Graph isomorphism via BLISS::
@c * igraph_automorphisms --- Number of automorphisms using BLISS::

@c
@c File: igraph_reference_manual.info,  Node: igraph_bliss_sh_t --- Splitting heuristics for BLISS,  Next: igraph_bliss_info_t --- Information about a BLISS run,  Up: The BLISS algorithm

@c 12.2.1 igraph_bliss_sh_t -- Splitting heuristics for BLISS
@c ----------------------------------------------------------


@c      typedef enum { IGRAPH_BLISS_F=0, IGRAPH_BLISS_FL,
@c      	       IGRAPH_BLISS_FS, IGRAPH_BLISS_FM,
@c      	       IGRAPH_BLISS_FLM, IGRAPH_BLISS_FSM } igraph_bliss_sh_t;

@c    *Values:. *

@c `IGRAPH_BLISS_F':
@c      First non-singleton cell.

@c `IGRAPH_BLISS_FL':
@c      First largest non-singleton cell.

@c `IGRAPH_BLISS_FS':
@c      First smallest non-singleton cell.

@c `IGRAPH_BLISS_FM':
@c      First maximally non-trivially connected non-singleton cell.

@c `IGRAPH_BLISS_FLM':
@c      Largest maximally non-trivially connected non-singleton cell.

@c `IGRAPH_BLISS_FSM':
@c      Smallest maximally non-trivially connected non-singletion cell.

@c
@c File: igraph_reference_manual.info,  Node: igraph_bliss_info_t --- Information about a BLISS run,  Next: igraph_canonical_permutation --- Canonical permutation using BLISS,  Prev: igraph_bliss_sh_t --- Splitting heuristics for BLISS,  Up: The BLISS algorithm

@c 12.2.2 igraph_bliss_info_t -- Information about a BLISS run
@c -----------------------------------------------------------


@c      typedef struct igraph_bliss_info_t {
@c        unsigned long nof_nodes;
@c        unsigned long nof_leaf_nodes;
@c        unsigned long nof_bad_nodes;
@c        unsigned long nof_canupdates;
@c        unsigned long max_level;
@c        char *group_size;
@c      } igraph_bliss_info_t;

@c    Some secondary information found by the BLISS algorithm is stored
@c here. It is useful if you wany to study the internal working of the
@c algorithm.

@c    *Values:. *

@c `nof_nodes':
@c      The number of nodes in the search tree.

@c `nof_leaf_nodes':
@c      The number of leaf nodes in the search tree.

@c `nof_bad_nodes':
@c      Number of bad nodes.

@c `nof_canupdates':
@c      Number of canrep updates.

@c `max_level':
@c      Maximum level.

@c `group_size':
@c      The size of the automorphism group of the graph, given as a
@c      string. It should be deallocated via `free()' if not needed any
@c      more.

@c    See http://www.tcs.hut.fi/Software/bliss/index.html
@c (http://www.tcs.hut.fi/Software/bliss/index.html) for details about the
@c algorithm and these parameters.

@c
@c File: igraph_reference_manual.info,  Node: igraph_canonical_permutation --- Canonical permutation using BLISS,  Next: igraph_isomorphic_bliss --- Graph isomorphism via BLISS,  Prev: igraph_bliss_info_t --- Information about a BLISS run,  Up: The BLISS algorithm

@c 12.2.3 igraph_canonical_permutation -- Canonical permutation using BLISS
@c ------------------------------------------------------------------------


@c      int igraph_canonical_permutation(const igraph_t *graph, igraph_vector_t *labeling,
@c      				 igraph_bliss_sh_t sh, igraph_bliss_info_t *info);

@c    This function computes the canonical permutation which transforms
@c the graph into a canonical form by using the BLISS algorithm.

@c    *Arguments:. *

@c `graph':
@c      The input graph, it is treated as undirected and the multiple
@c      edges are ignored.

@c `labeling':
@c      Pointer to a vector, the result is stored here. The permutation
@c      takes vertex 0 to the first element of the vector, vertex 1 to the
@c      second, etc. The vector will be resized as needed.

@c `sh':
@c      The split heuristics to be used in BLISS. See `igraph_bliss_sh_t'
@c      (*note igraph_bliss_sh_t --- Splitting heuristics for BLISS::).

@c `info':
@c      If not `NULL' then information on BLISS internals is stored here.
@c      See `igraph_bliss_info_t' (*note igraph_bliss_info_t ---
@c      Information about a BLISS run::).

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential, in practice it is fast for many graphs.

@c
@c File: igraph_reference_manual.info,  Node: igraph_isomorphic_bliss --- Graph isomorphism via BLISS,  Next: igraph_automorphisms --- Number of automorphisms using BLISS,  Prev: igraph_canonical_permutation --- Canonical permutation using BLISS,  Up: The BLISS algorithm

@c 12.2.4 igraph_isomorphic_bliss -- Graph isomorphism via BLISS
@c -------------------------------------------------------------


@c      int igraph_isomorphic_bliss(const igraph_t *graph1, const igraph_t *graph2,
@c      			    igraph_bool_t *iso, igraph_vector_t *map12,
@c      			    igraph_vector_t *map21,
@c      			    igraph_bliss_sh_t sh1, igraph_bliss_sh_t sh2,
@c      			    igraph_bliss_info_t *info1, igraph_bliss_info_t *info2);

@c    This function uses the BLISS graph isomorphism algorithm, a
@c successor of the famous NAUTY algorithm and implementation. BLISS is
@c open source and licensed according to the GNU GPL. See
@c http://www.tcs.hut.fi/Software/bliss/index.html
@c (http://www.tcs.hut.fi/Software/bliss/index.html) for details.
@c Currently the 0.35 version of BLISS is included in igraph.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, it is assumed to be undirected, directed
@c      graphs are treated as undirected too.  The algorithm eliminates
@c      multiple edges from the graph first.

@c `graph2':
@c      The second input graph, it is assumed to be undirected, directed
@c      graphs are treated as undirected too.  The algorithm eliminates
@c      multiple edges from the graph first.

@c `iso':
@c      Pointer to a boolean, the result is stored here.

@c `map12':
@c      A vector or `NULL' pointer. If not `NULL' then an isomorphic
@c      mapping from `graph1' to `graph2' is stored here.  If the input
@c      graphs are not isomorphic then this vector is cleared, i.e. it
@c      will have length zero.

@c `map21':
@c      Similar to `map12', but for the mapping from `graph2' to `graph1'.

@c `sh1':
@c      Splitting heuristics to be used for the first graph. See
@c      `igraph_bliss_sh_t' (*note igraph_bliss_sh_t --- Splitting
@c      heuristics for BLISS::).

@c `sh2':
@c      Splitting heuristics to be used for the second graph. See
@c      `igraph_bliss_sh_t' (*note igraph_bliss_sh_t --- Splitting
@c      heuristics for BLISS::).

@c `info1':
@c      If not `NULL', information about the canonization of the first
@c      input graph is stored here. See `igraph_bliss_info_t' (*note
@c      igraph_bliss_info_t --- Information about a BLISS run::) for
@c      details.

@c `info2':
@c      Same as `info1', but for the second graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential, but in practice it is quite fast.

@c
@c File: igraph_reference_manual.info,  Node: igraph_automorphisms --- Number of automorphisms using BLISS,  Prev: igraph_isomorphic_bliss --- Graph isomorphism via BLISS,  Up: The BLISS algorithm

@c 12.2.5 igraph_automorphisms -- Number of automorphisms using BLISS
@c ------------------------------------------------------------------


@c      int igraph_automorphisms(const igraph_t *graph,
@c      			 igraph_bliss_sh_t sh, igraph_bliss_info_t *info);

@c    The number of automorphisms of a graph is computed using BLISS. The
@c result is returned as part of the `info' structure, in tag
@c `group_size'. It is returned as a string, as it can be very high even
@c for relatively small graphs. If the GNU MP library is used then this
@c number is exact, otherwise a `long double' is used and it is only
@c approximate. See also `igraph_bliss_info_t' (*note igraph_bliss_info_t
@c --- Information about a BLISS run::).

@c    *Arguments:. *

@c `graph':
@c      The input graph, it is treated as undirected and the multiple
@c      edges are ignored.

@c `sh':
@c      The split heuristics to be used in BLISS. See `igraph_bliss_sh_t'
@c      (*note igraph_bliss_sh_t --- Splitting heuristics for BLISS::).

@c `info':
@c      The result is stored here, in particular in the `group_size' tag
@c      of `info'.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential, in practice it is fast for many graphs.

@c
@c File: igraph_reference_manual.info,  Node: The VF2 algorithm,  Next: Functions for graphs with 3 or 4 vertices,  Prev: The BLISS algorithm,  Up: Graph Isomorphism

@c 12.3 The VF2 algorithm
@c ======================

@c * Menu:

@c * igraph_isomorphic_vf2 --- Isomorphism via VF2::
@c * igraph_count_isomorphisms_vf2 --- Number of isomorphisms via VF2::
@c * igraph_get_isomorphisms_vf2 --- Collect the isomorphic mappings::
@c * igraph_isohandler_t --- Callback type, called when an isomorphism was found: igraph_isohandler_t --- Callback type; called when an isomorphism was found.
@c * igraph_isomorphic_function_vf2 --- The generic VF2 interface::
@c * igraph_subisomorphic_vf2 --- Decide subgraph isomorphism using VF2::
@c * igraph_count_subisomorphisms_vf2 --- Number of subgraph isomorphisms using VF2::
@c * igraph_get_subisomorphisms_vf2 --- Return all subgraph isomorphic mappings::
@c * igraph_subisomorphic_function_vf2 --- Generic VF2 function for subgraph isomorphism problems::

@c
@c File: igraph_reference_manual.info,  Node: igraph_isomorphic_vf2 --- Isomorphism via VF2,  Next: igraph_count_isomorphisms_vf2 --- Number of isomorphisms via VF2,  Up: The VF2 algorithm

@c 12.3.1 igraph_isomorphic_vf2 -- Isomorphism via VF2
@c ---------------------------------------------------


@c      int igraph_isomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2,
@c      			  igraph_bool_t *iso, igraph_vector_t *map12,
@c      			  igraph_vector_t *map21);

@c    This function performs the VF2 algorithm via calling
@c `igraph_isomorphic_function_vf2()' (*note
@c igraph_isomorphic_function_vf2 --- The generic VF2 interface::).

@c    Note that this function cannot be used for deciding subgraph
@c isomorphism, use `igraph_subisomorphic_vf2()' (*note
@c igraph_subisomorphic_vf2 --- Decide subgraph isomorphism using VF2::)
@c for that.

@c    *Arguments:. *

@c `graph1':
@c      The first graph, may be directed or undirected.

@c `graph2':
@c      The second graph. It must have the same directedness as `graph1',
@c      otherwise an error is reported.

@c `iso':
@c      Pointer to a logical constant, the result of the algorithm will be
@c      placed here.

@c `map12':
@c      Pointer to an initialized vector or a NULL pointer. If not a NULL
@c      pointer then the mapping from `graph1' to `graph2' is stored here.
@c      If the graphs are not isomorphic then the vector is cleared (ie.
@c      has zero elements).

@c `map21':
@c      Pointer to an initialized vector or a NULL pointer. If not a NULL
@c      pointer then the mapping from `graph2' to `graph1' is stored here.
@c      If the graphs are not isomorphic then the vector is cleared (ie.
@c      has zero elements).

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_subisomorphic_vf2()' (*note igraph_subisomorphic_vf2 ---
@c      Decide subgraph isomorphism using VF2::),
@c      `igraph_count_isomorphisms_vf2()' (*note
@c      igraph_count_isomorphisms_vf2 --- Number of isomorphisms via
@c      VF2::), `igraph_get_isomorphisms_vf2()' (*note
@c      igraph_get_isomorphisms_vf2 --- Collect the isomorphic mappings::),

@c    Time complexity: exponential, what did you expect?

@c
@c File: igraph_reference_manual.info,  Node: igraph_count_isomorphisms_vf2 --- Number of isomorphisms via VF2,  Next: igraph_get_isomorphisms_vf2 --- Collect the isomorphic mappings,  Prev: igraph_isomorphic_vf2 --- Isomorphism via VF2,  Up: The VF2 algorithm

@c 12.3.2 igraph_count_isomorphisms_vf2 -- Number of isomorphisms via VF2
@c ----------------------------------------------------------------------


@c      int igraph_count_isomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2,
@c      				  igraph_integer_t *count);

@c    This function counts the number of isomorphic mappings between two
@c graphs. It uses the generic `igraph_isomorphic_function_vf2()' (*note
@c igraph_isomorphic_function_vf2 --- The generic VF2 interface::)
@c function.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, may be directed or undirected.

@c `graph2':
@c      The second input graph, it must have the same directedness as
@c      `graph1', or an error will be reported.

@c `count':
@c      Point to an integer, the result will be stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_isomorphisms_vf2 --- Collect the isomorphic mappings,  Next: igraph_isohandler_t --- Callback type; called when an isomorphism was found,  Prev: igraph_count_isomorphisms_vf2 --- Number of isomorphisms via VF2,  Up: The VF2 algorithm

@c 12.3.3 igraph_get_isomorphisms_vf2 -- Collect the isomorphic mappings
@c ---------------------------------------------------------------------


@c      int igraph_get_isomorphisms_vf2(const igraph_t *graph1,
@c      				const igraph_t *graph2,
@c      				igraph_vector_ptr_t *maps);

@c    This function finds all the isomorphic mappings between two graphs.
@c It uses the `igraph_isomorphic_function_vf2()' (*note
@c igraph_isomorphic_function_vf2 --- The generic VF2 interface::)
@c function. Call the function with the same graph as `graph1' and
@c `graph2' to get automorphisms.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, may be directed or undirected.

@c `graph2':
@c      The second input graph, it must have the same directedness as
@c      `graph1', or an error will be reported.

@c `maps':
@c      Pointer vector. On return it is empty if the input graphs are no
@c      isomorphic. Otherwise it contains pointers to `igraph_vector_t'
@c      objects, each vector is an isomorphic mapping of `graph2' to
@c      `graph1'. Please note that you need to 1) Destroy the vectors via
@c      `igraph_vector_destroy()' (*note igraph_vector_destroy ---
@c      Destroys a vector object_::), 2) free them via `free()' and then
@c      3) call `igraph_vector_ptr_destroy()' (*note
@c      igraph_vector_ptr_destroy --- Destroys a pointer vector_::) on the
@c      pointer vector to deallocate all memory when `maps' is no longer
@c      needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: igraph_isohandler_t --- Callback type; called when an isomorphism was found,  Next: igraph_isomorphic_function_vf2 --- The generic VF2 interface,  Prev: igraph_get_isomorphisms_vf2 --- Collect the isomorphic mappings,  Up: The VF2 algorithm

@c 12.3.4 igraph_isohandler_t -- Callback type, called when an isomorphism was found
@c ---------------------------------------------------------------------------------


@c      typedef igraph_bool_t igraph_isohandler_t(const igraph_vector_t *map12,
@c      					  const igraph_vector_t *map21, void *arg);

@c    See the details at the documentation of
@c `igraph_isomorphic_function_vf2()' (*note
@c igraph_isomorphic_function_vf2 --- The generic VF2 interface::).

@c    *Arguments:. *

@c `map12':
@c      The mapping from the first graph to the second.

@c `map21':
@c      The mapping from the second graph to the first, the inverse of
@c      `map12' basically.

@c `arg':
@c      This extra argument was passed to
@c      `igraph_isomorphic_function_vf2()' (*note
@c      igraph_isomorphic_function_vf2 --- The generic VF2 interface::)
@c      when it was called.

@c    *Returns:. *

@c `'
@c      Boolean, whether to continue with the isomorphism search.

@c
@c File: igraph_reference_manual.info,  Node: igraph_isomorphic_function_vf2 --- The generic VF2 interface,  Next: igraph_subisomorphic_vf2 --- Decide subgraph isomorphism using VF2,  Prev: igraph_isohandler_t --- Callback type; called when an isomorphism was found,  Up: The VF2 algorithm

@c 12.3.5 igraph_isomorphic_function_vf2 -- The generic VF2 interface
@c ------------------------------------------------------------------


@c      int igraph_isomorphic_function_vf2(const igraph_t *graph1, const igraph_t *graph2,
@c      				   igraph_vector_t *map12,
@c      				   igraph_vector_t *map21,
@c      				   igraph_isohandler_t *function,
@c       				   void *arg);

@c    This function is an implementation of the VF2 isomorphism algorithm,
@c see P. Foggia, C. Sansone, M. Vento, An Improved algorithm for matching
@c large graphs, Proc. of the 3rd IAPR-TC-15 International Workshop on
@c Graph-based Representations, Italy, 2001.

@c    For using it you need to define a calback function of type
@c `igraph_isohandler_t' (*note igraph_isohandler_t --- Callback type;
@c called when an isomorphism was found::). This function will be called
@c whenever VF2 finds an isomorphism between the two graphs. The mapping
@c between the two graphs will be also provided to this function. If the
@c callback returns a nonzero value then the search is continued,
@c otherwise it stops.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph.

@c `graph2':
@c      The second input graph.

@c `map12':
@c      Pointer to an initialized vector or `NULL'. If not `NULL' and the
@c      supplied graphs are isomorphic then the permutation taking
@c      `graph1' to `graph' is stored here. If not `NULL' and the graphs
@c      are not isomorphic then a zero-length vector is returned.

@c `map21':
@c      This is the same as `map12', but for the permutation taking
@c      `graph2' to `graph1'.

@c `function':
@c      The callback function to be called if an isomorphism is found. See
@c      also `igraph_isohandler_t' (*note igraph_isohandler_t --- Callback
@c      type; called when an isomorphism was found::).

@c `arg':
@c      An extra argument to pass to `function'. E.g. if `function' needs
@c      to store the isomorphisms found, then `arg' may point to a
@c      container for them.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: igraph_subisomorphic_vf2 --- Decide subgraph isomorphism using VF2,  Next: igraph_count_subisomorphisms_vf2 --- Number of subgraph isomorphisms using VF2,  Prev: igraph_isomorphic_function_vf2 --- The generic VF2 interface,  Up: The VF2 algorithm

@c 12.3.6 igraph_subisomorphic_vf2 -- Decide subgraph isomorphism using VF2
@c ------------------------------------------------------------------------


@c      int igraph_subisomorphic_vf2(const igraph_t *graph1, const igraph_t *graph2,
@c      			     igraph_bool_t *iso, igraph_vector_t *map12,
@c      			     igraph_vector_t *map21);

@c    Decides whether a subgraph of `graph1' is isomorphic to `graph2'. It
@c uses `igraph_subisomorphic_function_vf2()' (*note
@c igraph_subisomorphic_function_vf2 --- Generic VF2 function for subgraph
@c isomorphism problems::).

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, may be directed or undirected. This is
@c      supposed to be the larger graph.

@c `graph2':
@c      The second input graph, it must have the same directedness as
@c      `graph1'. This is supposed to be the smaller graph.

@c `iso':
@c      Pointer to a boolean. The result of the decision problem is stored
@c      here.

@c `map12':
@c      Pointer to a vector or `NULL'. If not `NULL', then an isomorphic
@c      mapping from `graph1' to `graph2' is stored here.

@c `map21':
@c      Pointer to a vector ot `NULL'. If not `NULL', then an isomorphic
@c      mapping from `graph2' to `graph1' is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: igraph_count_subisomorphisms_vf2 --- Number of subgraph isomorphisms using VF2,  Next: igraph_get_subisomorphisms_vf2 --- Return all subgraph isomorphic mappings,  Prev: igraph_subisomorphic_vf2 --- Decide subgraph isomorphism using VF2,  Up: The VF2 algorithm

@c 12.3.7 igraph_count_subisomorphisms_vf2 -- Number of subgraph isomorphisms using VF2
@c ------------------------------------------------------------------------------------


@c      int igraph_count_subisomorphisms_vf2(const igraph_t *graph1, const igraph_t *graph2,
@c      				     igraph_integer_t *count);

@c    Count the number of isomorphisms between subgraphs of `graph1' and
@c `graph2'. This function uses `igraph_subisomorphic_function_vf2()'
@c (*note igraph_subisomorphic_function_vf2 --- Generic VF2 function for
@c subgraph isomorphism problems::).

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, may be directed or undirected. This is
@c      supposed to be the larger graph.

@c `graph2':
@c      The second input graph, it must have the same directedness as
@c      `graph1'. This is supposed to be the smaller graph.

@c `count':
@c      Pointer to an integer. The number of subgraph isomorphisms is
@c      stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_subisomorphisms_vf2 --- Return all subgraph isomorphic mappings,  Next: igraph_subisomorphic_function_vf2 --- Generic VF2 function for subgraph isomorphism problems,  Prev: igraph_count_subisomorphisms_vf2 --- Number of subgraph isomorphisms using VF2,  Up: The VF2 algorithm

@c 12.3.8 igraph_get_subisomorphisms_vf2 -- Return all subgraph isomorphic mappings
@c --------------------------------------------------------------------------------


@c      int igraph_get_subisomorphisms_vf2(const igraph_t *graph1,
@c      				   const igraph_t *graph2,
@c      				   igraph_vector_ptr_t *maps);

@c    This function collects all isomorphic mappings of `graph2' to a
@c subgraph of `graph1'. It uses the `igraph_subisomorphic_function_vf2()'
@c (*note igraph_subisomorphic_function_vf2 --- Generic VF2 function for
@c subgraph isomorphism problems::) function.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, may be directed or undirected. This is
@c      supposed to be the larger graph.

@c `graph2':
@c      The second input graph, it must have the same directedness as
@c      `graph1'. This is supposed to be the smaller graph.

@c `maps':
@c      Pointer vector. On return it contains pointers to
@c      `igraph_vector_t' objects, each vector is an isomorphic mapping of
@c      `graph2' to a subgraph of `graph1'. Please note that you need to
@c      1) Destroy the vectors via `igraph_vector_destroy()' (*note
@c      igraph_vector_destroy --- Destroys a vector object_::), 2) free
@c      them via `free()' and then 3) call `igraph_vector_ptr_destroy()'
@c      (*note igraph_vector_ptr_destroy --- Destroys a pointer vector_::)
@c      on the pointer vector to deallocate all memory when `maps' is no
@c      longer needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: igraph_subisomorphic_function_vf2 --- Generic VF2 function for subgraph isomorphism problems,  Prev: igraph_get_subisomorphisms_vf2 --- Return all subgraph isomorphic mappings,  Up: The VF2 algorithm

@c 12.3.9 igraph_subisomorphic_function_vf2 -- Generic VF2 function for subgraph isomorphism problems
@c --------------------------------------------------------------------------------------------------


@c      int igraph_subisomorphic_function_vf2(const igraph_t *graph1,
@c      				      const igraph_t *graph2,
@c      				      igraph_vector_t *map12,
@c      				      igraph_vector_t *map21,
@c      				      igraph_isohandler_t *function,
@c      				      void *arg);

@c    This function is the pair of `igraph_isomorphic_function_vf2()'
@c (*note igraph_isomorphic_function_vf2 --- The generic VF2 interface::),
@c for subgraph isomorphism problems. It searches for subgraphs of
@c `graph1' which are isomorphic to `graph2'. When it founds an isomorphic
@c mapping it calls the supplied callback `function'.  The mapping (and
@c its inverse) and the additional `arg' argument are supplied to the
@c callback.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph, may be directed or undirected. This is
@c      supposed to be the larger graph.

@c `graph2':
@c      The second input graph, it must have the same directedness as
@c      `graph1'. This is supposed to be the smaller graph.

@c `map12':
@c      Pointer to a vector or `NULL'. If not `NULL', then an isomorphic
@c      mapping from `graph1' to `graph2' is stored here.

@c `map21':
@c      Pointer to a vector ot `NULL'. If not `NULL', then an isomorphic
@c      mapping from `graph2' to `graph1' is stored here.

@c `function':
@c      A pointer to a function of type `igraph_isohandler_t' (*note
@c      igraph_isohandler_t --- Callback type; called when an isomorphism
@c      was found::). This will be called whenever a subgraph isomorphism
@c      is found. If the function returns with a non-zero value then the
@c      search is continued, otherwise it stops and the function returns.

@c `arg':
@c      Extra argument to supply to the callback `function'.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: exponential.

@c
@c File: igraph_reference_manual.info,  Node: Functions for graphs with 3 or 4 vertices,  Prev: The VF2 algorithm,  Up: Graph Isomorphism

@c 12.4 Functions for graphs with 3 or 4 vertices
@c ==============================================

@c * Menu:

@c * igraph_isomorphic_34 --- Graph isomorphism for 3-4 vertices::
@c * igraph_isoclass --- Determine the isomorphism class of a graph with 3 or 4 vertices::
@c * igraph_isoclass_subgraph --- The isomorphism class of a subgraph of a graph.: igraph_isoclass_subgraph --- The isomorphism class of a subgraph of a graph_.
@c * igraph_isoclass_create --- Creates a graph from the given isomorphism class.: igraph_isoclass_create --- Creates a graph from the given isomorphism class_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_isomorphic_34 --- Graph isomorphism for 3-4 vertices,  Next: igraph_isoclass --- Determine the isomorphism class of a graph with 3 or 4 vertices,  Up: Functions for graphs with 3 or 4 vertices

@c 12.4.1 igraph_isomorphic_34 -- Graph isomorphism for 3-4 vertices
@c -----------------------------------------------------------------


@c      int igraph_isomorphic_34(const igraph_t *graph1, const igraph_t *graph2,
@c      			 igraph_bool_t *iso);

@c    This function uses precomputed indices to decide isomorphism
@c problems for graphs with only 3 or 4 vertices.

@c    *Arguments:. *

@c `graph1':
@c      The first input graph.

@c `graph2':
@c      The second input graph. Must have the same directedness as
@c      `graph1'.

@c `iso':
@c      Pointer to a boolean, the result is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_isoclass --- Determine the isomorphism class of a graph with 3 or 4 vertices,  Next: igraph_isoclass_subgraph --- The isomorphism class of a subgraph of a graph_,  Prev: igraph_isomorphic_34 --- Graph isomorphism for 3-4 vertices,  Up: Functions for graphs with 3 or 4 vertices

@c 12.4.2 igraph_isoclass -- Determine the isomorphism class of a graph with 3 or 4 vertices
@c -----------------------------------------------------------------------------------------


@c      int igraph_isoclass(const igraph_t *graph, igraph_integer_t *isoclass);

@c    All graphs with a given number of vertices belong to a number of
@c isomorpism classes, with every graph in a given class being isomorphic
@c to each other.

@c    This function gives the isomorphism class (a number) of a graph. Two
@c graphs have the same isomorphism class if and only if they are
@c isomorphic.

@c    The first isomorphism class is numbered zero and it is the empty
@c graph, the last isomorphism class is the full graph. The number of
@c isomorphism class for directed graphs with three vertices is 16
@c (between 0 and 15), for undirected graph it is only 4. For graphs with
@c four vertices it is 218 (directed) and 11 (undirected).

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `isoclass':
@c      Pointer to an integer, the isomorphism class will be stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_isomorphic()' (*note igraph_isomorphic --- Decides whether
@c      two graphs are isomorphic::), `igraph_isoclass_subgraph()' (*note
@c      igraph_isoclass_subgraph --- The isomorphism class of a subgraph
@c      of a graph_::), `igraph_isoclass_create()' (*note
@c      igraph_isoclass_create --- Creates a graph from the given
@c      isomorphism class_::), `igraph_motifs_randesu()' (*note
@c      igraph_motifs_randesu --- Count the number of motifs in a graph::).

@c    Because of some limitations this function works only for graphs with
@c three of four vertices.

@c    Time complexity: O(|E|), the number of edges in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_isoclass_subgraph --- The isomorphism class of a subgraph of a graph_,  Next: igraph_isoclass_create --- Creates a graph from the given isomorphism class_,  Prev: igraph_isoclass --- Determine the isomorphism class of a graph with 3 or 4 vertices,  Up: Functions for graphs with 3 or 4 vertices

@c 12.4.3 igraph_isoclass_subgraph -- The isomorphism class of a subgraph of a graph.
@c ----------------------------------------------------------------------------------


@c      int igraph_isoclass_subgraph(const igraph_t *graph, igraph_vector_t *vids,
@c      			     igraph_integer_t *isoclass);

@c    This function is only implemented for subgraphs with three or four
@c vertices.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `vids':
@c      A vector containing the vertex ids to be considered as a subgraph.
@c      Each vertex id should be included at most once.

@c `isoclass':
@c      Pointer to an integer, this will be set to the isomorphism class.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_isoclass()' (*note igraph_isoclass --- Determine the
@c      isomorphism class of a graph with 3 or 4 vertices::),
@c      `igraph_isomorphic()' (*note igraph_isomorphic --- Decides whether
@c      two graphs are isomorphic::), `igraph_isoclass_create()' (*note
@c      igraph_isoclass_create --- Creates a graph from the given
@c      isomorphism class_::).

@c    Time complexity: O((d+n)*n), d is the average degree in the network,
@c and n is the number of vertices in `vids'.

@c
@c File: igraph_reference_manual.info,  Node: igraph_isoclass_create --- Creates a graph from the given isomorphism class_,  Prev: igraph_isoclass_subgraph --- The isomorphism class of a subgraph of a graph_,  Up: Functions for graphs with 3 or 4 vertices

@c 12.4.4 igraph_isoclass_create -- Creates a graph from the given isomorphism class.
@c ----------------------------------------------------------------------------------


@c      int igraph_isoclass_create(igraph_t *graph, igraph_integer_t size,
@c      			   igraph_integer_t number, igraph_bool_t directed);

@c    This function is implemented only for graphs with three or four
@c vertices.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `size':
@c      The number of vertices to add to the graph.

@c `number':
@c      The isomorphism class.

@c `directed':
@c      Logical constant, whether to create a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_isoclass()' (*note igraph_isoclass --- Determine the
@c      isomorphism class of a graph with 3 or 4 vertices::),
@c      `igraph_isoclass_subgraph()' (*note igraph_isoclass_subgraph ---
@c      The isomorphism class of a subgraph of a graph_::),
@c      `igraph_isomorphic()' (*note igraph_isomorphic --- Decides whether
@c      two graphs are isomorphic::).

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the graph to create.

@c
@c File: igraph_reference_manual.info,  Node: Graph Motifs; Dyad Census and Triad Census,  Next: Generating Layouts for Graph Drawing,  Prev: Graph Isomorphism,  Up: Top

@c 13 Graph Motifs, Dyad Census and Triad Census
@c *********************************************

@c This section deals with functions which find small induced subgraphs in
@c a graph. These were first defined for subgraphs of two and three
@c vertices by Holland and Leinhardt, and named dyad census and triad
@c census.

@c * Menu:

@c * igraph_dyad_census --- Calculating the dyad census as defined by Holland and Leinhardt::
@c * igraph_triad_census --- Triad census, as defined by Davis and Leinhardt: igraph_triad_census --- Triad census; as defined by Davis and Leinhardt.
@c * Graph motifs::

@c
@c File: igraph_reference_manual.info,  Node: igraph_dyad_census --- Calculating the dyad census as defined by Holland and Leinhardt,  Next: igraph_triad_census --- Triad census; as defined by Davis and Leinhardt,  Up: Graph Motifs; Dyad Census and Triad Census

@c 13.1 igraph_dyad_census -- Calculating the dyad census as defined by Holland and Leinhardt
@c ==========================================================================================


@c      int igraph_dyad_census(const igraph_t *graph, igraph_integer_t *mut,
@c      		       igraph_integer_t *asym, igraph_integer_t *null);

@c    Dyad census means classifying each pair of vertices of a directed
@c graph into three categories: mutual, there is an edge from `a' to `b'
@c and also from `b' to `a'; asymmetric, there is an edge either from `a'
@c to `b' or from `b' to `a' but not the other way and null, no edges
@c between `a' and `b'.

@c    Holland, P.W. and Leinhardt, S.  (1970).  A Method for Detecting
@c Structure in Sociometric Data.  American Journal of Sociology, 70,
@c 492-513.

@c    *Arguments:. *

@c `graph':
@c      The input graph, a warning is given if undirected as the results
@c      are undefined for undirected graphs.

@c `mut':
@c      Pointer to an integer, the number of mutual dyads is stored here.

@c `asym':
@c      Pointer to an integer, the number of asymmetric dyads is stored
@c      here.

@c `null':
@c      Pointer to an integer, the number of null dyads is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_reciprocity()' (*note igraph_reciprocity --- Calculates
@c      the reciprocity of a directed graph_::), `igraph_triad_census()'
@c      (*note igraph_triad_census --- Triad census; as defined by Davis
@c      and Leinhardt::).

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_triad_census --- Triad census; as defined by Davis and Leinhardt,  Next: Graph motifs,  Prev: igraph_dyad_census --- Calculating the dyad census as defined by Holland and Leinhardt,  Up: Graph Motifs; Dyad Census and Triad Census

@c 13.2 igraph_triad_census -- Triad census, as defined by Davis and Leinhardt
@c ===========================================================================


@c      int igraph_triad_census(const igraph_t *graph, igraph_vector_t *res);

@c    Calculating the triad census means classifying every triple of
@c vertices in a directed graph. A triple can be in one of 16 states:

@c `003 '
@c      A, B, C, the empty graph.

@c `012 '
@c      A->B, C, a graph with a single directed edge.

@c `102 '
@c      A<->B, C, a graph with a mutual connection between two vertices.

@c `021D '
@c      A<-B->C, the binary out-tree.

@c `021U '
@c      A->B<-C, the binary in-tree.

@c `021C '
@c      A->B->C, the directed line.

@c `111D '
@c      A<->B<-C.

@c `111U '
@c      A<->B->C.

@c `030T '
@c      A->B<-C, A->C.

@c `030C '
@c      A<-B<-C, A->C.

@c `201 '
@c      A<->B<->C.

@c `120D '
@c      A<-B->C, A<->C.

@c `120U '
@c      A->B<-C, A<->C.

@c `120C '
@c      A->B->C, A<->C.

@c `210 '
@c      A->B<->C, A<->C.

@c `300 '
@c      A<->B<->C, A<->C, the complete graph.

@c    See also Davis, J.A. and Leinhardt, S.  (1972).  The Structure of
@c Positive Interpersonal Relations in Small Groups.  In J. Berger (Ed.),
@c Sociological Theories in Progress, Volume 2, 218-251.  Boston: Houghton
@c Mifflin.

@c    This function calls `igraph_motifs_randesu()' (*note
@c igraph_motifs_randesu --- Count the number of motifs in a graph::)
@c which is an implementation of the FANMOD motif finder tool, see
@c `igraph_motifs_randesu()' (*note igraph_motifs_randesu --- Count the
@c number of motifs in a graph::) for details. Note that the order of the
@c triads is not the same for `igraph_triad_census()' (*note
@c igraph_triad_census --- Triad census; as defined by Davis and
@c Leinhardt::) and `igraph_motifs_randesu()' (*note igraph_motifs_randesu
@c --- Count the number of motifs in a graph::).

@c    *Arguments:. *

@c `graph':
@c      The input graph. A warning is given for undirected graphs, as the
@c      result is undefined for those.

@c `res':
@c      Pointer to an initialized vector, the result is stored here in the
@c      same order as given in the list above. Note that this order is
@c      different than the one used by `igraph_motifs_randesu()' (*note
@c      igraph_motifs_randesu --- Count the number of motifs in a graph::).

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_motifs_randesu()' (*note igraph_motifs_randesu --- Count
@c      the number of motifs in a graph::), `igraph_dyad_census()' (*note
@c      igraph_dyad_census --- Calculating the dyad census as defined by
@c      Holland and Leinhardt::).

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: Graph motifs,  Prev: igraph_triad_census --- Triad census; as defined by Davis and Leinhardt,  Up: Graph Motifs; Dyad Census and Triad Census

@c 13.3 Graph motifs
@c =================

@c * Menu:

@c * igraph_motifs_randesu --- Count the number of motifs in a graph::
@c * igraph_motifs_randesu_no --- Count the total number of motifs in a graph::
@c * igraph_motifs_randesu_estimate --- Estimate the total number of motifs in a graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_motifs_randesu --- Count the number of motifs in a graph,  Next: igraph_motifs_randesu_no --- Count the total number of motifs in a graph,  Up: Graph motifs

@c 13.3.1 igraph_motifs_randesu -- Count the number of motifs in a graph
@c ---------------------------------------------------------------------


@c      int igraph_motifs_randesu(const igraph_t *graph, igraph_vector_t *hist,
@c      			  int size, const igraph_vector_t *cut_prob);

@c    Motifs are small subgraphs of a given structure in a graph. It is
@c argued that the motif profile (ie. the number of different motifs in
@c the graph) is characteristic for different types of networks and
@c network function is related to the motifs in the graph.

@c    This function is able to find the different motifs of size three and
@c four (ie. the number of different subgraphs with three and four
@c vertices) in the network. (This limitation is the result of the lack of
@c code to decide graph isomorphism for larger graphs.)

@c    In a big network the total number of motifs can be very large, so it
@c takes a lot of time to find all of them, a sampling method can be used.
@c This function is capable of doing sampling via the `cut_prob' argument.
@c This argument gives the probability that a branch of the motif search
@c tree will not be explored. See S. Wernicke and F. Rasche: FANMOD: a
@c tool for fast network motif detection, Bioinformatics 22(9), 1152-1153,
@c 2006 for details.

@c    Set the `cut_prob' argument to a zero vector for finding all motifs.

@c    Directed motifs will be counted in directed graphs and undirected
@c motifs in undirected graphs.

@c    *Arguments:. *

@c `graph':
@c      The graph to find the motifs in.

@c `hist':
@c      The result of the computation, it gives the number of motifs found
@c      for each isomorphism class. See `igraph_isoclass()' (*note
@c      igraph_isoclass --- Determine the isomorphism class of a graph
@c      with 3 or 4 vertices::) for help about isomorphism classes.

@c `size':
@c      The size of the motifs to search for. Only three and four are
@c      implemented currently. The limitation is not in the motif finding
@c      code, but the graph isomorphism code.

@c `cut_prob':
@c      Vector of probabilities for cutting the search tree at a given
@c      level. The first element is the first level, etc.  Supply all
@c      zeros here (of length `size') to find all motifs in a graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_motifs_randesu_estimate()' (*note
@c      igraph_motifs_randesu_estimate --- Estimate the total number of
@c      motifs in a graph::) for estimating the number of motifs in a
@c      graph, this can help to set the `cut_prob' parameter;
@c      `igraph_motifs_randesu_no()' (*note igraph_motifs_randesu_no ---
@c      Count the total number of motifs in a graph::) to calculate the
@c      total number of motifs of a given size in a graph.

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_motifs_randesu_no --- Count the total number of motifs in a graph,  Next: igraph_motifs_randesu_estimate --- Estimate the total number of motifs in a graph,  Prev: igraph_motifs_randesu --- Count the number of motifs in a graph,  Up: Graph motifs

@c 13.3.2 igraph_motifs_randesu_no -- Count the total number of motifs in a graph
@c ------------------------------------------------------------------------------


@c      int igraph_motifs_randesu_no(const igraph_t *graph, igraph_integer_t *no,
@c      			     int size, const igraph_vector_t *cut_prob);

@c    This function counts the total number of motifs in a graph without
@c assigning isomorphism classes to them.

@c    Directed motifs will be counted in directed graphs and undirected
@c motifs in undirected graphs.

@c    *Arguments:. *

@c `graph':
@c      The graph object to study.

@c `no':
@c      Pointer to an integer type, the result will be stored here.

@c `size':
@c      The size of the motifs to count.

@c `cut_prob':
@c      Vector giving the probabilities that a branch of the search tree
@c      will be cut at a given level.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_motifs_randesu()' (*note igraph_motifs_randesu --- Count
@c      the number of motifs in a graph::),
@c      `igraph_motifs_randesu_estimate()' (*note
@c      igraph_motifs_randesu_estimate --- Estimate the total number of
@c      motifs in a graph::).

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_motifs_randesu_estimate --- Estimate the total number of motifs in a graph,  Prev: igraph_motifs_randesu_no --- Count the total number of motifs in a graph,  Up: Graph motifs

@c 13.3.3 igraph_motifs_randesu_estimate -- Estimate the total number of motifs in a graph
@c ---------------------------------------------------------------------------------------


@c      int igraph_motifs_randesu_estimate(const igraph_t *graph, igraph_integer_t *est,
@c      				   int size, const igraph_vector_t *cut_prob,
@c      				   igraph_integer_t sample_size,
@c      				   const igraph_vector_t *parsample);

@c    This function is useful for large graphs for which it is not
@c feasible to count all the different motifs, because there is very many
@c of them.

@c    The total number of motifs is estimated by taking a sample of
@c vertices and counts all motifs in which these vertices are included.
@c (There is also a `cut_prob' parameter which gives the probabilities to
@c cut a branch of the search tree.)

@c    Directed motifs will be counted in directed graphs and undirected
@c motifs in undirected graphs.

@c    *Arguments:. *

@c `graph':
@c      The graph object to study.

@c `est':
@c      Pointer to an integer type, the result will be stored here.

@c `size':
@c      The size of the motif to look for.

@c `cut_prob':
@c      Vector giving the probabilities to cut a branch of the search tree
@c      and omit counting the motifs in that branch.  It contains a
@c      probability for each level. Supply `size' zeros here to count all
@c      the motifs in the sample.

@c `sample_size':
@c      The number of vertices to use as the sample. This parameter is
@c      only used if the `parsample' argument is a null pointer.

@c `parsample':
@c      Either pointer to an initialized vector or a null pointer. If a
@c      vector then the vertex ids in the vector are used as a sample. If
@c      a null pointer then the `sample_size' argument is used to create a
@c      sample of vertices drawn with uniform probability.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_motifs_randesu()' (*note igraph_motifs_randesu --- Count
@c      the number of motifs in a graph::), `igraph_motifs_randesu_no()'
@c      (*note igraph_motifs_randesu_no --- Count the total number of
@c      motifs in a graph::).

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: Generating Layouts for Graph Drawing,  Next: Reading and Writing Graphs from and to Files,  Prev: Graph Motifs; Dyad Census and Triad Census,  Up: Top

@c 14 Generating Layouts for Graph Drawing
@c ***************************************

@c * Menu:

@c * 2D layout generators::
@c * 3D layout generators::
@c * Merging layouts::

@c
@c File: igraph_reference_manual.info,  Node: 2D layout generators,  Next: 3D layout generators,  Up: Generating Layouts for Graph Drawing

@c 14.1 2D layout generators
@c =========================

@c Layout generator functions (or at least most of them) try to place the
@c vertices and edges of a graph on a 2D plane or in 3D space in a way
@c which visually pleases the human eye.

@c    They take a graph object and a number of parameters as arguments and
@c return an `igraph_matrix_t', in which each row gives the coordinates of
@c a vertex.

@c * Menu:

@c * igraph_layout_random --- Places the vertices uniform randomly on a plane.: igraph_layout_random --- Places the vertices uniform randomly on a plane_.
@c * igraph_layout_circle --- Places the vertices uniformly on a circle, in the order of vertex ids.: igraph_layout_circle --- Places the vertices uniformly on a circle; in the order of vertex ids_.
@c * igraph_layout_graphopt --- Optimizes vertex layout via the graphopt algorithm.: igraph_layout_graphopt --- Optimizes vertex layout via the graphopt algorithm_.
@c * The DrL layout generator::
@c * igraph_layout_fruchterman_reingold --- Places the vertices on a plane according to the Fruchterman-Reingold algorithm.: igraph_layout_fruchterman_reingold --- Places the vertices on a plane according to the Fruchterman-Reingold algorithm_.
@c * igraph_layout_kamada_kawai --- Places the vertices on a plane according the Kamada-Kawai algorithm. : igraph_layout_kamada_kawai --- Places the vertices on a plane according the Kamada-Kawai algorithm_.
@c * igraph_layout_reingold_tilford --- Reingold-Tilford layout for tree graphs::
@c * igraph_layout_reingold_tilford_circular --- Circular Reingold-Tilford layout for trees::
@c * igraph_layout_grid_fruchterman_reingold --- Force based layout generator for large graphs.: igraph_layout_grid_fruchterman_reingold --- Force based layout generator for large graphs_.
@c * igraph_layout_lgl --- Force based layout algorithm for large graphs.: igraph_layout_lgl --- Force based layout algorithm for large graphs_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_random --- Places the vertices uniform randomly on a plane_,  Next: igraph_layout_circle --- Places the vertices uniformly on a circle; in the order of vertex ids_,  Up: 2D layout generators

@c 14.1.1 igraph_layout_random -- Places the vertices uniform randomly on a plane.
@c -------------------------------------------------------------------------------


@c      int igraph_layout_random(const igraph_t *graph, igraph_matrix_t *res);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an initialized graph object.

@c `res':
@c      Pointer to an initialized graph object. This will contain the
@c      result and will be resized in needed.

@c    *Returns:. *

@c `'
@c      Error code. The current implementation always returns with success.

@c    Time complexity: O(|V|), the number of vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_circle --- Places the vertices uniformly on a circle; in the order of vertex ids_,  Next: igraph_layout_graphopt --- Optimizes vertex layout via the graphopt algorithm_,  Prev: igraph_layout_random --- Places the vertices uniform randomly on a plane_,  Up: 2D layout generators

@c 14.1.2 igraph_layout_circle -- Places the vertices uniformly on a circle, in the order of vertex ids.
@c -----------------------------------------------------------------------------------------------------


@c      int igraph_layout_circle(const igraph_t *graph, igraph_matrix_t *res);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an initialized graph object.

@c `res':
@c      Pointer to an initialized graph object. This will contain the
@c      result and will be resized in needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|), the number of vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_graphopt --- Optimizes vertex layout via the graphopt algorithm_,  Next: The DrL layout generator,  Prev: igraph_layout_circle --- Places the vertices uniformly on a circle; in the order of vertex ids_,  Up: 2D layout generators

@c 14.1.3 igraph_layout_graphopt -- Optimizes vertex layout via the graphopt algorithm.
@c ------------------------------------------------------------------------------------


@c      int igraph_layout_graphopt(const igraph_t *graph, igraph_matrix_t *res,
@c      			   igraph_integer_t niter,
@c      			   igraph_real_t node_charge, igraph_real_t node_mass,
@c      			   igraph_integer_t spring_length,
@c      			   igraph_real_t spring_constant,
@c      			   igraph_real_t max_sa_movement,
@c      			   igraph_bool_t use_seed);

@c    This is a port of the graphopt layout algorithm by Michael Schmuhl.
@c graphopt version 0.4.1 was rewritten in C and the support for layers
@c was removed (might be added later) and a code was a bit reorganized to
@c avoid some unneccessary steps is the node charge (see below) is zero.

@c    graphopt uses physical analogies for defining attracting and
@c repelling forces among the vertices and then the physical system is
@c simulated until it reaches an equilibrium. (There is no simulated
@c annealing or anything like that, so a stable fixed point is not
@c guaranteed.)

@c    See also http://www.schmuhl.org/graphopt/
@c (http://www.schmuhl.org/graphopt/) for the original graphopt.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an initialized matrix, the result will be stored here
@c      and its initial contents is used the starting point of the
@c      simulation if the `use_seed' argument is true. Note that in this
@c      case the matrix should have the proper size, otherwise a warning
@c      is issued and the supplied values are ignored. If no starting
@c      positions are given (or they are invalid) then a random staring
@c      position is used.  The matrix will be resized if needed.

@c `niter':
@c      Integer constant, the number of iterations to perform.  Should be
@c      a couple of hundred in general. If you have a large graph then you
@c      might want to only do a few iterations and then check the result.
@c      If it is not good enough you can feed it in again in the `res'
@c      argument. The original graphopt default if 500.

@c `node_charge':
@c      The charge of the vertices, used to calculate electric repulsion.
@c      The original graphopt default is 0.001.

@c `node_mass':
@c      The mass of the vertices, used for the spring forces.  The
@c      original graphopt defaults to 30.

@c `spring_length':
@c      The length of the springs, an integer number.  The original
@c      graphopt defaults to zero.

@c `spring_constant':
@c      The spring constant, the original graphopt defaults to one.

@c `max_sa_movement':
@c      Real constant, it gives the maximum amount of movement allowed in
@c      a single step along a single axis. The original graphopt default
@c      is 5.

@c `use_seed':
@c      Logical scalar, whether to use the positions in `res' as a
@c      starting configuration. See also `res' above.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n (|V|^2+|E|) ), n is the number of iterations,
@c |V| is the number of vertices, |E| the number of edges. If
@c `node_charge' is zero then it is only O(n|E|).

@c
@c File: igraph_reference_manual.info,  Node: The DrL layout generator,  Next: igraph_layout_fruchterman_reingold --- Places the vertices on a plane according to the Fruchterman-Reingold algorithm_,  Prev: igraph_layout_graphopt --- Optimizes vertex layout via the graphopt algorithm_,  Up: 2D layout generators

@c 14.1.4 The DrL layout generator
@c -------------------------------

@c DrL is a sophisticated layout generator developed and implemented by
@c Shawn Martin et al., see
@c http://www.cs.sandia.gov/~smartin/software.html
@c (http://www.cs.sandia.gov/~smartin/software.html) for details. Only a
@c subset of the complete DrL functionality is included in igraph,
@c parallel runs and recursive, multi-level layouting is not supported.

@c    The parameters of the layout are stored in an
@c `igraph_layout_drl_options_t' (*note igraph_layout_drl_options_t ---
@c Parameters for the DrL layout generator::) structure, this can be
@c initialized by calling the function `igraph_layout_drl_options_init()'
@c (*note igraph_layout_drl_options_init --- Initialize parameters for the
@c DrL layout generator::).  The fields of this structure can then be
@c adjusted by hand if needed.  The layout is calculated by an
@c `igraph_layout_drl()' (*note igraph_layout_drl --- The DrL layout
@c generator::) call.

@c * Menu:

@c * igraph_layout_drl_options_t --- Parameters for the DrL layout generator::
@c * igraph_layout_drl_default_t --- Predefined parameter templates for the DrL layout generator::
@c * igraph_layout_drl_options_init --- Initialize parameters for the DrL layout generator::
@c * igraph_layout_drl --- The DrL layout generator::
@c * igraph_layout_drl_3d --- The DrL layout generator, 3d version.: igraph_layout_drl_3d --- The DrL layout generator; 3d version_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_drl_options_t --- Parameters for the DrL layout generator,  Next: igraph_layout_drl_default_t --- Predefined parameter templates for the DrL layout generator,  Up: The DrL layout generator

@c 14.1.4.1 igraph_layout_drl_options_t -- Parameters for the DrL layout generator
@c ...............................................................................


@c      typedef struct igraph_layout_drl_options_t {
@c        igraph_real_t    edge_cut;
@c        igraph_integer_t init_iterations;
@c        igraph_real_t    init_temperature;
@c        igraph_real_t    init_attraction;
@c        igraph_real_t    init_damping_mult;
@c        igraph_integer_t liquid_iterations;
@c        igraph_real_t    liquid_temperature;
@c        igraph_real_t    liquid_attraction;
@c        igraph_real_t    liquid_damping_mult;
@c        igraph_integer_t expansion_iterations;
@c        igraph_real_t    expansion_temperature;
@c        igraph_real_t    expansion_attraction;
@c        igraph_real_t    expansion_damping_mult;
@c        igraph_integer_t cooldown_iterations;
@c        igraph_real_t    cooldown_temperature;
@c        igraph_real_t    cooldown_attraction;
@c        igraph_real_t    cooldown_damping_mult;
@c        igraph_integer_t crunch_iterations;
@c        igraph_real_t    crunch_temperature;
@c        igraph_real_t    crunch_attraction;
@c        igraph_real_t    crunch_damping_mult;
@c        igraph_integer_t simmer_iterations;
@c        igraph_real_t    simmer_temperature;
@c        igraph_real_t    simmer_attraction;
@c        igraph_real_t    simmer_damping_mult;
@c      } igraph_layout_drl_options_t;

@c    *Values:. *

@c `edge_cut':
@c      The edge cutting parameter.  Edge cutting is done in the late
@c      stages of the algorithm in order to achieve less dense layouts.
@c      Edges are cut if there is a lot of stress on them (a large value
@c      in the objective function sum).  The edge cutting parameter is a
@c      value between 0 and 1 with 0 representing no edge cutting and 1
@c      representing maximal edge cutting. The default value is 32/40.

@c `init_iterations':
@c      Number of iterations, initial phase.

@c `init_temperature':
@c      Start temperature, initial phase.

@c `init_attraction':
@c      Attraction, initial phase.

@c `init_damping_mult':
@c      Damping factor, initial phase.

@c `liquid_iterations':
@c      Number of iterations in the liquid phase.

@c `liquid_temperature':
@c      Start temperature in the liquid phase.

@c `liquid_attraction':
@c      Attraction in the liquid phase.

@c `liquid_damping_mult':
@c      Multiplicatie damping factor, liquid phase.

@c `expansion_iterations':
@c      Number of iterations in the expansion phase.

@c `expansion_temperature':
@c      Start temperature in the expansion phase.

@c `expansion_attraction':
@c      Attraction, expansion phase.

@c `expansion_damping_mult':
@c      Damping factor, expansion phase.

@c `cooldown_iterations':
@c      Number of iterations in the cooldown phase.

@c `cooldown_temperature':
@c      Start temperature in the cooldown phase.

@c `cooldown_attraction':
@c      Attraction in the cooldown phase.

@c `cooldown_damping_mult':
@c      Damping fact int the cooldown phase.

@c `crunch_iterations':
@c      Number of iterations in the crunch phase.

@c `crunch_temperature':
@c      Start temperature in the crunch phase.

@c `crunch_attraction':
@c      Attraction in the crunch phase.

@c `crunch_damping_mult':
@c      Damping factor in the crunch phase.

@c `simmer_iterations':
@c      Number of iterations in the simmer phase.

@c `simmer_temperature':
@c      Start temperature in te simmer phase.

@c `simmer_attraction':
@c      Attraction in the simmer phase.

@c `simmer_damping_mult':
@c      Multiplicative damping factor in the simmer phase.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_drl_default_t --- Predefined parameter templates for the DrL layout generator,  Next: igraph_layout_drl_options_init --- Initialize parameters for the DrL layout generator,  Prev: igraph_layout_drl_options_t --- Parameters for the DrL layout generator,  Up: The DrL layout generator

@c 14.1.4.2 igraph_layout_drl_default_t -- Predefined parameter templates for the DrL layout generator
@c ...................................................................................................


@c      typedef enum { IGRAPH_LAYOUT_DRL_DEFAULT=0,
@c      	       IGRAPH_LAYOUT_DRL_COARSEN,
@c      	       IGRAPH_LAYOUT_DRL_COARSEST,
@c      	       IGRAPH_LAYOUT_DRL_REFINE,
@c      	       IGRAPH_LAYOUT_DRL_FINAL } igraph_layout_drl_default_t;

@c    These constants can be used to initialize a set of DrL parameters.
@c These can then be modified according to the user's needs.

@c    *Values:. *

@c `IGRAPH_LAYOUT_DRL_DEFAULT':
@c      The deafult parameters.

@c `IGRAPH_LAYOUT_DRL_COARSEN':
@c      Slightly modified parameters to get a coarser layout.

@c `IGRAPH_LAYOUT_DRL_COARSEST':
@c      An even coarser layout.

@c `IGRAPH_LAYOUT_DRL_REFINE':
@c      Refine an already calculated layout.

@c `IGRAPH_LAYOUT_DRL_FINAL':
@c      Finalize an already refined layout.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_drl_options_init --- Initialize parameters for the DrL layout generator,  Next: igraph_layout_drl --- The DrL layout generator,  Prev: igraph_layout_drl_default_t --- Predefined parameter templates for the DrL layout generator,  Up: The DrL layout generator

@c 14.1.4.3 igraph_layout_drl_options_init -- Initialize parameters for the DrL layout generator
@c .............................................................................................


@c      int igraph_layout_drl_options_init(igraph_layout_drl_options_t *options,
@c      				   igraph_layout_drl_default_t templ);

@c    This function can be used to initialize the struct holding the
@c parameters for the DrL layout generator. There are a number of
@c predefined templates available, it is a good idea to start from one of
@c these by modifying some parameters.

@c    *Arguments:. *

@c `options':
@c      The struct to initialize.

@c `templ':
@c      The template to use. Currently the following templates are
@c      supplied: `IGRAPH_LAYOUT_DRL_DEFAULT',
@c      `IGRAPH_LAYOUT_DRL_COARSEN', `IGRAPH_LAYOUT_DRL_COARSEST',
@c      `IGRAPH_LAYOUT_DRL_REFINE' and `IGRAPH_LAYOUT_DRL_FINAL'.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_drl --- The DrL layout generator,  Next: igraph_layout_drl_3d --- The DrL layout generator; 3d version_,  Prev: igraph_layout_drl_options_init --- Initialize parameters for the DrL layout generator,  Up: The DrL layout generator

@c 14.1.4.4 igraph_layout_drl -- The DrL layout generator
@c ......................................................


@c      int igraph_layout_drl(const igraph_t *graph, igraph_matrix_t *res,
@c      		      igraph_bool_t use_seed,
@c      		      igraph_layout_drl_options_t *options,
@c      		      const igraph_vector_t *weights,
@c      		      const igraph_vector_bool_t *fixed);

@c    This function implements the force-directed DrL layout generator.
@c Please see more at http://www.cs.sandia.gov/~smartin/software.html
@c (http://www.cs.sandia.gov/~smartin/software.html)

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `use_seed':
@c      Logical scalar, if true, then the coordinates supplied in the
@c      `res' argument are used as starting points.

@c `res':
@c      Pointer to a matrix, the result layout is stored here. It will be
@c      resized as needed.

@c `options':
@c      The parameters to pass to the layout generator.

@c `weights':
@c      Edge weights, pointer to a vector. If this is a null pointer then
@c      every edge will have the same weight.

@c `fixed':
@c      Pointer to a logical vector, or a null pointer. This can be used
@c      to fix the position of some vertices. Vertices for which it is
@c      true will not be moved, but stay at the coordinates given in the
@c      `res' matrix. This argument is ignored if it is a null pointer or
@c      if use_seed is false.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: ???.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_drl_3d --- The DrL layout generator; 3d version_,  Prev: igraph_layout_drl --- The DrL layout generator,  Up: The DrL layout generator

@c 14.1.4.5 igraph_layout_drl_3d -- The DrL layout generator, 3d version.
@c ......................................................................


@c      int igraph_layout_drl_3d(const igraph_t *graph, igraph_matrix_t *res,
@c      			 igraph_bool_t use_seed,
@c      			 igraph_layout_drl_options_t *options,
@c      			 const igraph_vector_t *weights,
@c      			 const igraph_vector_bool_t *fixed);

@c    This function implements the force-directed DrL layout generator.
@c Please see more at http://www.cs.sandia.gov/~smartin/software.html
@c (http://www.cs.sandia.gov/~smartin/software.html)

@c    This function uses a modified DrL generator that does the layout in
@c three dimensions.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `use_seed':
@c      Logical scalar, if true, then the coordinates supplied in the
@c      `res' argument are used as starting points.

@c `res':
@c      Pointer to a matrix, the result layout is stored here. It will be
@c      resized as needed.

@c `options':
@c      The parameters to pass to the layout generator.

@c `weights':
@c      Edge weights, pointer to a vector. If this is a null pointer then
@c      every edge will have the same weight.

@c `fixed':
@c      Pointer to a logical vector, or a null pointer. This can be used
@c      to fix the position of some vertices. Vertices for which it is
@c      true will not be moved, but stay at the coordinates given in the
@c      `res' matrix. This argument is ignored if it is a null pointer or
@c      if use_seed is false.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: ???.

@c    *See also:. *

@c `'
@c      `igraph_layout_drl()' (*note igraph_layout_drl --- The DrL layout
@c      generator::) for the standard 2d version.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_fruchterman_reingold --- Places the vertices on a plane according to the Fruchterman-Reingold algorithm_,  Next: igraph_layout_kamada_kawai --- Places the vertices on a plane according the Kamada-Kawai algorithm_,  Prev: The DrL layout generator,  Up: 2D layout generators

@c 14.1.5 igraph_layout_fruchterman_reingold -- Places the vertices on a plane according to the Fruchterman-Reingold algorithm.
@c ----------------------------------------------------------------------------------------------------------------------------


@c      int igraph_layout_fruchterman_reingold(const igraph_t *graph, igraph_matrix_t *res,
@c      				       igraph_integer_t niter, igraph_real_t maxdelta,
@c      				       igraph_real_t area, igraph_real_t coolexp,
@c      				       igraph_real_t repulserad, igraph_bool_t use_seed,
@c      				       const igraph_vector_t *weight);

@c    This is a force-directed layout, see Fruchterman, T.M.J. and
@c Reingold, E.M.: Graph Drawing by Force-directed Placement.  Software -
@c Practice and Experience, 21/11, 1129-1164, 1991.  This function was
@c ported from the SNA R package.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an initialized graph object.

@c `res':
@c      Pointer to an initialized matrix object. This will contain the
@c      result and will be resized in needed.

@c `niter':
@c      The number of iterations to do.

@c `maxdelta':
@c      The maximum distance to move a vertex in an iteration.

@c `area':
@c      The area parameter of the algorithm.

@c `coolexp':
@c      The cooling exponent of the simulated annealing.

@c `repulserad':
@c      Determines the radius at which vertex-vertex repulsion cancels out
@c      attraction of adjacent vertices.

@c `use_seed':
@c      Logical, if true the supplied values in the `res' argument are
@c      used as an initial layout, if false a random initial layout is
@c      used.

@c `weight':
@c      Pointer to a vector containing edge weights, the attraction along
@c      the edges will be multiplied by these.  It will be ignored if it
@c      is a null-pointer.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^2) in each iteration, |V| is the number of
@c vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_kamada_kawai --- Places the vertices on a plane according the Kamada-Kawai algorithm_,  Next: igraph_layout_reingold_tilford --- Reingold-Tilford layout for tree graphs,  Prev: igraph_layout_fruchterman_reingold --- Places the vertices on a plane according to the Fruchterman-Reingold algorithm_,  Up: 2D layout generators

@c 14.1.6 igraph_layout_kamada_kawai -- Places the vertices on a plane according the Kamada-Kawai algorithm.
@c ---------------------------------------------------------------------------------------------------------


@c      int igraph_layout_kamada_kawai(const igraph_t *graph, igraph_matrix_t *res,
@c      			       igraph_integer_t niter, igraph_real_t sigma,
@c      			       igraph_real_t initemp, igraph_real_t coolexp,
@c      			       igraph_real_t kkconst, igraph_bool_t use_seed);

@c    This is a force directed layout, see  Kamada, T. and Kawai, S.: An
@c Algorithm for Drawing General Undirected Graphs. Information Processing
@c Letters, 31/1, 7-15, 1989.  This function was ported from the SNA R
@c package.

@c    *Arguments:. *

@c `graph':
@c      A graph object.

@c `res':
@c      Pointer to an initialized matrix object. This will contain the
@c      result and will be resized if needed.

@c `niter':
@c      The number of iterations to perform.

@c `sigma':
@c      Sets the base standard deviation of position change proposals.

@c `initemp':
@c      Sets the initial temperature for the annealing.

@c `coolexp':
@c      The cooling exponent of the annealing.

@c `kkconst':
@c      The Kamada-Kawai vertex attraction constant.

@c `use_seed':
@c      Boolean, whether to use the values cupplied in the `res' argument
@c      as the initial configuration. If zero then a random initial
@c      configuration is used.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^2) for each iteration, |V| is the number of
@c vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_reingold_tilford --- Reingold-Tilford layout for tree graphs,  Next: igraph_layout_reingold_tilford_circular --- Circular Reingold-Tilford layout for trees,  Prev: igraph_layout_kamada_kawai --- Places the vertices on a plane according the Kamada-Kawai algorithm_,  Up: 2D layout generators

@c 14.1.7 igraph_layout_reingold_tilford -- Reingold-Tilford layout for tree graphs
@c --------------------------------------------------------------------------------


@c      int igraph_layout_reingold_tilford(const igraph_t *graph,
@c      				   igraph_matrix_t *res, long int root);

@c    Arranges the nodes in a tree where the given node is used as the
@c root.  The tree is directed downwards and the parents are centered
@c above its children. For the exact algorithm, see:

@c    Reingold, E and Tilford, J: Tidier drawing of trees.  IEEE Trans.
@c Softw. Eng., SE-7(2):223-228, 1981

@c    If the given graph is not a tree, a breadth-first search is executed
@c first to obtain a possible spanning tree.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result, the coordinates in a matrix. The parameter should
@c      point to an initialized matrix object and will be resized.

@c `root':
@c      The index of the root vertex.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2.

@c    TODO: decompose and merge for not fully connected graphs TODO:
@c possible speedup could be achieved if we use a table for storing the
@c children of each node in the tree. (Now the implementation uses a
@c single array containing the parent of each node and a node's children
@c are determined by looking for other nodes that have this node as parent)

@c    *See also:. *

@c `'
@c      `igraph_layout_reingold_tilford_circular()' (*note
@c      igraph_layout_reingold_tilford_circular --- Circular
@c      Reingold-Tilford layout for trees::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_reingold_tilford_circular --- Circular Reingold-Tilford layout for trees,  Next: igraph_layout_grid_fruchterman_reingold --- Force based layout generator for large graphs_,  Prev: igraph_layout_reingold_tilford --- Reingold-Tilford layout for tree graphs,  Up: 2D layout generators

@c 14.1.8 igraph_layout_reingold_tilford_circular -- Circular Reingold-Tilford layout for trees
@c --------------------------------------------------------------------------------------------


@c      int igraph_layout_reingold_tilford_circular(const igraph_t *graph,
@c      					    igraph_matrix_t *res, long int root);

@c    This layout is almost the same as `igraph_layout_reingold_tilford()'
@c (*note igraph_layout_reingold_tilford --- Reingold-Tilford layout for
@c tree graphs::), but the tree is drawn in a circular way, with the root
@c vertex in the center.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result, the coordinates in a matrix. The parameter should
@c      point to an initialized matrix object and will be resized.

@c `root':
@c      The index of the root vertex.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_layout_reingold_tilford()' (*note
@c      igraph_layout_reingold_tilford --- Reingold-Tilford layout for
@c      tree graphs::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_grid_fruchterman_reingold --- Force based layout generator for large graphs_,  Next: igraph_layout_lgl --- Force based layout algorithm for large graphs_,  Prev: igraph_layout_reingold_tilford_circular --- Circular Reingold-Tilford layout for trees,  Up: 2D layout generators

@c 14.1.9 igraph_layout_grid_fruchterman_reingold -- Force based layout generator for large graphs.
@c ------------------------------------------------------------------------------------------------


@c      int igraph_layout_grid_fruchterman_reingold(const igraph_t *graph,
@c      					    igraph_matrix_t *res,
@c      					    igraph_integer_t niter, igraph_real_t maxdelta,
@c      					    igraph_real_t area, igraph_real_t coolexp,
@c      					    igraph_real_t repulserad,
@c      					    igraph_real_t cellsize,
@c      					    igraph_bool_t use_seed);

@c    This algorithm is the same as the Fruchterman-Reingold layout
@c generator, but it partitions the 2d space to a grid and and vertex
@c repulsion is calculated only for vertices nearby.

@c    *Arguments:. *

@c `graph':
@c      The graph object.

@c `res':
@c      The result, the coordinates in a matrix. The parameter should
@c      point to an initialized matrix object and will be resized.

@c `niter':
@c      Number of iterations to perform.

@c `maxdelta':
@c      Maximum distance to move a vertex in an iteration.

@c `area':
@c      The area of the square on which the vertices will be placed.

@c `coolexp':
@c      The cooling exponent.

@c `repulserad':
@c      Determines the radius at which vertex-vertex repulsion cancels out
@c      attraction of adjacenct vertices.

@c `cellsize':
@c      The size of the grid cells.

@c `use_seed':
@c      Logical, if true, the coordinates passed in `res' (should have the
@c      appropriate size) will be used for the first iteration.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2.

@c    Time complexity: ideally (constant number of vertices in each cell)
@c O(niter*(|V|+|E|)), in the worst case O(niter*(|V|^2+|E|)).

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_lgl --- Force based layout algorithm for large graphs_,  Prev: igraph_layout_grid_fruchterman_reingold --- Force based layout generator for large graphs_,  Up: 2D layout generators

@c 14.1.10 igraph_layout_lgl -- Force based layout algorithm for large graphs.
@c ---------------------------------------------------------------------------


@c      int igraph_layout_lgl(const igraph_t *graph, igraph_matrix_t *res,
@c      		      igraph_integer_t maxit, igraph_real_t maxdelta,
@c      		      igraph_real_t area, igraph_real_t coolexp,
@c      		      igraph_real_t repulserad, igraph_real_t cellsize,
@c      		      igraph_integer_t proot);

@c    This is a layout generator similar to the Large Graph Layout
@c algorithm and program (http://bioinformatics.icmb.utexas.edu/lgl/
@c (http://bioinformatics.icmb.utexas.edu/lgl/)). But unlike LGL, this
@c version uses a Fruchterman-Reingold style simulated annealing algorithm
@c for placing the vertices. The speedup is achived by placing the
@c vertices on a grid and calculating the repulsion only for vertices
@c which are closer to each other than a limit.

@c    *Arguments:. *

@c `graph':
@c      The (initialized) graph object to place.

@c `res':
@c      Pointer to an initialized matrix object to hold the result. It
@c      will be resized if needed.

@c `maxit':
@c      The maximum number of cooling iterations to perform for each
@c      layout step.

@c `maxdelta':
@c      The maximum length of the move allowed for a vertex in a single
@c      iteration.

@c `area':
@c      This parameter gives the area of the square on which the vertices
@c      will be placed.

@c `coolexp':
@c      The cooling exponent.

@c `repulserad':
@c      Determines the radius at which vertex-vertex repulsion cancels out
@c      attraction of adjacenct vertices.

@c `cellsize':
@c      The size of the grid cells, one side of the square.

@c `proot':
@c      The root vertex, this is placed first, its neighbors in the first
@c      iteration, second neighbors in the second, etc. If negative then a
@c      random vertex is chosen.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2.

@c    Time complexity: ideally O(dia*maxit*(|V|+|E|)), |V| is the number
@c of vertices, dia is the diameter of the graph, worst case complexity is
@c still O(dia*maxit*(|V|^2+|E|)), this is the case when all vertices
@c happen to be in the same grid cell.

@c
@c File: igraph_reference_manual.info,  Node: 3D layout generators,  Next: Merging layouts,  Prev: 2D layout generators,  Up: Generating Layouts for Graph Drawing

@c 14.2 3D layout generators
@c =========================

@c * Menu:

@c * igraph_layout_random_3d --- Random layout in 3D::
@c * igraph_layout_sphere --- Places vertices (more or less) uniformly on a sphere.: igraph_layout_sphere --- Places vertices [more or less] uniformly on a sphere_.
@c * igraph_layout_fruchterman_reingold_3d --- 3D Fruchterman-Reingold algorithm.: igraph_layout_fruchterman_reingold_3d --- 3D Fruchterman-Reingold algorithm_.
@c * igraph_layout_kamada_kawai_3d --- 3D version of the force based Kamada-Kawai layout.: igraph_layout_kamada_kawai_3d --- 3D version of the force based Kamada-Kawai layout_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_random_3d --- Random layout in 3D,  Next: igraph_layout_sphere --- Places vertices [more or less] uniformly on a sphere_,  Up: 3D layout generators

@c 14.2.1 igraph_layout_random_3d -- Random layout in 3D
@c -----------------------------------------------------


@c      int igraph_layout_random_3d(const igraph_t *graph, igraph_matrix_t *res);

@c    *Arguments:. *

@c `graph':
@c      The graph to place.

@c `res':
@c      Pointer to an initialized matrix object. It will be resized to
@c      hold the result.

@c    *Returns:. *

@c `'
@c      Error code. The current implementation always returns with success.

@c    Added in version 0.2.

@c    Time complexity: O(|V|), the number of vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_sphere --- Places vertices [more or less] uniformly on a sphere_,  Next: igraph_layout_fruchterman_reingold_3d --- 3D Fruchterman-Reingold algorithm_,  Prev: igraph_layout_random_3d --- Random layout in 3D,  Up: 3D layout generators

@c 14.2.2 igraph_layout_sphere -- Places vertices (more or less) uniformly on a sphere.
@c ------------------------------------------------------------------------------------


@c      int igraph_layout_sphere(const igraph_t *graph, igraph_matrix_t *res);

@c    The algorithm was described in the following paper: Distributing
@c many points on a sphere by E.B. Saff and A.B.J. Kuijlaars, _
@c Mathematical Intelligencer _ 19.1 (1997) 5-11.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an initialized graph object.

@c `res':
@c      Pointer to an initialized matrix object, the will be stored here.
@c      It will be resized.

@c    *Returns:. *

@c `'
@c      Error code. The current implementation always returns with success.

@c    Added in version 0.2.

@c    Time complexity: O(|V|), the number of vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_fruchterman_reingold_3d --- 3D Fruchterman-Reingold algorithm_,  Next: igraph_layout_kamada_kawai_3d --- 3D version of the force based Kamada-Kawai layout_,  Prev: igraph_layout_sphere --- Places vertices [more or less] uniformly on a sphere_,  Up: 3D layout generators

@c 14.2.3 igraph_layout_fruchterman_reingold_3d -- 3D Fruchterman-Reingold algorithm.
@c ----------------------------------------------------------------------------------


@c      int igraph_layout_fruchterman_reingold_3d(const igraph_t *graph,
@c      					  igraph_matrix_t *res,
@c      					  igraph_integer_t niter, igraph_real_t maxdelta,
@c      					  igraph_real_t volume, igraph_real_t coolexp,
@c      					  igraph_real_t repulserad,
@c      					  igraph_bool_t use_seed,
@c      					  const igraph_vector_t *weight);

@c    This is the 3D version of the force based Fruchterman-Reingold
@c layout (see `igraph_layout_fruchterman_reingold' (*note
@c igraph_layout_fruchterman_reingold --- Places the vertices on a plane
@c according to the Fruchterman-Reingold algorithm_::) for the 2D version

@c    This function was ported from the SNA R package.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an initialized graph object.

@c `res':
@c      Pointer to an initialized matrix object. This will contain the
@c      result and will be resized in needed.

@c `niter':
@c      The number of iterations to do.

@c `maxdelta':
@c      The maximum distance to move a vertex in an iteration.

@c `volume':
@c      The volume parameter of the algorithm.

@c `coolexp':
@c      The cooling exponent of the simulated annealing.

@c `repulserad':
@c      Determines the radius at which vertex-vertex repulsion cancels out
@c      attraction of adjacent vertices.

@c `use_seed':
@c      Logical, if true the supplied values in the `res' argument are
@c      used as an initial layout, if false a random initial layout is
@c      used.

@c `weight':
@c      Pointer to a vector containing edge weights, the attraction along
@c      the edges will be multiplied by these.  It will be ignored if it
@c      is a null-pointer.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2.

@c    Time complexity: O(|V|^2) in each iteration, |V| is the number of
@c vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_kamada_kawai_3d --- 3D version of the force based Kamada-Kawai layout_,  Prev: igraph_layout_fruchterman_reingold_3d --- 3D Fruchterman-Reingold algorithm_,  Up: 3D layout generators

@c 14.2.4 igraph_layout_kamada_kawai_3d -- 3D version of the force based Kamada-Kawai layout.
@c ------------------------------------------------------------------------------------------


@c      int igraph_layout_kamada_kawai_3d(const igraph_t *graph, igraph_matrix_t *res,
@c      				  igraph_integer_t niter, igraph_real_t sigma,
@c      				  igraph_real_t initemp, igraph_real_t coolexp,
@c      				  igraph_real_t kkconst, igraph_bool_t use_seed);

@c    The pair of the `igraph_layout_kamada_kawai' (*note
@c igraph_layout_kamada_kawai --- Places the vertices on a plane according
@c the Kamada-Kawai algorithm_::) 2D layout generator

@c    This function was ported from the SNA R package.

@c    *Arguments:. *

@c `graph':
@c      A graph object.

@c `res':
@c      Pointer to an initialized matrix object. This will contain the
@c      result and will be resized if needed.

@c `niter':
@c      The number of iterations to perform.

@c `sigma':
@c      Sets the base standard deviation of position change proposals.

@c `initemp':
@c      Sets the initial temperature for the annealing.

@c `coolexp':
@c      The cooling exponent of the annealing.

@c `kkconst':
@c      The Kamada-Kawai vertex attraction constant.

@c `use_seed':
@c      Boolean, whether to use the values cupplied in the `res' argument
@c      as the initial configuration. If zero then a random initial
@c      configuration is used.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2.

@c    Time complexity: O(|V|^2) for each iteration, |V| is the number of
@c vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: Merging layouts,  Prev: 3D layout generators,  Up: Generating Layouts for Graph Drawing

@c 14.3 Merging layouts
@c ====================

@c * Menu:

@c * igraph_layout_merge_dla --- Merge multiple layouts by using a DLA algorithm::

@c
@c File: igraph_reference_manual.info,  Node: igraph_layout_merge_dla --- Merge multiple layouts by using a DLA algorithm,  Up: Merging layouts

@c 14.3.1 igraph_layout_merge_dla -- Merge multiple layouts by using a DLA algorithm
@c ---------------------------------------------------------------------------------


@c      int igraph_layout_merge_dla(igraph_vector_ptr_t *thegraphs,
@c      			    igraph_vector_ptr_t *coords,
@c      			    igraph_matrix_t *res);

@c    First each layout is covered by a circle. Then the layout of the
@c largest graph is placed at the origin. Then the other layouts are
@c placed by the DLA algorithm, larger ones first and smaller ones last.

@c    *Arguments:. *

@c `thegraphs':
@c      Pointer vector containing the graph object of which the layouts
@c      will be merged.

@c `coords':
@c      Pointer vector containing matrix objects with the 2d layouts of
@c      the graphs in `thegraphs'.

@c `res':
@c      Pointer to an initialized matrix object, the result will be stored
@c      here. It will be resized if needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Added in version 0.2. This function is experimental.

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: Reading and Writing Graphs from and to Files,  Next: Maximum Flows; Minimum Cuts and related measures,  Prev: Generating Layouts for Graph Drawing,  Up: Top

@c 15 Reading and Writing Graphs from and to Files
@c ***********************************************

@c These functions can write a graph to a file, or read a graph from a
@c file.

@c    Note that as `igraph' uses the traditional C streams, it is possible
@c to read/write files from/to memory, at least on GNU operating systems
@c supporting `non-standard' streams.

@c * Menu:

@c * Simple edge list and similar formats::
@c * Binary formats::
@c * GraphML format::
@c * GML format::
@c * Pajek format::
@c * Graphviz format::

@c
@c File: igraph_reference_manual.info,  Node: Simple edge list and similar formats,  Next: Binary formats,  Up: Reading and Writing Graphs from and to Files

@c 15.1 Simple edge list and similar formats
@c =========================================

@c * Menu:

@c * igraph_read_graph_edgelist --- Reads an edge list from a file and creates a graph.: igraph_read_graph_edgelist --- Reads an edge list from a file and creates a graph_.
@c * igraph_write_graph_edgelist --- Writes the edge list of a graph to a file.: igraph_write_graph_edgelist --- Writes the edge list of a graph to a file_.
@c * igraph_read_graph_ncol --- Reads a .ncol file used by LGL.: igraph_read_graph_ncol --- Reads a _ncol file used by LGL_.
@c * igraph_write_graph_ncol --- Writes the graph to a file in .ncol format: igraph_write_graph_ncol --- Writes the graph to a file in _ncol format.
@c * igraph_read_graph_lgl --- Reads a graph from an .lgl file: igraph_read_graph_lgl --- Reads a graph from an _lgl file.
@c * igraph_write_graph_lgl --- Writes the graph to a file in .lgl format: igraph_write_graph_lgl --- Writes the graph to a file in _lgl format.
@c * igraph_read_graph_dimacs --- Read a graph in DIMACS format.: igraph_read_graph_dimacs --- Read a graph in DIMACS format_.
@c * igraph_write_graph_dimacs --- Write a graph in DIMACS format.: igraph_write_graph_dimacs --- Write a graph in DIMACS format_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_edgelist --- Reads an edge list from a file and creates a graph_,  Next: igraph_write_graph_edgelist --- Writes the edge list of a graph to a file_,  Up: Simple edge list and similar formats

@c 15.1.1 igraph_read_graph_edgelist -- Reads an edge list from a file and creates a graph.
@c ----------------------------------------------------------------------------------------


@c      int igraph_read_graph_edgelist(igraph_t *graph, FILE *instream,
@c      			       igraph_integer_t n, igraph_bool_t directed);

@c    This format is simply a series of even number integers separated by
@c whitespace. The one edge (ie. two integers) per line format is thus not
@c required (but recommended for readability). Edges of directed graphs
@c are assumed to be in from, to order.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `instream':
@c      Pointer to a stream, it should be readable.

@c `n':
@c      The number of vertices in the graph. If smaller than the largest
@c      integer in the file it will be ignored. It is thus safe to supply
@c      zero here.

@c `directed':
@c      Logical, if true the graph is directed, if false it will be
@c      undirected.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_PARSEERROR': if there is a problem reading the
@c      file, or the file is syntactically incorrect.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges. It is assumed that reading an integer requires O(1) time.

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_edgelist --- Writes the edge list of a graph to a file_,  Next: igraph_read_graph_ncol --- Reads a _ncol file used by LGL_,  Prev: igraph_read_graph_edgelist --- Reads an edge list from a file and creates a graph_,  Up: Simple edge list and similar formats

@c 15.1.2 igraph_write_graph_edgelist -- Writes the edge list of a graph to a file.
@c --------------------------------------------------------------------------------


@c      int igraph_write_graph_edgelist(const igraph_t *graph, FILE *outstream);

@c    One edge is written per line, separated by a single space.  For
@c directed graphs edges are written in from, to order.

@c    *Arguments:. *

@c `graph':
@c      The graph object to write.

@c `outstream':
@c      Pointer to a stream, it should be writable.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EFILE' if there is an error writing the file.

@c    Time complexity: O(|E|), the number of edges in the  graph. It is
@c assumed that writing an integer to the file requires O(1) time.

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_ncol --- Reads a _ncol file used by LGL_,  Next: igraph_write_graph_ncol --- Writes the graph to a file in _ncol format,  Prev: igraph_write_graph_edgelist --- Writes the edge list of a graph to a file_,  Up: Simple edge list and similar formats

@c 15.1.3 igraph_read_graph_ncol -- Reads a .ncol file used by LGL.
@c ----------------------------------------------------------------


@c      int igraph_read_graph_ncol(igraph_t *graph, FILE *instream,
@c      			   igraph_strvector_t *predefnames,
@c      			   igraph_bool_t names, igraph_bool_t weights, igraph_bool_t directed);

@c    Also useful for creating graphs from `named' (and optionally
@c weighted) edge lists.

@c    This format is used by the Large Graph Layout program
@c (http://bioinformatics.icmb.utexas.edu/lgl/
@c (http://bioinformatics.icmb.utexas.edu/lgl/)), and it is simply a
@c symbolic weighted edge list. It is a simple text file with one edge per
@c line. An edge is defined by two symbolic vertex names separated by
@c whitespace. (The symbolic vertex names themselves cannot contain
@c whitespace. They might follow by an optional number, this will be the
@c weight of the edge; the number can be negative and can be in scientific
@c notation. If there is no weight specified to an edge it is assumed to
@c be zero.

@c    The resulting graph is always undirected.  LGL cannot deal with
@c files which contain multiple or loop edges, this is however not checked
@c here, as `igraph' is happy with these.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `instream':
@c      Pointer to a stream, it should be readable.

@c `predefnames':
@c      Pointer to the symbolic names of the vertices in the file. If
@c      `NULL' is given here then vertex ids will be assigned to vertex
@c      names in the order of their appearence in the \c .ncol file. If it
@c      is not `NULL' and some unknown vertex names are found in the \c
@c      .ncol file then new vertex ids will be assigned to them.

@c `names':
@c      Logical value, if TRUE the symbolic names of the vertices will be
@c      added to the graph as a vertex attribute called `name'.

@c `weights':
@c      Logical value, if TRUE the weights of the edges is added to the
@c      graph as an edge attribute called `weight'.

@c `directed':
@c      Whether to create a directed graph. As this format was originally
@c      used only for undirected graphs there is no information in the
@c      file about the directedness of the graph.  Set this parameter to
@c      `IGRAPH_DIRECTED' or `IGRAPH_UNDIRECTED' to create a directed or
@c      undirected graph.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_PARSEERROR': if there is a problem reading the
@c      file, or the file is syntactically incorrect.

@c    Time complexity: O(|V|+|E|log(|V|)) if we neglect the time required
@c by the parsing. As usual |V| is the number of vertices, while |E| is
@c the number of edges.

@c    *See also:. *

@c `'
@c      `igraph_read_graph_lgl()' (*note igraph_read_graph_lgl --- Reads a
@c      graph from an _lgl file::), `igraph_write_graph_ncol()' (*note
@c      igraph_write_graph_ncol --- Writes the graph to a file in _ncol
@c      format::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_ncol --- Writes the graph to a file in _ncol format,  Next: igraph_read_graph_lgl --- Reads a graph from an _lgl file,  Prev: igraph_read_graph_ncol --- Reads a _ncol file used by LGL_,  Up: Simple edge list and similar formats

@c 15.1.4 igraph_write_graph_ncol -- Writes the graph to a file in .ncol format
@c ----------------------------------------------------------------------------


@c      int igraph_write_graph_ncol(const igraph_t *graph, FILE *outstream,
@c      			    const char *names, const char *weights);

@c    ` .ncol'  is a format used by LGL, see `igraph_read_graph_ncol()'
@c (*note igraph_read_graph_ncol --- Reads a _ncol file used by LGL_::)
@c for details.

@c    Note that having multiple or loop edges in an ` .ncol'  file breaks
@c the  LGL software but `igraph' does not check for this condition.

@c    *Arguments:. *

@c `graph':
@c      The graph to write.

@c `outstream':
@c      The stream object to write to, it should be writable.

@c `names':
@c      The name of the vertex attribute, if symbolic names are written to
@c      the file. If not, supply 0 here.

@c `weights':
@c      The name of the edge attribute, if they are also written to the
@c      file. If you don't want weights, supply 0 here.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EFILE' if there is an error writing the file.

@c    Time complexity: O(|E|), the number of edges. All file operations
@c are expected to have time complexity O(1).

@c    *See also:. *

@c `'
@c      `igraph_read_graph_ncol()' (*note igraph_read_graph_ncol --- Reads
@c      a _ncol file used by LGL_::), `igraph_write_graph_lgl()' (*note
@c      igraph_write_graph_lgl --- Writes the graph to a file in _lgl
@c      format::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_lgl --- Reads a graph from an _lgl file,  Next: igraph_write_graph_lgl --- Writes the graph to a file in _lgl format,  Prev: igraph_write_graph_ncol --- Writes the graph to a file in _ncol format,  Up: Simple edge list and similar formats

@c 15.1.5 igraph_read_graph_lgl -- Reads a graph from an .lgl file
@c ---------------------------------------------------------------


@c      int igraph_read_graph_lgl(igraph_t *graph, FILE *instream,
@c      			  igraph_bool_t names, igraph_bool_t weights);

@c    The ` .lgl'  format is used by the Large Graph Layout visualization
@c software (http://bioinformatics.icmb.utexas.edu/lgl/
@c (http://bioinformatics.icmb.utexas.edu/lgl/)), it can describe
@c undirected optionally weighted graphs. From the LGL manual:

@c      The second format is the LGL file format (` .lgl'  file suffix).
@c      This is yet another graph file format that tries to be as stingy
@c      as possible with space, yet keeping the edge file in a human
@c      readable (not binary) format. The format itself is like the
@c      following:

@c            # vertex1name
@c           vertex2name [optionalWeight]
@c           vertex3name [optionalWeight]

@c      Here, the first vertex of an edge is preceded with a pound sign
@c      '#'.  Then each vertex that shares an edge with that vertex is
@c      listed one per line on subsequent lines.

@c    LGL cannot handle loop and multiple edges or directed graphs, but in
@c `igraph' it is not an error to have multiple and loop edges.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `instream':
@c      A stream, it should be readable.

@c `names':
@c      Logical value, if TRUE the symbolic names of the vertices will be
@c      added to the graph as a vertex attribute called `name'.

@c `weights':
@c      Logical value, if TRUE the weights of the edges is added to the
@c      graph as an edge attribute called `weight'.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_PARSEERROR': if there is a problem reading the
@c      file, or the file is syntactically incorrect.

@c    Time complexity: O(|V|+|E|log(|V|)) if we neglect the time required
@c by the parsing. As usual |V| is the number of vertices, while |E| is
@c the number of edges.

@c    *See also:. *

@c `'
@c      `igraph_read_graph_ncol()' (*note igraph_read_graph_ncol --- Reads
@c      a _ncol file used by LGL_::), `igraph_write_graph_lgl()' (*note
@c      igraph_write_graph_lgl --- Writes the graph to a file in _lgl
@c      format::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_lgl --- Writes the graph to a file in _lgl format,  Next: igraph_read_graph_dimacs --- Read a graph in DIMACS format_,  Prev: igraph_read_graph_lgl --- Reads a graph from an _lgl file,  Up: Simple edge list and similar formats

@c 15.1.6 igraph_write_graph_lgl -- Writes the graph to a file in .lgl format
@c --------------------------------------------------------------------------


@c      int igraph_write_graph_lgl(const igraph_t *graph, FILE *outstream,
@c      			   const char *names, const char *weights,
@c      			   igraph_bool_t isolates);

@c    ` .lgl'  is a format used by LGL, see `igraph_read_graph_lgl()'
@c (*note igraph_read_graph_lgl --- Reads a graph from an _lgl file::) for
@c details.

@c    Note that having multiple or loop edges in an ` .lgl'  file breaks
@c the  LGL software but `igraph' does not check for this condition.

@c    *Arguments:. *

@c `graph':
@c      The graph to write.

@c `outstream':
@c      The stream object to write to, it should be writable.

@c `names':
@c      The name of the vertex attribute, if symbolic names are written to
@c      the file. If not supply 0 here.

@c `weights':
@c      The name of the edge attribute, if they are also written to the
@c      file. If you don't want weights supply 0 here.

@c `isolates':
@c      Logical, if TRUE isolated vertices are also written to the file.
@c      If FALSE they will be omitted.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EFILE' if there is an error writing the file.

@c    Time complexity: O(|E|), the number of edges if `isolates' is FALSE,
@c O(|V|+|E|) otherwise. All file operations are expected to have time
@c complexity O(1).

@c    *See also:. *

@c `'
@c      `igraph_read_graph_ncol()' (*note igraph_read_graph_ncol --- Reads
@c      a _ncol file used by LGL_::), `igraph_write_graph_lgl()' (*note
@c      igraph_write_graph_lgl --- Writes the graph to a file in _lgl
@c      format::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_dimacs --- Read a graph in DIMACS format_,  Next: igraph_write_graph_dimacs --- Write a graph in DIMACS format_,  Prev: igraph_write_graph_lgl --- Writes the graph to a file in _lgl format,  Up: Simple edge list and similar formats

@c 15.1.7 igraph_read_graph_dimacs -- Read a graph in DIMACS format.
@c -----------------------------------------------------------------


@c      int igraph_read_graph_dimacs(igraph_t *graph, FILE *instream,
@c      			     igraph_strvector_t *problem,
@c      			     igraph_vector_t *label,
@c      			     igraph_integer_t *source,
@c      			     igraph_integer_t *target,
@c      			     igraph_vector_t *capacity,
@c      			     igraph_bool_t directed);

@c    This function reads the DIMACS file format, more specifically the
@c version for network flow problems, see the files at
@c ftp://dimacs.rutgers.edu/pub/netflow/general-info/

@c    This is a line-oriented text file (ASCII) format. The first
@c character of each line defines the type of the line. If the first
@c character is ` c'  the line is a comment line and it is ignored. There
@c is one problem line (` p'  in the file, it must appear before any node
@c and arc descriptor lines. The problem line has three fields separated
@c by spaces: the problem type (` min' , ` max'  or ` asn' ), the number
@c of vertices and number of edges in the graph.  Exactly two node
@c identification lines are expected (` n' ), one for the source, one for
@c the target vertex.  These have two fields: the id of the vertex and the
@c type of the vertex, either ` s'  (=source) or ` t' (=target). Arc lines
@c start with ` a'  and have three fields: the source vertex, the target
@c vertex and the edge capacity.

@c    Vertex ids are numbered from 1.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `instream':
@c      The file to read from.

@c `source':
@c      Pointer to an integer, the id of the source node will be stored
@c      here. (The igraph vertex id, which is one less than the actual
@c      number in the file.) It is ignored if ` NULL' .

@c `target':
@c      Pointer to an integer, the (igraph) id of the target node will be
@c      stored here. It is ignored if ` NULL' .

@c `capacity':
@c      Pointer to an initialized vector, the capacity of the edges will
@c      be stored here if not ` NULL' .

@c `directed':
@c      Boolean, whether to create a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|+c), the number of vertices plus the
@c number of edges, plus the size of the file in characters.

@c    *See also:. *

@c `'
@c      `igraph_write_graph_dimacs()' (*note igraph_write_graph_dimacs ---
@c      Write a graph in DIMACS format_::)

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_dimacs --- Write a graph in DIMACS format_,  Prev: igraph_read_graph_dimacs --- Read a graph in DIMACS format_,  Up: Simple edge list and similar formats

@c 15.1.8 igraph_write_graph_dimacs -- Write a graph in DIMACS format.
@c -------------------------------------------------------------------


@c      int igraph_write_graph_dimacs(const igraph_t *graph, FILE *outstream,
@c      			      long int source, long int target,
@c      			      const igraph_vector_t *capacity);

@c    This function writes a graph to an output stream in DIMACS format,
@c describing a maximum flow problem.  See
@c ftp://dimacs.rutgers.edu/pub/netflow/general-info/

@c    This file format is discussed in the documentation of
@c `igraph_read_graph_dimacs()' (*note igraph_read_graph_dimacs --- Read a
@c graph in DIMACS format_::), see that for more information.

@c    *Arguments:. *

@c `graph':
@c      The graph to write to the stream.

@c `outstream':
@c      The stream.

@c `source':
@c      Integer, the id of the source vertex for the maximum flow.

@c `target':
@c      Integer, the id of the target vertex.

@c `capacity':
@c      Pointer to an initialized vector containing the edge capacity
@c      values.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|E|), the number of edges in the graph.

@c    *See also:. *

@c `'
@c      igraph_read_graph_dimacs()

@c
@c File: igraph_reference_manual.info,  Node: Binary formats,  Next: GraphML format,  Prev: Simple edge list and similar formats,  Up: Reading and Writing Graphs from and to Files

@c 15.2 Binary formats
@c ===================

@c * Menu:

@c * igraph_read_graph_graphdb --- Read a graph in the binary graph database format.: igraph_read_graph_graphdb --- Read a graph in the binary graph database format_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_graphdb --- Read a graph in the binary graph database format_,  Up: Binary formats

@c 15.2.1 igraph_read_graph_graphdb -- Read a graph in the binary graph database format.
@c -------------------------------------------------------------------------------------


@c      int igraph_read_graph_graphdb(igraph_t *graph, FILE *instream,
@c      			      igraph_bool_t directed);

@c    This is a binary format, used in the graph database for isomorphism
@c testing (http://amalfi.dis.unina.it/graph/
@c (http://amalfi.dis.unina.it/graph/)) From the graph database homepage
@c (http://amalfi.dis.unina.it/graph/db/doc/graphdbat-2.html
@c (http://amalfi.dis.unina.it/graph/db/doc/graphdbat-2.html)):

@c      The graphs are stored in a compact binary format, one graph per
@c      file. The file is composed of 16 bit words, which are represented
@c      using the so-called little-endian convention, i.e. the least
@c      significant byte of the word is stored first.

@c      Then, for each node, the file contains the list of edges coming
@c      out of the node itself. The list is represented by a word encoding
@c      its length, followed by a word for each edge, representing the
@c      destination node of the edge. Node numeration is 0-based, so the
@c      first node of the graph has index 0.

@c    Only unlabelled graphs are implemented.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `instream':
@c      The stream to read from.

@c `directed':
@c      Logical scalar, whether to create a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: GraphML format,  Next: GML format,  Prev: Binary formats,  Up: Reading and Writing Graphs from and to Files

@c 15.3 GraphML format
@c ===================

@c * Menu:

@c * igraph_read_graph_graphml --- Reads a graph from a GraphML file.: igraph_read_graph_graphml --- Reads a graph from a GraphML file_.
@c * igraph_write_graph_graphml --- Writes the graph to a file in GraphML format::

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_graphml --- Reads a graph from a GraphML file_,  Next: igraph_write_graph_graphml --- Writes the graph to a file in GraphML format,  Up: GraphML format

@c 15.3.1 igraph_read_graph_graphml -- Reads a graph from a GraphML file.
@c ----------------------------------------------------------------------


@c      int igraph_read_graph_graphml(igraph_t *graph, FILE *instream,
@c      			      int index);

@c    GraphML is an XML-based file format for representing various types of
@c graphs. Currently only the most basic import functionality is
@c implemented in igraph: it can read GraphML files without nested graphs
@c and hyperedges.  Attributes of the graph are loaded only if an
@c attribute interface is attached, ie. if you use igraph from R or Python.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `instream':
@c      A stream, it should be readable.

@c `index':
@c      If the GraphML file contains more than one graph, the one
@c      specified by this index will be loaded. Indices start from zero,
@c      so supply zero here if your GraphML file contains only a single
@c      graph.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_PARSEERROR': if there is a problem reading the
@c      file, or the file is syntactically incorrect.
@c      `IGRAPH_UNIMPLEMENTED': the GraphML functionality was disabled at
@c      compile-time

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_graphml --- Writes the graph to a file in GraphML format,  Prev: igraph_read_graph_graphml --- Reads a graph from a GraphML file_,  Up: GraphML format

@c 15.3.2 igraph_write_graph_graphml -- Writes the graph to a file in GraphML format
@c ---------------------------------------------------------------------------------


@c      int igraph_write_graph_graphml(const igraph_t *graph, FILE *outstream);

@c    GraphML is an XML-based file format for representing various types of
@c graphs. See the GraphML Primer
@c (http://graphml.graphdrawing.org/primer/graphml-primer.html
@c (http://graphml.graphdrawing.org/primer/graphml-primer.html)) for
@c detailed format description.

@c    *Arguments:. *

@c `graph':
@c      The graph to write.

@c `outstream':
@c      The stream object to write to, it should be writable.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_EFILE' if there is an error writing the file.

@c    Time complexity: O(|V|+|E|) otherwise. All file operations are
@c expected to have time complexity O(1).

@c
@c File: igraph_reference_manual.info,  Node: GML format,  Next: Pajek format,  Prev: GraphML format,  Up: Reading and Writing Graphs from and to Files

@c 15.4 GML format
@c ===============

@c * Menu:

@c * igraph_read_graph_gml --- Read a graph in GML format.: igraph_read_graph_gml --- Read a graph in GML format_.
@c * igraph_write_graph_gml --- Write the graph to a stream in GML format : igraph_write_graph_gml --- Write the graph to a stream in GML format.

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_gml --- Read a graph in GML format_,  Next: igraph_write_graph_gml --- Write the graph to a stream in GML format,  Up: GML format

@c 15.4.1 igraph_read_graph_gml -- Read a graph in GML format.
@c -----------------------------------------------------------


@c      int igraph_read_graph_gml(igraph_t *graph, FILE *instream);

@c    GML is a simple textual format, see
@c http://www.infosun.fim.uni-passau.de/Graphlet/GML/
@c (http://www.infosun.fim.uni-passau.de/Graphlet/GML/) for details.

@c    Although all syntactically correct GML can be parsed, we implement
@c only a subset of this format, some attributes might be ignored. Here is
@c a list of all the differences:

@c   1. Only ` node'  and ` edge'  attributes are used, and only if they
@c      have a simple type: integer, real or string. So if an attribute is
@c      an array or a record, then it is ignored. This is also true if
@c      only some values of the attribute are complex.

@c   2. Top level attributes except for ` Version'  and the first ` graph'
@c      attribute are completely ignored.

@c   3. Graph attributes except for ` node'  and ` edge'  are completely
@c      ignored.

@c   4. There is no maximum line length.

@c   5. There is no maximum keyword length.

@c   6. Character entities in strings are not interpreted.

@c   7. We allow ` inf'  (infinity) and ` nan' (not a number) as a real
@c      number. This is case insensitive, so ` nan' , ` NaN'  and ` NAN'
@c      are equal.

@c    Please contact us if you cannot live with these limitations of the
@c GML parser.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `instream':
@c      The stream to read the GML file from.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: should be proportional to the length of the file.

@c    *See also:. *

@c `'
@c      `igraph_read_graph_graphml()' (*note igraph_read_graph_graphml ---
@c      Reads a graph from a GraphML file_::) for a more modern format,
@c      `igraph_write_graph_gml()' (*note igraph_write_graph_gml --- Write
@c      the graph to a stream in GML format::) for writing GML files.

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_gml --- Write the graph to a stream in GML format,  Prev: igraph_read_graph_gml --- Read a graph in GML format_,  Up: GML format

@c 15.4.2 igraph_write_graph_gml -- Write the graph to a stream in GML format
@c --------------------------------------------------------------------------


@c      int igraph_write_graph_gml(const igraph_t *graph, FILE *outstream,
@c      			   const igraph_vector_t *id, const char *creator);

@c    GML is a quite general textual format, see
@c http://www.infosun.fim.uni-passau.de/Graphlet/GML/
@c (http://www.infosun.fim.uni-passau.de/Graphlet/GML/) for details.

@c    The graph, vertex and edges attributes are written to the file as
@c well, if they are numeric of string.

@c    As igraph is more forgiving about attribute names, it might be
@c neccessary to simplify the them before writing to the GML file.  This
@c way we'll have a syntactically correct GML file. The following simple
@c procedure is performed on each attribute name: first the alphanumeric
@c characters are extracted, the others are ignored. Then if the first
@c character is not a letter then the attribute name is prefixed with
@c `igraph'.  Note that this might result identical names for two
@c attributes, igraph does not check this.

@c    The `id' vertex attribute is treated specially.  If the `id'
@c argument is not 0 then it should be a numeric vector with the vertex
@c ids and the `id' vertex attribute is ignored (if there is one). If `id'
@c is 0 and there is a numeric `id' vertex attribute that is used instead.
@c If ids are not specified in either way then the regular igraph vertex
@c ids are used.

@c    Note that whichever way vertex ids are specified, their uniqueness
@c is not checked.

@c    If the graph has edge attributes named `source' or `target' they're
@c silently ignored. GML uses these attributes to specify the edges, so we
@c cannot write them to the file. Rename them before calling this function
@c if you want to preserve them.

@c    *Arguments:. *

@c `graph':
@c      The graph to write to the stream.

@c `outstream':
@c      The stream to write the file to.

@c `id':
@c      Either ` NULL'  or a numeric vector with the vertex ids.  See
@c      details above.

@c `creator':
@c      An optional string to write to the stream in the creator line.  If
@c      this is 0 then the current date and time is added.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: should be proportional to the number of characters
@c written to the file.

@c    *See also:. *

@c `'
@c      `igraph_read_graph_gml()' (*note igraph_read_graph_gml --- Read a
@c      graph in GML format_::) for reading GML files,
@c      `igraph_read_graph_graphml()' (*note igraph_read_graph_graphml ---
@c      Reads a graph from a GraphML file_::) for a more modern format.

@c
@c File: igraph_reference_manual.info,  Node: Pajek format,  Next: Graphviz format,  Prev: GML format,  Up: Reading and Writing Graphs from and to Files

@c 15.5 Pajek format
@c =================

@c * Menu:

@c * igraph_read_graph_pajek --- Reads a file in Pajek format::
@c * igraph_write_graph_pajek --- Writes a graph to a file in Pajek format.: igraph_write_graph_pajek --- Writes a graph to a file in Pajek format_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_read_graph_pajek --- Reads a file in Pajek format,  Next: igraph_write_graph_pajek --- Writes a graph to a file in Pajek format_,  Up: Pajek format

@c 15.5.1 igraph_read_graph_pajek -- Reads a file in Pajek format
@c --------------------------------------------------------------


@c      int igraph_read_graph_pajek(igraph_t *graph, FILE *instream);

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `file':
@c      An already opened file handler.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Only a subset of the Pajek format is implemented. This is partially
@c because this format is not very well documented, but also because
@c `igraph' does not support some Pajek features, like multigraphs.

@c    The list of the current limitations:

@c   1. Only `.net' files are supported, Pajek project files (`.paj') are
@c      not. These might be supported in the future if there is need for
@c      it.

@c   2. Time events networks are not supported.

@c   3. Hypergraphs (ie. graphs with non-binary edges) are not supported.

@c   4. Graphs with both directed and non-directed edges are not
@c      supported, are they cannot be represented in `igraph'.

@c   5. Bipartite or affiliation networks are not supported. They can be
@c      imported but the vertex type information is omitted.

@c   6. Only Pajek networks are supported, permutations, hierarchies,
@c      clusters and vectors are not.

@c   7. Graphs with multiple edge sets are not supported.

@c    If there are attribute handlers installed, `igraph' also reads the
@c vertex and edge attributes from the file. Most attributes are renamed
@c to be more informative: ``color'' instead of ``c'', ``xfact'' instead
@c of ``x_fact'', ``yfact'' instead of `y_fact', ``labeldist'' instead of
@c ``lr'', ``labeldegree2'' instead of ``lphi'', ``framewidth'' instead of
@c ``bw'', ``fontsize'' instead of ``fos'', ``rotation'' instead of
@c ``phi'', ``radius'' instead of ``r'', ``diamondratio'' instead of
@c ``q'', ``labeldegree'' instead of ``la'', ``vertexsize'' instead of
@c ``size'', ``color'' instead of ``ic'', ``framecolor'' instead of
@c ``bc'', ``labelcolor'' instead of ``lc'', these belong to vertices.

@c    Edge attributes are also renamed, ``s'' to ``arrowsize'', ``w'' to
@c ``edgewidth'', ``h1'' to ``hook1'', ``h2'' to ``hook2'', ``a1'' to
@c ``angle1'', ``a2'' to ``angle2'', ``k1'' to ``velocity1'', ``k2'' to
@c ``velocity2'', ``ap'' to ``arrowpos'', ``lp'' to ``labelpos'', ``lr'' to
@c ``labelangle'', ``lphi'' to ``labelangle2'', ``la'' to ``labeldegree'',
@c ``fos'' to ``fontsize'', ``a'' to ``arrowtype'', ``p'' to
@c ``linepattern'', ``l'' to ``label'', ``lc'' to ``labelcolor'', ``c'' to
@c ``color''.

@c    In addition the following vertex attributes might be added: ``id''
@c if there are vertex ids in the file, ``x'' and ``y'' or ``x'' and ``y''
@c and ``z'' if there are vertex coordinates in the file, ``color-red'',
@c ``color-green'' and ``color-blue'' if the vertex color is given in RGB
@c notation, ``framecolor-red'', ``framecolor-green'' and
@c ``framecolor-blue'` if the frame color is given in RGB notation and
@c finally ``labelcolor-red'', ``labelcolor-green'' and
@c ``labelcolor-blue'' if the label color is given in RGB notation.

@c    The following additional edge attributes might be added: ``weight''
@c if there are edge weights present, ``color-red'', ``color-green'' and
@c ``color-blue'' if the edge color is given in RGB notation.

@c    See the pajek homepage:
@c http://vlado.fmf.uni-lj.si/pub/networks/pajek/
@c (http://vlado.fmf.uni-lj.si/pub/networks/pajek/) for more info on Pajek
@c and the Pajek manual:
@c http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/pajekman.pdf
@c (http://vlado.fmf.uni-lj.si/pub/networks/pajek/doc/pajekman.pdf) for
@c information on the Pajek file format.

@c    Time complexity: O(|V|+|E|+|A|), |V| is the number of vertices, |E|
@c the number of edges, |A| the number of attributes (vertex + edge) in
@c the graph if there are attribute handlers installed.

@c    *See also:. *

@c `'
@c      `igraph_write_graph_pajek()' (*note igraph_write_graph_pajek ---
@c      Writes a graph to a file in Pajek format_::) for writing Pajek
@c      files, `igraph_read_graph_graphml()' (*note
@c      igraph_read_graph_graphml --- Reads a graph from a GraphML
@c      file_::) for reading GraphML files.

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_pajek --- Writes a graph to a file in Pajek format_,  Prev: igraph_read_graph_pajek --- Reads a file in Pajek format,  Up: Pajek format

@c 15.5.2 igraph_write_graph_pajek -- Writes a graph to a file in Pajek format.
@c ----------------------------------------------------------------------------


@c      int igraph_write_graph_pajek(const igraph_t *graph, FILE *outstream);

@c    The Pajek vertex and edge parameters (like color) are determined by
@c the attributes of the vertices and edges, of course this requires an
@c attribute handler to be installed. The names of the corresponding
@c vertex and edge attributes are listed at `igraph_read_graph_pajek()'
@c (*note igraph_read_graph_pajek --- Reads a file in Pajek format::), eg.
@c the ``color'' vertex attributes determines the color (``c'' in Pajek)
@c parameter.

@c    *Arguments:. *

@c `graph':
@c      The graph object to write.

@c `outstream':
@c      The file to write to. It should be opened and writable. Make sure
@c      that you open the file in binary format if you use MS Windows,
@c      otherwise end of line characters will be messed up. (igraph will
@c      be able to read back these messed up files, but Pajek won't.)

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|+|A|), |V| is the number of vertices, |E|
@c is the number of edges, |A| the number of attributes (vertex + edge) in
@c the graph if there are attribute handlers installed.

@c    *See also:. *

@c `'
@c      `igraph_read_graph_pajek()' (*note igraph_read_graph_pajek ---
@c      Reads a file in Pajek format::) for reading Pajek graphs,
@c      `igraph_write_graph_graphml()' (*note igraph_write_graph_graphml
@c      --- Writes the graph to a file in GraphML format::) for writing a
@c      graph in GraphML format, this suites `igraph' graphs better.

@c
@c File: igraph_reference_manual.info,  Node: Graphviz format,  Prev: Pajek format,  Up: Reading and Writing Graphs from and to Files

@c 15.6 Graphviz format
@c ====================

@c * Menu:

@c * igraph_write_graph_dot --- Write the graph to a stream in DOT format::

@c
@c File: igraph_reference_manual.info,  Node: igraph_write_graph_dot --- Write the graph to a stream in DOT format,  Up: Graphviz format

@c 15.6.1 igraph_write_graph_dot -- Write the graph to a stream in DOT format
@c --------------------------------------------------------------------------


@c      int igraph_write_graph_dot(const igraph_t *graph, FILE* outstream);

@c    DOT is the format used by the widely known GraphViz software, see
@c http://www.graphviz.org (http://www.graphviz.org) for details. The
@c grammar of the DOT format can be found here:
@c http://www.graphviz.org/doc/info/lang.html
@c (http://www.graphviz.org/doc/info/lang.html)

@c    This is only a preliminary implementation, only the vertices and the
@c edges are written but not the attributes or any visualization
@c information.

@c    *Arguments:. *

@c `graph':
@c      The graph to write to the stream.

@c `outstream':
@c      The stream to write the file to.

@c    Time complexity: should be proportional to the number of characters
@c written to the file.

@c    *See also:. *

@c `'
@c      `igraph_write_graph_graphml()' (*note igraph_write_graph_graphml
@c      --- Writes the graph to a file in GraphML format::) for a more
@c      modern format.

@c
@c File: igraph_reference_manual.info,  Node: Maximum Flows; Minimum Cuts and related measures,  Next: Detecting Community Structure,  Prev: Reading and Writing Graphs from and to Files,  Up: Top

@c 16 Maximum Flows, Minimum Cuts and related measures
@c ***************************************************

@c * Menu:

@c * Maximum Flows::
@c * Minimum cuts::
@c * Connectivity::
@c * Edge- and Vertex-Disjoint Paths::
@c * Graph Adhesion and Cohesion::

@c
@c File: igraph_reference_manual.info,  Node: Maximum Flows,  Next: Minimum cuts,  Up: Maximum Flows; Minimum Cuts and related measures

@c 16.1 Maximum Flows
@c ==================

@c * Menu:

@c * igraph_maxflow_value --- Maximum flow in a network with the push/relabel algorithm::

@c
@c File: igraph_reference_manual.info,  Node: igraph_maxflow_value --- Maximum flow in a network with the push/relabel algorithm,  Up: Maximum Flows

@c 16.1.1 igraph_maxflow_value -- Maximum flow in a network with the push/relabel algorithm
@c ----------------------------------------------------------------------------------------


@c      int igraph_maxflow_value(const igraph_t *graph, igraph_real_t *value,
@c      			 igraph_integer_t source, igraph_integer_t target,
@c      			 const igraph_vector_t *capacity);

@c    This function implements the Goldberg-Tarjan algorithm for
@c calculating value of the maximum flow in a directed or undirected
@c graph. The algorithm was given in Andrew V. Goldberg, Robert E. Tarjan:
@c A New Approach to the Maximum-Flow Problem, Journal of the ACM, 35(4),
@c 921-940, 1988.

@c    The input of the function is a graph, a vector of real numbers
@c giving the capacity of the edges and two vertices of the graph, the
@c source and the target. A flow is a function assigning positive real
@c numbers to the edges and satisfying two requirements: (1) the flow
@c value is less than the capacity of the edge and (2) at each vertex
@c except the source and the target, the incoming flow (ie. the sum of the
@c flow on the incoming edges) is the same as the outgoing flow (ie. the
@c sum of the flow on the outgoing edges). The value of the flow is the
@c incoming flow at the target vertex. The maximum flow is the flow with
@c the maximum value.

@c    This function can only calculate the value of the maximum flow, but
@c not the flow itself (may be added later).

@c    According to a theorem by Ford and Furkelson (L. R. Ford Jr. and D.
@c R. Fulkerson. Maximal flow through a network. Canadian J. Math.,
@c 8:399-404, 1956.) the maximum flow between two vertices is the same as
@c the minimum cut between them (also called the minimum s-t cut). So
@c `igraph_st_mincut_value()' (*note igraph_st_mincut_value --- The
@c minimum s-t cut in a graph::) gives the same result in all cases as
@c `igraph_maxflow_value'().

@c    Note that the value of the maximum flow is the same as the minimum
@c cut in the graph.

@c    *Arguments:. *

@c `graph':
@c      The input graph, either directed or undirected.

@c `value':
@c      Pointer to a real number, the result will be placed here.

@c `source':
@c      The id of the source vertex.

@c `target':
@c      The id of the target vertex.

@c `capacity':
@c      Vector containing the capacity of the edges. If NULL, then every
@c      edge is considered to have capacity 1.0.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^3). In practice it is much faster, but i
@c cannot prove a better lower bound for the data structure i've used. In
@c fact, this implementation runs much faster than the `hi_pr'
@c implementation discussed in B. V. Cherkassky and A. V. Goldberg: On
@c implementing the push-relabel method for the maximum flow problem,
@c (Algorithmica, 19:390-410, 1997) on all the graph classes i've tried.

@c    *See also:. *

@c `'
@c      `igraph_mincut_value()' (*note igraph_mincut_value --- The minimum
@c      edge cut in a graph::), `igraph_edge_connectivity()' (*note
@c      igraph_edge_connectivity --- The minimum edge connectivity in a
@c      graph_::), `igraph_vertex_connectivity()' (*note
@c      igraph_vertex_connectivity --- The vertex connectivity of a
@c      graph::) for properties based on the maximum flow.

@c
@c File: igraph_reference_manual.info,  Node: Minimum cuts,  Next: Connectivity,  Prev: Maximum Flows,  Up: Maximum Flows; Minimum Cuts and related measures

@c 16.2 Minimum cuts
@c =================

@c * Menu:

@c * igraph_st_mincut_value --- The minimum s-t cut in a graph::
@c * igraph_mincut_value --- The minimum edge cut in a graph::
@c * igraph_mincut --- Calculates the minimum cut in a graph.: igraph_mincut --- Calculates the minimum cut in a graph_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_st_mincut_value --- The minimum s-t cut in a graph,  Next: igraph_mincut_value --- The minimum edge cut in a graph,  Up: Minimum cuts

@c 16.2.1 igraph_st_mincut_value -- The minimum s-t cut in a graph
@c ---------------------------------------------------------------


@c      int igraph_st_mincut_value(const igraph_t *graph, igraph_real_t *value,
@c      			   igraph_integer_t source, igraph_integer_t target,
@c      			   const igraph_vector_t *capacity);

@c    The minimum s-t cut in a weighted (=valued) graph is the total
@c minimum edge weight needed to remove from the graph to eliminate all
@c paths from a given vertex (`source') to another vertex (`target').
@c Directed paths are considered in directed graphs, and undirected paths
@c in undirected graphs.

@c    The minimum s-t cut between two vertices is known to be same as the
@c maximum flow between these two vertices. So this function calls
@c `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum flow
@c in a network with the push/relabel algorithm::) to do the calculation.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `value':
@c      Pointer to a real variable, the result will be stored here.

@c `source':
@c      The id of the source vertex.

@c `target':
@c      The id of the target vertex.

@c `capacity':
@c      Pointer to the capacity vector, it should contain non-negative
@c      numbers and its length should be the same the the number of edges
@c      in the graph. It can be a null pointer, then every edge has unit
@c      capacity.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^3), see also the discussion for
@c `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum flow
@c in a network with the push/relabel algorithm::), |V| is the number of
@c vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_mincut_value --- The minimum edge cut in a graph,  Next: igraph_mincut --- Calculates the minimum cut in a graph_,  Prev: igraph_st_mincut_value --- The minimum s-t cut in a graph,  Up: Minimum cuts

@c 16.2.2 igraph_mincut_value -- The minimum edge cut in a graph
@c -------------------------------------------------------------


@c      int igraph_mincut_value(const igraph_t *graph, igraph_real_t *res,
@c      			const igraph_vector_t *capacity);

@c    The minimum edge cut in a graph is the total minimum weight of the
@c edges needed to remove from the graph to make the graph _not_ strongly
@c connected. (If the original graph is not strongly connected then this
@c is zero.) Note that in undirected graphs strong connectedness is the
@c same as weak connectedness.

@c    The minimum cut can be calculated with maximum flow techniques,
@c although the current implementation does this only for directed graphs
@c and a separate non-flow based implementation is used for undirected
@c graphs. See Mechthild Stoer and Frank Wagner: A simple min-cut
@c algorithm, Journal of the ACM 44 585-591, 1997.  For directed graphs
@c the maximum flow is calculated between a fixed vertex and all the other
@c vertices in the graph and this is done in both directions. Then the
@c minimum is taken to get the minimum cut.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a real variable, the result will be stored here.

@c `capacity':
@c      Pointer to the capacity vector, it should contain the same number
@c      of non-negative numbers as the number of edges in the graph. If a
@c      null pointer then all edges will have unit capacity.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_mincut()' (*note igraph_mincut --- Calculates the minimum
@c      cut in a graph_::), `igraph_maxflow_value()' (*note
@c      igraph_maxflow_value --- Maximum flow in a network with the
@c      push/relabel algorithm::), `igraph_st_mincut_value()' (*note
@c      igraph_st_mincut_value --- The minimum s-t cut in a graph::).

@c    Time complexity: O(log(|V|)*|V|^2) for undirected graphs and
@c O(|V|^4) for directed graphs, but see also the discussion at the
@c documentation of `igraph_maxflow_value()' (*note igraph_maxflow_value
@c --- Maximum flow in a network with the push/relabel algorithm::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_mincut --- Calculates the minimum cut in a graph_,  Prev: igraph_mincut_value --- The minimum edge cut in a graph,  Up: Minimum cuts

@c 16.2.3 igraph_mincut -- Calculates the minimum cut in a graph.
@c --------------------------------------------------------------


@c      int igraph_mincut(const igraph_t *graph,
@c      		  igraph_real_t *value,
@c      		  igraph_vector_t *partition,
@c      		  igraph_vector_t *partition2,
@c      		  igraph_vector_t *cut,
@c      		  const igraph_vector_t *capacity);

@c    This function calculates the minimum cut in a graph. Right now it is
@c implemented only for undirected graphs, in which case it uses the
@c Stoer-Wagner algorithm, as described in M. Stoer and F. Wagner: A
@c simple min-cut algorithm, Journal of the ACM, 44 585-591, 1997.

@c    The minimum cut is the mimimum set of edges which needs to be
@c removed to disconnect the graph. The minimum is calculated using the
@c weigths (`capacity') of the edges, so the cut with the minimum total
@c capacity is calculated.

@c    The first implementation of the actual cut calculation was made by
@c Gregory Benison, thanks Greg.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `value':
@c      Pointer to an integer, the value of the cut will be stored here.

@c `partition':
@c      Pointer to an initialized vector, the ids of the vertices in the
@c      first partition after separating the graph will be stored here.
@c      The vector will be resized as needed. This argument is ignored if
@c      it is a NULL pointer.

@c `partition2':
@c      Pointer to an initialized vector the ids of the vertices in the
@c      second partition will be stored here.  The vector will be resized
@c      as needed. This argument is ignored if it is a NULL pointer.

@c `cut':
@c      Pointer to an initialized vector, the ids of the edges in the cut
@c      will be stored here. This argument is ignored if it is a NULL
@c      pointer.

@c `capacity':
@c      A numeric vector giving the capacities of the edges. If a null
@c      pointer then all edges have unit capacity.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_mincut_value()' (*note igraph_mincut_value --- The minimum
@c      edge cut in a graph::), a simpler interface for calculating the
@c      value of the cut only.

@c    Time complexity: for undirected graphs it is O(|V|E|+|V|^2 log|V|),
@c |V| and |E| are the number of vertices and edges respectively.

@c
@c File: igraph_reference_manual.info,  Node: Connectivity,  Next: Edge- and Vertex-Disjoint Paths,  Prev: Minimum cuts,  Up: Maximum Flows; Minimum Cuts and related measures

@c 16.3 Connectivity
@c =================

@c * Menu:

@c * igraph_st_edge_connectivity --- Edge connectivity of a pair of vertices::
@c * igraph_edge_connectivity --- The minimum edge connectivity in a graph.: igraph_edge_connectivity --- The minimum edge connectivity in a graph_.
@c * igraph_st_vertex_connectivity --- The vertex connectivity of a pair of vertices::
@c * igraph_vertex_connectivity --- The vertex connectivity of a graph::

@c
@c File: igraph_reference_manual.info,  Node: igraph_st_edge_connectivity --- Edge connectivity of a pair of vertices,  Next: igraph_edge_connectivity --- The minimum edge connectivity in a graph_,  Up: Connectivity

@c 16.3.1 igraph_st_edge_connectivity -- Edge connectivity of a pair of vertices
@c -----------------------------------------------------------------------------


@c      int igraph_st_edge_connectivity(const igraph_t *graph, igraph_integer_t *res,
@c      				igraph_integer_t source,
@c      				igraph_integer_t target);

@c    The edge connectivity of two vertices (`source' and `target') in a
@c graph is the minimum number of edges that have to be deleted from the
@c graph to eliminate all paths from `source' to `target'.

@c    This function uses the maximum flow algorithm to calculate the edge
@c connectivity.

@c    *Arguments:. *

@c `graph':
@c      The input graph, it has to be directed.

@c `res':
@c      Pointer to an integer, the result will be stored here.

@c `source':
@c      The id of the source vertex.

@c `target':
@c      The id of the target vertex.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^3).

@c    *See also:. *

@c `'
@c      `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum
@c      flow in a network with the push/relabel algorithm::),
@c      `igraph_edge_connectivity()' (*note igraph_edge_connectivity ---
@c      The minimum edge connectivity in a graph_::),
@c      `igraph_st_vertex_connectivity()' (*note
@c      igraph_st_vertex_connectivity --- The vertex connectivity of a
@c      pair of vertices::), `igraph_vertex_connectivity()' (*note
@c      igraph_vertex_connectivity --- The vertex connectivity of a
@c      graph::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_edge_connectivity --- The minimum edge connectivity in a graph_,  Next: igraph_st_vertex_connectivity --- The vertex connectivity of a pair of vertices,  Prev: igraph_st_edge_connectivity --- Edge connectivity of a pair of vertices,  Up: Connectivity

@c 16.3.2 igraph_edge_connectivity -- The minimum edge connectivity in a graph.
@c ----------------------------------------------------------------------------


@c      int igraph_edge_connectivity(const igraph_t *graph, igraph_integer_t *res,
@c      			     igraph_bool_t checks);

@c    This is the minimum of the edge connectivity over all pairs of
@c vertices in the graph.

@c    The edge connectivity of a graph is the same as group adhesion as
@c defined in Douglas R. White and Frank Harary: The cohesiveness of
@c blocks in social networks: node connectivity and conditional density,
@c Sociological Methodology 31:305-359, 2001.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an integer, the result will be stored here.

@c `checks':
@c      Logical constant. Whether to check that the graph is connected and
@c      also the degree of the vertices. If the graph is not (strongly)
@c      connected then the connectivity is obviously zero. Otherwise if
@c      the minimum degree is one then the edge connectivity is also one.
@c      It is a good idea to perform these checks, as they can be done
@c      quickly compared to the connectivity calculation itself.  They
@c      were suggested by Peter McMahan, thanks Peter.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(log(|V|)*|V|^2) for undirected graphs and
@c O(|V|^4) for directed graphs, but see also the discussion at the
@c documentation of `igraph_maxflow_value()' (*note igraph_maxflow_value
@c --- Maximum flow in a network with the push/relabel algorithm::).

@c    *See also:. *

@c `'
@c      `igraph_st_edge_connectivity()' (*note igraph_st_edge_connectivity
@c      --- Edge connectivity of a pair of vertices::),
@c      `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum
@c      flow in a network with the push/relabel algorithm::),
@c      `igraph_vertex_connectivity()' (*note igraph_vertex_connectivity
@c      --- The vertex connectivity of a graph::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_st_vertex_connectivity --- The vertex connectivity of a pair of vertices,  Next: igraph_vertex_connectivity --- The vertex connectivity of a graph,  Prev: igraph_edge_connectivity --- The minimum edge connectivity in a graph_,  Up: Connectivity

@c 16.3.3 igraph_st_vertex_connectivity -- The vertex connectivity of a pair of vertices
@c -------------------------------------------------------------------------------------


@c      int igraph_st_vertex_connectivity(const igraph_t *graph,
@c      				  igraph_integer_t *res,
@c      				  igraph_integer_t source,
@c      				  igraph_integer_t target,
@c      				  igraph_vconn_nei_t neighbors);

@c    The vertex connectivity of two vertices (`source' and `target') is
@c the minimum number of vertices that have to be deleted to eliminate all
@c paths from `source' to `target'. Directed paths are considered in
@c directed graphs.

@c    The vertex connectivity of a pair is the same as the number of
@c different (ie. node-independent) paths from source to target.

@c    The current implementation uses maximum flow calculations to obtain
@c the result.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an integer, the result will be stored here.

@c `source':
@c      The id of the source vertex.

@c `target':
@c      The id of the target vertex.

@c `neighbors':
@c      A constant giving what to do if the two vertices are connected.
@c      Possible values: `IGRAPH_VCONN_NEI_ERROR', stop with an error
@c      message, `IGRAPH_VCONN_INFINITY', return infinity (ie. 1.0/0.0).
@c      `IGRAPH_VCONN_IGNORE', ignore the fact that the two vertices are
@c      connected and calculated the number of vertices needed to
@c      aliminate all paths except for the trivial (direct) paths between
@c      `source' and `vertex'. TOOD: what about neighbors?

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^3), but see the discussion at
@c `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum flow
@c in a network with the push/relabel algorithm::).

@c    *See also:. *

@c `'
@c      `igraph_vertex_connectivity()' (*note igraph_vertex_connectivity
@c      --- The vertex connectivity of a graph::),
@c      `igraph_edge_connectivity()' (*note igraph_edge_connectivity ---
@c      The minimum edge connectivity in a graph_::),
@c      `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum
@c      flow in a network with the push/relabel algorithm::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vertex_connectivity --- The vertex connectivity of a graph,  Prev: igraph_st_vertex_connectivity --- The vertex connectivity of a pair of vertices,  Up: Connectivity

@c 16.3.4 igraph_vertex_connectivity -- The vertex connectivity of a graph
@c -----------------------------------------------------------------------


@c      int igraph_vertex_connectivity(const igraph_t *graph, igraph_integer_t *res,
@c      			       igraph_bool_t checks);

@c    The vertex connectivity of a graph is the minimum vertex
@c connectivity along each pairs of vertices in the graph.

@c    The vertex connectivity of a graph is the same as group cohesion as
@c defined in Douglas R. White and Frank Harary: The cohesiveness of
@c blocks in social networks: node connectivity and conditional density,
@c Sociological Methodology 31:305-359, 2001.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an integer, the result will be stored here.

@c `checks':
@c      Logical constant. Whether to check that the graph is connected and
@c      also the degree of the vertices. If the graph is not (strongly)
@c      connected then the connectivity is obviously zero. Otherwise if
@c      the minimum degree is one then the vertex connectivity is also
@c      one. It is a good idea to perform these checks, as they can be
@c      done quickly compared to the connectivity calculation itself.
@c      They were suggested by Peter McMahan, thanks Peter.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complecity: O(|V|^5).

@c    *See also:. *

@c `'
@c      `igraph_st_vertex_connectivity()' (*note
@c      igraph_st_vertex_connectivity --- The vertex connectivity of a
@c      pair of vertices::), `igraph_maxflow_value()' (*note
@c      igraph_maxflow_value --- Maximum flow in a network with the
@c      push/relabel algorithm::), and `igraph_edge_connectivity()' (*note
@c      igraph_edge_connectivity --- The minimum edge connectivity in a
@c      graph_::).

@c
@c File: igraph_reference_manual.info,  Node: Edge- and Vertex-Disjoint Paths,  Next: Graph Adhesion and Cohesion,  Prev: Connectivity,  Up: Maximum Flows; Minimum Cuts and related measures

@c 16.4 Edge- and Vertex-Disjoint Paths
@c ====================================

@c * Menu:

@c * igraph_edge_disjoint_paths --- The maximum number of edge-disjoint paths between two vertices. : igraph_edge_disjoint_paths --- The maximum number of edge-disjoint paths between two vertices_.
@c * igraph_vertex_disjoint_paths --- Maximum number of vertex-disjoint paths between two vertices.: igraph_vertex_disjoint_paths --- Maximum number of vertex-disjoint paths between two vertices_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_edge_disjoint_paths --- The maximum number of edge-disjoint paths between two vertices_,  Next: igraph_vertex_disjoint_paths --- Maximum number of vertex-disjoint paths between two vertices_,  Up: Edge- and Vertex-Disjoint Paths

@c 16.4.1 igraph_edge_disjoint_paths -- The maximum number of edge-disjoint paths between two vertices.
@c ----------------------------------------------------------------------------------------------------


@c      int igraph_edge_disjoint_paths(const igraph_t *graph, igraph_integer_t *res,
@c      			       igraph_integer_t source,
@c      			       igraph_integer_t target);

@c    A set of paths between two vertices is called edge-disjoint if they
@c do not share any edges. The maximum number of edge-disjoint paths are
@c calculated by this function using maximum flow techniques. Directed
@c paths are considered in directed graphs.

@c    Note that the number of disjoint paths is the same as the edge
@c connectivity of the two vertices using uniform edge weights.

@c    *Arguments:. *

@c `graph':
@c      The input graph, can be directed or undirected.

@c `res':
@c      Pointer to an integer variable, the result will be stored here.

@c `source':
@c      The id of the source vertex.

@c `target':
@c      The id of the target vertex.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complecity: O(|V|^3), but see the discussion at
@c `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum flow
@c in a network with the push/relabel algorithm::).

@c    *See also:. *

@c `'
@c      `igraph_vertex_disjoint_paths()' (*note
@c      igraph_vertex_disjoint_paths --- Maximum number of vertex-disjoint
@c      paths between two vertices_::), `igraph_st_edge_connectivity()'
@c      (*note igraph_st_edge_connectivity --- Edge connectivity of a pair
@c      of vertices::), `igraph_maxflow_value()' (*note
@c      igraph_maxflow_value --- Maximum flow in a network with the
@c      push/relabel algorithm::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_vertex_disjoint_paths --- Maximum number of vertex-disjoint paths between two vertices_,  Prev: igraph_edge_disjoint_paths --- The maximum number of edge-disjoint paths between two vertices_,  Up: Edge- and Vertex-Disjoint Paths

@c 16.4.2 igraph_vertex_disjoint_paths -- Maximum number of vertex-disjoint paths between two vertices.
@c ----------------------------------------------------------------------------------------------------


@c      int igraph_vertex_disjoint_paths(const igraph_t *graph, igraph_integer_t *res,
@c      				 igraph_integer_t source,
@c      				 igraph_integer_t target);

@c    A set of paths between two vertices is called vertex-disjoint if
@c they share no vertices. The calculation is performed by using maximum
@c flow techniques.

@c    Note that the number of vertex-disjoint paths is the same as the
@c vertex connectivity of the two vertices in most cases (if the two
@c vertices are not connected by an edge).

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an integer variable, the result will be stored here.

@c `source':
@c      The id of the source vertex.

@c `target':
@c      The id of the target vertex.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^3).

@c    *See also:. *

@c `'
@c      `igraph_edge_disjoint_paths()' (*note igraph_edge_disjoint_paths
@c      --- The maximum number of edge-disjoint paths between two
@c      vertices_::), `igraph_vertex_connectivity()' (*note
@c      igraph_vertex_connectivity --- The vertex connectivity of a
@c      graph::), `igraph_maxflow_value()' (*note igraph_maxflow_value ---
@c      Maximum flow in a network with the push/relabel algorithm::).

@c
@c File: igraph_reference_manual.info,  Node: Graph Adhesion and Cohesion,  Prev: Edge- and Vertex-Disjoint Paths,  Up: Maximum Flows; Minimum Cuts and related measures

@c 16.5 Graph Adhesion and Cohesion
@c ================================

@c * Menu:

@c * igraph_adhesion --- Graph adhesion, this is (almost) the same as edge connectivity.: igraph_adhesion --- Graph adhesion; this is [almost] the same as edge connectivity_.
@c * igraph_cohesion --- Graph cohesion, this is the same as vertex connectivity. : igraph_cohesion --- Graph cohesion; this is the same as vertex connectivity_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_adhesion --- Graph adhesion; this is [almost] the same as edge connectivity_,  Next: igraph_cohesion --- Graph cohesion; this is the same as vertex connectivity_,  Up: Graph Adhesion and Cohesion

@c 16.5.1 igraph_adhesion -- Graph adhesion, this is (almost) the same as edge connectivity.
@c -----------------------------------------------------------------------------------------


@c      int igraph_adhesion(const igraph_t *graph, igraph_integer_t *res,
@c      		    igraph_bool_t checks);

@c    This quantity is defined by White and Harary in The cohesiveness of
@c blocks in social networks: node connectivity and conditional density,
@c (Sociological Methodology 31:305-359, 2001) and basically it is the
@c edge connectivity of the graph with uniform edge weights.

@c    *Arguments:. *

@c `graph':
@c      The input graph, either directed or undirected.

@c `res':
@c      Pointer to an integer, the result will be stored here.

@c `checks':
@c      Logical constant. Whether to check that the graph is connected and
@c      also the degree of the vertices. If the graph is not (strongly)
@c      connected then the adhesion is obviously zero. Otherwise if the
@c      minimum degree is one then the adhesion is also one. It is a good
@c      idea to perform these checks, as they can be done quickly compared
@c      to the edge connectivity calculation itself.  They were suggested
@c      by Peter McMahan, thanks Peter.  *

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(log(|V|)*|V|^2) for undirected graphs and
@c O(|V|^4) for directed graphs, but see also the discussion at the
@c documentation of `igraph_maxflow_value()' (*note igraph_maxflow_value
@c --- Maximum flow in a network with the push/relabel algorithm::).

@c    *See also:. *

@c `'
@c      `igraph_cohesion()' (*note igraph_cohesion --- Graph cohesion;
@c      this is the same as vertex connectivity_::),
@c      `igraph_maxflow_value()' (*note igraph_maxflow_value --- Maximum
@c      flow in a network with the push/relabel algorithm::),
@c      `igraph_edge_connectivity()' (*note igraph_edge_connectivity ---
@c      The minimum edge connectivity in a graph_::),
@c      `igraph_mincut_value()' (*note igraph_mincut_value --- The minimum
@c      edge cut in a graph::).

@c
@c File: igraph_reference_manual.info,  Node: igraph_cohesion --- Graph cohesion; this is the same as vertex connectivity_,  Prev: igraph_adhesion --- Graph adhesion; this is [almost] the same as edge connectivity_,  Up: Graph Adhesion and Cohesion

@c 16.5.2 igraph_cohesion -- Graph cohesion, this is the same as vertex connectivity.
@c ----------------------------------------------------------------------------------


@c      int igraph_cohesion(const igraph_t *graph, igraph_integer_t *res,
@c      		    igraph_bool_t checks);

@c    This quantity was defined by White and Harary in `The cohesiveness
@c of blocks in social networks: node connectivity and conditional
@c density', (Sociological Methodology 31:305-359, 2001) and it is the
@c same as the vertex connectivity of a graph.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to an integer variable, the result will be stored here.

@c `checks':
@c      Logical constant. Whether to check that the graph is connected and
@c      also the degree of the vertices. If the graph is not (strongly)
@c      connected then the cohesion is obviously zero. Otherwise if the
@c      minimum degree is one then the cohesion is also one. It is a good
@c      idea to perform these checks, as they can be done quickly compared
@c      to the vertex connectivity calculation itself.  They were
@c      suggested by Peter McMahan, thanks Peter.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|^4), |V| is the number of vertices. In
@c practice it is more like O(|V|^2), see `igraph_maxflow_value()' (*note
@c igraph_maxflow_value --- Maximum flow in a network with the
@c push/relabel algorithm::).

@c    *See also:. *

@c `'
@c      `igraph_vertex_connectivity()' (*note igraph_vertex_connectivity
@c      --- The vertex connectivity of a graph::), `igraph_adhesion()'
@c      (*note igraph_adhesion --- Graph adhesion; this is [almost] the
@c      same as edge connectivity_::), `igraph_maxflow_value()' (*note
@c      igraph_maxflow_value --- Maximum flow in a network with the
@c      push/relabel algorithm::).

@c
@c File: igraph_reference_manual.info,  Node: Detecting Community Structure,  Next: Graph Operators,  Prev: Maximum Flows; Minimum Cuts and related measures,  Up: Top

@c 17 Detecting Community Structure
@c ********************************

@c * Menu:

@c * Common functions related to community structure::
@c * Community structure based on statistical mechanics::
@c * Community structure based on eigenvectors of matrices::
@c * Walktrap; community structure based on random walks::
@c * Edge betweenness based community detection::
@c * Community structure based on fast greedy optimization of modularity::

@c
@c File: igraph_reference_manual.info,  Node: Common functions related to community structure,  Next: Community structure based on statistical mechanics,  Up: Detecting Community Structure

@c 17.1 Common functions related to community structure
@c ====================================================

@c * Menu:

@c * igraph_modularity --- Calculate the modularity of a graph with respect to some vertex types::
@c * igraph_community_to_membership --- Create membership vector from community structure dendrogram::

@c
@c File: igraph_reference_manual.info,  Node: igraph_modularity --- Calculate the modularity of a graph with respect to some vertex types,  Next: igraph_community_to_membership --- Create membership vector from community structure dendrogram,  Up: Common functions related to community structure

@c 17.1.1 igraph_modularity -- Calculate the modularity of a graph with respect to some vertex types
@c -------------------------------------------------------------------------------------------------


@c      int igraph_modularity(const igraph_t *graph,
@c      		      const igraph_vector_t *membership,
@c      		      igraph_real_t *modularity,
@c      			  const igraph_vector_t *weights);

@c    The modularity of a graph with respect to some division (or vertex
@c types) measures how good the division is, or how separated are the
@c different vertex types from each other. It defined as Q=1/(2m) *
@c sum(Aij-ki*kj/(2m)delta(ci,cj),i,j), here `m' is the number of edges,
@c `Aij' is the element of the `A' adjacency matrix in row `i' and column
@c `j', `ki' is the degree of `i', `kj' is the degree of `j', `ci' is the
@c type (or component) of `i', `cj' that of `j', the sum goes over all `i'
@c and `j' pairs of vertices, and `delta(x,y)' is one if x=y and zero
@c otherwise.

@c    Modularity on weighted graphs is also meaningful. When taking edge
@c weights into account, `Aij' becomes the weight of the corresponding
@c edge (or 0 if there is no edge), `ki' is the total weight of edges
@c adjacent to vertex `i', `kj' is the total weight of edges adjacent to
@c vertex `j' and `m' is the total weight of all edges.

@c    See also MEJ Newman and M Girvan: Finding and evaluating community
@c structure in networks. Physical Review E 69 026113, 2004.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `membership':
@c      Numeric vector which gives the type of each vertex, ie. the
@c      component to which it belongs.

@c `modularity':
@c      Pointer to a real number, the result will be stored here.

@c `weights':
@c      Weight vector or NULL if no weights are specified.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_to_membership --- Create membership vector from community structure dendrogram,  Prev: igraph_modularity --- Calculate the modularity of a graph with respect to some vertex types,  Up: Common functions related to community structure

@c 17.1.2 igraph_community_to_membership -- Create membership vector from community structure dendrogram
@c -----------------------------------------------------------------------------------------------------


@c      int igraph_community_to_membership(const igraph_matrix_t *merges,
@c      				   igraph_integer_t nodes,
@c      				   igraph_integer_t steps,
@c      				   igraph_vector_t *membership,
@c      				   igraph_vector_t *csize);

@c    This function creates a membership vector from a community structure
@c dendrogram. A membership vector contains for each vertex the id of its
@c graph component, the graph components are numbered from zero, see the
@c same argument of `igraph_clusters()' (*note igraph_clusters ---
@c Calculates the [weakly or strongly] connected components in a graph_::)
@c for an example of a membership vector.

@c    Many community detection algorithms return with a _merges_ matrix,
@c `igraph_community_walktrap()' (*note igraph_community_walktrap --- This
@c function is the implementation of the Walktrap community::) an
@c `igraph_community_edge_betweenness()' (*note
@c igraph_community_edge_betweenness --- Community findinf based on edge
@c betweenness::) are two examples. The matrix contains the merge
@c operations performed while mapping the hierarchical structure of a
@c network. If the matrix has `n-1' rows, where `n' is the number of
@c vertices in the graph, then it contains the hierarchical structure of
@c the whole network and it is called a dendrogram.

@c    This function performs `steps' merge operations as prescribed by the
@c `merges' matrix and returns the current state of the network.

@c    If if `merges' is not a complete dendrogram, it is possible to take
@c `steps' steps if `steps' is not bigger than the number lines in
@c `merges'.

@c    *Arguments:. *

@c `merges':
@c      The two-column matrix containing the merge operations. See
@c      `igraph_community_walktrap()' (*note igraph_community_walktrap ---
@c      This function is the implementation of the Walktrap community::)
@c      for the detailed syntax.

@c `nodes':
@c      The number of leaf nodes in the dendrogram

@c `steps':
@c      Integer constant, the number of steps to take.

@c `membership':
@c      Pointer to an initialied vector, the membership results will be
@c      stored here, if not NULL. The vector will be resized as needed.

@c `csize':
@c      Pointer to an initialized vector, or NULL. If not NULL then the
@c      sizes of the components will be stored here, the vector will be
@c      resized as needed.

@c    *See also:. *

@c `'
@c      `igraph_community_walktrap()' (*note igraph_community_walktrap ---
@c      This function is the implementation of the Walktrap community::),
@c      `igraph_community_edge_betweenness()' (*note
@c      igraph_community_edge_betweenness --- Community findinf based on
@c      edge betweenness::), `igraph_community_fastgreedy()' (*note
@c      igraph_community_fastgreedy --- Finding community structure by
@c      greedy optimization of modularity::) for community structure
@c      detection algorithms.

@c    Time complexity: O(|V|), the number of vertices in the graph.

@c
@c File: igraph_reference_manual.info,  Node: Community structure based on statistical mechanics,  Next: Community structure based on eigenvectors of matrices,  Prev: Common functions related to community structure,  Up: Detecting Community Structure

@c 17.2 Community structure based on statistical mechanics
@c =======================================================

@c * Menu:

@c * igraph_community_spinglass --- Community detection based on statistical mechanics::
@c * igraph_community_spinglass_single --- Community of a single node based on statistical mechanics::

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_spinglass --- Community detection based on statistical mechanics,  Next: igraph_community_spinglass_single --- Community of a single node based on statistical mechanics,  Up: Community structure based on statistical mechanics

@c 17.2.1 igraph_community_spinglass -- Community detection based on statistical mechanics
@c ---------------------------------------------------------------------------------------


@c      int igraph_community_spinglass(const igraph_t *graph,
@c      			       const igraph_vector_t *weights,
@c      			       igraph_real_t *modularity,
@c      			       igraph_real_t *temperature,
@c      			       igraph_vector_t *membership,
@c      			       igraph_vector_t *csize,
@c      			       igraph_integer_t spins,
@c      			       igraph_bool_t parupdate,
@c      			       igraph_real_t starttemp,
@c      			       igraph_real_t stoptemp,
@c      			       igraph_real_t coolfact,
@c      			       igraph_spincomm_update_t update_rule,
@c      			       igraph_real_t gamma);

@c    This function implements the community structure detection algorithm
@c proposed by Joerg Reichardt and Stefan Bornholdt.  The algorithm is
@c described in their paper: Statistical Mechanics of Community Detection,
@c http://arxiv.org/abs/cond-mat/0603718.
@c (http://arxiv.org/abs/cond-mat/0603718.)

@c    *Arguments:. *

@c `graph':
@c      The input graph, it may be directed but the direction of the edge
@c      is not used in the algorithm.

@c `weights':
@c      The vector giving the edge weights, it may be `NULL', in which
@c      case all edges are weighted equally. Edge weights should be
@c      positive, altough this is not tested.

@c `modularity':
@c      Pointer to a real number, if not `NULL' then the modularity score
@c      of the solution will be stored here, see M. E. J. Newman and M.
@c      Girvan, Phys. Rev. E 69, 026113 (2004) for details.

@c `temperature':
@c      Pointer to a real number, if not `NULL' then the temperature at
@c      the end of the algorithm will be stored here.

@c `membership':
@c      Pointer to an initialized vector or `NULL'. If not `NULL' then the
@c      result of the clustering will be stored here, for each vertex the
@c      number of its cluster is given, the first cluster is numbered
@c      zero. The vector will be resized as needed.

@c `csize':
@c      Pointer to an initialized vector or `NULL'. If not `NULL' then the
@c      sizes of the clusters will stored here in cluster number order.
@c      The vector will be resized as needed.

@c `spins':
@c      Integer giving the number of spins, ie. the maximum number of
@c      clusters. Usually it is not a program to give a high number here,
@c      the default was 25 in the original code. Even if the number of
@c      spins is high the number of clusters in the result might small.

@c `parupdate':
@c      A logical constant, whether to update all spins in parallel. The
@c      default for this argument was `FALSE' (ie. 0) in the original code.

@c `starttemp':
@c      Real number, the temperature at the start. The value of this
@c      argument was 1.0 in the original code.

@c `stoptemp':
@c      Real number, the algorithm stops at this temperature. The default
@c      was 0.01 in the original code.

@c `coolfact':
@c      Real number, the coolinf factor for the simulated annealing. The
@c      default was 0.99 in the original code.

@c `update_rule':
@c      The type of the update rule. Possible values:
@c      `IGRAPH_SPINCOMM_UPDATE_SIMPLE' and
@c      `IGRAPH_SPINCOMM_UPDATE_CONFIG'. Basically this parameter defined
@c      the null model based on which the actual clustering is done. If
@c      this is `IGRAPH_SPINCOMM_UPDATE_SIMPLE' then the random graph (ie.
@c      G(n,p)), if it is `IGRAPH_SPINCOMM_UPDATE' then the configuration
@c      model is used. The configuration means that the baseline for the
@c      clustering is a random graph with the same degree distribution as
@c      the input graph.

@c `gamma':
@c      Real number. The gamma parameter of the algorithm. This defined
@c      the weight of the missing and existing links in the quality
@c      function for the clustering. The default value in the original
@c      code was 1.0, which is equal weight to missing and existing edges.
@c      Smaller values make the existing links contibute more to the
@c      energy function which is minimized in the algorithm. Bigger values
@c      make the missing links more important. (If my understanding is
@c      correct.)

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      igraph_community_spinglass_single() for calculating the community
@c      of a single vertex.

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_spinglass_single --- Community of a single node based on statistical mechanics,  Prev: igraph_community_spinglass --- Community detection based on statistical mechanics,  Up: Community structure based on statistical mechanics

@c 17.2.2 igraph_community_spinglass_single -- Community of a single node based on statistical mechanics
@c -----------------------------------------------------------------------------------------------------


@c      int igraph_community_spinglass_single(const igraph_t *graph,
@c      				      const igraph_vector_t *weights,
@c      				      igraph_integer_t vertex,
@c      				      igraph_vector_t *community,
@c      				      igraph_real_t *cohesion,
@c      				      igraph_real_t *adhesion,
@c      				      igraph_integer_t *inner_links,
@c      				      igraph_integer_t *outer_links,
@c      				      igraph_integer_t spins,
@c      				      igraph_spincomm_update_t update_rule,
@c      				      igraph_real_t gamma);

@c    This function implements the community structure detection algorithm
@c proposed by Joerg Reichardt and Stefan Bornholdt. It is described in
@c their paper: Statistical Mechanics of Community Detection,
@c http://arxiv.org/abs/cond-mat/0603718.
@c (http://arxiv.org/abs/cond-mat/0603718.)

@c    This function calculates the community of a single vertex without
@c calculating all the communities in the graph.

@c    *Arguments:. *

@c `graph':
@c      The input graph, it may be directed but the direction of the edges
@c      is not used in the algorithm.

@c `weights':
@c      Pointer to a vector with the weights of the edges.  Alternatively
@c      `NULL' can be supplied to have the same weight for every edge.

@c `vertex':
@c      The vertex id of the vertex of which ths community is calculated.

@c `community':
@c      Pointer to an initialized vector, the result, the ids of the
@c      vertices in the community of the input vertex will be stored here.
@c      The vector will be resized as needed.

@c `cohesion':
@c      Pointer to a real variable, if not `NULL' the cohesion index of
@c      the community will be stored here.

@c `adhesion':
@c      Pointer to a real variable, if not `NULL' the adhesion index of
@c      the community will be stored here.

@c `inner_links':
@c      Pointer to an integer, if not `NULL' the number of edges within
@c      the community is stored here.

@c `outer_links':
@c      Pointer to an integer, if not `NULL' the number of edges between
@c      the community and the rest of the graph will be stored here.

@c `spins':
@c      The number of spins to use, this can be higher than the actual
@c      number of clusters in the network, in which case some clusters
@c      will contain zero vertices.

@c `update_rule':
@c      The type of the update rule. Possible values:
@c      `IGRAPH_SPINCOMM_UPDATE_SIMPLE' and
@c      `IGRAPH_SPINCOMM_UPDATE_CONFIG'. Basically this parameter defined
@c      the null model based on which the actual clustering is done. If
@c      this is `IGRAPH_SPINCOMM_UPDATE_SIMPLE' then the random graph (ie.
@c      G(n,p)), if it is `IGRAPH_SPINCOMM_UPDATE' then the configuration
@c      model is used. The configuration means that the baseline for the
@c      clustering is a random graph with the same degree distribution as
@c      the input graph.

@c `gamma':
@c      Real number. The gamma parameter of the algorithm. This defined
@c      the weight of the missing and existing links in the quality
@c      function for the clustering. The default value in the original
@c      code was 1.0, which is equal weight to missing and existing edges.
@c      Smaller values make the existing links contibute more to the
@c      energy function which is minimized in the algorithm. Bigger values
@c      make the missing links more important. (If my understanding is
@c      correct.)

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      igraph_community_spinglass() for the traditional version of the
@c      algorithm.

@c    Time complexity: TODO.

@c
@c File: igraph_reference_manual.info,  Node: Community structure based on eigenvectors of matrices,  Next: Walktrap; community structure based on random walks,  Prev: Community structure based on statistical mechanics,  Up: Detecting Community Structure

@c 17.3 Community structure based on eigenvectors of matrices
@c ==========================================================

@c The functions documented in these section implement the `leading
@c eigenvector' method developed by Mark Newman and published in MEJ
@c Newman: Finding community structure using the eigenvectors of matrices,
@c arXiv:physics/0605087. TODO: proper citation.

@c    The heart of the method is the definition of the modularity matrix,
@c B, which is B=A-P, A being the adjacency matrix of the (undirected)
@c network, and P contains the probability that certain edges are present
@c according to the `configuration model' In other words, a Pij element of
@c P is the probability that there is an edge between vertices i and j in
@c a random network in which the degrees of all vertices are the same as
@c in the input graph.

@c    The leading eigenvector method works by calculating the eigenvector
@c of the modularity matrix for the largest positive eigenvalue and then
@c separating vertices into two community based on the sign of the
@c corresponding element in the eigenvector. If all elements in the
@c eigenvector are of the same sign that means that the network has no
@c underlying comuunity structure.  Check Newman's paper to understand why
@c this is a good method for detecting community structure.

@c    Three function are implemented, they all work accoding to the same
@c principles. The simplest is perhaps
@c `igraph_community_leading_eigenvector_naive()' (*note
@c igraph_community_leading_eigenvector_naive --- Leading eigenvector
@c community finding [naive version]_::). This function splits the network
@c as described above and then recursively splits the two components after
@c the split as individual networks, if possible.  This however is not a
@c good way for maximizing moduilarity, again see the paper for
@c explanation and the proper definition of modularity.

@c    The correct recursive community structure detection method is
@c implemented in `igraph_community_leading_eigenvector()' (*note
@c igraph_community_leading_eigenvector --- Leading eigenvector community
@c finding [proper version]_::).  Here, after the initial split, the
@c following splits are done in a way to optimize modularity regarding the
@c original network.  I can't say it enough, see the paper, particularly
@c section VI.

@c    The third function is `igraph_community_leading_eigenvector_step()'
@c (*note igraph_community_leading_eigenvector_step --- Leading
@c eigenvector community finding [make one step]_::), this starts from a
@c division of the network and tries to split a given community into two
@c subcommunities via the same (correct) method as
@c `igraph_community_leading_eigenvector()' (*note
@c igraph_community_leading_eigenvector --- Leading eigenvector community
@c finding [proper version]_::).

@c * Menu:

@c * igraph_community_leading_eigenvector --- Leading eigenvector community finding (proper version).: igraph_community_leading_eigenvector --- Leading eigenvector community finding [proper version]_.
@c * igraph_community_leading_eigenvector_naive --- Leading eigenvector community finding (naive version).: igraph_community_leading_eigenvector_naive --- Leading eigenvector community finding [naive version]_.
@c * igraph_community_leading_eigenvector_step --- Leading eigenvector community finding (make one step).: igraph_community_leading_eigenvector_step --- Leading eigenvector community finding [make one step]_.
@c * igraph_le_community_to_membership --- Vertex membership from the leading eigenvector community structure::

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_leading_eigenvector --- Leading eigenvector community finding [proper version]_,  Next: igraph_community_leading_eigenvector_naive --- Leading eigenvector community finding [naive version]_,  Up: Community structure based on eigenvectors of matrices

@c 17.3.1 igraph_community_leading_eigenvector -- Leading eigenvector community finding (proper version).
@c ------------------------------------------------------------------------------------------------------


@c      int igraph_community_leading_eigenvector(const igraph_t *graph,
@c      					 igraph_matrix_t *merges,
@c      					 igraph_vector_t *membership,
@c      					 igraph_integer_t steps,
@c      					 igraph_arpack_options_t *options);

@c    Newman's leading eigenvector method for detecting community
@c structure. This is the proper implementation of the recursive, divisive
@c algorithm: each split is done by maximizing the modularity regarding
@c the original network, see MEJ Newman: Finding community structure in
@c networks using the eigenvectors of matrices, arXiv:physics/0605087.

@c    *Arguments:. *

@c `graph':
@c      The undirected input graph.

@c `merges':
@c      The result of the algorithm, a matrix containing the information
@c      about the splits performed. The matrix is built in the opposite
@c      way however, it is like the result of an agglomerative algorithm.
@c      If at the end of the algorithm (after `steps' steps was done)
@c      there are `p' communities, then these are numbered from zero to
@c      `p-1'. The first line of the matrix contains the first `merge'
@c      (which is in reality the last split) of two communities into
@c      community `p', the merge in the second line forms community `p+1',
@c      etc. The matrix should be initialized before calling and will be
@c      resized as needed.  This argument is ignored of it is `NULL'.

@c `membership':
@c      The membership of the vertices after all the splits were performed
@c      will be stored here. The vector must be initialized  before
@c      calling and will be resized as needed.  This argument is ignored
@c      if it is `NULL'.

@c `steps':
@c      The maximum number of steps to perform. It might happen that some
@c      component (or the whole network) has no underlying community
@c      structure and no further steps can be done. If you wany as many
@c      steps as possible then supply the number of vertices in the
@c      network here.

@c `options':
@c      The options for ARPACK. `n' is always overwritten. `ncv' is set to
@c      at least 3.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_community_walktrap()' (*note igraph_community_walktrap ---
@c      This function is the implementation of the Walktrap community::)
@c      and `igraph_community_spinglass()' (*note
@c      igraph_community_spinglass --- Community detection based on
@c      statistical mechanics::) for other community structure detection
@c      methods.

@c    Time complexity: O(|E|+|V|^2*steps), |V| is the number of vertices,
@c |E| the number of edges, `steps' the number of splits performed.

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_leading_eigenvector_naive --- Leading eigenvector community finding [naive version]_,  Next: igraph_community_leading_eigenvector_step --- Leading eigenvector community finding [make one step]_,  Prev: igraph_community_leading_eigenvector --- Leading eigenvector community finding [proper version]_,  Up: Community structure based on eigenvectors of matrices

@c 17.3.2 igraph_community_leading_eigenvector_naive -- Leading eigenvector community finding (naive version).
@c -----------------------------------------------------------------------------------------------------------


@c      int igraph_community_leading_eigenvector_naive(const igraph_t *graph,
@c      					       igraph_matrix_t *merges,
@c      					       igraph_vector_t *membership,
@c      					       igraph_integer_t steps,
@c      					       igraph_arpack_options_t *options);

@c    A naive implementation of Newman's eigenvector community structure
@c detection. This function splits the network into two components
@c according to the leading eigenvector of the modularity matrix and then
@c recursively takes `steps' steps by splitting the components as
@c individual network. This is not the correct way however, see MEJ
@c Newman: Finding community structure in networks using the eigenvectors
@c of matrices, arXiv:physics/0605087. Consider using the correct
@c `igraph_community_leading_eigenvector()' (*note
@c igraph_community_leading_eigenvector --- Leading eigenvector community
@c finding [proper version]_::) function instead.

@c    *Arguments:. *

@c `graph':
@c      The input graph, should be undirected to make sense.

@c `merges':
@c      The merge matrix. The splits done by the algorithm are stored
@c      here, its structure is the same ad for
@c      `igraph_community_leading_eigenvector()' (*note
@c      igraph_community_leading_eigenvector --- Leading eigenvector
@c      community finding [proper version]_::). This argument is ignored
@c      if it is `NULL'.

@c `membership':
@c      The membership vector, for each vertex it gives the id of its
@c      community after all the splits are performed.  This argument is
@c      ignored if it is `NULL'.

@c `steps':
@c      The number of splits to do, if possible. Supply the number of
@c      vertices in the network here to perform as many steps as possible.

@c `options':
@c      The options for ARPACK. `n' is always overwritten. `ncv' is set to
@c      at least 3.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_community_leading_eigenvector()' (*note
@c      igraph_community_leading_eigenvector --- Leading eigenvector
@c      community finding [proper version]_::) for the proper way,
@c      `igraph_community_leading_eigenvector_step()' (*note
@c      igraph_community_leading_eigenvector_step --- Leading eigenvector
@c      community finding [make one step]_::) to do just one split.

@c    Time complexity: O(E|+|V|^2*steps), |V| is the number of vertices,
@c |E| is the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_leading_eigenvector_step --- Leading eigenvector community finding [make one step]_,  Next: igraph_le_community_to_membership --- Vertex membership from the leading eigenvector community structure,  Prev: igraph_community_leading_eigenvector_naive --- Leading eigenvector community finding [naive version]_,  Up: Community structure based on eigenvectors of matrices

@c 17.3.3 igraph_community_leading_eigenvector_step -- Leading eigenvector community finding (make one step).
@c ----------------------------------------------------------------------------------------------------------


@c      int igraph_community_leading_eigenvector_step(const igraph_t *graph,
@c      					      igraph_vector_t *membership,
@c      					      igraph_integer_t community,
@c      					      igraph_bool_t *split,
@c      					      igraph_vector_t *eigenvector,
@c      					      igraph_real_t *eigenvalue,
@c      					      igraph_arpack_options_t *options,
@c      					      igraph_arpack_storage_t *storage);

@c    Do one split according to Mark Newman's leading eigenvector
@c community detection method. See MEJ Newman: Finding community structure
@c in networks using the eigenvectors of matrices, arXiv:phyisics/0605087
@c for the details.

@c    Use this function instead of
@c `igraph_community_leading_eigenvector()' (*note
@c igraph_community_leading_eigenvector --- Leading eigenvector community
@c finding [proper version]_::) if you want to have full control over and
@c information about each split performed along community structure
@c detection. `igraph_community_leading_eigenvector()' (*note
@c igraph_community_leading_eigenvector --- Leading eigenvector community
@c finding [proper version]_::) can be simulated by repeatedly calling
@c this function.

@c    *Arguments:. *

@c `graph':
@c      The undirected input graph.

@c `membership':
@c      Numeric vector giving a division of `graph'.  The result will be
@c      also stored here. The vector contains the community ids for each
@c      vertex, these are numbered from 0.

@c `community':
@c      The id of the community to split.

@c `split':
@c      Pointer to a logical variable, if it was possible to split
@c      community `community' then 1, otherwise 0 will be stored here.
@c      This argument is ignored if it is `NULL'.

@c `eigenvector':
@c      Pointer to an initialized vector, the eigenvector on which the
@c      split was done will be stored here.  It will be resised to have
@c      the same length as the number of vertices in community
@c      `community'. This argument is ignored if it is `NULL'.

@c `eigenvalue':
@c      Pointer to a real variable, the eigenvalue associated with
@c      `eigenvector' will be stored here.  This argument is ignored if it
@c      is `NULL'.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_community_leading_eigenvector()' (*note
@c      igraph_community_leading_eigenvector --- Leading eigenvector
@c      community finding [proper version]_::).

@c    Time complexity: O(|E|+|V|^2), |E| is the number of edges, |V| is
@c the number of vertices.

@c
@c File: igraph_reference_manual.info,  Node: igraph_le_community_to_membership --- Vertex membership from the leading eigenvector community structure,  Prev: igraph_community_leading_eigenvector_step --- Leading eigenvector community finding [make one step]_,  Up: Community structure based on eigenvectors of matrices

@c 17.3.4 igraph_le_community_to_membership -- Vertex membership from the leading eigenvector community structure
@c --------------------------------------------------------------------------------------------------------------


@c      int igraph_le_community_to_membership(const igraph_matrix_t *merges,
@c      				      igraph_integer_t steps,
@c      				      igraph_vector_t *membership,
@c      				      igraph_vector_t *csize);

@c    This function creates a membership vector from the result of
@c `igraph_community_leading_eigenvector()' (*note
@c igraph_community_leading_eigenvector --- Leading eigenvector community
@c finding [proper version]_::) or
@c `igraph_community_leading_eigenvector_naive()' (*note
@c igraph_community_leading_eigenvector_naive --- Leading eigenvector
@c community finding [naive version]_::). It takes `membership' and
@c permformes `steps' merges, according to the supplied `merges' matrix.

@c    *Arguments:. *

@c `merges':
@c      The matrix defining the merges to make.  This is usually from the
@c      output of the leading eigenvector community structure detection
@c      routines.

@c `steps':
@c      The number of steps to make according to `merges'.

@c `membership':
@c      Initially the starting membership vector, on output the resulting
@c      membership vector, after performing `steps' merges.

@c `csize':
@c      Optionally the sizes of the commmunities is stored here, if this
@c      is not a null pointer, but an initialized vector.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|), the number of vertices.

@c
@c File: igraph_reference_manual.info,  Node: Walktrap; community structure based on random walks,  Next: Edge betweenness based community detection,  Prev: Community structure based on eigenvectors of matrices,  Up: Detecting Community Structure

@c 17.4 Walktrap: community structure based on random walks
@c ========================================================

@c * Menu:

@c * igraph_community_walktrap --- This function is the implementation of the Walktrap community::

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_walktrap --- This function is the implementation of the Walktrap community,  Up: Walktrap; community structure based on random walks

@c 17.4.1 igraph_community_walktrap -- This function is the implementation of the Walktrap community
@c -------------------------------------------------------------------------------------------------


@c      int igraph_community_walktrap(const igraph_t *graph,
@c      			      const igraph_vector_t *weights,
@c      			      int steps,
@c      			      igraph_matrix_t *merges,
@c      			      igraph_vector_t *modularity);

@c    finding algorithm, see Pascal Pons, Matthieu Latapy: Computing
@c communities in large networks using random walks,
@c http://arxiv.org/abs/physics/0512106
@c (http://arxiv.org/abs/physics/0512106)

@c    Currently the original C++ implementation is used in igraph, see
@c http://www.liafa.jussieu.fr/~pons/index.php?item=prog&item2=walktrap&lang=en
@c (http://www.liafa.jussieu.fr/~pons/index.php?item=prog&item2=walktrap&lang=en)
@c I'm grateful to Matthieu Latapy and Pascal Pons for providing this
@c source code.

@c    Note that the graph must not contain isolated vertices in order to
@c use this method.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `weights':
@c      Numeric vector giving the weights of the edges.  If it is a NULL
@c      pointer then all edges will have equal weights. The weights are
@c      expected to be positive.

@c `steps':
@c      Integer constant, the length of the random walks.

@c `merges':
@c      Pointer to a matrix, the merges performed by the algorithm will be
@c      stored here (if not NULL). Each merge is a row in a two-column
@c      matrix and contains the ids of the merged clusters. Clusters are
@c      numbered from zero and cluster number smaller than the number of
@c      nodes in the network belong to the individual vertices as
@c      singleton clusters. In each step a new cluster is created from two
@c      other clusters and its id will be one larger than the largest
@c      cluster id so far. This means that before the first merge we have
@c      `n' clusters (the number of vertices in the graph) numbered from
@c      zero to `n-1'. The first merge created cluster `n', the second
@c      cluster `n'+1, etc.

@c `modularity':
@c      Pointer to a vector. If not NULL then the modularity score of the
@c      current clustering is stored here after each merge operation.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_community_spinglass()' (*note igraph_community_spinglass
@c      --- Community detection based on statistical mechanics::),
@c      `igraph_community_edge_betweenness()' (*note
@c      igraph_community_edge_betweenness --- Community findinf based on
@c      edge betweenness::).

@c    Time complexity: O(|E||V|^2) in the worst case, O(|V|^2 log|V|)
@c typically, |V| is the number of vertices, |E| is the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: Edge betweenness based community detection,  Next: Community structure based on fast greedy optimization of modularity,  Prev: Walktrap; community structure based on random walks,  Up: Detecting Community Structure

@c 17.5 Edge betweenness based community detection
@c ===============================================

@c * Menu:

@c * igraph_community_edge_betweenness --- Community findinf based on edge betweenness::
@c * igraph_community_eb_get_merges --- Calculating the merges, ie. the dendrogram for an edge betweenness community structure: igraph_community_eb_get_merges --- Calculating the merges; ie_ the dendrogram for an edge betweenness community structure.

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_edge_betweenness --- Community findinf based on edge betweenness,  Next: igraph_community_eb_get_merges --- Calculating the merges; ie_ the dendrogram for an edge betweenness community structure,  Up: Edge betweenness based community detection

@c 17.5.1 igraph_community_edge_betweenness -- Community findinf based on edge betweenness
@c ---------------------------------------------------------------------------------------


@c      int igraph_community_edge_betweenness(const igraph_t *graph,
@c      				      igraph_vector_t *result,
@c      				      igraph_vector_t *edge_betweenness,
@c      				      igraph_matrix_t *merges,
@c      				      igraph_vector_t *bridges,
@c      				      igraph_bool_t directed);

@c    Community structure detection based on the betweenness of the edges
@c in the network. The algorithm was invented by M. Girvan and M. Newman,
@c see: M. Girvan and M. E. J. Newman: Community structure in social and
@c biological networks, Proc. Nat. Acad. Sci. USA 99, 7821-7826 (2002).

@c    The idea is that the betweenness of the edges connecting two
@c communities is typically high, as many of the shortest paths between
@c nodes in separate communities go through them. So we gradually remove
@c the edge with highest betweenness from the network, and recalculate
@c edge betweenness after every removal.  This way sooner or later the
@c network falls off to two components, then after a while one of these
@c components falls off to two smaller components, etc. until all edges
@c are removed. This is a divisive hieararchical approach, the result is a
@c dendrogram.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `result':
@c      Pointer to an initialized vector, the result will be stored here,
@c      the ids of the removed edges in the order of their removal. It
@c      will be resized as needed.

@c `edge_betweenness':
@c      Pointer to an initialized vector or NULL. In the former case the
@c      edge betweenness of the removed edge is stored here. The vector
@c      will be resized as needed.

@c `merges':
@c      Pointer to an initialized matrix or NULL. If not NULL then merges
@c      performed by the algorithm are stored here. Even if this is a
@c      divisive algorithm, we can replay it backwards and note which two
@c      clusters were merged. Clusters are numbered from zero, see the
@c      `merges' argument of `igraph_community_walktrap()' (*note
@c      igraph_community_walktrap --- This function is the implementation
@c      of the Walktrap community::) for details. The matrix will be
@c      resized as needed.

@c `bridges':
@c      Pointer to an initialized vector of NULL. If not NULL then all
@c      edge removals which separated the network into more components are
@c      marked here.

@c `directed':
@c      Logical constant, whether to calculate directed betweenness (ie.
@c      directed paths) for directed graphs. It is ignored for undirected
@c      graphs.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_community_eb_get_merges()' (*note
@c      igraph_community_eb_get_merges --- Calculating the merges; ie_ the
@c      dendrogram for an edge betweenness community structure::),
@c      `igraph_community_spinglass()' (*note igraph_community_spinglass
@c      --- Community detection based on statistical mechanics::),
@c      `igraph_community_walktrap()' (*note igraph_community_walktrap ---
@c      This function is the implementation of the Walktrap community::).

@c    Time complexity: O(|V|^3), as the betweenness calculation requires
@c O(|V|^2) and we do it |V|-1 times.

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_eb_get_merges --- Calculating the merges; ie_ the dendrogram for an edge betweenness community structure,  Prev: igraph_community_edge_betweenness --- Community findinf based on edge betweenness,  Up: Edge betweenness based community detection

@c 17.5.2 igraph_community_eb_get_merges -- Calculating the merges, ie. the dendrogram for an edge betweenness community structure
@c -------------------------------------------------------------------------------------------------------------------------------


@c      int igraph_community_eb_get_merges(const igraph_t *graph,
@c      				   const igraph_vector_t *edges,
@c      				   igraph_matrix_t *res,
@c      				   igraph_vector_t *bridges);

@c    This function is handy if you have a sequence of edge which are
@c gradually removed from the network and you would like to know how the
@c network falls apart into separate components. The edge sequence may
@c come from the `igraph_community_edge_betweenness()' (*note
@c igraph_community_edge_betweenness --- Community findinf based on edge
@c betweenness::) function, but this is not neccessary. Note that
@c `igraph_community_edge_betweenness' (*note
@c igraph_community_edge_betweenness --- Community findinf based on edge
@c betweenness::) can also calculate the dendrogram, via its `merges'
@c argument.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `edges':
@c      Vector containing the edges to be removed from the network, all
@c      edges are expected to appear exactly once in the vector.

@c `res':
@c      Pointer to an initialized matrix, if not NULL then the dendrogram
@c      will be stored here, in the same form as for the
@c      `igraph_community_walktrap()' (*note igraph_community_walktrap ---
@c      This function is the implementation of the Walktrap community::)
@c      function: the matrix has two columns and each line is a merge
@c      given by the ids of the merged components. The component ids are
@c      number from zero and component ids smaller than the number of
@c      vertices in the graph belong to individual vertices. The
@c      non-trivial components containing at least two vertices are
@c      numbered from `n', `n' is the number of vertices in the graph. So
@c      if the first line contains `a' and `b' that means that components
@c      `a' and `b' are merged into component `n', the second line creates
@c      component `n'+1, etc. The matrix will be resized as needed.

@c `bridges':
@c      Pointer to an initialized vector or NULL. If not null then the
@c      index of the edge removals which split the network will be stored
@c      here. The vector will be resized as needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_community_edge_betweenness()' (*note
@c      igraph_community_edge_betweenness --- Community findinf based on
@c      edge betweenness::).

@c    Time complexity: O(|E|+|V|log|V|), |V| is the number of vertices,
@c |E| is the number of edges.

@c
@c File: igraph_reference_manual.info,  Node: Community structure based on fast greedy optimization of modularity,  Prev: Edge betweenness based community detection,  Up: Detecting Community Structure

@c 17.6 Community structure based on fast greedy optimization of modularity
@c ========================================================================

@c * Menu:

@c * igraph_community_fastgreedy --- Finding community structure by greedy optimization of modularity::

@c
@c File: igraph_reference_manual.info,  Node: igraph_community_fastgreedy --- Finding community structure by greedy optimization of modularity,  Up: Community structure based on fast greedy optimization of modularity

@c 17.6.1 igraph_community_fastgreedy -- Finding community structure by greedy optimization of modularity
@c ------------------------------------------------------------------------------------------------------


@c      int igraph_community_fastgreedy(const igraph_t *graph,
@c        const igraph_vector_t *weights,
@c        igraph_matrix_t *merges, igraph_vector_t *modularity);

@c    This function implements the fast greedy modularity optimization
@c algorithm for finding community structure, see A Clauset, MEJ Newman, C
@c Moore: Finding community structure in very large networks,
@c http://www.arxiv.org/abs/cond-mat/0408187
@c (http://www.arxiv.org/abs/cond-mat/0408187) for the details.

@c    Some improvements proposed in K Wakita, T Tsurumi: Finding community
@c structure in mega-scale social networks,
@c http://www.arxiv.org/abs/cs.CY/0702048v1
@c (http://www.arxiv.org/abs/cs.CY/0702048v1) have also been implemented.

@c    *Arguments:. *

@c `graph':
@c      The input graph. It must be a simple graph, i.e. a graph without
@c      multiple and without loop edges. This is checked and an error
@c      message is given for non-simple graphs.

@c `weights':
@c      Potentially a numeric vector containing edge weights. Supply a
@c      null pointer here for unweighted graphs. The weights are expected
@c      to be non-negative.

@c `merges':
@c      Pointer to an initialized matrix or NULL, the result of the
@c      computation is stored here. The matrix has two columns and each
@c      merge corresponds to one merge, the ids of the two merged
@c      components are stored. The component ids are numbered from zero and
@c      the first `n' components are the individual vertices, `n' is the
@c      number of vertices in the graph. Component `n' is created in the
@c      first merge, component `n'+1 in the second merge, etc.  The matrix
@c      will be resized as needed. If this argument is NULL then it is
@c      ignored completely.

@c `modularity':
@c      Pointer to an initialized matrix or NULL pointer, in the former
@c      case the modularity scores along the stages of the computation are
@c      recorded here. The vector will be resized as needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_community_walktrap()' (*note igraph_community_walktrap ---
@c      This function is the implementation of the Walktrap community::),
@c      `igraph_community_edge_betweenness()' (*note
@c      igraph_community_edge_betweenness --- Community findinf based on
@c      edge betweenness::) for other community detection algorithms,
@c      `igraph_community_to_membership()' (*note
@c      igraph_community_to_membership --- Create membership vector from
@c      community structure dendrogram::) to convert the dendrogram to a
@c      membership vector.

@c    Time complexity: O(|E||V|log|V|) in the worst case,
@c O(|E|+|V|log^2|V|) typically, |V| is the number of vertices, |E| is the
@c number of edges.

@c
@c File: igraph_reference_manual.info,  Node: Graph Operators,  Next: Using ARPACK for igraph graphs,  Prev: Detecting Community Structure,  Up: Top

@c 18 Graph Operators
@c ******************

@c * Menu:

@c * Union and intersection::
@c * Other set-like operators::

@c
@c File: igraph_reference_manual.info,  Node: Union and intersection,  Next: Other set-like operators,  Up: Graph Operators

@c 18.1 Union and intersection
@c ===========================

@c * Menu:

@c * igraph_disjoint_union --- Creates the union of two disjoint graphs::
@c * igraph_disjoint_union_many --- The disjint union of many graphs.: igraph_disjoint_union_many --- The disjint union of many graphs_.
@c * igraph_union --- Calculates the union of two graphs.: igraph_union --- Calculates the union of two graphs_.
@c * igraph_union_many --- Creates the union of many graphs.: igraph_union_many --- Creates the union of many graphs_.
@c * igraph_intersection --- Collect the common edges from two graphs.: igraph_intersection --- Collect the common edges from two graphs_.
@c * igraph_intersection_many --- The intersection of more than two graphs.: igraph_intersection_many --- The intersection of more than two graphs_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_disjoint_union --- Creates the union of two disjoint graphs,  Next: igraph_disjoint_union_many --- The disjint union of many graphs_,  Up: Union and intersection

@c 18.1.1 igraph_disjoint_union -- Creates the union of two disjoint graphs
@c ------------------------------------------------------------------------


@c      int igraph_disjoint_union(igraph_t *res, const igraph_t *left,
@c      			  const igraph_t *right);

@c    First the vertices of the second graph will be relabeled with new
@c vertex ids to have two disjoint sets of vertex ids, then the union of
@c the two graphs will be formed.  If the two graphs have |V1| and |V2|
@c vertices and |E1| and |E2| edges respectively then the new graph will
@c have |V1|+|V2| vertices and |E1|+|E2| edges.

@c    Both graphs need to have the same directedness, ie. either both
@c directed or both undirected.

@c    The current version of this function cannot handle graph, vertex and
@c edge attributes, they will be lost.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object, the result will stored
@c      here.

@c `left':
@c      The first graph.

@c `right':
@c      The second graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_disjoint_union_many()' (*note igraph_disjoint_union_many
@c      --- The disjint union of many graphs_::) for creating the disjoint
@c      union of more than two graphs, `igraph_union()' (*note
@c      igraph_union --- Calculates the union of two graphs_::) for
@c      non-disjoint union.

@c    Time complexity: O(|V1|+|V2|+|E1|+|E2|).

@c
@c File: igraph_reference_manual.info,  Node: igraph_disjoint_union_many --- The disjint union of many graphs_,  Next: igraph_union --- Calculates the union of two graphs_,  Prev: igraph_disjoint_union --- Creates the union of two disjoint graphs,  Up: Union and intersection

@c 18.1.2 igraph_disjoint_union_many -- The disjint union of many graphs.
@c ----------------------------------------------------------------------


@c      int igraph_disjoint_union_many(igraph_t *res,
@c      			       const igraph_vector_ptr_t *graphs);

@c    First the vertices in the graphs will be relabed with new vertex ids
@c to have pairwise disjoint vertex id sets and then the union of the
@c graphs is formed.  The number of vertices and edges in the result is
@c the total number of vertices and edges in the graphs.

@c    Both graphs need to have the same directedness, ie. either both
@c directed or both undirected.

@c    The current version of this function cannot handle graph, vertex and
@c edge attributes, they will be lost.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object, the result of the
@c      operation will be stored here.

@c `graphs':
@c      Pointer vector, contains pointers to initialized graph objects.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_disjoint_union()' (*note igraph_disjoint_union --- Creates
@c      the union of two disjoint graphs::) for an easier syntax if you
@c      have only two graphs, `igraph_union_many()' (*note
@c      igraph_union_many --- Creates the union of many graphs_::) for
@c      non-disjoint union.

@c    Time complexity: O(|V|+|E|), the number of vertices plus the number
@c of edges in the result.

@c
@c File: igraph_reference_manual.info,  Node: igraph_union --- Calculates the union of two graphs_,  Next: igraph_union_many --- Creates the union of many graphs_,  Prev: igraph_disjoint_union_many --- The disjint union of many graphs_,  Up: Union and intersection

@c 18.1.3 igraph_union -- Calculates the union of two graphs.
@c ----------------------------------------------------------


@c      int igraph_union(igraph_t *res,
@c      		 const igraph_t *left, const igraph_t *right);

@c    The number of vertices in the result is that of the larger graph
@c from the two arguments. The result graph contains edges which are
@c present in at least one of the operand graphs.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object, the result will be
@c      stored here.

@c `left':
@c      The first graph.

@c `right':
@c      The second graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_union_many()' (*note igraph_union_many --- Creates the
@c      union of many graphs_::) for the union of many graphs,
@c      `igraph_intersection()' (*note igraph_intersection --- Collect the
@c      common edges from two graphs_::) and `igraph_difference()' (*note
@c      igraph_difference --- Calculate the difference of two graphs::)
@c      for other operators.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| the
@c number of edges in the result graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_union_many --- Creates the union of many graphs_,  Next: igraph_intersection --- Collect the common edges from two graphs_,  Prev: igraph_union --- Calculates the union of two graphs_,  Up: Union and intersection

@c 18.1.4 igraph_union_many -- Creates the union of many graphs.
@c -------------------------------------------------------------


@c      int igraph_union_many(igraph_t *res, const igraph_vector_ptr_t *graphs);

@c    The result graph will contain as many vertices as the largest graph
@c among the agruments does, and an edge will be included in it if it is
@c part of at least one operand graph.

@c    The directedness of the operand graphs must be the same.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object, this will contain the
@c      result.

@c `graphs':
@c      Pointer vector, contains pointers to the operands of the union
@c      operator, graph objects of course.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_union()' (*note igraph_union --- Calculates the union of
@c      two graphs_::) for the union of two graphs,
@c      `igraph_intersection_many()' (*note igraph_intersection_many ---
@c      The intersection of more than two graphs_::),
@c      `igraph_intersection()' (*note igraph_intersection --- Collect the
@c      common edges from two graphs_::) and `igraph_difference' (*note
@c      igraph_difference --- Calculate the difference of two graphs::)
@c      for other operators.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices in
@c largest graph and |E| is the number of edges in the result graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_intersection --- Collect the common edges from two graphs_,  Next: igraph_intersection_many --- The intersection of more than two graphs_,  Prev: igraph_union_many --- Creates the union of many graphs_,  Up: Union and intersection

@c 18.1.5 igraph_intersection -- Collect the common edges from two graphs.
@c -----------------------------------------------------------------------


@c      int igraph_intersection(igraph_t *res,
@c      			const igraph_t *left, const igraph_t *right);

@c    The result graph contains only edges present both in the first and
@c the second graph. The number of vertices in the result graph is the
@c same as the larger from the two arguments.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object. This will contain the
@c      result of the operation.

@c `left':
@c      The first operand, a graph object.

@c `right':
@c      The second operand, a graph object.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_intersection_many()' (*note igraph_intersection_many ---
@c      The intersection of more than two graphs_::) to calculate the
@c      intersection of many graphs at once, `igraph_union()' (*note
@c      igraph_union --- Calculates the union of two graphs_::),
@c      `igraph_difference()' (*note igraph_difference --- Calculate the
@c      difference of two graphs::) for other operators.

@c    Time complexity: O(|V|+|E|), |V| is the number of nodes, |E| is the
@c number of edges in the smaller graph of the two. (The one containing
@c less vertices is considered smaller.)

@c
@c File: igraph_reference_manual.info,  Node: igraph_intersection_many --- The intersection of more than two graphs_,  Prev: igraph_intersection --- Collect the common edges from two graphs_,  Up: Union and intersection

@c 18.1.6 igraph_intersection_many -- The intersection of more than two graphs.
@c ----------------------------------------------------------------------------


@c      int igraph_intersection_many(igraph_t *res,
@c      			     const igraph_vector_ptr_t *graphs);

@c    This function calculates the intersection of the graphs stored in
@c the `graphs' argument. Only those edges will be included in the result
@c graph which are part of every graph in `graphs'.

@c    The number of vertices in the result graph will be the maximum
@c number of vertices in the argument graphs.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object, the result of the
@c      operation will be stored here.

@c `graphs':
@c      Pointer vector, contains pointers to graphs objects, the operands
@c      of the intersection operator.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_intersection()' (*note igraph_intersection --- Collect the
@c      common edges from two graphs_::) for the intersection of two
@c      graphs, `igraph_union_many()' (*note igraph_union_many --- Creates
@c      the union of many graphs_::), `igraph_union()' (*note igraph_union
@c      --- Calculates the union of two graphs_::) and
@c      `igraph_difference()' (*note igraph_difference --- Calculate the
@c      difference of two graphs::) for other operators.

@c    Time complexity: O(|V|+|E|), |V| is the number of vertices, |E| is
@c the number of edges in the smallest graph (ie. the graph having the
@c less vertices).

@c
@c File: igraph_reference_manual.info,  Node: Other set-like operators,  Prev: Union and intersection,  Up: Graph Operators

@c 18.2 Other set-like operators
@c =============================

@c * Menu:

@c * igraph_difference --- Calculate the difference of two graphs::
@c * igraph_complementer --- Create the complementer of a graph::
@c * igraph_compose --- Calculates the composition of two graphs::

@c
@c File: igraph_reference_manual.info,  Node: igraph_difference --- Calculate the difference of two graphs,  Next: igraph_complementer --- Create the complementer of a graph,  Up: Other set-like operators

@c 18.2.1 igraph_difference -- Calculate the difference of two graphs
@c ------------------------------------------------------------------


@c      int igraph_difference(igraph_t *res,
@c      		      const igraph_t *orig, const igraph_t *sub);

@c    The number of vertices in the result is the number of vertices in
@c the original graph, ie. the left, first operand. In the results graph
@c only edges will be included from `orig' which are not present in `sub'.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object, the result will be
@c      stored here.

@c `orig':
@c      The left operand of the operator, a graph object.

@c `sub':
@c      The right operand of the operator, a graph object.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_intersection()' (*note igraph_intersection --- Collect the
@c      common edges from two graphs_::) and `igraph_union()' (*note
@c      igraph_union --- Calculates the union of two graphs_::) for other
@c      operators.

@c    Time complexity: O(|V|+|E|), |V| is the number vertices in the
@c smaller graph, |E| is the number of edges in the result graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_complementer --- Create the complementer of a graph,  Next: igraph_compose --- Calculates the composition of two graphs,  Prev: igraph_difference --- Calculate the difference of two graphs,  Up: Other set-like operators

@c 18.2.2 igraph_complementer -- Create the complementer of a graph
@c ----------------------------------------------------------------


@c      int igraph_complementer(igraph_t *res, const igraph_t *graph,
@c      			igraph_bool_t loops);

@c    The complementer graph means that all edges which are not part of
@c the original graph will be included in the result.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object.

@c `graph':
@c      The original graph.

@c `loops':
@c      Whether to add loop edges to the complementer graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_union()' (*note igraph_union --- Calculates the union of
@c      two graphs_::), `igraph_intersection()' (*note igraph_intersection
@c      --- Collect the common edges from two graphs_::) and
@c      `igraph_difference()' (*note igraph_difference --- Calculate the
@c      difference of two graphs::).

@c    Time complexity: O(|V|+|E1|+|E2|), |V| is the number of vertices in
@c the graph, |E1| is the number of edges in the original and |E2| in the
@c complementer graph.

@c
@c File: igraph_reference_manual.info,  Node: igraph_compose --- Calculates the composition of two graphs,  Prev: igraph_complementer --- Create the complementer of a graph,  Up: Other set-like operators

@c 18.2.3 igraph_compose -- Calculates the composition of two graphs
@c -----------------------------------------------------------------


@c      int igraph_compose(igraph_t *res, const igraph_t *g1, const igraph_t *g2);

@c    The composition of graphs contains the same number of vertices as
@c the bigger graph of the two operands. It contains an (i,j) edge if and
@c only if there is a k vertex, such that the first graphs contains an
@c (i,k) edge and the second graph a (k,j) edge.

@c    This is of course exactly the composition of two binary relations.

@c    Two two graphs must have the same directedness, otherwise the
@c function returns with an error message.  Note that for undirected
@c graphs the two relations are by definition symmetric.

@c    *Arguments:. *

@c `res':
@c      Pointer to an uninitialized graph object, the result will be
@c      stored here.

@c `g1':
@c      The firs operarand, a graph object.

@c `g2':
@c      The second operand, another graph object.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|*d1*d2), |V| is the number of vertices in the
@c first graph, d1 and d2 the average degree in the first and second
@c graphs.

@c
@c File: igraph_reference_manual.info,  Node: Using ARPACK for igraph graphs,  Next: Bipartite; i_e_ two-mode graphs,  Prev: Graph Operators,  Up: Top

@c 19 Using ARPACK for igraph graphs
@c *********************************

@c * Menu:

@c * About the ARPACK interface in igraph::
@c * Data structures::
@c * ARPACK solvers::

@c
@c File: igraph_reference_manual.info,  Node: About the ARPACK interface in igraph,  Next: Data structures,  Up: Using ARPACK for igraph graphs

@c 19.1 About the ARPACK interface in igraph
@c =========================================

@c ARPACK is a library for solving large scale eigenvalue problems.  The
@c package is designed to compute a few eigenvalues and corresponding
@c eigenvectors of a general `n' by `n' matrix `A'. It is most appropriate
@c for large sparse or structured matrices `A' where structured means that
@c a matrix-vector product ` w <- Av'  requires order `n' rather than the
@c usual order ` n^2'  floating point operations. Please see
@c http://www.caam.rice.edu/software/ARPACK/
@c (http://www.caam.rice.edu/software/ARPACK/) for details.

@c    The eigenvalue calculation in ARPACK (in the simplest case) involves
@c the calculation of the `Av' product where `A' is the matrix we work
@c with and `v' is an arbitrary vector. A user-defined function of type
@c `igraph_arpack_function_t' (*note igraph_arpack_function_t --- Type of
@c the ARPACK callback function::) is expected to perform this product. If
@c the product can be done efficiently, e.g. if the matrix is sparse, then
@c ARPACK is usually able to calculate the eigenvalues very quickly.

@c    In igraph, eigenvalue/eigenvector calculations usually involve the
@c following steps:

@c   1. Initialization of an `igraph_arpack_options_t' (*note
@c      igraph_arpack_options_t --- Options for ARPACK::) data structure
@c      using `igraph_arpack_options_init' (*note
@c      igraph_arpack_options_init --- Initialize ARPACK options::).

@c   2. Setting some options in the initialized `igraph_arpack_options_t'
@c      (*note igraph_arpack_options_t --- Options for ARPACK::) object.

@c   3. Defining a function of type `igraph_arpack_function_t' (*note
@c      igraph_arpack_function_t --- Type of the ARPACK callback
@c      function::).  The input of this function is a vector, and the
@c      output should be the output matrix multiplied by the input vector.

@c   4. Calling `igraph_arpack_rssolve()' (*note igraph_arpack_rssolve ---
@c      ARPACK solver for symmetric matrices::) (is the matrix is
@c      symmetric), or `igraph_arpack_rnsolve()' (*note
@c      igraph_arpack_rnsolve --- ARPACK solver for non-symmetric
@c      matrices::).

@c The `igraph_arpack_options_t' (*note igraph_arpack_options_t ---
@c Options for ARPACK::) object can be used multiple times.

@c    If we have many eigenvalue problems to solve, then it might worth to
@c create an `igraph_arpack_storage_t' (*note igraph_arpack_storage_t ---
@c Storage for ARPACK::) object, and initialize it via
@c `igraph_arpack_storage_init()' (*note igraph_arpack_storage_init ---
@c Initialize ARPACK storage::). This structure contains all memory needed
@c for ARPACK (with the given upper limit regerding to the size of the
@c eigenvalue problem). Then many problems can be solved using the same
@c `igraph_arpack_storage_t' (*note igraph_arpack_storage_t --- Storage
@c for ARPACK::) object, without always reallocating the required memory.
@c The `igraph_arpack_storage_t' (*note igraph_arpack_storage_t ---
@c Storage for ARPACK::) object needs to be destroyed by calling
@c `igraph_arpack_storage_destroy()' (*note igraph_arpack_storage_destroy
@c --- Deallocate ARPACK storage::) on it, when it is not needed any more.

@c    igraph does not contain all ARPACK routines, only the ones dealing
@c with symmetric and non-symmetric eigenvalue problems using double
@c precision real numbers.

@c
@c File: igraph_reference_manual.info,  Node: Data structures,  Next: ARPACK solvers,  Prev: About the ARPACK interface in igraph,  Up: Using ARPACK for igraph graphs

@c 19.2 Data structures
@c ====================

@c * Menu:

@c * igraph_arpack_options_t --- Options for ARPACK::
@c * igraph_arpack_storage_t --- Storage for ARPACK::
@c * igraph_arpack_function_t --- Type of the ARPACK callback function::
@c * igraph_arpack_options_init --- Initialize ARPACK options::
@c * igraph_arpack_storage_init --- Initialize ARPACK storage::
@c * igraph_arpack_storage_destroy --- Deallocate ARPACK storage::

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_options_t --- Options for ARPACK,  Next: igraph_arpack_storage_t --- Storage for ARPACK,  Up: Data structures

@c 19.2.1 igraph_arpack_options_t -- Options for ARPACK
@c ----------------------------------------------------


@c      typedef struct igraph_arpack_options_t {
@c        /* INPUT */
@c        char bmat[1];			/* I-standard problem, G-generalized */
@c        long int n; 			/* Dimension of the eigenproblem */
@c        char which[2];		/* LA, SA, LM, SM, BE */
@c        long int nev;                 /* Number of eigenvalues to be computed */
@c        igraph_real_t tol;		/* Stopping criterion */
@c        long int ncv;			/* Number of columns in V */
@c        long int ldv;			/* Leading dimension of V */
@c        long int ishift;		/* 0-reverse comm., 1-exact with tridiagonal */
@c        long int mxiter;              /* Maximum number of update iterations to take */
@c        long int nb;			/* Block size on the recurrence, only 1 works */
@c        long int mode;		/* The kind of problem to be solved (1-5)
@c      				   1: A*x=l*x, A symmetric
@c      				   2: A*x=l*M*x, A symm. M pos. def.
@c      				   3: K*x = l*M*x, K symm., M pos. semidef.
@c      				   4: K*x = l*KG*x, K s. pos. semidef. KG s. indef.
@c      				   5: A*x = l*M*x, A symm., M symm. pos. semidef. */
@c        long int start;		/* 0: random, 1: use the supplied vector */
@c        long int lworkl;		/* Size of temporary storage, default is fine */
@c        igraph_real_t sigma;          /* The shift for modes 3,4,5 */
@c        igraph_real_t sigmai;		/* The imaginary part of shift for rnsolve */
@c        /* OUTPUT */
@c        long int info;		/* What happened, see docs */
@c        long int ierr;		/* What happened  in the dseupd call */
@c        long int noiter;		/* The number of iterations taken */
@c        long int nconv;
@c        long int numop;		/* Number of OP*x operations */
@c        long int numopb;		/* Number of B*x operations if BMAT='G' */
@c        long int numreo;		/* Number of steps of re-orthogonalizations */
@c        /* INTERNAL */
@c        long int iparam[11];
@c        long int ipntr[14];
@c      } igraph_arpack_options_t;

@c    This data structure contains the options of thee ARPACK eigenvalue
@c solver routines. It must be initialized by calling
@c `igraph_arpack_options_init()' (*note igraph_arpack_options_init ---
@c Initialize ARPACK options::) on it. Then it can be used for multiple
@c ARPACK calls, as the ARPACK solvers do not modify it.  Input options:

@c    *Values:. *

@c `bmat':
@c      Character. Whether to solve a standard ('I') ot a generalized
@c      problem ('B').

@c `n':
@c      Dimension of the eigenproblem.

@c `which':
@c      Specifies which eigenvalues/vectors to compute. Possible values
@c      for symmetric matrices:

@c     `LA '
@c           Compute `nev' largest (algebraic) eigenvalues.

@c     `SA '
@c           Compute `nev' smallest (algebraic) eigenvalues.

@c     `LM '
@c           Compute `nev' largest (in magnitude) eigenvalues.

@c     `SM '
@c           Compute `nev' smallest (in magnitude) eigenvalues.

@c     `BE '
@c           Compute `nev' eigenvalues, half from each end of the
@c           spectrum. When `nev' is odd, compute one more from the high
@c           en than from the low end.

@c      Possible values for non-symmetric matrices:

@c     `LM '
@c           Compute `nev' largest (in magnitude) eigenvalues.

@c     `SM '
@c           Compute `nev' smallest (in magnitude) eigenvalues.

@c     `LR '
@c           Compute `nev' eigenvalues of largest real part.

@c     `SR '
@c           Compute `nev' eigenvalues of smallest real part.

@c     `LI '
@c           Compute `nev' eigenvalues of largest imaginary part.

@c     `SI '
@c           Compute `nev' eigenvalues of smallest imaginary part.

@c `nev':
@c      The number of eigenvalues to be computed.

@c `tol':
@c      Stopping criterion: the relative accuracy of the Ritz value is
@c      considered acceptable if its error is less than `tol' times its
@c      estimated value. If this is set to zero then machine precision is
@c      used.

@c `ncv':
@c      Number of Lanczos vectors to be generated.

@c `ldv':
@c      Numberic scalar. It should be set to zero in the current igraph
@c      implementation.

@c `ishift':
@c      Either zero or one. If zero then the shifts are provided by the
@c      user via reverse communication. If one then exact shifts with
@c      respect to the reduced tridiagonal matrix `T'.  Please always set
@c      this to one.

@c `mxiter':
@c      Maximum number of Arnoldi update iterations allowed.

@c `nb':
@c      Blocksize to be used in the recurrence. Please always leave this
@c      on the default value, one.

@c `mode':
@c      The type of the eigenproblem to be solved.  Possible values if the
@c      input matrix is symmetric:

@c        1. A*x=lambda*x, A is symmetric.

@c        2. A*x=lambda*M*x, A is symmetric, M is symmetric positive
@c           definite.

@c        3. K*x=lambda*M*x, K is symmetric, M is symmetric positive
@c           semi-definite.

@c        4. K*x=lambda*KG*x, K is symmetric positive semi-definite, KG is
@c           symmetric indefinite.

@c        5. A*x=lambda*M*x, A is symmetric, M is symmetric positive
@c           semi-definite. (Cayley transformed mode.)

@c      Please note that only `mode' ==1 was tested and other values might
@c      not work properly.  Possible values if the input matrix is not
@c      symmetric:

@c        1. A*x=lambda*x.

@c        2. A*x=lambda*M*x, M is symmetric positive definite.

@c        3. A*x=lambda*M*x, M is symmetric semi-definite.

@c        4. A*x=lambda*M*x, M is symmetric semi-definite.

@c      Please note that only `mode' == 1 was tested and other values
@c      might not work properly.

@c `start':
@c      Whether to use the supplied starting vector (1), or use a random
@c      starting vector (0). The starting vector must be supplied in the
@c      first column of the `vectors' argument of the
@c      `igraph_arpack_rssolve()' (*note igraph_arpack_rssolve --- ARPACK
@c      solver for symmetric matrices::) of `igraph_arpack_rnsolve()'
@c      (*note igraph_arpack_rnsolve --- ARPACK solver for non-symmetric
@c      matrices::) call.

@c    Output options:

@c    *Values:. *

@c `info':
@c      Error flag of ARPACK. Possible values:

@c     `0 '
@c           Normal exit.

@c     `1 '
@c           Maximum number of iterations taken.

@c     `3 '
@c           No shifts could be applied during a cycle of the Implicitly
@c           restarted Arnoldi iteration. One possibility is to increase
@c           the size of \ ncv relative to `nev'.

@c      ARPACK can return other error flags as well, but these are
@c      converted to igraph errors, see `igraph_error_type_t' (*note
@c      igraph_error_type_t --- Error code type_::).

@c `ierr':
@c      Error flag of the second ARPACK call (one eigenvalue computation
@c      usually involves two calls to ARPACK). This is always zero, as
@c      other error codes are converted to igraph errors.

@c `noiter':
@c      Number of Arnoldi iterations taken.

@c `nconv':
@c      Number of converged Ritz values. This represents the number of
@c      Ritz values that satisfy the convergence critetion.

@c `numop':
@c      Total number of matrix-vector multiplications.

@c `numopb':
@c      Not used currently.

@c `numreo':
@c      Total number of steps of re-orthogonalization.

@c    Internal options:

@c    *Values:. *

@c `lworkl':
@c      Do not modify this option.

@c `sigma':
@c      Do not modify this option.

@c `sigmai':
@c      Do not modify this option.

@c `iparam':
@c      Do not modify this option.

@c `ipntr':
@c      Do not modify this option.

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_storage_t --- Storage for ARPACK,  Next: igraph_arpack_function_t --- Type of the ARPACK callback function,  Prev: igraph_arpack_options_t --- Options for ARPACK,  Up: Data structures

@c 19.2.2 igraph_arpack_storage_t -- Storage for ARPACK
@c ----------------------------------------------------


@c      typedef struct igraph_arpack_storage_t {
@c        long int maxn, maxncv, maxldv;
@c        igraph_real_t *v;
@c        igraph_real_t *workl;
@c        igraph_real_t *workd;
@c        igraph_real_t *d;
@c        igraph_real_t *resid;
@c        igraph_real_t *ax;
@c        long int *select;
@c        igraph_real_t *di;		/* These two only for non-symmetric problems */
@c        igraph_real_t *workev;
@c      } igraph_arpack_storage_t;

@c    Public members, do not modify them directly, these are considered to
@c be read-only.

@c    *Values:. *

@c `maxn':
@c      Maximum rank of matrix.

@c `maxncv':
@c      Maximum NCV.

@c `maxldv':
@c      Maximum LDV.

@c    These members are considered to be private:

@c    *Values:. *

@c `workl':
@c      Working memory.

@c `workd':
@c      Working memory.

@c `d':
@c      Memory for eigenvalues.

@c `resid':
@c      Memory for residuals.

@c `ax':
@c      Working memory.

@c `select':
@c      Working memory.

@c `di':
@c      Memory for eigenvalues, non-symmetric case only.

@c `workev':
@c      Working memory, non-symmetric case only.

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_function_t --- Type of the ARPACK callback function,  Next: igraph_arpack_options_init --- Initialize ARPACK options,  Prev: igraph_arpack_storage_t --- Storage for ARPACK,  Up: Data structures

@c 19.2.3 igraph_arpack_function_t -- Type of the ARPACK callback function
@c -----------------------------------------------------------------------


@c      typedef int igraph_arpack_function_t(igraph_real_t *to, const igraph_real_t *from,
@c      				     long int n, void *extra);

@c    *Arguments:. *

@c `to':
@c      Pointer to an `igraph_real_t', the result of the matrix-vector
@c      product is expected to be stored here.

@c `from':
@c      Pointer to an `igraph_real_t', the input matrix should be
@c      multiplied by the vector stored here.

@c `n':
@c      The length of the vector (which is the same as the order of the
@c      input matrix).

@c `extra':
@c      Extra argument to the matrix-vector calculation function. This is
@c      coming from the `igraph_arpack_rssolve()' (*note
@c      igraph_arpack_rssolve --- ARPACK solver for symmetric matrices::)
@c      or `igraph_arpack_rnsolve()' (*note igraph_arpack_rnsolve ---
@c      ARPACK solver for non-symmetric matrices::) function.

@c    *Returns:. *

@c `'
@c      Error code, if not zero, then the ARPACK solver considers this as
@c      an error, stops and calls the igraph error handler.

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_options_init --- Initialize ARPACK options,  Next: igraph_arpack_storage_init --- Initialize ARPACK storage,  Prev: igraph_arpack_function_t --- Type of the ARPACK callback function,  Up: Data structures

@c 19.2.4 igraph_arpack_options_init -- Initialize ARPACK options
@c --------------------------------------------------------------


@c      void igraph_arpack_options_init(igraph_arpack_options_t *o);

@c    Initializes ARPACK options, set them to default values.  You can
@c always pass the initialized `igraph_arpack_options_t' (*note
@c igraph_arpack_options_t --- Options for ARPACK::) object to built-in
@c igraph functions without any modification. The built-in igraph
@c functions modify the options to perform their calculation, e.g.
@c `igraph_pagerank()' (*note igraph_pagerank --- Calculates the Google
@c PageRank for the specified vertices_::) always searches for the
@c eigenvalue with the largest magnitude, regardless of the supplied value.

@c    If you want to implement your own function involving eigenvalue
@c calculation using ARPACK, however, you will likely need to set up the
@c fields for yourself.

@c    *Arguments:. *

@c `o':
@c      The `igraph_arpack_options_t' (*note igraph_arpack_options_t ---
@c      Options for ARPACK::) object to initialize.

@c    Time complexity: O(1).

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_storage_init --- Initialize ARPACK storage,  Next: igraph_arpack_storage_destroy --- Deallocate ARPACK storage,  Prev: igraph_arpack_options_init --- Initialize ARPACK options,  Up: Data structures

@c 19.2.5 igraph_arpack_storage_init -- Initialize ARPACK storage
@c --------------------------------------------------------------


@c      int igraph_arpack_storage_init(igraph_arpack_storage_t *s, long int maxn,
@c      			       long int maxncv, long int maxldv,
@c      			       igraph_bool_t symm);

@c    You only need this function if you want to run multiple eigenvalue
@c calculations using ARPACK, and want to spare the memory
@c allocation/deallocation between each two runs. Otherwise it is safe to
@c supply a null pointer as the `storage' argument of both
@c `igraph_arpack_rssolve()' (*note igraph_arpack_rssolve --- ARPACK
@c solver for symmetric matrices::) and `igraph_arpack_rnsolve()' (*note
@c igraph_arpack_rnsolve --- ARPACK solver for non-symmetric matrices::)
@c to make memory allocated and deallocated automatically.

@c    Don't forget to call the `igraph_arpack_storage_destroy()' (*note
@c igraph_arpack_storage_destroy --- Deallocate ARPACK storage::) function
@c on the storage object if you don't need it any more.

@c    *Arguments:. *

@c `s':
@c      The `igraph_arpack_storage_t' (*note igraph_arpack_storage_t ---
@c      Storage for ARPACK::) object to initialize.

@c `maxn':
@c      The maximum order of the matrices.

@c `maxncv':
@c      The maximum NCV parameter intended to use.

@c `maxldv':
@c      The maximum LDV parameter intended to use.

@c `symm':
@c      Whether symmetric or non-symmetric problems will be solved using
@c      this `igraph_arpack_storage_t' (*note igraph_arpack_storage_t ---
@c      Storage for ARPACK::). (You cannot use the same storage both with
@c      symmetric and non-symmetric solvers.)

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(maxncv*(maxldv+maxn)).

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_storage_destroy --- Deallocate ARPACK storage,  Prev: igraph_arpack_storage_init --- Initialize ARPACK storage,  Up: Data structures

@c 19.2.6 igraph_arpack_storage_destroy -- Deallocate ARPACK storage
@c -----------------------------------------------------------------


@c      void igraph_arpack_storage_destroy(igraph_arpack_storage_t *s);

@c    *Arguments:. *

@c `s':
@c      The `igraph_arpack_storage_t' (*note igraph_arpack_storage_t ---
@c      Storage for ARPACK::) object for which the memory will be
@c      deallocated.

@c    Time complexity: operating system dependent.

@c
@c File: igraph_reference_manual.info,  Node: ARPACK solvers,  Prev: Data structures,  Up: Using ARPACK for igraph graphs

@c 19.3 ARPACK solvers
@c ===================

@c * Menu:

@c * igraph_arpack_rssolve --- ARPACK solver for symmetric matrices::
@c * igraph_arpack_rnsolve --- ARPACK solver for non-symmetric matrices::
@c * igraph_arpack_unpack_complex --- Make the result of the non-symmetric ARPACK solver more readable::

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_rssolve --- ARPACK solver for symmetric matrices,  Next: igraph_arpack_rnsolve --- ARPACK solver for non-symmetric matrices,  Up: ARPACK solvers

@c 19.3.1 igraph_arpack_rssolve -- ARPACK solver for symmetric matrices
@c --------------------------------------------------------------------


@c      int igraph_arpack_rssolve(igraph_arpack_function_t *fun, void *extra,
@c      			  igraph_arpack_options_t *options,
@c      			  igraph_arpack_storage_t *storage,
@c      			  igraph_vector_t *values, igraph_matrix_t *vectors);

@c    This is the ARPACK solver for symmetric matrices. Please use
@c `igraph_arpack_rnsolve()' (*note igraph_arpack_rnsolve --- ARPACK
@c solver for non-symmetric matrices::) for non-symmetric matrices.

@c    *Arguments:. *

@c `fun':
@c      Pointer to an `igraph_arpack_function_t' (*note
@c      igraph_arpack_function_t --- Type of the ARPACK callback
@c      function::) object, the function that performs the matrix-vector
@c      multiplication.

@c `extra':
@c      An extra argument to be passed to `fun'.

@c `options':
@c      An `igraph_arpack_options_t' (*note igraph_arpack_options_t ---
@c      Options for ARPACK::) object.

@c `storage':
@c      An `igraph_arpack_storage_t' (*note igraph_arpack_storage_t ---
@c      Storage for ARPACK::) object, or a null pointer. In the latter
@c      case memory allocation and deallocation is performed automatically.

@c `values':
@c      If not a null pointer, then it should be a pointer to an
@c      initialized vector. The eigenvalues will be stored here. The
@c      vector will be resized as needed.

@c `vectors':
@c      If not a null pointer, then it must be a pointer to an initialized
@c      matrix. The eigenvectors will be stored in the columns of the
@c      matrix. The matrix will be resized as needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: depends on the matrix-vector multiplication.
@c Usually a small number of iterations is enough, so if the matrix is
@c sparse and the matrix-vector multiplication can be done in O(n) time
@c (the number of vertices), then the eigenvalues are found in O(n) time
@c as well.

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_rnsolve --- ARPACK solver for non-symmetric matrices,  Next: igraph_arpack_unpack_complex --- Make the result of the non-symmetric ARPACK solver more readable,  Prev: igraph_arpack_rssolve --- ARPACK solver for symmetric matrices,  Up: ARPACK solvers

@c 19.3.2 igraph_arpack_rnsolve -- ARPACK solver for non-symmetric matrices
@c ------------------------------------------------------------------------


@c      int igraph_arpack_rnsolve(igraph_arpack_function_t *fun, void *extra,
@c      			  igraph_arpack_options_t *options,
@c      			  igraph_arpack_storage_t *storage,
@c      			  igraph_matrix_t *values, igraph_matrix_t *vectors);

@c    Please always consider calling `igraph_arpack_rssolve()' (*note
@c igraph_arpack_rssolve --- ARPACK solver for symmetric matrices::) if
@c your matrix is symmetric, it is much faster.  `igraph_arpack_rnsolve()'
@c (*note igraph_arpack_rnsolve --- ARPACK solver for non-symmetric
@c matrices::) for non-symmetric matrices.

@c    *Arguments:. *

@c `fun':
@c      Pointer to an `igraph_arpack_function_t' (*note
@c      igraph_arpack_function_t --- Type of the ARPACK callback
@c      function::) object, the function that performs the matrix-vector
@c      multiplication.

@c `extra':
@c      An extra argument to be passed to `fun'.

@c `options':
@c      An `igraph_arpack_options_t' (*note igraph_arpack_options_t ---
@c      Options for ARPACK::) object.

@c `storage':
@c      An `igraph_arpack_storage_t' (*note igraph_arpack_storage_t ---
@c      Storage for ARPACK::) object, or a null pointer. In the latter
@c      case memory allocation and deallocation is performed automatically.

@c `values':
@c      If not a null pointer, then it should be a pointer to an
@c      initialized matrix. The (possibly complex) eigenvalues will be
@c      stored here. The matrix will have two columns, the first column
@c      contains the real, the second the imaginary parts of the
@c      eigenvalues.  The matrix will be resized as needed.

@c `vectors':
@c      If not a null pointer, then it must be a pointer to an initialized
@c      matrix. The eigenvectors will be stored in the columns of the
@c      matrix. The matrix will be resized as needed.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: depends on the matrix-vector multiplication.
@c Usually a small number of iterations is enough, so if the matrix is
@c sparse and the matrix-vector multiplication can be done in O(n) time
@c (the number of vertices), then the eigenvalues are found in O(n) time
@c as well.

@c
@c File: igraph_reference_manual.info,  Node: igraph_arpack_unpack_complex --- Make the result of the non-symmetric ARPACK solver more readable,  Prev: igraph_arpack_rnsolve --- ARPACK solver for non-symmetric matrices,  Up: ARPACK solvers

@c 19.3.3 igraph_arpack_unpack_complex -- Make the result of the non-symmetric ARPACK solver more readable
@c -------------------------------------------------------------------------------------------------------


@c      int igraph_arpack_unpack_complex(igraph_matrix_t *vectors, igraph_matrix_t *values,
@c      				 long int nev);

@c    This function works on the output of `igraph_arpack_rnsolve' (*note
@c igraph_arpack_rnsolve --- ARPACK solver for non-symmetric matrices::)
@c and brushes it up a bit: it only keeps `nev' eigenvalues/vectors and
@c every eigenvector is stored in two columns of the `vectors' matrix.

@c    The output of the non-symmetric ARPACK solver is somewhat hard to
@c parse, as real eigenvectors occupy only one column in the matrix, and
@c the complex conjugate eigenvectors are not stored at all (usually). The
@c other problem is that the solver might return more eigenvalues than
@c requested. The common use of this function is to call it directly after
@c `igraph_arpack_rnsolve' (*note igraph_arpack_rnsolve --- ARPACK solver
@c for non-symmetric matrices::) with its `vectors' and `values' argument
@c and `options'->nev as `nev'.

@c    *Arguments:. *

@c `vectors':
@c      The eigenvector matrix, as returned by `igraph_arpack_rnsolve'
@c      (*note igraph_arpack_rnsolve --- ARPACK solver for non-symmetric
@c      matrices::). It will be resized, typically it will be larger.

@c `values':
@c      The eigenvalue matrix, as returned by `igraph_arpack_rnsolve'
@c      (*note igraph_arpack_rnsolve --- ARPACK solver for non-symmetric
@c      matrices::). It will be resized, typically extra, unneeded rows
@c      (=eigenvalues) will be removed.

@c `nev':
@c      The number of eigenvalues/vectors to keep. Can be less or equal
@c      than the number originally requested from ARPACK.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: linear in the number of elements in the `vectors'
@c matrix.

@c
@c File: igraph_reference_manual.info,  Node: Bipartite; i_e_ two-mode graphs,  Next: Not Graph Related Functions,  Prev: Using ARPACK for igraph graphs,  Up: Top

@c 20 Bipartite, i.e. two-mode graphs
@c **********************************

@c * Menu:

@c * Bipartite networks in igraph::
@c * Create two-mode networks::
@c * Incidence matrices::
@c * Project a two-mode graphs::
@c * Other operations on bipartite graphs::

@c
@c File: igraph_reference_manual.info,  Node: Bipartite networks in igraph,  Next: Create two-mode networks,  Up: Bipartite; i_e_ two-mode graphs

@c 20.1 Bipartite networks in igraph
@c =================================

@c A bipartite network contains two kinds of vertices and connections are
@c only possible between two vertices of different kind. There are many
@c natural examples, e.g. movies and actors as vertices and a movie is
@c connected to all participating actors, etc.

@c    igraph does not have direct support for bipartite networks, at least
@c not at the C language level. In other words the igraph_t structure does
@c not contain information about the vertex types.  The C functions for
@c bipartite networks usually have an additional input argument to graph,
@c called `types', a boolean vector giving the vertex types.

@c    Most functions creating bipartite networks are able to create this
@c extra vector, you just need to supply an initialized boolean vector to
@c them.

@c
@c File: igraph_reference_manual.info,  Node: Create two-mode networks,  Next: Incidence matrices,  Prev: Bipartite networks in igraph,  Up: Bipartite; i_e_ two-mode graphs

@c 20.2 Create two-mode networks
@c =============================

@c * Menu:

@c * igraph_create_bipartite --- Create a bipartite graph::
@c * igraph_full_bipartite --- Create a full bipartite network::

@c
@c File: igraph_reference_manual.info,  Node: igraph_create_bipartite --- Create a bipartite graph,  Next: igraph_full_bipartite --- Create a full bipartite network,  Up: Create two-mode networks

@c 20.2.1 igraph_create_bipartite -- Create a bipartite graph
@c ----------------------------------------------------------


@c      int igraph_create_bipartite(igraph_t *graph, const igraph_vector_bool_t *types,
@c      			    const igraph_vector_t *edges,
@c      			    igraph_bool_t directed);

@c    This is a simple wrapper function to create a bipartite graph. It
@c does a little more than `igraph_create()' (*note igraph_create ---
@c Creates a graph with the specified edges_::), e.g. it checks that the
@c graph is indeed bipartite with respect to the given `types' vector. If
@c there is an edge connecting two vertices of the same kind, then an
@c error is reported.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitlized graph object, the result is created here.

@c `types':
@c      Boolean vector giving the vertex types. The length of the vector
@c      defines the number of vertices in the graph.

@c `edges':
@c      Vector giving the edges of the graph. The highest vertex id in
@c      this vector must be smaller than the length of the `types' vector.

@c `directed':
@c      Boolean scalar, whether to create a directed graph.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c
@c File: igraph_reference_manual.info,  Node: igraph_full_bipartite --- Create a full bipartite network,  Prev: igraph_create_bipartite --- Create a bipartite graph,  Up: Create two-mode networks

@c 20.2.2 igraph_full_bipartite -- Create a full bipartite network
@c ---------------------------------------------------------------


@c      int igraph_full_bipartite(igraph_t *graph,
@c      			  igraph_vector_bool_t *types,
@c      			  igraph_integer_t n1, igraph_integer_t n2,
@c      			  igraph_bool_t directed,
@c      			  igraph_neimode_t mode);

@c    A bipartite network contains two kinds of vertices and connections
@c are only possible between two vertices of different kind. There are
@c many natural examples, e.g. movies and actors as vertices and a movie
@c is connected to all participating actors, etc.

@c    igraph does not have direct support for bipartite networks, at least
@c not at the C language level. In other words the igraph_t structure does
@c not contain information about the vertex types.  The C functions for
@c bipartite networks usually have an additional input argument to graph,
@c called `types', a boolean vector giving the vertex types.

@c    Most functions creating bipartite networks are able to create this
@c extra vector, you just need to supply an initialized boolean vector to
@c them.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an igraph_t object, the graph will be created here.

@c `types':
@c      Pointer to a boolean vector. If not a null pointer, then the
@c      vertex types will be stored here.

@c `n1':
@c      Integer, the number of vertices of the first kind.

@c `n2':
@c      Integer, the number of vertices of the second kind.

@c `directed':
@c      Boolean, whether to create a directed graph.

@c `mode':
@c      A constant that gives the type of connections for directed graphs.
@c      If `IGRAPH_OUT', then edges point from vertices of the first kind
@c      to vertices of the second kind; if `IGRAPH_IN', then the opposite
@c      direction is realized; if `IGRAPH_ALL', then mutual edges will be
@c      created.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c    *See also:. *

@c `'
@c      `igraph_full()' (*note igraph_full --- Creates a full graph
@c      [directed or undirected; with or without loops]_::) for
@c      non-bipartite full graphs.

@c
@c File: igraph_reference_manual.info,  Node: Incidence matrices,  Next: Project a two-mode graphs,  Prev: Create two-mode networks,  Up: Bipartite; i_e_ two-mode graphs

@c 20.3 Incidence matrices
@c =======================

@c * Menu:

@c * igraph_incidence --- Create a bipartite graph from an incidence matrix::
@c * igraph_get_incidence --- Convert a bipartite graph into an incidence matrix::

@c
@c File: igraph_reference_manual.info,  Node: igraph_incidence --- Create a bipartite graph from an incidence matrix,  Next: igraph_get_incidence --- Convert a bipartite graph into an incidence matrix,  Up: Incidence matrices

@c 20.3.1 igraph_incidence -- Create a bipartite graph from an incidence matrix
@c ----------------------------------------------------------------------------


@c      int igraph_incidence(igraph_t *graph, igraph_vector_bool_t *types,
@c      		     const igraph_matrix_t *incidence,
@c      		     igraph_bool_t directed,
@c      		     igraph_neimode_t mode, igraph_bool_t multiple);

@c    A bipartite (or two-mode) graph contains two types of vertices and
@c edges always connect vertices of different types. An incidence matrix
@c is an nxm matrix, n and m are the number of vertices of the two types,
@c respectively. Nonzero elements in the matrix denote edges between the
@c two corresponding vertices.

@c    Note that this function can operate in two modes, depending on the
@c `multiple' argument. If it is FALSE (i.e. 0), then a single edge is
@c created for every non-zero element in the incidence matrix. If
@c `multiple' is TRUE (i.e. 1), then the matrix elements are rounded up to
@c the closest non-negative integer to get the number of edges to create
@c between a pair of vertices.

@c    This function does not create multiple edges if `multiple' is FALSE,
@c but might create some if it is TRUE.

@c    *Arguments:. *

@c `graph':
@c      Pointer to an uninitialized graph object.

@c `types':
@c      Pointer to an initialized boolean vector, or a null pointer. If
@c      not a null pointer, then the vertex types are stored here. It is
@c      resized as needed.

@c `incidence':
@c      The incidence matrix.

@c `directed':
@c      Gives whether to create an undirected or a directed graph.

@c `mode':
@c      Specifies the direction of the edges in a directed graph. If
@c      `IGRAPH_OUT', then edges point from vertices of the first kind
@c      (corresponding to rows) to vertices of the second kind
@c      (corresponding to columns); if `IGRAPH_IN', then the opposite
@c      direction is realized; if `IGRAPH_ALL', then mutual edges will be
@c      created.

@c `multiple':
@c      How to interpret the incidence matrix elements. See details below.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n*m), the size of the incidence matrix.

@c
@c File: igraph_reference_manual.info,  Node: igraph_get_incidence --- Convert a bipartite graph into an incidence matrix,  Prev: igraph_incidence --- Create a bipartite graph from an incidence matrix,  Up: Incidence matrices

@c 20.3.2 igraph_get_incidence -- Convert a bipartite graph into an incidence matrix
@c ---------------------------------------------------------------------------------


@c      int igraph_get_incidence(const igraph_t *graph,
@c      			 const igraph_vector_bool_t *types,
@c      			 igraph_matrix_t *res,
@c      			 igraph_vector_t *row_ids,
@c      			 igraph_vector_t *col_ids);

@c    *Arguments:. *

@c `graph':
@c      The input graph, edge directions are ignored.

@c `types':
@c      Boolean vector containing the vertex types.

@c `res':
@c      Pointer to an initialized matrix, the result is stored here. An
@c      element of the matrix gives the number of edges (irrespectively of
@c      their direction) between the two corresponding vertices.

@c `row_ids':
@c      Pointer to an initialized vector or a null pointer. If not a null
@c      pointer, then the vertex ids (in the graph) corresponding to the
@c      rows of the result matrix are stored here.

@c `col_ids':
@c      Pointer to an initialized vector or a null pointer. If not a null
@c      pointer, then the vertex ids corresponding to the columns of the
@c      result matrix are stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n*m), n and m are number of vertices of the two
@c different kind.

@c    *See also:. *

@c `'
@c      `igraph_incidence()' (*note igraph_incidence --- Create a
@c      bipartite graph from an incidence matrix::) for the opposite
@c      operation.

@c
@c File: igraph_reference_manual.info,  Node: Project a two-mode graphs,  Next: Other operations on bipartite graphs,  Prev: Incidence matrices,  Up: Bipartite; i_e_ two-mode graphs

@c 20.4 Project a two-mode graphs
@c ==============================

@c * Menu:

@c * igraph_bipartite_projection_size --- Calculate the number of vertices and edges in the bipartite projections::
@c * igraph_bipartite_projection --- Create one or both projections of a bipartite (two-mode) network: igraph_bipartite_projection --- Create one or both projections of a bipartite [two-mode] network.

@c
@c File: igraph_reference_manual.info,  Node: igraph_bipartite_projection_size --- Calculate the number of vertices and edges in the bipartite projections,  Next: igraph_bipartite_projection --- Create one or both projections of a bipartite [two-mode] network,  Up: Project a two-mode graphs

@c 20.4.1 igraph_bipartite_projection_size -- Calculate the number of vertices and edges in the bipartite projections
@c ------------------------------------------------------------------------------------------------------------------


@c      int igraph_bipartite_projection_size(const igraph_t *graph,
@c      				     const igraph_vector_bool_t *types,
@c      				     igraph_integer_t *vcount1,
@c      				     igraph_integer_t *ecount1,
@c      				     igraph_integer_t *vcount2,
@c      				     igraph_integer_t *ecount2);

@c    This function calculates the number of vertices and edges in the two
@c projections of a bipartite network. This is useful if you have a big
@c bipartite network and you want to estimate the amount of memory you
@c would need to calculate the projections themselves.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `types':
@c      Boolean vector giving the vertex types of the graph.

@c `vcount1':
@c      Pointer to an `igraph_integer_t', the number of vertices in the
@c      first projection is stored here.

@c `ecount1':
@c      Pointer to an `igraph_integer_t', the number of edges in the first
@c      projection is stored here.

@c `vcount2':
@c      Pointer to an `igraph_integer_t', the number of vertices in the
@c      second projection is stored here.

@c `ecount2':
@c      Pointer to an `igraph_integer_t', the number of edges in the
@c      second projection is stored here.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_bipartite_projection()' (*note igraph_bipartite_projection
@c      --- Create one or both projections of a bipartite [two-mode]
@c      network::) to calculate the actual projection.

@c    Time complexity: O(|V|*d^2+|E|), |V| is the number of vertices, |E|
@c is the number of edges, d is the average (total) degree of the graphs.

@c
@c File: igraph_reference_manual.info,  Node: igraph_bipartite_projection --- Create one or both projections of a bipartite [two-mode] network,  Prev: igraph_bipartite_projection_size --- Calculate the number of vertices and edges in the bipartite projections,  Up: Project a two-mode graphs

@c 20.4.2 igraph_bipartite_projection -- Create one or both projections of a bipartite (two-mode) network
@c ------------------------------------------------------------------------------------------------------


@c      int igraph_bipartite_projection(const igraph_t *graph,
@c      				const igraph_vector_bool_t *types,
@c      				igraph_t *proj1,
@c      				igraph_t *proj2,
@c      				igraph_integer_t probe1);

@c    Creates one or both projections of a bipartite graph.

@c    *Arguments:. *

@c `graph':
@c      The bipartite input graph. Directedness of the edges is ignored.

@c `types':
@c      Boolean vector giving the vertex types of the graph.

@c `proj1':
@c      Pointer to an uninitialized graph object, the first projection
@c      will be created here. It a null pointer, then it is ignored, see
@c      also the `probe1' argument.

@c `proj2':
@c      Pointer to an uninitialized graph object, the second projection is
@c      created here, if it is not a null pointer. See also the `probe1'
@c      argument.

@c    *Returns:. *

@c `'
@c      Error code.

@c    *See also:. *

@c `'
@c      `igraph_bipartite_projection_size()' (*note
@c      igraph_bipartite_projection_size --- Calculate the number of
@c      vertices and edges in the bipartite projections::) to calculate
@c      the number of vertices and edges in the projections, without
@c      creating the projection graphs themselves.

@c    Time complexity: O(|V|*d^2+|E|), |V| is the number of vertices, |E|
@c is the number of edges, d is the average (total) degree of the graphs.

@c
@c File: igraph_reference_manual.info,  Node: Other operations on bipartite graphs,  Prev: Project a two-mode graphs,  Up: Bipartite; i_e_ two-mode graphs

@c 20.5 Other operations on bipartite graphs
@c =========================================

@c * Menu:

@c * igraph_is_bipartite --- Check whether a graph is bipartite::

@c
@c File: igraph_reference_manual.info,  Node: igraph_is_bipartite --- Check whether a graph is bipartite,  Up: Other operations on bipartite graphs

@c 20.5.1 igraph_is_bipartite -- Check whether a graph is bipartite
@c ----------------------------------------------------------------


@c      int igraph_is_bipartite(const igraph_t *graph,
@c      			igraph_bool_t *res,
@c      			igraph_vector_bool_t *type);

@c    This function simply checks whether a graph \emph{could} be
@c bipartite. It tries to find a mapping that gives a possible division of
@c the vertices into two classes, such that no two vertices of the same
@c class are connected by an edge.

@c    The existence of such a mapping is equivalent of having no circuits
@c of odd length in the graph. A graph with loop edges cannot bipartite.

@c    Note that the mapping is not necessarily unique, e.g. if the graph
@c has at least two components, then the vertices in the separate
@c components can be mapped independently.

@c    *Arguments:. *

@c `graph':
@c      The input graph.

@c `res':
@c      Pointer to a boolean, the result is stored here.

@c `type':
@c      Pointer to an initialized boolean vector, or a null pointer. If
@c      not a null pointer and a mapping was found, then it is stored
@c      here. If not a null pointer, but no mapping was found, the
@c      contents of this vector is invalid.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(|V|+|E|), linear in the number of vertices and
@c edges.

@c
@c File: igraph_reference_manual.info,  Node: Not Graph Related Functions,  Next: Licenses for igraph and this manual,  Prev: Bipartite; i_e_ two-mode graphs,  Up: Top

@c 21 Not Graph Related Functions
@c ******************************

@c * Menu:

@c * Running Mean of a Time Series::
@c * Random Sampling from Very Long Sequences::
@c * Convex hull of a set of points on a plane::

@c
@c File: igraph_reference_manual.info,  Node: Running Mean of a Time Series,  Next: Random Sampling from Very Long Sequences,  Up: Not Graph Related Functions

@c 21.1 Running Mean of a Time Series
@c ==================================

@c * Menu:

@c * igraph_running_mean --- Calculates the running mean of a vector.: igraph_running_mean --- Calculates the running mean of a vector_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_running_mean --- Calculates the running mean of a vector_,  Up: Running Mean of a Time Series

@c 21.1.1 igraph_running_mean -- Calculates the running mean of a vector.
@c ----------------------------------------------------------------------


@c      int igraph_running_mean(const igraph_vector_t *data, igraph_vector_t *res,
@c      			igraph_integer_t binwidth);

@c    The running mean is defined by the mean of the previous `binwidth'
@c values.

@c    *Arguments:. *

@c `data':
@c      The vector containing the data.

@c `res':
@c      The vector containing the result. This should be initialized
@c      before calling this function and will be resized.

@c `binwidth':
@c      Integer giving the width of the bin for the running mean
@c      calculation.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: O(n), n is the length of the data vector.

@c
@c File: igraph_reference_manual.info,  Node: Random Sampling from Very Long Sequences,  Next: Convex hull of a set of points on a plane,  Prev: Running Mean of a Time Series,  Up: Not Graph Related Functions

@c 21.2 Random Sampling from Very Long Sequences
@c =============================================

@c * Menu:

@c * igraph_random_sample --- Generates an increasing random sequence of integers.: igraph_random_sample --- Generates an increasing random sequence of integers_.

@c
@c File: igraph_reference_manual.info,  Node: igraph_random_sample --- Generates an increasing random sequence of integers_,  Up: Random Sampling from Very Long Sequences

@c 21.2.1 igraph_random_sample -- Generates an increasing random sequence of integers.
@c -----------------------------------------------------------------------------------


@c      int igraph_random_sample(igraph_vector_t *res, igraph_integer_t l, igraph_integer_t h,
@c      			 igraph_integer_t length);

@c    This function generates an incresing sequence of random integer
@c numbers from a given interval. The algorithm is taken literally from
@c Jeffrey Scott Vitter: 'An Efficient Algorithm for Sequential Random
@c Sampling', ACM Transactions on Mathematical Software, 13/1, 58-67. This
@c method can be used for generating numbers from a _very_ large interval,
@c it is primilarly created for randomly selecting some edges from the
@c sometimes huge set of possible edges in a large graph.

@c    *Arguments:. *

@c `res':
@c      Pointer to an initialized vector, this will hold the result. It
@c      will be resized to the proper size.

@c `l':
@c      The lower limit of the generation interval (inclusive).

@c `h':
@c      The upper limit of the generation interval (inclusive).

@c `length':
@c      The number of random integers to generate.

@c    *Returns:. *

@c `'
@c      Error code.

@c    Time complexity: according to the referenced paper, the expected
@c running time is O(length).

@c
@c File: igraph_reference_manual.info,  Node: Convex hull of a set of points on a plane,  Prev: Random Sampling from Very Long Sequences,  Up: Not Graph Related Functions

@c 21.3 Convex hull of a set of points on a plane
@c ==============================================

@c * Menu:

@c * igraph_convex_hull --- Determines the convex hull of a given set of points in the 2D plane::

@c
@c File: igraph_reference_manual.info,  Node: igraph_convex_hull --- Determines the convex hull of a given set of points in the 2D plane,  Up: Convex hull of a set of points on a plane

@c 21.3.1 igraph_convex_hull -- Determines the convex hull of a given set of points in the 2D plane
@c ------------------------------------------------------------------------------------------------


@c      int igraph_convex_hull(const igraph_matrix_t *data, igraph_vector_t *resverts,
@c      		       igraph_matrix_t *rescoords);

@c    The convex hull is determined by the Graham scan algorithm.  See the
@c following reference for details:

@c    Thomas H. Cormen, Charles E. Leiserson, Ronald L. Rivest, and
@c Clifford Stein. Introduction to Algorithms, Second Edition. MIT Press
@c and McGraw-Hill, 2001. ISBN 0262032937. Pages 949-955 of section 33.3:
@c Finding the convex hull.

@c    *Arguments:. *

@c `data':
@c      vector containing the coordinates. The length of the vector must
@c      be even, since it contains X-Y coordinate pairs.

@c `resverts':
@c      the vector containing the result, e.g. the vector of vertex
@c      indices used as the corners of the convex hull. Supply `NULL' here
@c      if you are only interested in the coordinates of the convex hull
@c      corners.

@c `rescoords':
@c      the matrix containing the coordinates of the selected corner
@c      vertices. Supply `NULL' here if you are only interested in the
@c      vertex indices.

@c    *Returns:. *

@c `'
@c      Error code: `IGRAPH_ENOMEM': not enough memory

@c    Time complexity: O(n log(n)) where n is the number of vertices

@c page

@include gpl-2.0.texi

@c page
@node Documentation License
@appendix @gnu{} Free Documentation License

@cindex FDL, GNU Free Documentation License
@center Version 1.3, 3 November 2008

@c This file is intended to be included within another document,
@c hence no sectioning command or @node.

@display
Copyright @copyright{} 2000, 2001, 2002, 2007, 2008 Free Software Foundation, Inc.
@uref{http://fsf.org/}

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
@end display

@enumerate 0
@item
PREAMBLE

The purpose of this License is to make a manual, textbook, or other
functional and useful document @dfn{free} in the sense of freedom: to
assure everyone the effective freedom to copy and redistribute it,
with or without modifying it, either commercially or noncommercially.
Secondarily, this License preserves for the author and publisher a way
to get credit for their work, while not being considered responsible
for modifications made by others.

This License is a kind of ``copyleft'', which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

@item
APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work, in any medium, that
contains a notice placed by the copyright holder saying it can be
distributed under the terms of this License.  Such a notice grants a
world-wide, royalty-free license, unlimited in duration, to use that
work under the conditions stated herein.  The ``Document'', below,
refers to any such manual or work.  Any member of the public is a
licensee, and is addressed as ``you''.  You accept the license if you
copy, modify or distribute the work in a way requiring permission
under copyright law.

A ``Modified Version'' of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A ``Secondary Section'' is a named appendix or a front-matter section
of the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall
subject (or to related matters) and contains nothing that could fall
directly within that overall subject.  (Thus, if the Document is in
part a textbook of mathematics, a Secondary Section may not explain
any mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The ``Invariant Sections'' are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.  If a
section does not fit the above definition of Secondary then it is not
allowed to be designated as Invariant.  The Document may contain zero
Invariant Sections.  If the Document does not identify any Invariant
Sections then there are none.

The ``Cover Texts'' are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.  A Front-Cover Text may
be at most 5 words, and a Back-Cover Text may be at most 25 words.

A ``Transparent'' copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, that is suitable for revising the document
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup, or absence of markup, has been arranged to thwart
or discourage subsequent modification by readers is not Transparent.
An image format is not Transparent if used for any substantial amount
of text.  A copy that is not ``Transparent'' is called ``Opaque''.

Examples of suitable formats for Transparent copies include plain
@sc{ascii} without markup, Texinfo input format, La@TeX{} input
format, @acronym{SGML} or @acronym{XML} using a publicly available
@acronym{DTD}, and standard-conforming simple @acronym{HTML},
PostScript or @acronym{PDF} designed for human modification.  Examples
of transparent image formats include @acronym{PNG}, @acronym{XCF} and
@acronym{JPG}.  Opaque formats include proprietary formats that can be
read and edited only by proprietary word processors, @acronym{SGML} or
@acronym{XML} for which the @acronym{DTD} and/or processing tools are
not generally available, and the machine-generated @acronym{HTML},
PostScript or @acronym{PDF} produced by some word processors for
output purposes only.

The ``Title Page'' means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, ``Title Page'' means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

The ``publisher'' means any person or entity that distributes copies
of the Document to the public.

A section ``Entitled XYZ'' means a named subunit of the Document whose
title either is precisely XYZ or contains XYZ in parentheses following
text that translates XYZ in another language.  (Here XYZ stands for a
specific section name mentioned below, such as ``Acknowledgements'',
``Dedications'', ``Endorsements'', or ``History''.)  To ``Preserve the Title''
of such a section when you modify the Document means that it remains a
section ``Entitled XYZ'' according to this definition.

The Document may include Warranty Disclaimers next to the notice which
states that this License applies to the Document.  These Warranty
Disclaimers are considered to be included by reference in this
License, but only as regards disclaiming warranties: any other
implication that these Warranty Disclaimers may have is void and has
no effect on the meaning of this License.

@item
VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

@item
COPYING IN QUANTITY

If you publish printed copies (or copies in media that commonly have
printed covers) of the Document, numbering more than 100, and the
Document's license notice requires Cover Texts, you must enclose the
copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a computer-network location from which the general network-using
public has access to download using public-standard network protocols
a complete Transparent copy of the Document, free of added material.
If you use the latter option, you must take reasonably prudent steps,
when you begin distribution of Opaque copies in quantity, to ensure
that this Transparent copy will remain thus accessible at the stated
location until at least one year after the last time you distribute an
Opaque copy (directly or through your agents or retailers) of that
edition to the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

@item
MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

@enumerate A
@item
Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

@item
List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has fewer than five),
unless they release you from this requirement.

@item
State on the Title page the name of the publisher of the
Modified Version, as the publisher.

@item
Preserve all the copyright notices of the Document.

@item
Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

@item
Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

@item
Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

@item
Include an unaltered copy of this License.

@item
Preserve the section Entitled ``History'', Preserve its Title, and add
to it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section Entitled ``History'' in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

@item
Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the ``History'' section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

@item
For any section Entitled ``Acknowledgements'' or ``Dedications'', Preserve
the Title of the section, and preserve in the section all the
substance and tone of each of the contributor acknowledgements and/or
dedications given therein.

@item
Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

@item
Delete any section Entitled ``Endorsements''.  Such a section
may not be included in the Modified Version.

@item
Do not retitle any existing section to be Entitled ``Endorsements'' or
to conflict in title with any Invariant Section.

@item
Preserve any Warranty Disclaimers.
@end enumerate

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.

You may add a section Entitled ``Endorsements'', provided it contains
nothing but endorsements of your Modified Version by various
parties---for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

@item
COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice, and that you preserve all their Warranty Disclaimers.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections Entitled ``History''
in the various original documents, forming one section Entitled
``History''; likewise combine any sections Entitled ``Acknowledgements'',
and any sections Entitled ``Dedications''.  You must delete all
sections Entitled ``Endorsements.''

@item
COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

@item
AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, is called an ``aggregate'' if the copyright
resulting from the compilation is not used to limit the legal rights
of the compilation's users beyond what the individual works permit.
When the Document is included in an aggregate, this License does not
apply to the other works in the aggregate which are not themselves
derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one half of
the entire aggregate, the Document's Cover Texts may be placed on
covers that bracket the Document within the aggregate, or the
electronic equivalent of covers if the Document is in electronic form.
Otherwise they must appear on printed covers that bracket the whole
aggregate.

@item
TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License, and all the license notices in the
Document, and any Warranty Disclaimers, provided that you also include
the original English version of this License and the original versions
of those notices and disclaimers.  In case of a disagreement between
the translation and the original version of this License or a notice
or disclaimer, the original version will prevail.

If a section in the Document is Entitled ``Acknowledgements'',
``Dedications'', or ``History'', the requirement (section 4) to Preserve
its Title (section 1) will typically require changing the actual
title.

@item
TERMINATION

You may not copy, modify, sublicense, or distribute the Document
except as expressly provided under this License.  Any attempt
otherwise to copy, modify, sublicense, or distribute it is void, and
will automatically terminate your rights under this License.

However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, receipt of a copy of some or all of the same material does
not give you any rights to use it.

@item
FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
@uref{http://www.gnu.org/copyleft/}.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License ``or any later version'' applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.  If the Document
specifies that a proxy can decide which future versions of this
License can be used, that proxy's public statement of acceptance of a
version permanently authorizes you to choose that version for the
Document.

@item
RELICENSING

``Massive Multiauthor Collaboration Site'' (or ``MMC Site'') means any
World Wide Web server that publishes copyrightable works and also
provides prominent facilities for anybody to edit those works.  A
public wiki that anybody can edit is an example of such a server.  A
``Massive Multiauthor Collaboration'' (or ``MMC'') contained in the
site means any set of copyrightable works thus published on the MMC
site.

``CC-BY-SA'' means the Creative Commons Attribution-Share Alike 3.0
license published by Creative Commons Corporation, a not-for-profit
corporation with a principal place of business in San Francisco,
California, as well as future copyleft versions of that license
published by that same organization.

``Incorporate'' means to publish or republish a Document, in whole or
in part, as part of another Document.

An MMC is ``eligible for relicensing'' if it is licensed under this
License, and if all works that were first published under this License
somewhere other than this MMC, and subsequently incorporated in whole
or in part into the MMC, (1) had no cover texts or invariant sections,
and (2) were thus incorporated prior to November 1, 2008.

The operator of an MMC Site may republish an MMC contained in the site
under CC-BY-SA on the same site at any time before August 1, 2009,
provided the MMC is eligible for relicensing.

@end enumerate

@page
@heading ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

@smallexample
@group
  Copyright (C)  @var{year}  @var{your name}.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.3
  or any later version published by the Free Software Foundation;
  with no Invariant Sections, no Front-Cover Texts, and no Back-Cover
  Texts.  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
@end group
@end smallexample

If you have Invariant Sections, Front-Cover Texts and Back-Cover Texts,
replace the ``with@dots{}Texts.'' line with this:

@smallexample
@group
    with the Invariant Sections being @var{list their titles}, with
    the Front-Cover Texts being @var{list}, and with the Back-Cover Texts
    being @var{list}.
@end group
@end smallexample

If you have Invariant Sections without Cover Texts, or some other
combination of the three, merge those two alternatives to suit the
situation.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c ispell-local-pdict: "ispell-dict"
@c End:

