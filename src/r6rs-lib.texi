\input texinfo.tex
@c %**start of header
@setfilename r6rs-lib.info
@settitle Revised^6 Report on the Algorithmic Language Scheme --- Standard Libraries
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Generic macros.
@c ------------------------------------------------------------

@macro version{}
2008-11-05-21-32-46
@end macro

@macro errataupdatedate{}
2008-11-05-21-32-46
@end macro

@macro rfive{}
@emph{Revised^5 Report on the Algorithmic Language Scheme}
@end macro

@macro rsix{}
@emph{Revised^6 Report on the Algorithmic Language Scheme}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro acite{NAME}
[@sc{\NAME\}]
@end macro

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@macro rnrs{NUMBER}
@acronym{R\NUMBER\RS}
@end macro

@c ------------------------------------------------------------

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro api{}
@acronym{API}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@macro iso{}
@acronym{ISO}
@end macro


@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro false{}
@code{#f}
@end macro

@macro true{}
@code{#t}
@end macro

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro

@macro library{NAME}
@code{(\NAME\)}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c References to external documents.
@c ------------------------------------------------------------

@macro rsixref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@end macro



@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Revised^6 Report on the Algorithmic Language Scheme --- Standard Libraries

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    R6RS-lib

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
The report gives a defining description of the standard libraries of the
programming language Scheme.

@noindent
MICHAEL SPERBER@*
R. KENT DYBVIG, MATTHEW FLATT, ANTON VAN STRAATEN@*
(Editors)

@noindent
RICHARD KELSEY, WILLIAM CLINGER, JONATHAN REES@*
(Editors, Revised^5 Report on the Algorithmic Language Scheme)

@noindent
ROBERT BRUCE FINDLER, JACOB MATTHEWS@*
(Authors, formal semantics)

@noindent
26 September 2007

The original version of this document, and its errata, are available at:

@center @url{http://www.r6rs.org/}
@center @url{http://www.r6rs.org/r6rs-errata.html}

This document is version @version{} (with errata corrige update date
@errataupdatedate{}) of the Texinfo reformatting of the original sources
of the @rnrs{6}--lib document; author and maintainer of the reformatted
version is @value{AUTHOR} @value{AUTHOR_EMAIL}.  This document is
slightly modified to allow for more readability in Info format, where
(for example) too many cross references would make the text ugly.
@end copying

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Documentation
@direntry
* r6rs-lib: (r6rs-lib).         Revised^6 Report on the Algorithmic
                                Language Scheme -- Standard Libraries.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c ------------------------------------------------------------

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* stdlib overview::             Overview of the document.
* stdlib unicode::              Unicode.
* stdlib bytevector::           Bytevectors.
* stdlib list::                 List utilities.
* stdlib sorting::              Sorting.
* stdlib control::              Control structures.
* stdlib records::              Records.
* stdlib exceptions::           Exceptions and conditions.
* stdlib io::                   Input/output.
* stdlib files::                File system.
* stdlib programlib::           Command line access and exit values.
* stdlib arithmetics::          Arithmetics.
* stdlib syntax-case::          Syntax-case.
* stdlib hashtable::            Hashtables.
* stdlib enum::                 Enumerations.
* stdlib complib::              Composite library.
* stdlib eval::                 Evaluation.
* stdlib mutable pairs::        Mutable pairs.
* stdlib mutable strings::      Mutable strings.
* stdlib rfive compat::         @rnrs{5} compatibility.

Appendices

* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Unicode

* stdlib unicode characters::   Characters.
* stdlib unicode strings::      Strings.

Bytevectors

* stdlib bytevector endianness::        Endianness.
* stdlib bytevector general::           General operations.
* stdlib bytevector bytes and octets::  Operations on bytes and octets.
* stdlib bytevector integers::          Operations on integers of
                                        arbitrary size.
* stdlib bytevector integers 16::       Operations on 16-bit integers.
* stdlib bytevector integers 32::       Operations on 32-bit integers.
* stdlib bytevector integers 64::       Operations on 64-bit integers.
* stdlib bytevector flonum::            Operations on @ieee{} 754
                                        representations.
* stdlib bytevector strings::           Operations on strings.

Records

* stdlib records intro::                Introduction.
* stdlib records mutability::           Mutability and equivalence
                                        of records.
* stdlib records syntactic layer::      Syntactic layer.
* stdlib records procedural layer::     Procedural layer.
* stdlib records inspection::           Inspection.

Exceptions and conditions

* stdlib exceptions exceptions::        Exceptions.
* stdlib exceptions conditions::        Conditions.

Conditions

* stdlib exceptions conditions objects::        Condition objects.
* stdlib exceptions conditions types::          Standard condition
                                                types.

Input/output

* stdlib io conditions::        Condition types.
* stdlib io port::              Port input/output.
* stdlib io simple::            Simple input/output.

Port input/output

* stdlib io port file names::           File names.
* stdlib io port file options::         File options.
* stdlib io port buffer modes::         Buffer modes.
* stdlib io port transcoders::          Transcoders.
* stdlib io port eof object::           End of file object.
* stdlib io port io ports::             Input and output ports.
* stdlib io port input ports::          Input ports.
* stdlib io port binary input::         Binary input.
* stdlib io port textual input::        Textual input.
* stdlib io port output ports::         Output ports.
* stdlib io port binary output::        Binary output.
* stdlib io port textual output::       Textual output.
* stdlib io port input output ports::   Input/output ports.

Arithmetics

* stdlib arithmetics bitwise::          Bitwise operations.
* stdlib arithmetics fixnum::           Fixnums.
* stdlib arithmetics flonum::           Flonums.
* stdlib arithmetics exact bitwise::    Exact bitwise arithmetic.

Syntax--case

* stdlib syntax-case hygiene::          Hygiene.
* stdlib syntax-case objects::          Syntax objects.
* stdlib syntax-case transformers::     Transformers.
* stdlib syntax-case parsing::          Parsing input and producing
                                        output.
* stdlib syntax-case identifier::       Identifier predicates.
* stdlib syntax-case conversion::       Syntax-object and datum
                                        conversions.
* stdlib syntax-case temporaries::      Generating lists of temporaries.
* stdlib syntax-case derived::          Derived forms and procedures.
* stdlib syntax-case violations::       Syntax violations.

Hashtables

* stdlib hashtable constructors::       Constructors.
* stdlib hashtable procedures::         Procedures.
* stdlib hashtable inspection::         Inspection.
* stdlib hashtable hash functions::     Hash functions.

@end detailmenu
@end menu

@end ifnottex

@c ------------------------------------------------------------

@c page
@node stdlib overview
@chapter Overview of the document


The report gives a defining description of the standard libraries of the
programming language Scheme.  This report frequently refers back to the
``Revised^6 Report on the Algorithmic Language Scheme''; references to
the report are identified by designations such as ``report section'' or
``report chapter''.

Parts of the library report are derived from earlier revisions of the
report @rnrs{5}.  We gratefully acknowledge their authors for their
contributions.  More detailed information on authorship can be found at
the beginning of the ``Revised^6 Report on the Algorithmic Language
Scheme''.

We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as a
starting point for manuals and other documentation, modifying it as
necessary.


@c ------------------------------------------------------------

@c page
@node stdlib unicode
@chapter Unicode


The procedures exported by the @rsixlibrary{unicode} library provide
access to some aspects of the Unicode semantics for characters and
strings: category information, case--independent comparisons, case
mappings, and normalization.

Some of the procedures that operate on characters or strings ignore the
difference between upper case and lower case.  These procedures have
@code{-ci} (for ``case insensitive'') embedded in their names.


@menu
* stdlib unicode characters::   Characters.
* stdlib unicode strings::      Strings.
@end menu

@c ------------------------------------------------------------

@c page
@node stdlib unicode characters
@section Characters


@deffn Procedure char-upcase @var{char}
@deffnx Procedure char-downcase @var{char}
@deffnx Procedure char-titlecase @var{char}
@deffnx Procedure char-foldcase @var{char}
These procedures take a character argument and return a character
result.

If the argument is an upper--case or title--case character, and if there
is a single character that is its lower--case form, then
@func{char-downcase} returns that character.

If the argument is a lower--case or title--case character, and there is
a single character that is its upper--case form, then @func{char-upcase}
returns that character.

If the argument is a lower--case or upper--case character, and there is
a single character that is its title--case form, then
@func{char-titlecase} returns that character.

If the argument is not a title--case character and there is no single
character that is its title--case form, then @func{char-titlecase}
returns the upper--case form of the argument.

Finally, if the character has a case--folded character, then
@func{char-foldcase} returns that character.  Otherwise the character
returned is the same as the argument.

For Turkic characters @code{#\x130} and @code{#\x131},
@func{char-foldcase} behaves as the identity function; otherwise
@func{char-foldcase} is the same as @func{char-downcase} composed with
@func{char-upcase}.

@example
(char-upcase #\i)               => #\I
(char-downcase #\i)             => #\i
(char-titlecase #\i)            => #\I
(char-foldcase #\i)             => #\i
@end example

@quotation
@emph{Note:} @func{char-titlecase} does not always return a title--case
character.
@end quotation

@quotation
@emph{Note:} These procedures are consistent with Unicode's
locale--independent mappings from scalar values to scalar values for
upcase, downcase, titlecase, and case--folding operations.  These
mappings can be extracted from @file{UnicodeData.txt} and
@file{CaseFolding.txt} from the Unicode Consortium, ignoring Turkic
mappings in the latter.

Note that these character--based procedures are an incomplete
approximation to case conversion, even ignoring the user's locale.  In
general, case mappings require the context of a string, both in
arguments and in result.  The @func{string-upcase},
@func{string-downcase}, @func{string-titlecase}, and
@func{string-foldcase} procedures (@ref{stdlib unicode strings} perform
more general case conversion.
@end quotation
@end deffn


@deffn Procedure char-ci=? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci<? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci>? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci<=? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci>=? @vari{char} @varii{char} @variii{char} @dots{}
These procedures are similar to @func{char=?}, etc., but operate on the
case--folded versions of the characters.

@example
(char-ci<? #\z #\Z)             => #f
(char-ci=? #\z #\Z)             => #f
@end example
@end deffn


@deffn Procedure char-alphabetic? @var{char}
@deffnx Procedure char-numeric? @var{char}
@deffnx Procedure char-whitespace? @var{char}
@deffnx Procedure char-upper-case? @var{char}
@deffnx Procedure char-lower-case? @var{char}
@deffnx Procedure char-title-case? @var{char}
These procedures return @true{} if their arguments are alphabetic,
numeric, whitespace, upper--case, lower--case, or title--case
characters, respectively; otherwise they return @false{}.

A character is alphabetic if it has the Unicode ``Alphabetic'' property.
A character is numeric if it has the Unicode ``Numeric'' property.  A
character is whitespace if has the Unicode ``White_Space'' property.  A
character is upper case if it has the Unicode ``Uppercase'' property,
lower case if it has the ``Lowercase'' property, and title case if it is
in the Lt general category.

@example
(char-alphabetic? #\a)          => #t
(char-numeric? #\1)             => #t
(char-whitespace? #\space)      => #t
(char-whitespace? #\x00A0)      => #t
(char-lower-case? #\x00AA)      => #t
(char-title-case? #\I)          => #f
(char-title-case? #\x01C5)      => #t
@end example
@end deffn


@deffn Procedure char-general-category @var{char}
Return a symbol representing the Unicode general category of
@var{char}, one of @code{Lu}, @code{Ll}, @code{Lt}, @code{Lm},
@code{Lo}, @code{Mn}, @code{Mc}, @code{Me}, @code{Nd}, @code{Nl},
@code{No}, @code{Ps}, @code{Pe}, @code{Pi}, @code{Pf}, @code{Pd},
@code{Pc}, @code{Po}, @code{Sc}, @code{Sm}, @code{Sk}, @code{So},
@code{Zs}, @code{Zp}, @code{Zl}, @code{Cc}, @code{Cf}, @code{Cs},
@code{Co}, or @code{Cn}.

@example
(char-general-category #\a)             => Ll
(char-general-category #\space)         => Zs
(char-general-category #\x10FFFF)       => Cn
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib unicode strings
@section Strings


@deffn Procedure string-upcase @var{string}
@deffnx Procedure string-downcase @var{string}
@deffnx Procedure string-titlecase @var{string}
@deffnx Procedure string-foldcase @var{string}
These procedures take a string argument and return a string result.
They are defined in terms of Unicode's locale--independent case mappings
from Unicode scalar--value sequences to scalar--value sequences.  In
particular, the length of the result string can be different from the
length of the input string.  When the specified result is equal in the
sense of @func{string=?} to the argument, these procedures may return
the argument instead of a newly allocated string.

The @func{string-upcase} procedure converts a string to upper case;
@func{string-downcase} converts a string to lower case.  The
@func{string-foldcase} procedure converts the string to its case--folded
counterpart, using the full case--folding mapping, but without the
special mappings for Turkic languages.  The @func{string-titlecase}
procedure converts the first cased character of each word, and downcases
all other cased characters.

@example
(string-upcase "Hi")                    => "HI"
(string-downcase "Hi")                  => "hi"
(string-foldcase "Hi")                  => "hi"

(string-titlecase "kNock KNoCK")        => "Knock Knock"
(string-titlecase "who's there?")       => "Who's There?"
(string-titlecase "r6rs")               => "R6rs"
(string-titlecase "R6RS")               => "R6rs"
@end example

@quotation
@emph{Note:} The case mappings needed for implementing these procedures
can be extracted from @file{UnicodeData.txt}, @file{SpecialCasing.txt},
@file{WordBreakProperty.txt} (the ``MidLetter'' property partly defines
case--ignorable characters), and @file{CaseFolding.txt} from the Unicode
Consortium.

Since these procedures are locale--independent, they may not be
appropriate for some locales.
@end quotation

@quotation
@emph{Note:} Word breaking, as needed for the correct casing of the
upper case greek sigma and for @func{string-titlecase}, is specified in
Unicode Standard Annex #29.
@end quotation
@end deffn


@deffn Procedure string-ci=? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci<? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci>? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci<=? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci>=? @vari{string} @varii{string} @variii{string} @dots{}
These procedures are similar to @func{string=?}, etc., but operate on
the case--folded versions of the strings.

@example
(string-ci<? "z" "Z")                   => #f
(string-ci=? "z" "Z")                   => #t
@end example
@end deffn


@deffn Procedure string-normalize-nfd @var{string}
@deffnx Procedure string-normalize-nfkd @var{string}
@deffnx Procedure string-normalize-nfc @var{string}
@deffnx Procedure string-normalize-nfkc @var{string}
These procedures take a string argument and return a string result,
which is the input string normalized to Unicode normalization form D,
KD, C, or KC, respectively.  When the specified result is equal in the
sense of @func{string=?} to the argument, these procedures may return
the argument instead of a newly allocated string.

@example
(string-normalize-nfd "\xE9;")          => "\x65;\x301;"
(string-normalize-nfc "\xE9;")          => "\xE9;"
(string-normalize-nfd "\x65;\x301;")    => "\x65;\x301;"
(string-normalize-nfc "\x65;\x301;")    => "\xE9;"
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector
@chapter Bytevectors


Many applications deal with blocks of binary data by accessing them in
various ways---extracting signed or unsigned numbers of various sizes.
Therefore, the @rsixlibrary{bytevectors} library provides a single type
for blocks of binary data with multiple ways to access that data. It
deals with integers and floating--point representations in various sizes
with specified endianness.

Bytevectors are objects of a disjoint type.  Conceptually, a bytevector
represents a sequence of 8-bit bytes.  The description of bytevectors
uses the term @emph{byte} for an exact integer object in the interval
@code{(-128, @dots{}, 127)} and the term @emph{octet} for an exact
integer object in the interval @code{(0, @dots{}, 255)}.  A byte
corresponds to its two's complement representation as an octet.

The length of a bytevector is the number of bytes it contains. This
number is fixed.  A valid index into a bytevector is an exact,
non--negative integer object less than the length of the bytevector.
The first byte of a bytevector has index 0; the last byte has an index
one less than the length of the bytevector.

Generally, the access procedures come in different flavors according to
the size of the represented integer and the endianness of the
representation.  The procedures also distinguish signed and unsigned
representations.  The signed representations all use two's complement.

Like string literals, literals representing bytevectors do not need to
be quoted:

@example
#vu8(12 23 123) => #vu8(12 23 123)
@end example


@menu
* stdlib bytevector endianness::        Endianness.
* stdlib bytevector general::           General operations.
* stdlib bytevector bytes and octets::  Operations on bytes and octets.
* stdlib bytevector integers::          Operations on integers of
                                        arbitrary size.
* stdlib bytevector integers 16::       Operations on 16-bit integers.
* stdlib bytevector integers 32::       Operations on 32-bit integers.
* stdlib bytevector integers 64::       Operations on 64-bit integers.
* stdlib bytevector flonum::            Operations on @ieee{} 754
                                        representations.
* stdlib bytevector strings::           Operations on strings.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib bytevector endianness
@section Endianness


Many operations described in this chapter accept an @emph{endianness}
argument.  Endianness describes the encoding of exact integer objects as
several contiguous bytes in a bytevector.  For this purpose, the binary
representation of the integer object is split into consecutive bytes.
The little--endian encoding places the least significant byte of an
integer first, with the other bytes following in increasing order of
significance.  The big--endian encoding places the most significant byte
of an integer first, with the other bytes following in decreasing order
of significance.

This terminology also applies to @ieee{} 754 numbers: @ieee{} 754
describes how to represent a floating--point number as an exact integer
object, and endianness describes how the bytes of such an integer are
laid out in a bytevector.

@quotation
@emph{Note:} Little-- and big--endianness are only the most common kinds
of endianness.  Some architectures distinguish between the endianness at
different levels of a binary representation.
@end quotation


@c ------------------------------------------------------------

@c page
@node stdlib bytevector general
@section General operations


@deffn Syntax endianness @meta{endianness symbol}
The name of @meta{endianness symbol} must be a symbol describing an
endianness.  An implementation must support at least the symbols
@code{big} and @code{little}, but may support other endianness symbols.

@code{(endianness @meta{endianness symbol})} evaluates to the symbol
named @meta{endianness symbol}.  Whenever one of the procedures
operating on bytevectors accepts an endianness as an argument, that
argument must be one of these symbols.  It is a syntax violation for
@meta{endianness symbol} to be anything other than an endianness symbol
supported by the implementation.

@quotation
@emph{Note:} Implementors should use widely accepted designations for
endianness symbols other than @code{big} and @code{little}.
@end quotation

@quotation
@emph{Note:} Only the name of @meta{endianness symbol} is significant.
@end quotation
@end deffn


@deffn Procedure native-endianness
Return the endianness symbol associated implementation's preferred
endianness (usually that of the underlying machine architecture).  This
may be any @meta{endianness symbol}, including a symbol other than
@code{big} and @code{little}.
@end deffn


@deffn Procedure bytevector? @var{obj}
Return @true{} if @var{obj} is a bytevector, @false{} otherwise.
@end deffn


@deffn Procedure make-bytevector @var{k}
@deffnx Procedure make-bytevector @var{k} @var{fill}
Return a newly allocated bytevector of @var{k} bytes.  If the @var{fill}
argument is missing, the initial contents of the returned bytevector are
unspecified.  If the @var{fill} argument is present, it must be an exact
integer object in the interval @code{(-128, @dots{} 255)} that specifies
the initial value for the bytes of the bytevector: If @var{fill} is
positive, it is interpreted as an octet; if it is negative, it is
interpreted as a byte.
@end deffn


@deffn Procedure bytevector-length @var{bytevector}
Return, as an exact integer object, the number of bytes in
@var{bytevector}.
@end deffn


@deffn Procedure {bytevector=?} @vari{bytevector} @varii{bytevector}
Return @true{} if @vari{bytevector} and @varii{bytevector} are equal;
that is, if they have the same length and equal bytes at all valid
indices.  It returns @false{} otherwise.
@end deffn


@deffn Procedure {bytevector-fill!} @var{bytevector} @var{fill}
The @var{fill} argument is as in the description of the
@func{make-bytevector} procedure.  The @func{bytevector-fill!}
procedure stores @var{fill} in every element of @var{bytevector} and
returns unspecified values.  Analogous to @func{vector-fill!}.
@end deffn


@deffn Procedure {bytevector-copy!} @var{source} @var{source-start} @var{target} @var{target-start} @var{k}
@var{source} and @var{target} must be bytevectors.  @var{source-start},
@var{target-start}, and @var{k} must be non--negative exact integer
objects that satisfy:

@example
0 <= @var{source-start} <= @var{source-start} + @var{k} <= l_@var{source}
0 <= @var{target-start} <= @var{target-start} + @var{k} <= l_@var{target}
@end example

@noindent
where @emph{l_@var{source}} is the length of @var{source} and
@emph{l_@var{target}} is the length of @var{target}.

The @func{bytevector-copy!} procedure copies the bytes from @var{source}
at indices:

@example
@var{source-start}, @dots{}, @var{source-start} + @var{k} - 1
@end example

@noindent
to consecutive indices in @var{target} starting at @var{target-index}.

This must work even if the memory regions for the source and the target
overlap, i.e., the bytes at the target location after the copy must be
equal to the bytes at the source location before the copy.

This returns unspecified values.

@example
(let ((b (u8-list->bytevector '(1 2 3 4 5 6 7 8))))
  (bytevector-copy! b 0 b 3 4)
  (bytevector->u8-list b))
=> (1 2 3 1 2 3 4 8)
@end example
@end deffn


@deffn Procedure bytevector-copy @var{bytevector}
Return a newly allocated copy of @var{bytevector}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector bytes and octets
@section Operations on bytes and octets


@deffn Procedure bytevector-u8-ref @var{bytevector} @var{k}
@deffnx Procedure bytevector-s8-ref @var{bytevector} @var{k}
@var{k} must be a valid index of @var{bytevector}.

The @func{bytevector-u8-ref} procedure returns the byte at index @var{k}
of @var{bytevector}, as an octet.

The @func{bytevector-s8-ref} procedure returns the byte at index @var{k}
of @var{bytevector}, as a (signed) byte.

@example
(let ((b1 (make-bytevector 16 -127))
      (b2 (make-bytevector 16 255)))
  (list
    (bytevector-s8-ref b1 0)
    (bytevector-u8-ref b1 0)
    (bytevector-s8-ref b2 0)
    (bytevector-u8-ref b2 0)))
=> (-127 129 -1 255)
@end example
@end deffn


@deffn Procedure {bytevector-u8-set!} @var{bytevector} @var{k} @var{octet}
@deffnx Procedure {bytevector-s8-set!} @var{bytevector} @var{k} @var{byte}
@var{k} must be a valid index of @var{bytevector}.

The @func{bytevector-u8-set!} procedure stores @var{octet} in element
@var{k} of @var{bytevector}.

The @func{bytevector-s8-set!} procedure stores the two's--complement
representation of @var{byte} in element @var{k} of @var{bytevector}.

Both procedures return unspecified values.

@example
(let ((b (make-bytevector 16 -127)))

  (bytevector-s8-set! b 0 -126)
  (bytevector-u8-set! b 1 246)

  (list
    (bytevector-s8-ref b 0)
    (bytevector-u8-ref b 0)
    (bytevector-s8-ref b 1)
    (bytevector-u8-ref b 1)))
=> (-126 130 -10 246)
@end example
@end deffn


@deffn Procedure {bytevector->u8-list} @var{bytevector}
@deffnx Procedure {u8-list->bytevector} @var{list}
@var{list} must be a list of octets.

The @func{bytevector->u8-list} procedure returns a newly allocated list
of the octets of @var{bytevector} in the same order.

The @func{u8-list->bytevector} procedure returns a newly allocated
bytevector whose elements are the elements of list @var{list}, in the
same order.  It is analogous to @func{list->vector}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector integers
@section Operations on integers of arbitrary size


@deffn Procedure bytevector-uint-ref @var{bytevector} @var{k} @var{endianness} @var{size}
@deffnx Procedure bytevector-sint-ref @var{bytevector} @var{k} @var{endianness} @var{size}
@deffnx Procedure {bytevector-uint-set!} @var{bytevector} @var{k} @var{n} @var{endianness} @var{size}
@deffnx Procedure {bytevector-sint-set!} @var{bytevector} @var{k} @var{n} @var{endianness} @var{size}
@var{size} must be a positive exact integer object.  @var{k}, @dots{},
@var{k}+@var{size}-1 must be valid indices of @var{bytevector}.

The @func{bytevector-uint-ref} procedure retrieves the exact integer
object corresponding to the unsigned representation of size @var{size}
and specified by @var{endianness} at indices @var{k}, @dots{},
@var{k}+@var{size}-1.

The @func{bytevector-sint-ref} procedure retrieves the exact integer
object corresponding to the two's--complement representation of size
@var{size} and specified by @var{endianness} at indices @var{k},
@dots{}, @var{k}+@var{size}-1.

For @func{bytevector-uint-set!}, @var{n} must be an exact integer object
in the interval @code{(0, @dots{}, 256^(size-1))}.

The @func{bytevector-uint-set!} procedure stores the unsigned
representation of size @var{size} and specified by @var{endianness} into
@var{bytevector} at indices @var{k}, @dots{}, @var{k}+@var{size}-1.

For @func{bytevector-sint-set!}, @var{n} must be an exact integer object
in the interval @code{(-(256^size)/2, @dots{}, (256^(size))/2-1)}.
@func{bytevector-sint-set!} stores the two's--complement representation
of size @var{size} and specified by @var{endianness} into
@var{bytevector} at indices @var{k}, @dots{}, @var{k}+@var{size}-1.

The @code{...-set!} procedures return unspecified values.

@example
(define b (make-bytevector 16 -127))

(bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness little) 16)

(bytevector-uint-ref b 0 (endianness little) 16)
=> #xfffffffffffffffffffffffffffffffd

(bytevector-sint-ref b 0 (endianness little) 16)
=> -3

(bytevector->u8-list b)
=> (253 255 255 255 255 255 255 255
    255 255 255 255 255 255 255 255)

(bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness big) 16)

(bytevector-uint-ref b 0 (endianness big) 16)
=> #xfffffffffffffffffffffffffffffffd

(bytevector-sint-ref b 0 (endianness big) 16)
=> -3

(bytevector->u8-list b)
=> (255 255 255 255 255 255 255 255
    255 255 255 255 255 255 255 253))
@end example
@end deffn


@deffn Procedure {bytevector->uint-list} @var{bytevector} @var{endianness} @var{size}
@deffnx Procedure {bytevector->sint-list} @var{bytevector} @var{endianness} @var{size}
@deffnx Procedure {uint-list->bytevector} @var{list} @var{endianness} @var{size}
@deffnx Procedure {sint-list->bytevector} @var{list} @var{endianness} @var{size}
@var{size} must be a positive exact integer object.

For @func{uint-list->bytevector}, @var{list} must be a list of exact
integer objects in the interval @code{(0, @dots{}, (256^size)-1)}.

For @func{sint-list->bytevector}, @var{list} must be a list of exact
integer objects in the interval @code{(-(256^size)/2, @dots{},
(256^(size))/2-1)}.

The length of @var{bytevector} must be divisible by @var{size}.

These procedures convert between lists of integer objects and their
consecutive representations according to @var{size} and @var{endianness}
in the @var{bytevector} objects in the same way as
@func{bytevector->u8-list} and @func{u8-list->bytevector} do for
one--byte representations.

@example
(let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
  (bytevector->sint-list b (endianness little) 2))
=> (513 -253 513 513)

(let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
  (bytevector->uint-list b (endianness little) 2))
=> (513 65283 513 513)
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector integers 16
@section Operations on 16--bit integers


@deffn Procedure {bytevector-u16-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-s16-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-u16-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-s16-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-u16-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-s16-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-u16-native-set!} @var{bytevector} @var{k} @var{n}
@deffnx Procedure {bytevector-s16-native-set!} @var{bytevector} @var{k} @var{n}
@var{k} must be a valid index of @var{bytevector}; so must @var{k}+1.

For @func{bytevector-u16-set!} and @func{bytevector-u16-native-set!},
@var{n} must be an exact integer object in the interval @code{(0,
@dots{}, 2^16-1)}.

For @func{bytevector-s16-set!} and @func{bytevector-s16-native-set!},
@var{n} must be an exact integer object in the interval @code{(-2^15,
@dots{}, 2^15-1)}.

These procedures retrieve and set two--byte representations of numbers
at indices @var{k} and @var{k}+1 according to the endianness specified
by @var{endianness}.  The procedures with @code{u16} in their names deal
with the unsigned representation; those with @code{s16} in their names
deal with the two's--complement representation.

The procedures with @code{native} in their names employ the native
endianness, and work only at aligned indices: @var{k} must be a multiple
of 2.

The @code{...-set!} procedures return unspecified values.

@example
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u16-ref b 14 (endianness little))           => 65023
(bytevector-s16-ref b 14 (endianness little))           => -513
(bytevector-u16-ref b 14 (endianness big))              => 65533
(bytevector-s16-ref b 14 (endianness big))              => -3

(bytevector-u16-set! b 0 12345 (endianness little))
(bytevector-u16-ref b 0 (endianness little))            => 12345

(bytevector-u16-native-set! b 0 12345)
(bytevector-u16-native-ref b 0)                         => 12345

(bytevector-u16-ref b 0 (endianness little))            => unspecified
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector integers 32
@section Operations on 32--bit integers


@deffn Procedure {bytevector-u32-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-s32-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-u32-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-s32-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-u32-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-s32-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-u32-native-set!} @var{bytevector} @var{k} @var{n}
@deffnx Procedure {bytevector-s32-native-set!} @var{bytevector} @var{k} @var{n}
@var{k}, @dots{}, @var{k}+3 must be valid indices of @var{bytevector}.

For @func{bytevector-u32-set!} and @func{bytevector-u32-native-set!},
@var{n} must be an exact integer object in the interval @code{(0,
@dots{}, 2^32-1)}.

For @func{bytevector-s32-set!} and @func{bytevector-s32-native-set!},
@var{n} must be an exact integer object in the interval @code{(-2^31,
@dots{}, 2^32-1)}.

These retrieve and set four--byte representations of numbers at indices
@var{k}, @dots{}, @var{k}+3, according to the endianness specified by
@var{endianness}.  The procedures with @code{u32} in their names deal
with the unsigned representation; those with @code{s32} with the
two's--complement representation.

The procedures with @code{native} in their names employ the native
endianness, and work only at aligned indices: @var{k} must be a multiple
of 4.

The @code{...-set!} procedures return unspecified values.

@example
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u32-ref b 12 (endianness little))   => 4261412863
(bytevector-s32-ref b 12 (endianness little))   => -33554433
(bytevector-u32-ref b 12 (endianness big))      => 4294967293
(bytevector-s32-ref b 12 (endianness big))      => -3
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector integers 64
@section Operations on 64--bit integers


@deffn Procedure {bytevector-u64-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-s64-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-u64-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-s64-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-u64-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-s64-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-u64-native-set!} @var{bytevector} @var{k} @var{n}
@deffnx Procedure {bytevector-s64-native-set!} @var{bytevector} @var{k} @var{n}
@var{k}, @dots{}, @var{k}+7 must be valid indices of @var{bytevector}.

For @func{bytevector-u64-set!} and @func{bytevector-u64-native-set!},
@var{n} must be an exact integer object in the interval @code{(0,
@dots{}, 2^64-1)}.

For @func{bytevector-s64-set!} and @func{bytevector-s64-native-set!},
@var{n} must be an exact integer object in the interval @code{(-2^63,
@dots{}, 2^64-1)}.

These retrieve and set eight--byte representations of numbers at indices
@var{k}, @dots{}, @var{k}+7, according to the endianness specified by
@var{endianness}.  The procedures with @code{u64} in their names deal
with the unsigned representation; those with @code{s64} with the
two's--complement representation.

The procedures with @code{native} in their names employ the native
endianness, and work only at aligned indices: @var{k} must be a multiple
of 8.

The @code{...-set!} procedures return unspecified values.

@example
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u64-ref b 8 (endianness little))    => 18302628885633695743
(bytevector-s64-ref b 8 (endianness little))    => -144115188075855873
(bytevector-u64-ref b 8 (endianness big))       => 18446744073709551613
(bytevector-s64-ref b 8 (endianness big))       => -3
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector flonum
@section Operations on @ieee{} 754 representations


@deffn Procedure bytevector-ieee-single-native-ref @var{bytevector} @var{k}
@deffnx Procedure bytevector-ieee-single-ref @var{bytevector} @var{k} @var{endianness}
@var{k}, @dots{}, @var{k}+3 must be valid indices of @var{bytevector}.

For @code{bytevector-ieee-single-native-ref}, @var{k} must be a multiple
of 4.

These procedures return the inexact real number object that best
represents the @ieee{} 754 single--precision number represented by the
four bytes beginning at index @var{k}.
@end deffn


@deffn Procedure bytevector-ieee-double-native-ref @var{bytevector} @var{k}
@deffnx Procedure bytevector-ieee-double-ref @var{bytevector} @var{k} @var{endianness}
@var{k}, @dots{}, @var{k}+7 must be valid indices of @var{bytevector}.

For @func{bytevector-ieee-double-native-ref}, @var{k} must be a multiple
of 8.

These procedures return the inexact real number object that best
represents the @ieee{} 754 double--precision number represented by the
eight bytes beginning at index @var{k}.
@end deffn


@deffn Procedure {bytevector-ieee-single-native-set!} @var{bytevector} @var{k} @var{x}
@deffnx Procedure {bytevector-ieee-single-set!} @var{bytevector} @var{k} @var{x} @var{endianness}
@var{k}, @dots{}, @var{k}+3 must be valid indices of @var{bytevector}.

For @func{bytevector-ieee-single-native-set!}, @var{k} must be a
multiple of 4.

These procedures store an @ieee{} 754 single--precision representation
of @var{x} into elements @var{k} through @var{k}+3 of @var{bytevector},
and return unspecified values.
@end deffn


@deffn Procedure {bytevector-ieee-double-native-set!} @var{bytevector} @var{k} @var{x}
@deffnx Procedure {bytevector-ieee-double-set!} @var{bytevector} @var{k} @var{x} @var{endianness}
@var{K}, @dots{}, @var{k}+7 must be valid indices of @var{bytevector}.

For @func{bytevector-ieee-double-native-set!}, @var{k} must be a
multiple of 8.

These procedures store an @ieee{} 754 double--precision representation
of @var{x} into elements @var{k} through @var{k}+7 of @var{bytevector},
and return unspecified values.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib bytevector strings
@section Operations on strings


This section describes procedures that convert between strings and
bytevectors containing Unicode encodings of those strings.  When
decoding bytevectors, encoding errors are handled as with the
@code{replace} semantics of textual I/O: If an invalid or incomplete
character encoding is encountered, then the replacement character
@code{U+FFFD} is appended to the string being generated, an appropriate
number of bytes are ignored, and decoding continues with the following
bytes.


@deffn Procedure string->utf8 @var{string}
Return a newly allocated (unless empty) bytevector that contains the
@utf{}-8 encoding of the given string.
@end deffn


@deffn Procedure string->utf16 @var{string}
@deffnx Procedure string->utf16 @var{string} @var{endianness}
If @var{endianness} is specified, it must be the symbol @code{big} or
the symbol @code{little}.  The @func{string->utf16} procedure returns a
newly allocated (unless empty) bytevector that contains the @utf{}-16BE
or @utf{}-16LE encoding of the given string (with no byte--order mark).
If endianness is not specified or is @code{big}, then @utf{}-16BE is
used.  If endianness is @code{little}, then @utf{}-16LE is used.
@end deffn


@deffn Procedure string->utf32 @var{string}
@deffnx Procedure string->utf32 @var{string} @var{endianness}
If @var{endianness} is specified, it must be the symbol @code{big} or
the symbol @code{little}.  The @func{string->utf32} procedure returns a
newly allocated (unless empty) bytevector that contains the @utf{}-32BE
or @utf{}-32LE encoding of the given string (with no byte mark).  If
endianness is not specified or is @code{big}, then @utf{}-32BE is used.
If endianness is @code{little}, then @utf{}-32LE is used.
@end deffn


@deffn Procedure utf8->string @var{bytevector}
Return a newly allocated (unless empty) string whose character sequence
is encoded by the given bytevector.
@end deffn


@deffn Procedure utf16->string @var{bytevector} @var{endianness}
@deffnx Procedure utf16->string @var{bytevector} @var{endianness} @var{endianness-mandatory}
@var{endianness} must be the symbol @code{big} or the symbol
@code{little}.

The @func{utf16->string} procedure returns a newly allocated (unless
empty) string whose character sequence is encoded by the given
bytevector.

@var{bytevector} is decoded according to @utf{}-16, @utf{}-16BE,
@utf{}-16LE, or a fourth encoding scheme that differs from all three of
those as follows: If @var{endianness-mandatory} is absent or @false{},
@func{utf16->string} determines the endianness according to a @utf{}-16
BOM at the beginning of @var{bytevector} if a BOM is present; in this
case, the BOM is not decoded as a character.  Also in this case, if no
@utf{}-16 BOM is present, @var{endianness} specifies the endianness of
the encoding.  If @var{endianness-mandatory} is a true value,
@var{endianness} specifies the endianness of the encoding, and any
@utf{}-16 BOM in the encoding is decoded as a regular character.

@quotation
@emph{Note:} A @utf{}-16 BOM is either a sequence of bytes @code{#xFE},
@code{#xFF} specifying @code{big} and @utf{}-16BE, or @code{#xFF},
@code{#xFE} specifying @code{little} and @utf{}-16LE.
@end quotation
@end deffn


@deffn Procedure utf32->string @var{bytevector} @var{endianness}
@deffnx Procedure utf32->string @var{bytevector} @var{endianness} @var{endianness-mandatory}
@var{endianness} must be the symbol @code{big} or the symbol
@code{little}.

The @func{utf32->string} procedure returns a newly allocated (unless
empty) string whose character sequence is encoded by the given
bytevector.

@var{bytevector} is decoded according to @utf{}-32, @utf{}-32BE,
@utf{}-32LE, or a fourth encoding scheme that differs from all three of
those as follows: If @var{endianness-mandatory} is absent or @false{},
@func{utf32->string} determines the endianness according to a @utf{}-32
BOM at the beginning of @var{bytevector} if a BOM is present; in this
case, the BOM is not decoded as a character.  Also in this case, if no
@utf{}-32 BOM is present, @var{endianness} specifies the endianness of
the encoding.  If @var{endianness-mandatory} is a true value,
@var{endianness} specifies the endianness of the encoding, and any
@utf{}-32 BOM in the encoding is decoded as a regular character.

@quotation
@emph{Note:} A @utf{}-32 BOM is either a sequence of bytes @code{#x00},
@code{#x00}, @code{#xFE}, @code{#xFF} specifying @code{big} and
@utf{}-32BE, or @code{#xFF}, @code{#xFE}, @code{#x00}, @code{#x00},
specifying @code{little} and @utf{}-32LE.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib list
@chapter List utilities


This chapter describes the @rsixlibrary{lists} library, which contains
various useful procedures that operate on lists.


@deffn Procedure find @var{proc} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.  The @func{find} procedure
applies @var{proc} to the elements of @var{list} in order.  If
@var{proc} returns a true value for an element, @func{find} immediately
returns that element.  If @var{proc} returns @false{} for all elements
of the list, @func{find} returns @false{}.  @var{proc} is always called
in the same dynamic environment as @func{find} itself.

@example
(find even? '(3 1 4 1 5 9))             => 4
(find even? '(3 1 5 1 5 9))             => #f
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs up to the found element, or that it
is indeed a list if no element is found.  It should not check that it is
a chain of pairs beyond the found element.  The implementation must
check the restrictions on @var{proc} to the extent performed by applying
it as described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure for-all @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
@deffnx Procedure exists @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s should all have the same length, and @var{proc} should
accept @emph{n} arguments and return a single value.  @var{proc} should
not mutate the @var{list} arguments.

For natural numbers @emph{i} = 0, 1, @dots{}, the @func{for-all}
procedure successively applies @var{proc} to arguments @emph{x_i^1
@dots{} x_i^n}, where @emph{x_i^j} is the @emph{i}th element of
@var{listj}, until @false{} is returned.

If @var{proc} returns true values for all but the last element of
@vari{list}, @func{for-all} performs a tail call of @var{proc} on the
@emph{k}th elements, where @emph{k} is the length of @vari{list}.  If
@var{proc} returns @false{} on any set of elements, @func{for-all}
returns @false{} after the first such application of @var{proc}.  If the
@var{list}s are all empty, @func{for-all} returns @true{}.

For natural numbers @emph{i} = 0, 1, @dots{}, the @func{exists}
procedure applies @var{proc} successively to arguments @emph{x_i^1}
@dots{} @emph{x_i^n}, where @emph{x_i^j} is the @emph{i}th element of
@var{listj}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the
@var{list}s, @code{exists} performs a tail call of @var{proc} on the
@emph{k}th elements, where @emph{k} is the length of @vari{list}.  If
@var{proc} returns a true value on any set of elements, @code{ exists}
returns that value after the first such application of @var{proc}.  If
the @var{list}s are all empty, @code{exists} returns @false{}.

@var{proc} is always called in the same dynamic environment as
@func{for-all} or, respectively, @func{exists} itself.

@example
(for-all even? '(3 1 4 1 5 9))          => #f
(for-all even? '(3 1 4 1 5 9 . 2))      => #f
(for-all even? '(2 4 14))               => #t
(for-all even? '(2 4 14 . 9))           => exception &assertion
(for-all (lambda (n) (and (even? n) n))
         '(2 4 14))                     => 14
(for-all < '(1 2 3) '(2 3 4))           => #t
(for-all < '(1 2 4) '(2 3 4))           => #f

(exists even? '(3 1 4 1 5 9))           => #t
(exists even? '(3 1 1 5 9))             => #f
(exists even? '(3 1 1 5 9 . 2))         => exception &assertion
(exists (lambda (n) (and (even? n) n))
        '(2 1 4 14))                    => 2
(exists < '(1 2 4) '(2 3 4))            => #t
(exists > '(1 2 3) '(2 3 4))            => #f
@end example

@strong{Implementation responsibilities:} The implementation must check
that the @var{list}s are chains of pairs to the extent necessary to
determine the return value.  If this requires traversing the lists
entirely, the implementation should check that the @var{list}s all have
the same length.  If not, it should not check that the @var{list}s are
chains of pairs beyond the traversal.  The implementation must check the
restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure filter @var{proc} @var{list}
@deffnx Procedure partition @var{proc} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.

The @func{filter} procedure applies @var{proc} to each element of
@var{list} and returns a list of the elements of @var{list} for which
@var{proc} returned a true value.

The @func{partition} procedure also applies @var{proc} to each element
of @var{list}, but returns two values, the first one a list of the
elements of @var{list} for which @var{proc} returned a true value, and
the second a list of the elements of @var{list} for which @var{proc}
returned @false{}.

In both cases, the elements of the result list(s) are in the same order
as they appear in the input list.  @var{proc} is always called in the
same dynamic environment as @func{filter} or, respectively,
@func{partition} itself.  If multiple returns occur from @func{filter}
or @func{partitions}, the return values returned by earlier returns are
not mutated.

@example
(filter even? '(3 1 4 1 5 9 2 6))       => (4 2 6)

(partition even? '(3 1 4 1 5 9 2 6))    => (4 2 6) (3 1 1 5 9)
                                           ; two values
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure fold-left @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s should all have the same length.  @var{combine} must be
a procedure; it should accept one more argument than there are
@var{list}s and return a single value; it should not mutate the
@var{list} arguments.

The @func{fold-left} procedure iterates the @var{combine} procedure over
an accumulator value and the elements of the @var{list}s from left to
right, starting with an accumulator value of @var{nil}.

More specifically, @func{fold-left} returns @var{nil} if the @var{list}s
are empty.  If they are not empty, @var{combine} is first applied to
@var{nil} and the respective first elements of the @var{list}s in order.
The result becomes the new accumulator value, and @var{combine} is
applied to the new accumulator value and the respective next elements of
the @var{list}.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.

@var{combine} is always called in the same dynamic environment as
@func{fold-left} itself.

@example
(fold-left + 0 '(1 2 3 4 5))            => 15

(fold-left (lambda (a e)
             (cons e a))
           '()
           '(1 2 3 4 5))                => (5 4 3 2 1)

(fold-left (lambda (count x)
             (if (odd? x)
                 (+ count 1)
               count))
           0
           '(3 1 4 1 5 9 2 6 5 3))      => 7

(fold-left (lambda (max-len s)
             (max max-len (string-length s)))
           0
           '("longest" "long" "longer"))
                                        => 7

(fold-left cons '(q) '(a b c))          => ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6))       => 21
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{combine} to the extent performed by
applying it as described.  An implementation may check whether
@var{combine} is an appropriate argument before applying it.
@end deffn


@deffn Procedure fold-right @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s should all have the same length.  @var{combine} must be
a procedure; it should accept one more argument than there are
@var{list}s and return a single value; @var{combine} should not mutate
the @var{list} arguments.

The @func{fold-right} procedure iterates the @var{combine} procedure
over the elements of the @var{list}s from right to left and an
accumulator value, starting with an accumulator value of @var{nil}.

More specifically, @func{fold-right} returns @var{nil} if the
@var{list}s are empty.  If they are not empty, @var{combine} is first
applied to the respective last elements of the @var{list}s in order and
@var{nil}.  The result becomes the new accumulator value, and
@var{combine} is applied to the respective previous elements of the
@var{list}s and the new accumulator value.  This step is repeated until
the beginning of the list is reached; then the accumulator value is
returned.

@var{proc} is always called in the same dynamic environment as
@func{fold-right} itself.

@example
(fold-right + 0 '(1 2 3 4 5))                   => 15

(fold-right cons '() '(1 2 3 4 5))              => (1 2 3 4 5)

(fold-right (lambda (x l)
              (if (odd? x) (cons x l) l))
            '()
            '(3 1 4 1 5 9 2 6 5))
                                                => (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c))                 => (a b c q)

(fold-right + 0 '(1 2 3) '(4 5 6))              => 21
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{combine} to the extent performed by
applying it as described.  An implementation may check whether
@var{combine} is an appropriate argument before applying it.
@end deffn


@deffn Procedure remp @var{proc} @var{list}
@deffnx Procedure remove @var{obj} @var{list}
@deffnx Procedure remv @var{obj} @var{list}
@deffnx Procedure remq @var{obj} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.

Each of these procedures returns a list of the elements of @var{list}
that do not satisfy a given condition.

The @func{remp} procedure applies @var{proc} to each element of
@var{list} and returns a list of the elements of @var{list} for which
@var{proc} returned @false{}.  @var{proc} is always called in the same
dynamic environment as @func{remp} itself.

The @func{remove}, @func{remv}, and @func{remq} procedures return a list
of the elements that are not @var{obj}.  The @func{remq} procedure uses
@func{eq?} to compare @var{obj} with the elements of @var{list}, while
@func{remv} uses @func{eqv?} and @func{remove} uses @func{equal?}.

The elements of the result list are in the same order as they appear in
the input list.  If multiple returns occur from @func{remp}, the return
values returned by earlier returns are not mutated.

@example
(remp even? '(3 1 4 1 5 9 2 6 5))       => (3 1 1 5 9 5)

(remove 1 '(3 1 4 1 5 9 2 6 5))         => (3 4 5 9 2 6 5)

(remv 1 '(3 1 4 1 5 9 2 6 5))           => (3 4 5 9 2 6 5)

(remq 'foo '(bar foo baz))              => (bar baz)
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure memp @var{proc} @var{list}
@deffnx Procedure member @var{obj} @var{list}
@deffnx Procedure memv @var{obj} @var{list}
@deffnx Procedure memq @var{obj} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.

These procedures return the first sublist of @var{list} whose car
satisfies a given condition, where the sublists of @var{lists} are the
lists returned by @code{(list-tail @var{list} @var{k})} for @var{k} less
than the length of @var{list}.

The @func{memp} procedure applies @var{proc} to the cars of the sublists
of @var{list} until it finds one for which @var{proc} returns a true
value.  @var{proc} is always called in the same dynamic environment as
@func{memp} itself.

The @func{member}, @func{memv}, and @func{memq} procedures look for the
first occurrence of @var{obj}.  If @var{list} does not contain an
element satisfying the condition, then @false{} (not the empty list) is
returned.  The @func{member} procedure uses @func{equal?} to compare
@var{obj} with the elements of @var{list}, while @func{memv} uses
@func{eqv?} and @func{memq} uses @func{eq?}.

@example
(memp even? '(3 1 4 1 5 9 2 6 5))       => (4 1 5 9 2 6 5)

(memq 'a '(a b c))                      => (a b c)
(memq 'b '(a b c))                      => (b c)
(memq 'a '(b c d))                      => #f
(memq (list 'a) '(b (a) c))             => #f
(member (list 'a) '(b (a) c))           => ((a) c)
(memq 101 '(100 101 102))               => unspecified
(memv 101 '(100 101 102))               => (101 102)
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs up to the found element, or that it
is indeed a list if no element is found.  It should not check that it is
a chain of pairs beyond the found element.  The implementation must
check the restrictions on @var{proc} to the extent performed by applying
it as described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure assp @var{proc} @var{alist}
@deffnx Procedure assoc @var{obj} @var{alist}
@deffnx Procedure assv @var{obj} @var{alist}
@deffnx Procedure assq @var{obj} @var{alist}
@var{alist} (for ``association list'') should be a list of pairs.
@var{proc} should accept one argument and return a single value.
@var{Proc} should not mutate @var{alist}.

These procedures find the first pair in @var{alist} whose car field
satisfies a given condition, and returns that pair without traversing
@var{alist} further.  If no pair in @var{alist} satisfies the condition,
then @false{} is returned.

The @func{assp} procedure successively applies @var{proc} to the car
fields of @var{alist} and looks for a pair for which it returns a true
value.  @var{proc} is always called in the same dynamic environment as
@func{assp} itself.

The @func{assoc}, @func{assv}, and @func{assq} procedures look for a
pair that has @var{obj} as its car.  The @func{assoc} procedure uses
@func{equal?} to compare @var{obj} with the car fields of the pairs in
@var{alist}, while @func{assv} uses @func{eqv?} and @func{assq} uses
@func{eq?}.

@strong{Implementation responsibilities:} The implementation must check
that @var{alist} is a chain of pairs containing pairs up to the found
pair, or that it is indeed a list of pairs if no element is found.  It
should not check that it is a chain of pairs beyond the found element.
The implementation must check the restrictions on @var{proc} to the
extent performed by applying it as described.  An implementation may
check whether @var{proc} is an appropriate argument before applying it.

@example
(define d '((3 a) (1 b) (4 c)))

(assp even? d)                                  => (4 c)
(assp odd? d)                                   => (3 a)

(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                                     => (a 1)
(assq 'b e)                                     => (b 2)
(assq 'd e)                                     => #f
(assq (list 'a) '(((a)) ((b)) ((c))))           => #f
(assoc (list 'a) '(((a)) ((b)) ((c))))          => ((a))
(assq 5 '((2 3) (5 7) (11 13)))                 => unspecified
(assv 5 '((2 3) (5 7) (11 13)))                 => (5 7)
@end example
@end deffn


@deffn Procedure {cons*} @vari{obj} @dots{} @varn{obj} @var{obj}
@deffnx Procedure {cons*} @var{obj}
If called with at least two arguments, @func{cons*} returns a freshly
allocated chain of pairs whose cars are @vari{obj}, @dots{}, @varn{obj},
and whose last cdr is @var{obj}.  If called with only one argument,
@func{cons*} returns that argument.

@example
(cons* 1 2 '(3 4 5))            => (1 2 3 4 5)
(cons* 1 2 3)                   => (1 2 . 3)
(cons* 1)                       => 1
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib sorting
@chapter Sorting


This chapter describes the @rsixlibrary{sorting} library for sorting
lists and vectors.


@deffn Procedure list-sort @var{proc list}
@deffnx Procedure vector-sort @var{proc vector}
@var{proc} should accept any two elements of @var{list} or @var{vector},
and should not have any side effects.  @var{proc} should return a true
value when its first argument is strictly less than its second, and
@false{} otherwise.

The @func{list-sort} and @func{vector-sort} procedures perform a stable
sort of @var{list} or @var{vector} in ascending order according to
@var{proc}, without changing @var{list} or @var{vector} in any way.  The
@func{list-sort} procedure returns a list, and @func{vector-sort}
returns a vector.

The results may be @func{eq?} to the argument when the argument is
already sorted, and the result of @func{list-sort} may share structure
with a tail of the original list.

The sorting algorithm performs @emph{O(n log n)} calls to @var{proc}
where @emph{n} is the length of @var{list} or @var{vector}, and all
arguments passed to @var{proc} are elements of the list or vector being
sorted, but the pairing of arguments and the sequencing of calls to
@var{proc} are not specified.  If multiple returns occur from
@func{list-sort} or @func{vector-sort}, the return values returned by
earlier returns are not mutated.

@example
(list-sort < '(3 5 2 1))                => (1 2 3 5)
(vector-sort < '#(3 5 2 1))             => #(1 2 3 5)
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure vector-sort! @var{proc} @var{vector}
@var{proc} should accept any two elements of the vector, and should not
have any side effects.  @var{proc} should return a true value when its
first argument is strictly less than its second, and @false{}
otherwise.

The @func{vector-sort!} procedure destructively sorts @var{vector} in
ascending order according to @var{proc}.  The sorting algorithm performs
@emph{O(n^2)} calls to @var{proc} where @emph{n} is the length of
@var{vector}, and all arguments passed to @var{proc} are elements of the
vector being sorted, but the pairing of arguments and the sequencing of
calls to @var{proc} are not specified.  The sorting algorithm may be
unstable.  The procedure returns unspecified values.

@example
(define v (vector 3 5 2 1))
(vector-sort! < v)              => unspecified
v                               => #(1 2 3 5)
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib control
@chapter Control structures


This chapter describes the @rsixlibrary{control} library, which provides
useful control structures.


@deffn Syntax when @meta{test} @hyperi{expression} @hyperii{expression} @dots{}
@deffnx Syntax unless @meta{test} @hyperi{expression} @hyperii{expression} @dots{}
@meta{test} must be an expression.

A @func{when} expression is evaluated by evaluating the @meta{test}
expression.  If @meta{test} evaluates to a true value, the remaining
@hyper{expression}s are evaluated in order, and the results of the last
@hyper{expression} are returned as the results of the entire @func{when}
expression.  Otherwise, the @func{when} expression returns unspecified
values.

An @func{unless} expression is evaluated by evaluating the @meta{test}
expression.  If @meta{test} evaluates to @false{}, the remaining
@hyper{expression}s are evaluated in order, and the results of the last
@hyper{expression} are returned as the results of the entire
@func{unless} expression.  Otherwise, the @func{unless} expression
returns unspecified values.

The final @hyper{expression} is in tail context if the @func{when} or
@func{unless} form is itself in tail context.

@example
(when (> 3 2) 'greater)         => greater
(when (< 3 2) 'greater)         => unspecified
(unless (> 3 2) 'less)          => unspecified
(unless (< 3 2) 'less)          => less
@end example

The @func{when} and @func{unless} expressions are derived forms.  They
could be defined by the following macros:

@example
(define-syntax @code{when}
  (syntax-rules ()
    ((when test result1 result2 ...)
     (if test
         (begin result1 result2 ...)))))

(define-syntax @code{unless}
  (syntax-rules ()
    ((unless test result1 result2 ...)
     (if (not test)
         (begin result1 result2 ...)))))
@end example
@end deffn


@deffn Syntax do ((@hyperi{variable} @hyperi{init} @hyperi{step}) @dots{}) (@meta{test} @hyper{expression} @dots{}) @meta{command} @dots{}
The @meta{init}s, @hyper{step}s, @hyper{test}s, and @hyper{command}s
must be expressions.  The @meta{variable}s must be pairwise distinct
variables.

The @func{do} expression is an iteration construct.  It specifies a set
of variables to be bound, how they are to be initialized at the start,
and how they are to be updated on each iteration.

A @func{do} expression is evaluated as follows: The @meta{init}
expressions are evaluated (in some unspecified order), the
@meta{variable}s are bound to fresh locations, the results of the
@meta{init} expressions are stored in the bindings of the
@meta{variable}s, and then the iteration phase begins.

Each iteration begins by evaluating @meta{test}; if the result is
@false{}, then the @meta{command}s are evaluated in order for effect,
the @meta{step} expressions are evaluated in some unspecified order, the
@meta{variable}s are bound to fresh locations holding the results, and
the next iteration begins.

If @meta{test} evaluates to a true value, the @meta{expression}s are
evaluated from left to right and the values of the last
@meta{expression} are returned.  If no @hyper{expression}s are present,
then the @code{do} expression returns unspecified values.

The region consists of the entire @func{do} expression except for the
@meta{init}s.

A @meta{step} may be omitted, in which case the effect is the same as if
@code{(@meta{variable} @hyper{init} @hyper{variable})} had been written
instead of @code{(@meta{variable} @hyper{init})}.

If a @code{do} expression appears in a tail context, the
@meta{expression}s are a @hyper{tail sequence} in the sense of report
section @rsixref{base tail call, Tail calls and tail contexts}, i.e.,
the last @meta{expression} is also in a tail context.

@example
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))                => #(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))                 => 25
@end example

The following definition of @func{do} uses a trick to expand the
variable clauses.

@example
(define-syntax do
  (syntax-rules ()
    ((do ((var init step ...) ...)
         (test expr ...)
         command ...)
     (letrec
       ((loop
         (lambda (var ...)
           (if test
               (begin
                 #f ; avoid empty begin
                 expr ...)
               (begin
                 command
                 ...
                 (loop (do "step" var step ...)
                       ...))))))
       (loop init ...)))
    ((do "step" x)
     x)
    ((do "step" x y)
     y)))
@end example
@end deffn


@deffn Syntax case-lambda @meta{case-lambda clause} @dots{}
Each @meta{case-lambda clause} must be of the form:

@example
(@meta{formals} @hyper{body})
@end example

@meta{formals} must be as in a @func{lambda} form (@rsixref{base
expressions procedures,Procedures}), and @meta{body} is as described in
report section @rsixref{base bodies,Bodies}.

A @func{case-lambda} expression evaluates to a procedure.  This
procedure, when applied, tries to match its arguments to the
@meta{case-lambda clause}s in order.  The arguments match a clause if
one of the following conditions is fulfilled:

@itemize
@item
@meta{formals} has the form @code{(@hyper{variable} @dots{})} and the
number of arguments is the same as the number of formal parameters in
@meta{formals}.

@item
@meta{formals} has the form:

@example
(@hyperi{variable} @dots{} @hypern{variable} . @meta{variable_(n+1)})
@end example

@noindent
and the number of arguments is at least @emph{n}.

@item
@meta{formals} has the form @code{@hyper{variable}}.
@end itemize

For the first clause matched by the arguments, the variables of the
@meta{formals} are bound to fresh locations containing the argument
values in the same arrangement as with @func{lambda}.

The last expression of a @meta{body} in a @func{case-lambda} expression
is in tail context.

If the arguments match none of the clauses, an exception with condition
type @code{&assertion} is raised.

@example
(define foo
  (case-lambda
   (() 'zero)
   ((x) (list 'one x))
   ((x y) (list 'two x y))
   ((a b c d . e) (list 'four a b c d e))
   (rest (list 'rest rest))))

(foo)                                   => zero
(foo 1)                                 => (one 1)
(foo 1 2)                               => (two 1 2)
(foo 1 2 3)                             => (rest (1 2 3))
(foo 1 2 3 4)                           => (four 1 2 3 4 ())
@end example

The @func{case-lambda} keyword can be defined in terms of @func{lambda}
by the following macros:

@example
(define-syntax case-lambda
  (syntax-rules ()
    ((_ (fmls b1 b2 ...))
     (lambda fmls b1 b2 ...))
    ((_ (fmls b1 b2 ...) ...)
     (lambda args
       (let ((n (length args)))
         (case-lambda-help args n
           (fmls b1 b2 ...) ...))))))

(define-syntax case-lambda-help
  (syntax-rules ()
    ((_ args n)
     (assertion-violation #f
       "unexpected number of arguments"))
    ((_ args n ((x ...) b1 b2 ...) more ...)
     (if (= n (length '(x ...)))
         (apply (lambda (x ...) b1 b2 ...) args)
         (case-lambda-help args n more ...)))
    ((_ args n ((x1 x2 ... . r) b1 b2 ...) more ...)
     (if (>= n (length '(x1 x2 ...)))
         (apply (lambda (x1 x2 ... . r) b1 b2 ...)
                   args)
         (case-lambda-help args n more ...)))
    ((_ args n (r b1 b2 ...) more ...)
     (apply (lambda r b1 b2 ...) args))))
@end example
@end deffn



@c ------------------------------------------------------------

@c page
@node stdlib records
@chapter Records


This section describes abstractions for creating new data types
representing records.

@menu
* stdlib records intro::                Introduction.
* stdlib records mutability::           Mutability and equivalence
                                        of records.
* stdlib records syntactic layer::      Syntactic layer.
* stdlib records procedural layer::     Procedural layer.
* stdlib records inspection::           Inspection.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib records intro
@section Introduction


A record is a compound data structure with a fixed number of components,
called @emph{fields}.  Each record has an associated type specified by a
@emph{record-type descriptor}, which is an object that specifies the
fields of the record and various other properties that all records of
that type share.  Record objects are created by a @emph{record
constructor}, a procedure that creates a fresh record object and
initializes its fields to values.  Records of different types can be
distinguished from each other and from other types of objects by
@emph{record predicates}.  A record predicate returns @true{} when
passed a record of the type specified by the record--type descriptor and
@false{} otherwise.  An @emph{accessor} extracts from a record the
component associated with a field, and a @emph{mutator} changes the
component to a different value.

Record types can be extended via single inheritance, allowing record
types to model hierarchies that occur in applications like algebraic
data types as well as single--inheritance class systems.  If a record
type @var{t} extends another record type @var{p}, each record of type
@var{t} is also a record of type @var{p}, and the predicate, accessors,
and mutators applicable to a record of type @var{p} are also applicable
to a record of type @var{t}.  The extension relationship is transitive
in the sense that a type extends its parent's parent, if any, and so on.
A record type that does not extend another record type is called a
@emph{base record type}.

A record type can be @emph{sealed} to prevent it from being extended.
Moreover, a record type can be @emph{nongenerative}, i.e., it is
globally identified by a ``uid'', and new, compatible definitions of a
nongenerative record type with the same uid as a previous always yield
the same record type.

The record mechanism spans three libraries:

@table @rsixlibrary
@item records syntactic
library, a syntactic layer for defining a record type and associated
constructor, predicate, accessor, and mutators,

@item records procedural
library, a procedural layer for creating and manipulating record types
and creating constructors, predicates, accessors, and mutators;

@item records inspection
library, a set of inspection procedures.
@end table

The inspection procedures allow programs to obtain from a record
instance a descriptor for the type and from there obtain access to the
fields of the record instance. This facility allows the creation of
portable printers and inspectors.  A program may prevent access to a
record's type (and thereby protect the information stored in the record
from the inspection mechanism) by declaring the type opaque.  Thus,
opacity as presented here can be used to enforce abstraction barriers.

Any of the standard types mentioned in this report may or may not be
implemented as an opaque record type.  Thus, it may be possible to use
inspection on objects of the standard types.

The procedural layer is particularly useful for writing interpreters
that construct host--compatible record types.  It may also serve as a
target for expansion of the syntactic layers.  The record operations
provided through the procedural layer may, however, be less efficient
than the operations provided through the syntactic layer, which is
designed to allow expand--time determination of record--instance sizes
and field offsets.  Therefore, alternative implementations of syntactic
record--type definition should, when possible, expand into the syntactic
layer rather than the procedural layer.

The syntactic layer is used more commonly and therefore described first.
This chapter uses the @var{rtd} and @var{constructor-descriptor}
parameter names for arguments that must be record-type descriptors and
constructor descriptors, respectively.


@c ------------------------------------------------------------

@c page
@node stdlib records mutability
@section Mutability and equivalence of records


The fields of a record type are designated @emph{mutable} or
@emph{immutable}.  Correspondingly, a record type with no mutable field
is called @emph{immutable}, and all records of that type are immutable
objects.  All other record types are @emph{mutable}, and so are their
records.

Each call to a record constructor returns a new record with a fresh
location (see report section @rsixref{basic storage model,Storage
model}).  Consequently, for two records @vari{obj} and @varii{obj}, the
return value of @code{(eqv? @vari{obj} @varii{obj})}, as well as the
return value of @code{(eq? @vari{obj} @varii{obj})}, adheres to the
following criteria (see report section @rsixref{base
predicates,Equivalence predicates}):

@itemize
@item
If @vari{obj} and @varii{obj} have different record types (i.e., their
record--type descriptors are not @func{eqv?}), @func{eqv?}  returns
@false{}.

@item
If @vari{obj} and @varii{obj} are both records of the same record type,
and are the results of two separate calls to record constructors, then
@func{eqv?} returns @false{}.
@item
If @vari{obj} and @varii{obj} are both the result of a single call to a
record constructor, then @func{eqv?} returns @true{}.

@item
If @vari{obj} and @varii{obj} are both records of the same record type,
where applying an accessor to both yields results for which @func{eqv?}
returns @false{}, then @func{eqv?} returns @false{}.
@end itemize


@c ------------------------------------------------------------

@c page
@node stdlib records syntactic layer
@section Syntactic layer


The syntactic layer is provided by the @rsixlibrary{records syntactic}
library.  Some details of the specification are explained in terms of
the specification of the procedural layer below.

The record--type--defining form @func{define-record-type} is a
definition and can appear anywhere any other @meta{definition} can
appear.


@deffn Syntax define-record-type @meta{name spec} @arbno{@hyper{record clause}}
@deffnx {Auxiliary Syntax} fields
@deffnx {Auxiliary Syntax} mutable
@deffnx {Auxiliary Syntax} immutable
@deffnx {Auxiliary Syntax} parent
@deffnx {Auxiliary Syntax} protocol
@deffnx {Auxiliary Syntax} sealed
@deffnx {Auxiliary Syntax} opaque
@deffnx {Auxiliary Syntax} nongenerative
@deffnx {Auxiliary Syntax} parent-rtd
A @func{define-record-type} form defines a record type along with
associated constructor descriptor and constructor, predicate, field
accessors, and field mutators.  The @func{define-record-type} form
expands into a set of definitions in the environment where
@func{define-record-type} appears; hence, it is possible to refer to the
bindings (except for that of the record type itself) recursively.

The @meta{name spec} specifies the names of the record type,
constructor, and predicate. It must take one of the following forms:

@example
(@meta{record name} @hyper{constructor name} @hyper{predicate name})
@meta{record name}
@end example

@meta{record name}, @hyper{constructor name}, and @hyper{predicate name}
must all be identifiers.

@meta{record name}, taken as a symbol, becomes the name of the record
type.  (See the description of @func{make-record-type-descriptor}
below.)  Additionally, it is bound by this definition to an expand--time
or run--time representation of the record type and can be used as parent
name in syntactic record--type definitions that extend this
definition. It can also be used as a handle to gain access to the
underlying record--type descriptor and constructor descriptor (see
@func{record-type-descriptor} and @func{record-constructor-descriptor}
below).

@meta{constructor name} is defined by this definition to be a
constructor for the defined record type, with a protocol specified by
the @code{protocol} clause, or, in its absence, using a default
protocol.  For details, see the description of the @code{protocol}
clause below.

@meta{predicate name} is defined by this definition to a predicate for
the defined record type.

The second form of @meta{name spec} is an abbreviation for the first
form, where the name of the constructor is generated by prefixing the
record name with @code{make-}, and the predicate name is generated by
adding a question mark (@code{?}) to the end of the record name. For
example, if the record name is @code{frob}, the name of the constructor
is @func{make-frob}, and the predicate name is @func{frob?}.

Each @meta{record clause} must take one of the following forms; it is a
syntax violation if multiple @meta{record clause}s of the same kind
appear in a @func{define-record-type} form.
@end deffn


@deffn {Auxiliary Syntax} fields @arbno{@meta{field spec}}
Each @meta{field spec} has one of the following forms

@example
(immutable @meta{field name} @hyper{accessor name})
(mutable @meta{field name}
         @meta{accessor name} @hyper{mutator name})
(immutable @meta{field name})
(mutable @meta{field name})
@meta{field name}
@end example

@meta{field name}, @hyper{accessor name}, and @hyper{mutator name} must
all be identifiers.  The first form declares an immutable field called
@meta{field name}, with the corresponding accessor named @meta{accessor
name}.  The second form declares a mutable field called @meta{field
name}, with the corresponding accessor named @meta{accessor name}, and
with the corresponding mutator named @meta{mutator name}.

If @meta{field spec} takes the third or fourth form, the accessor name
is generated by appending the record name and field name with a hyphen
separator, and the mutator name (for a mutable field) is generated by
adding a @code{-set!} suffix to the accessor name.  For example, if the
record name is @code{frob} and the field name is @code{widget}, the
accessor name is @func{frob-widget} and the mutator name is
@func{frob-widget-set!}.

If @meta{field spec} is just a @hyper{field name} form, it is an
abbreviation for @code{(immutable @meta{field name})}.

The @meta{field name}s become, as symbols, the names of the fields in
the record--type descriptor being created, in the same order.

The @code{fields} clause may be absent; this is equivalent to an empty
@code{fields} clause.
@end deffn


@deffn {Auxiliary Syntax} parent @meta{parent name}
Specifies that the record type is to have parent type @hyper{parent
name}, where @meta{parent name} is the @hyper{record name} of a record
type previously defined using @func{define-record-type}.  The
record--type definition associated with @meta{parent name} must not be
sealed.  If no @code{parent} clause and no @code{parent-rtd} (see below)
clause is present, the record type is a base type.
@end deffn


@deffn {Auxiliary Syntax} protocol @meta{expression}
@meta{expression} is evaluated in the same environment as the
@func{define-record-type} form, and must evaluate to a protocol
appropriate for the record type being defined.

The protocol is used to create a record--constructor descriptor as
described below.  If no @code{protocol} clause is specified, a
constructor descriptor is still created using a default protocol.  The
clause can be absent only if the record type being defined has no parent
type, or if the parent definition does not specify a protocol.
@end deffn


@deffn {Auxiliary Syntax} sealed #t
@deffnx {Auxiliary Syntax} sealed #f
If this option is specified with operand @true{}, the defined record
type is sealed, i.e., no extensions of the record type can be created.
If this option is specified with operand @false{}, or is absent, the
defined record type is not sealed.
@end deffn


@deffn {Auxiliary Syntax} opaque #t
@deffnx {Auxiliary Syntax} opaque #f
If this option is specified with operand @true{}, or if an opaque parent
record type is specified, the defined record type is opaque.  Otherwise,
the defined record type is not opaque.  See the specification of
@code{record-rtd} below for details.
@end deffn


@deffn {Auxiliary Syntax} nongenerative @meta{uid}
@deffnx {Auxiliary Syntax} nongenerative
This specifies that the record type is nongenerative with uid
@meta{uid}, which must be an @hyper{identifier}.  If @meta{uid} is
absent, a unique uid is generated at macro--expansion time.  If two
record--type definitions specify the same @var{uid}, then the
record--type definitions should be equivalent, i.e., the implied
arguments to @func{make-record-type-descriptor} must be equivalent as
described under @func{make-record-type-descriptor}.

If this condition is not met, it is either considered a syntax violation
or an exception with condition type @code{&assertion} is raised.  If the
condition is met, a single record type is generated for both
definitions.

In the absence of a @code{nongenerative} clause, a new record type is
generated every time a @func{define-record-type} form is evaluated:

@example
(let ((f (lambda (x)
           (define-record-type r ...)
           (if x r? (make-r ...)))))
  ((f #t) (f #f)))
=> #f
@end example
@end deffn


@deffn {Auxiliary Syntax} parent-rtd @meta{parent rtd} @hyper{parent cd}
Specifies that the record type is to have its parent type specified by
@meta{parent rtd}, which should be an expression evaluating to a
record--type descriptor, and @meta{parent cd}, which should be an
expression evaluating to a constructor descriptor (see below).  Either
@meta{parent rtd} or @meta{parent cd} can evaluate to @false{}.  The
record--type definition associated with the value of @meta{parent rtd}
must not be sealed.  Moreover, a record--type definition must not have
both a @code{parent} and a @code{parent-rtd} clause.
@end deffn


@quotation
@emph{Note:} The syntactic layer is designed to allow record--instance
sizes and field offsets to be determined at expand time, i.e., by a
macro definition of @func{define-record-type}, as long as the parent (if
any) is known.  Implementations that take advantage of this may generate
less efficient constructor, accessor, and mutator code when the
@code{parent-rtd} clause is used, since the type of the parent is
generally not known until run time.  The @code{parent} clause should
therefore be used instead when possible.
@end quotation

All bindings created by @func{define-record-type} (for the record type,
the constructor, the predicate, the accessors, and the mutators) must
have names that are pairwise distinct.

The constructor created by a @func{define-record-type} form is a
procedure as follows:

@itemize
@item
If there is no @code{parent} clause and no @code{protocol} clause, the
constructor accepts as many arguments as there are fields, in the same
order as they appear in the @code{fields} clause, and returns a record
object with the fields initialized to the corresponding arguments.

@item
If there is no @code{parent} or @code{parent-rtd} clause and a
@code{protocol} clause, the protocol expression must evaluate to a
procedure that accepts a single argument.  The protocol procedure is
called once during the evaluation of the @func{define-record-type} form
with a procedure @var{p} as its argument.  It should return a procedure,
which will become the constructor bound to @meta{constructor name}.  The
procedure @var{p} accepts as many arguments as there are fields, in the
same order as they appear in the @code{fields} clause, and returns a
record object with the fields initialized to the corresponding
arguments.

The constructor returned by the protocol procedure can accept an
arbitrary number of arguments, and should call @var{p} once to construct
a record object, and return that record object.

For example, the following protocol expression for a record--type
definition with three fields creates a constructor that accepts values
for all fields, and initialized them in the reverse order of the
arguments:

@example
(lambda (p)
  (lambda (v1 v2 v3)
    (p v3 v2 v1)))
@end example

@item
If there is both a @code{parent} clause and a @code{protocol} clause,
then the protocol procedure is called once with a procedure @var{n} as
its argument.  As in the previous case, the protocol procedure should
return a procedure, which will become the constructor bound to
@meta{constructor name}.  However, @var{n} is different from @var{p} in
the previous case: It accepts arguments corresponding to the arguments
of the constructor of the parent type.  It then returns a procedure
@var{p} that accepts as many arguments as there are (additional) fields
in this type, in the same order as in the @code{fields} clause, and
returns a record object with the fields of the parent record types
initialized according to their constructors and the arguments to
@var{n}, and the fields of this record type initialized to its arguments
of @var{p}.

The constructor returned by the protocol procedure can accept an
arbitrary number of arguments, and should call @var{n} once to construct
the procedure @var{p}, and call @var{p} once to create the record
object, and finally return that record object.

For example, the following protocol expression assumes that the
constructor of the parent type takes three arguments:

@example
(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))
@end example

The resulting constructor accepts seven arguments, and initializes the
fields of the parent types according to the constructor of the parent
type, with @var{v1}, @var{v2}, and @var{v3} as arguments.  It also
initializes the fields of this record type to the values of @var{x1},
@dots{}, @var{x4}.

@item
If there is a @code{parent} clause, but no @code{protocol} clause, then
the parent type must not have a @code{protocol} clause itself.  The
constructor bound to @meta{constructor name} is a procedure that accepts
arguments corresponding to the parent types' constructor first, and then
one argument for each field in the same order as in the @code{fields}
clause.  The constructor returns a record object with the fields
initialized to the corresponding arguments.

@item
If there is a @code{parent-rtd} clause, then the constructor is as with
a @code{parent} clause, except that the constructor of the parent type
is determined by the constructor descriptor of the @code{parent-rtd}
clause.
@end itemize

A protocol may perform other actions consistent with the requirements
described above, including mutation of the new record or other side
effects, before returning the record.

Any definition that takes advantage of implicit naming for the
constructor, predicate, accessor, and mutator names can be rewritten
trivially to a definition that specifies all names explicitly. For
example, the implicit--naming record definition:

@example
(define-record-type frob
  (fields (mutable widget))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
@end example

@noindent
is equivalent to the following explicit--naming record definition.

@example
(define-record-type (frob make-frob frob?)
  (fields (mutable widget
                   frob-widget
                   frob-widget-set!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
@end example

Also, the implicit--naming record definition:

@example
(define-record-type point (fields x y))
@end example

@noindent
is equivalent to the following explicit--naming record definition:

@example
(define-record-type (point make-point point?)
  (fields
    (immutable x point-x)
    (immutable y point-y)))
@end example

With implicit naming, it is still possible to specify some of the names
explicitly; for example, the following overrides the choice of accessor
and mutator names for the widget field.

@example
(define-record-type frob
  (fields (mutable widget getwid setwid!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
@end example


@deffn Syntax record-type-descriptor @meta{record name}
Evaluates to the record--type descriptor (see below) associated with the
type specified by @meta{record name}.

@quotation
@emph{Note:} The @func{record-type-descriptor} procedure works on both
opaque and non--opaque record types.
@end quotation
@end deffn


@deffn Syntax record-constructor-descriptor @meta{record name}
Evaluates to the record--constructor descriptor (see below) associated
with @meta{record name}.
@end deffn


The following example uses the @func{record?} procedure from the
@rsixlibrary{records inspection} library:

@example
(define-record-type (point make-point point?)
  (fields (immutable x point-x)
          (mutable y point-y set-point-y!))
  (nongenerative
    point-4893d957-e00b-11d9-817f-00111175eb9e))

(define-record-type (cpoint make-cpoint cpoint?)
  (parent point)
  (protocol
   (lambda (n)
     (lambda (x y c)
       ((n x y) (color->rgb c)))))
  (fields
    (mutable rgb cpoint-rgb cpoint-rgb-set!)))

(define (color->rgb c)
  (cons 'rgb c))

(define p1 (make-point 1 2))
(define p2 (make-cpoint 3 4 'red))

(point? p1)                             => #t
(point? p2)                             => #t
(point? (vector))                       => #f
(point? (cons 'a 'b))                   => #f
(cpoint? p1)                            => #f
(cpoint? p2)                            => #f
(point-x p1)                            => 1
(point-y p1)                            => 2
(point-x p2)                            => 3
(point-y p2)                            => 4
(cpoint-rgb p2)                         => (rgb . red)

(set-point-y! p1 17)                    => unspecified
(point-y p1)                            => 17

(record-rtd p1)
=> (record-type-descriptor point)

(define-record-type (ex1 make-ex1 ex1?)
  (protocol (lambda (p) (lambda a (p a))))
  (fields (immutable f ex1-f)))

(define ex1-i1 (make-ex1 1 2 3))
(ex1-f ex1-i1)                          => (1 2 3)

(define-record-type (ex2 make-ex2 ex2?)
  (protocol
    (lambda (p) (lambda (a . b) (p a b))))
  (fields (immutable a ex2-a)
          (immutable b ex2-b)))

(define ex2-i1 (make-ex2 1 2 3))
(ex2-a ex2-i1)                          => 1
(ex2-b ex2-i1)                          => (2 3)

(define-record-type (unit-vector
                     make-unit-vector
                     unit-vector?)
  (protocol
   (lambda (p)
     (lambda (x y z)
       (let ((length
               (sqrt (+ (* x x)
                        (* y y)
                        (* z z)))))
         (p (/ x length)
            (/ y length)
            (/ z length))))))
  (fields (immutable x unit-vector-x)
          (immutable y unit-vector-y)
          (immutable z unit-vector-z)))

(define *ex3-instance* #f)

(define-record-type ex3
  (parent cpoint)
  (protocol
   (lambda (n)
     (lambda (x y t)
       (let ((r ((n x y 'red) t)))
         (set! *ex3-instance* r)
         r))))
  (fields
   (mutable thickness))
  (sealed #t) (opaque #t))

(define ex3-i1 (make-ex3 1 2 17))
(ex3? ex3-i1)                           => #t
(cpoint-rgb ex3-i1) => (rgb . red)
(ex3-thickness ex3-i1)                  => 17
(ex3-thickness-set! ex3-i1 18)          => unspecified
(ex3-thickness ex3-i1)                  => 18
*ex3-instance*                          => ex3-i1

(record? ex3-i1)                        => #f
@end example



@c ------------------------------------------------------------

@c page
@node stdlib records procedural layer
@section Procedural layer


The procedural layer is provided by the @rsixlibrary{records procedural}
library.


@deffn Procedure make-record-type-descriptor @var{name} @var{parent} @var{uid} @var{sealed?} @var{opaque?} @var{fields}
Return a @emph{record-type descriptor}, or @emph{rtd}, representing a
record type distinct from all built--in types and other record types.

The @var{name} argument must be a symbol.  It names the record type, and
is intended purely for informational purposes and may be used for
printing by the underlying Scheme system.

The @var{parent} argument must be either @false{} or an rtd. If it is an
rtd, the returned record type, @var{t}, extends the record type @var{p}
represented by @var{parent}.  An exception with condition type
@code{&assertion} is raised if @var{parent} is sealed (see below).

The @var{uid} argument must be either @false{} or a symbol.  If
@var{uid} is a symbol, the record--creation operation is
@emph{nongenerative} i.e., a new record type is created only if no
previous call to @func{make-record-type-descriptor} was made with the
@var{uid}.  If @var{uid} is @false{}, the record--creation operation is
@emph{generative}, i.e., a new record type is created even if a previous
call to @func{make-record-type-descriptor} was made with the same
arguments.

If @func{make-record-type-descriptor} is called twice with the same
@var{uid} symbol, the parent arguments in the two calls must be
@func{eqv?}, the @var{fields} arguments @func{equal?}, the @var{sealed?}
arguments boolean--equivalent (both @false{} or both true), and the
@var{opaque?} arguments boolean--equivalent.  If these conditions are
not met, an exception with condition type @code{&assertion} is raised
when the second call occurs.  If they are met, the second call returns,
without creating a new record type, the same record--type descriptor (in
the sense of @func{eqv?}) as the first call.

@quotation
@emph{Note:} Users are encouraged to use symbol names constructed using
the @acronym{UUID} namespace (for example, using the record--type name
as a prefix) for the uid argument.
@end quotation

The @var{sealed?} flag must be a boolean.  If true, the returned record
type is sealed, i.e., it cannot be extended.

The @var{opaque?} flag must be a boolean.  If true, the record type is
opaque.  If passed an instance of the record type, @func{record?}
returns @false{}.  Moreover, if @code{record-rtd} (see ``Inspection''
below) is called with an instance of the record type, an exception with
condition type @code{&assertion} is raised.  The record type is also
opaque if an opaque parent is supplied.  If @var{opaque?} is @false{}
and an opaque parent is not supplied, the record is not opaque.

The @var{fields} argument must be a vector of field specifiers. Each
field specifier must be a list of the form @code{(mutable @var{name})}
or a list of the form @code{(immutable @var{name})}.  Each name must be
a symbol and names the corresponding field of the record type; the names
need not be distinct.  A field identified as mutable may be modified,
whereas, when a program attempts to obtain a mutator for a field
identified as immutable, an exception with condition type
@code{&assertion} is raised.  Where field order is relevant, e.g., for
record construction and field access, the fields are considered to be
ordered as specified, although no particular order is required for the
actual representation of a record instance.

The specified fields are added to the parent fields, if any, to
determine the complete set of fields of the returned record type.  If
@var{fields} is modified after @func{make-record-type-descriptor} has
been called, the effect on the returned rtd is unspecified.

A generative record--type descriptor created by a call to
@func{make-record-type-descriptor} is not @func{eqv?} to any
record--type descriptor (generative or nongenerative) created by another
call to @func{make-record-type-descriptor}.  A generative record--type
descriptor is @func{eqv?}  only to itself, i.e., @code{(eqv? @vari{rtd}
@varii{rtd})} if, and only if, @code{(eq? @vari{rtd} @varii{rtd})}.
Also, two nongenerative record--type descriptors are @func{eqv?} if, and
only if, they were created by calls to
@func{make-record-type-descriptor} with the same uid arguments.
@end deffn


@deffn Procedure record-type-descriptor? @var{obj}
Return @true{} if the argument is a record--type descriptor, @false{}
otherwise.
@end deffn


@deffn Procedure make-record-constructor-descriptor @var{rtd} @var{parent-constructor-descriptor} @var{protocol}
Return a @emph{record-constructor descriptor} (or @emph{constructor
descriptor} for short) that specifies a @emph{record constructor} (or
@emph{constructor} for short), that can be used to construct record
values of the type specified by @var{rtd}, and which can be obtained via
@func{record-constructor}.  A constructor descriptor can also be used to
create other constructor descriptors for subtypes of its own record
type.  @var{rtd} must be a record--type descriptor.  @var{protocol} must
be a procedure or @false{}.  If it is @false{}, a default @var{protocol}
procedure is supplied.

If @var{protocol} is a procedure, it is handled analogously to the
protocol expression in a @func{define-record-type} form.

If @var{rtd} is a base record type @var{parent-constructor-descriptor}
must be @false{}.  In this case, @var{protocol} is called by
@func{record-constructor} with a single argument @var{p}.  @var{p} is a
procedure that expects one argument for every field of @var{rtd} and
returns a record with the fields of @var{rtd} initialized to these
arguments.  The procedure returned by @var{protocol} should call @var{p}
once with the number of arguments @var{p} expects and return the
resulting record as shown in the simple example below:

@example
(lambda (p)
  (lambda (v1 v2 v3)
    (p v1 v2 v3)))
@end example

Here, the call to @code{p} returns a record whose fields are initialized
with the values of @code{v1}, @code{v2}, and @code{v3}.  The expression
above is equivalent to @code{(lambda (p) p)}.  Note that the procedure
returned by @var{protocol} is otherwise unconstrained; specifically, it
can take any number of arguments.

If @var{rtd} is an extension of another record type @var{parent-rtd} and
@var{protocol} is a procedure, @var{parent-constructor-descriptor} must
be a constructor descriptor of @var{parent-rtd} or @false{}.  If
@var{parent-constructor-descriptor} is a constructor descriptor,
@var{protocol} it is called by @code{record-constructor} with a single
argument @var{n}, which is a procedure that accepts the same number of
arguments as the constructor of @var{parent-constructor-descriptor} and
returns a procedure @var{p} that, when called, constructs the record
itself.  The @var{p} procedure expects one argument for every field of
@var{rtd} (not including parent fields) and returns a record with the
fields of @var{rtd} initialized to these arguments, and the fields of
@var{parent-rtd} and its parents initialized as specified by
@var{parent-constructor-descriptor}.

The procedure returned by @var{protocol} should call @var{n} once with
the number of arguments @var{n} expects, call the procedure @var{p} it
returns once with the number of arguments @var{p} expects and return the
resulting record.  A simple @var{protocol} in this case might be written
as follows:

@example
(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))
@end example

This passes arguments @var{v1}, @var{v2}, @var{v3} to @var{n} for
@var{parent-constructor-descriptor} and calls @func{p} with @var{x1},
@dots{}, @var{x4} to initialize the fields of @var{rtd} itself.

Thus, the constructor descriptors for a record type form a sequence of
protocols parallel to the sequence of record--type parents.  Each
constructor descriptor in the chain determines the field values for the
associated record type.  Child record constructors need not know the
number or contents of parent fields, only the number of arguments
accepted by the parent constructor.

@var{protocol} may be @false{}, specifying a default constructor that
accepts one argument for each field of @var{rtd} (including the fields
of its parent type, if any).  Specifically, if @var{rtd} is a base type,
the default @var{protocol} procedure behaves as if it were @code{(lambda
(p) p)}.  If @var{rtd} is an extension of another type, then
@var{parent-constructor-descriptor} must be either @false{} or itself
specify a default constructor, and the default @var{protocol} procedure
behaves as if it were:

@example
(lambda (n)
  (lambda (@vari{v} @dots{} @varj{v} @vari{x} @dots{} @vark{x})
    (let ((p (n @vari{v} @dots{} @varj{v})))
      (p @vari{x} @dots{} @vark{x}))))
@end example

The resulting constructor accepts one argument for each of the record
type's complete set of fields (including those of the parent record
type, the parent's parent record type, etc.) and returns a record with
the fields initialized to those arguments, with the field values for the
parent coming before those of the extension in the argument list.  (In
the example, @emph{j} is the complete number of fields of the parent
type, and $k$ is the number of fields of @var{rtd} itself.)

If @var{rtd} is an extension of another record type and
@var{parent-constructor-descriptor} is @false{},
@var{parent-constructor-descriptor} is treated as if it were a
constructor descriptor for the parent rtd of @var{rtd} with a default
protocol.

@strong{Implementation responsibilities:} If @var{protocol} is a
procedure, the implementation must check the restrictions on it to the
extent performed by applying it as described when the constructor is
called.  An implementation may check whether @var{protocol} is an
appropriate argument before applying it.

@example
(define rtd1
  (make-record-type-descriptor
   'rtd1 #f #f #f #f
   '#((immutable x1) (immutable x2))))

(define rtd2
  (make-record-type-descriptor
   'rtd2 rtd1 #f #f #f
   '#((immutable x3) (immutable x4))))

(define rtd3
  (make-record-type-descriptor
   'rtd3 rtd2 #f #f #f
   '#((immutable x5) (immutable x6))))

(define protocol1
  (lambda (p)
    (lambda (a b c)
      (p (+ a b) (+ b c)))))

(define protocol2
  (lambda (n)
    (lambda (a b c d e f)
      (let ((p (n a b c)))
        (p (+ d e) (+ e f))))))

(define protocol3
  (lambda (n)
    (lambda (a b c d e f g h i)
      (let ((p (n a b c d e f)))
        (p (+ g h) (+ h i))))))

(define cd1
  (make-record-constructor-descriptor
    rtd1 #f protocol1))

(define cd2
  (make-record-constructor-descriptor
    rtd2 cd1 protocol2))

(define cd3
  (make-record-constructor-descriptor
    rtd3 cd2 protocol3))

(define make-rtd1 (record-constructor cd1))

(define make-rtd2 (record-constructor cd2))

(define make-rtd3 (record-constructor cd3))

(make-rtd3 1 2 3 4 5 6 7 8 9)
=> <record with fields initialized to 3, 5, 9, 11, 15, 17>
@end example
@end deffn


@deffn Procedure record-constructor @var{constructor-descriptor}
Call the @var{protocol} of @var{constructor-descriptor} (as described
for @func{make-record-constructor-descriptor}) and returns the resulting
constructor @var{constructor} for records of the record type associated
with @var{constructor-descriptor}.
@end deffn


@deffn Procedure record-predicate @var{rtd}
Return a procedure that, given an object @var{obj}, returns @true{} if
@var{obj} is a record of the type represented by @var{rtd}, and @false{}
otherwise.
@end deffn


@deffn Procedure record-accessor @var{rtd} @var{k}
@var{k} must be a valid field index of @var{rtd}.  The
@func{record-accessor} procedure returns a one--argument procedure whose
argument must be a record of the type represented by @var{rtd}.  This
procedure returns the value of the selected field of that record.

The field selected corresponds to the @var{k}th element (0--based) of
the @var{fields} argument to the invocation of
@func{make-record-type-descriptor} that created @var{rtd}.  Note that
@var{k} cannot be used to specify a field of any type @var{rtd} extends.
@end deffn


@deffn Procedure record-mutator @var{rtd} @var{k}
@var{k} must be a valid field index of @var{rtd}.  The
@func{record-mutator} procedure returns a two--argument procedure whose
arguments must be a record record @var{r} of the type represented by
@var{rtd} and an object @var{obj}.  This procedure stores @var{obj}
within the field of @var{r} specified by @var{k}.  The @var{k} argument
is as in @func{record-accessor}.  If @var{k} specifies an immutable
field, an exception with condition type @code{&assertion} is raised.
The mutator returns unspecified values.
@end deffn


@example
(define :point
  (make-record-type-descriptor
    'point #f
    #f #f #f
    '#((mutable x) (mutable y))))

(define :point-cd
  (make-record-constructor-descriptor :point #f #f))

(define make-point (record-constructor :point-cd))

(define point? (record-predicate :point))
(define point-x (record-accessor :point 0))
(define point-y (record-accessor :point 1))
(define point-x-set! (record-mutator :point 0))
(define point-y-set! (record-mutator :point 1))

(define p1 (make-point 1 2))
(point? p1)                             => #t
(point-x p1)                            => 1
(point-y p1)                            => 2
(point-x-set! p1 5)                     => unspecified
(point-x p1)                            => 5

(define :point2
  (make-record-type-descriptor
    'point2 :point
    #f #f # f '#((mutable x) (mutable y))))

(define make-point2
  (record-constructor
    (make-record-constructor-descriptor :point2
      #f #f)))
(define point2? (record-predicate :point2))
(define point2-xx (record-accessor :point2 0))
(define point2-yy (record-accessor :point2 1))

(define p2 (make-point2 1 2 3 4))
(point? p2)                             => #t
(point-x p2)                            => 1
(point-y p2)                            => 2
(point2-xx p2)                          => 3
(point2-yy p2)                          => 4

(define :point-cd/abs
  (make-record-constructor-descriptor
   :point #f
   (lambda (new)
     (lambda (x y)
       (new (abs x) (abs y))))))

(define make-point/abs
  (record-constructor :point-cd/abs))

(point-x (make-point/abs -1 -2))        => 1
(point-y (make-point/abs -1 -2))        => 2

(define :cpoint
  (make-record-type-descriptor
   'cpoint :point
   #f #f #f
   '#((mutable rgb))))

(define make-cpoint
  (record-constructor
   (make-record-constructor-descriptor
    :cpoint :point-cd
    (lambda (p)
      (lambda (x y c)
	((p x y) (color->rgb c)))))))

(define make-cpoint/abs
  (record-constructor
   (make-record-constructor-descriptor
    :cpoint :point-cd/abs
    (lambda (p)
      (lambda (x y c)
	((p x y) (color->rgb c)))))))

(define cpoint-rgb
  (record-accessor :cpoint 0))

(define (color->rgb c)
  (cons 'rgb c))

(cpoint-rgb (make-cpoint -1 -3 'red))   => (rgb . red)
(point-x (make-cpoint -1 -3 'red))      => -1
(point-x (make-cpoint/abs -1 -3 'red))  => 1
@end example


@c ------------------------------------------------------------

@c page
@node stdlib records inspection
@section Inspection


The @rsixlibrary{records inspection} library provides procedures for
inspecting records and their record--type descriptors.  These procedures
are designed to allow the writing of portable printers and inspectors.

On the one hand, @func{record?} and @func{record-rtd} treat records of
opaque record types as if they were not records.  On the other hand, the
inspection procedures that operate on record--type descriptors
themselves are not affected by opacity.  In other words, opacity
controls whether a program can obtain an rtd from a record.  If the
program has access to the original rtd via
@func{make-record-type-descriptor} or @func{record-type-descriptor}, it
can still make use of the inspection procedures.


@deffn Procedure record? @var{obj}
Return @true{} if @var{obj} is a record, and its record type is not
opaque, and return @false{} otherwise.
@end deffn


@deffn Procedure record-rtd @var{record}
Return the rtd representing the type of @var{record} if the type is not
opaque.  The rtd of the most precise type is returned; that is, the type
@var{t} such that @var{record} is of type @var{t} but not of any type
that extends @var{t}.  If the type is opaque, an exception is raised
with condition type @code{&assertion}.
@end deffn


@deffn Procedure record-type-name @var{rtd}
Return the name of the record--type descriptor @var{rtd}.
@end deffn


@deffn Procedure record-type-parent @var{rtd}
Return the parent of the record--type descriptor @var{rtd}, or @false{}
if it has none.
@end deffn


@deffn Procedure record-type-uid @var{rtd}
Return the uid of the record--type descriptor rtd, or @false{} if it has
none.  (An implementation may assign a generated uid to a record type
even if the type is generative, so the return of a uid does not
necessarily imply that the type is nongenerative.)
@end deffn


@deffn Procedure record-type-generative? @var{rtd}
Return @true{} if @var{rtd} is generative, and @false{} if not.
@end deffn


@deffn Procedure record-type-sealed? @var{rtd}
Return @true{} if the record-type descriptor is sealed, and @false{} if
not.
@end deffn


@deffn Procedure record-type-opaque? @var{rtd}
Return @true{} if the the record-type descriptor is opaque, and @false{}
if not.
@end deffn


@deffn Procedure record-type-field-names @var{rtd}
Return a vector of symbols naming the fields of the type represented by
@var{rtd} (not including the fields of parent types) where the fields
are ordered as described under @func{make-record-type-descriptor}.  The
returned vector may be immutable.  If the returned vector is modified,
the effect on @var{rtd} is unspecified.
@end deffn


@deffn Procedure record-field-mutable? @var{rtd} @var{k}
Returns @true{} if the field specified by @var{k} of the type
represented by @var{rtd} is mutable, and @false{} if not.  @var{k} is as
in @func{record-accessor}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib exceptions
@chapter Exceptions and conditions


Scheme allows programs to deal with exceptional situations using two
cooperating facilities: The exception system for raising and handling
exceptional situations, and the condition system for describing these
situations.

The exception system allows the program, when it detects an exceptional
situation, to pass control to an exception handler, and to dynamically
establish such exception handlers.  Exception handlers are always
invoked with an object describing the exceptional situation.  Scheme's
condition system provides a standardized taxonomy of such descriptive
objects, as well as a facility for extending the taxonomy.


@menu
* stdlib exceptions exceptions::        Exceptions.
* stdlib exceptions conditions::        Conditions.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib exceptions exceptions
@section Exceptions


This section describes Scheme's exception--handling and
exception--raising constructs provided by the @rsixlibrary{exceptions}
library.

Exception handlers are one--argument procedures that determine the
action the program takes when an exceptional situation is signalled.
The system implicitly maintains a current exception handler.

The program raises an exception by invoking the current exception
handler, passing it an object encapsulating information about the
exception.  Any procedure accepting one argument may serve as an
exception handler and any object may be used to represent an exception.

The system maintains the current exception handler as part of the
dynamic environment of the program; see report section @rsixref{basic
dynamic extent,Dynamic extent and dynamic environment}.

When a program begins its execution, the current exception handler is
expected to handle all @code{&serious} conditions by interrupting
execution, reporting that an exception has been raised, and displaying
information about the condition object that was provided.  The handler
may then exit, or may provide a choice of other options.  Moreover, the
exception handler is expected to return when passed any other
non--@code{&serious} condition.  Interpretation of these expectations
necessarily depends upon the nature of the system in which programs are
executed, but the intent is that users perceive the raising of an
exception as a controlled escape from the situation that raised the
exception, not as a crash.


@deffn Procedure with-exception-handler @var{handler} @var{thunk}
@var{handler} must be a procedure and should accept one argument.
@var{thunk} must be a procedure that accepts zero arguments.  The
@func{with-exception-handler} procedure returns the results of invoking
@var{thunk}.  @var{handler} is installed as the current exception
handler for the dynamic extent (as determined by @func{dynamic-wind}) of
the invocation of @var{thunk}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{handler} to the extent performed by applying it
as described when it is called as a result of a call to @func{raise} or
@func{raise-continuable}.  An implementation may check whether
@var{handler} is an appropriate argument before applying it.
@end deffn


@deffn Syntax guard (@meta{variable} @hyperi{cond clause} @hyperii{cond clause} @dots{}) @meta{body}
@deffnx {Auxiliary Syntax} {=>}
@deffnx {Auxiliary Syntax} else
Each @meta{cond clause} is as in the specification of @func{cond}.  (See
report section @rsixref{base expressions derived cond,Derived
conditionals}.)  @code{=>} and @code{else} are the same as in the
@rsixlibrary{base} library.

Evaluating a @func{guard} form evaluates @meta{body} with an exception
handler that binds the raised object to @meta{variable} and within the
scope of that binding evaluates the clauses as if they were the clauses
of a @func{cond} expression.  That implicit @func{cond} expression is
evaluated with the continuation and dynamic environment of the
@func{guard} expression.  If every @meta{cond clause}'s @hyper{test}
evaluates to @false{} and there is no @code{else} clause, then
@func{raise-continuable} is re--invoked on the raised object within the
dynamic environment of the original call to @func{raise} except that the
current exception handler is that of the @func{guard} expression.

The final expression in a @meta{cond} clause is in a tail context if the
@func{guard} expression itself is.
@end deffn


@deffn Procedure raise @var{obj}
Raise a non--continuable exception by invoking the current exception
handler on @var{obj}.  The handler is called with a continuation whose
dynamic environment is that of the call to @func{raise}, except that the
current exception handler is the one that was in place when the handler
being called was installed.  When the handler returns, a
non--continuable exception with condition type @code{&non-continuable}
is raised in the same dynamic environment as the handler.
@end deffn


@deffn Procedure raise-continuable @var{obj}
Raise a @emph{continuable exception} by invoking the current exception
handler on @var{obj}. The handler is called with a continuation that is
equivalent to the continuation of the call to @func{raise-continuable},
with these two exceptions:

@enumerate
@item
the current exception handler is the one that was in place when the
handler being called was installed, and

@item
if the handler being called returns, then it will again become the
current exception handler.
@end enumerate

If the handler returns, the values it returns become the values returned
by the call to @code{raise-continuable}.
@end deffn

@example
(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred"))
          'error)
         ((violation? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "the program has a bug"))
          'violation))
  (raise
    (condition
      (make-error)
      (make-message-condition "I am an error"))))
   ;; prints: I am an error
=> error

(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred"))
          'error))
  (raise
    (condition
      (make-violation)
      (make-message-condition "I am an error"))))
=> exception &violation

(guard (con
         ((error? con)
          (display "error opening file")
          #f))
  (call-with-input-file "foo.scm" read))
   ;; prints: error opening file
=> #f

(with-exception-handler
  (lambda (con)
    (cond
      ((not (warning? con))
       (raise con))
      ((message-condition? con)
       (display (condition-message con)))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable
         (condition
           (make-warning)
           (make-message-condition
             "should be a number")))
       23)))
   ;; prints: should be a number
=> 65
@end example


@c ------------------------------------------------------------

@c page
@node stdlib exceptions conditions
@section Conditions


The section describes Scheme's @rsixlibrary{conditions} library for
creating and inspecting condition types and values.  A condition value
encapsulates information about an exceptional situation.  Scheme also
defines a number of basic condition types.

Scheme conditions provides two mechanisms to enable communication about
an exceptional situation: subtyping among condition types allows
handling code to determine the general nature of an exception even
though it does not anticipate its exact nature, and compound conditions
allow an exceptional situation to be described in multiple ways.


@menu
* stdlib exceptions conditions objects::        Condition objects.
* stdlib exceptions conditions types::          Standard condition
                                                types.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib exceptions conditions objects
@subsection Condition objects


Conceptually, there are two different kinds of condition objects:
@emph{simple conditions} and @emph{compound conditions}.  An object that
is either a simple condition or a compound condition is simply a
@emph{condition}.  Compound conditions form a type disjoint from the
base types described in report section @rsixref{base types,Base types}.
A simple condition describes a single aspect of an exceptional
situation.  A compound condition represents multiple aspects of an
exceptional situation as a list of simple conditions, its
@emph{components}.  Most of the operations described in this section
treat a simple condition identically to a compound condition with itself
as its own sole component.  For a subtype @var{t} of @code{&condition},
a @emph{condition of type @var{t}} is either a record of type @var{t} or
a compound condition containing a component of type @var{t}.


@deffn {Condition Type} {&condition}
Simple conditions are records of subtypes of the @code{&condition}
record type.  The @code{&condition} type has no fields and is neither
sealed nor opaque.
@end deffn


@deffn Procedure condition @vari{condition} @dots{}
The @func{condition} procedure returns a condition object with the
components of the @var{condition}s as its components, in the same order,
i.e., with the components of @vari{condition} appearing first in the
same order as in @vari{condition}, then with the components of
@varii{condition}, and so on.  The returned condition is compound if the
total number of components is zero or greater than one.  Otherwise, it
may be compound or simple.
@end deffn


@deffn Procedure simple-conditions @var{condition}
The @func{simple-conditions} procedure returns a list of the components
of @var{condition}, in the same order as they appeared in the
construction of @var{condition}.  The returned list is immutable.  If
the returned list is modified, the effect on @var{condition} is
unspecified.

@quotation
@emph{Note:} Because @func{condition} decomposes its arguments into
simple conditions, @func{simple-conditions} always returns a
``flattened'' list of simple conditions.
@end quotation
@end deffn


@deffn Procedure {condition?} @var{obj}
Return @true{} if @var{obj} is a (simple or compound) condition,
otherwise returns @false{}.
@end deffn


@deffn Procedure condition-predicate @var{rtd}
@var{rtd} must be a record--type descriptor of a subtype of
@code{&condition}.  The @func{condition-predicate} procedure returns a
procedure that takes one argument.  This procedure returns @true{} if
its argument is a condition of the condition type represented by
@var{rtd}, i.e., if it is either a simple condition of that record type
(or one of its subtypes) or a compound conditition with such a simple
condition as one of its components, and @false{} otherwise.
@end deffn


@deffn Procedure condition-accessor @var{rtd} @var{proc}
@var{rtd} must be a record--type descriptor of a subtype of
@code{&condition}.  @var{proc} should accept one argument, a record of
the record type of @var{rtd}.  The @func{condition-accessor} procedure
returns a procedure that accepts a single argument, which must be a
condition of the type represented by @var{rtd}.  This procedure extracts
the first component of the condition of the type represented by
@var{rtd}, and returns the result of applying @var{proc} to that
component.
@end deffn

@example
(define-record-type (&cond1 make-cond1 real-cond1?)
  (parent &condition)
  (fields
   (immutable x real-cond1-x)))

(define cond1?
  (condition-predicate
    (record-type-descriptor &cond1)))
(define cond1-x
  (condition-accessor
    (record-type-descriptor &cond1)
    real-cond1-x))

(define foo (make-cond1 'foo))

(condition? foo)                        => #t
(cond1? foo)                            => #t
(cond1-x foo)                           => foo

(define-record-type (&cond2 make-cond2 real-cond2?)
  (parent &condition)
  (fields
   (immutable y real-cond2-y)))

(define cond2?
  (condition-predicate
    (record-type-descriptor &cond2)))
(define cond2-y
  (condition-accessor
     (record-type-descriptor &cond2)
     real-cond2-y))

(define bar (make-cond2 'bar))

(condition? (condition foo bar))        => #t
(cond1? (condition foo bar))            => #t
(cond2? (condition foo bar))            => #t
(cond1? (condition foo))                => #t
(real-cond1? (condition foo))           => unspecified
(real-cond1? (condition foo bar))       => #f
(cond1-x (condition foo bar))           => foo
(cond2-y (condition foo bar))           => bar

(equal? (simple-conditions (condition foo bar))
        (list foo bar))                 => #t

(equal? (simple-conditions
          (condition foo (condition bar)))
        (list foo bar))                 => #t
@end example


@deffn Syntax define-condition-type @meta{condition-type} @meta{supertype} @meta{constructor} @hyper{predicate} @hyperi{field-spec} @dots{}
@meta{condition-type}, @hyper{supertypes}, @meta{constructor}, and
@hyper{predicate} must all be identifiers.  Each @meta{field-spec} must
be of the form

@example
(@meta{field} @hyper{accessor})
@end example

@noindent
where both @meta{field} and @hyper{accessor} must be identifiers.

The @func{define-condition-type} form expands into a record--type
definition for a record type @meta{condition-type}.  The record type
will be non--opaque, non--sealed, and its fields will be immutable.  It
will have @meta{supertype} has its parent type.  The remaining
identifiers will be bound as follows:

@itemize
@item
@meta{constructor} is bound to a default constructor for the type: It
accepts one argument for each of the record type's complete set of
fields (including parent types, with the fields of the parent coming
before those of the extension in the arguments) and returns a condition
object initialized to those arguments.

@item
@meta{predicate} is bound to a predicate that identifies conditions of
type @meta{condition-type} or any of its subtypes.

@item
Each @meta{accessor} is bound to a procedure that extracts the
corresponding field from a condition of type @meta{condition-type}.
@end itemize
@end deffn

@example
(define-condition-type &c &condition
  make-c c?
  (x c-x))

(define-condition-type &c1 &c
  make-c1 c1?
  (a c1-a))

(define-condition-type &c2 &c
  make-c2 c2?
  (b c2-b))
@end example

@example
(define v1 (make-c1 "V1" "a1"))

(c? v1)        => #t
(c1? v1)       => #t
(c2? v1)       => #f
(c-x v1)       => "V1"
(c1-a v1)      => "a1"
@end example

@example
(define v2 (make-c2 "V2" "b2"))

(c? v2)        => #t
(c1? v2)       => #f
(c2? v2)       => #t
(c-x v2)       => "V2"
(c2-b v2)      => "b2"
@end example

@example
(define v3 (condition
             (make-c1 "V3/1" "a3")
             (make-c2 "V3/2" "b3")))

(c? v3)        => #t
(c1? v3)       => #t
(c2? v3)       => #t
(c-x v3)       => "V3/1"
(c1-a v3)      => "a3"
(c2-b v3)      => "b3"
@end example

@example
(define v4 (condition v1 v2))

(c? v4)        => #t
(c1? v4)       => #t
(c2? v4)       => #t
(c-x v4)       => "V1"
(c1-a v4)      => "a1"
(c2-b v4)      => "b2"
@end example

@example
(define v5 (condition v2 v3))

(c? v5)        => #t
(c1? v5)       => #t
(c2? v5)       => #t
(c-x v5)       => "V2"
(c1-a v5)      => "a3"
(c2-b v5)      => "b2"
@end example


@c ------------------------------------------------------------

@c page
@node stdlib exceptions conditions types
@subsection Standard condition types


Hierarchy of standard condition types:

@example
&condition
   |
   +-----> &warning
   |
   +-----> &message
   |       &irritants
   |       &who
   |
   +-----> &serious
              |
              +-----> &error
              |
              +-----> &violation
                         |
                         +-----> &assertion
                         |
                         +-----> &non-continuable
                         |
                         +-----> &implementation-restriction
                         |
                         +-----> &lexical
                         |
                         +-----> &syntax
                         |
                          -----> &undefined
@end example


@deffn {Condition Type} {&message}
@deffnx Procedure make-message-condition @var{message}
@deffnx Procedure message-condition? @var{obj}
@deffnx Procedure condition-message @var{condition}
This condition type could be defined by:

@example
(define-condition-type &message &condition
  make-message-condition message-condition?
  (message condition-message))
@end example

It carries a message further describing the nature of the condition to
humans.
@end deffn


@deffn {Condition Type} {&warning}
@deffnx Procedure make-warning
@deffnx Procedure warning? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &warning &condition
  make-warning warning?)
@end example

This type describes conditions that do not, in principle, prohibit
immediate continued execution of the program, but may interfere with the
program's execution later.
@end deffn


@deffn {Condition Type} {&serious}
@deffnx Procedure make-serious-condition
@deffnx Procedure serious-condition? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &serious &condition
  make-serious-condition serious-condition?)
@end example

This type describes conditions serious enough that they cannot safely be
ignored.  This condition type is primarily intended as a supertype of
other condition types.
@end deffn


@deffn {Condition Type} {&error}
@deffnx Procedure make-error
@deffnx Procedure error? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &error &serious
  make-error error?)
@end example

This type describes errors, typically caused by something that has gone
wrong in the interaction of the program with the external world or the
user.
@end deffn


@deffn {Condition Type} {&violation}
@deffnx Procedure make-violation
@deffnx Procedure violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &violation &serious
  make-violation violation?)
@end example

This type describes violations of the language standard or a library
standard, typically caused by a programming error.
@end deffn


@deffn {Condition Type} {&assertion}
@deffnx Procedure make-assertion-violation
@deffnx Procedure assertion-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &assertion &violation
  make-assertion-violation assertion-violation?)
@end example

This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
@end deffn


@deffn {Condition Type} {&irritants}
@deffnx Procedure make-irritants-condition @var{irritants}
@deffnx Procedure irritants-condition? @var{obj}
@deffnx Procedure condition-irritants @var{condition}
This condition type could be defined by:

@example
(define-condition-type &irritants &condition
  make-irritants-condition irritants-condition?
  (irritants condition-irritants))
@end example

@var{irritants} should be a list of objects.  This condition provides
additional information about a condition, typically the argument list of
a procedure that detected an exception.  Conditions of this type are
created by the @func{error} and @func{assertion-violation} procedures of
report section @rsixref{base errors,Errors and violations}.
@end deffn


@deffn {Condition Type} {&who}
@deffnx Procedure make-who-condition @var{who}
@deffnx Procedure who-condition? @var{obj}
@deffnx Procedure condition-who @var{condition}
This condition type could be defined by:

@example
(define-condition-type &who &condition
  make-who-condition who-condition?
  (who condition-who))
@end example

@var{who} should be a symbol or string identifying the entity reporting
the exception.  Conditions of this type are created by the @func{error}
and @func{assertion-violation} procedures (report section @rsixref{base
errors,Errors and violations}), and the @func{syntax-violation}
procedure (section @rsixref{basic syntax violations,Syntax violations}).
@end deffn


@deffn {Condition Type} {&non-continuable}
@deffnx Procedure make-non-continuable-violation
@deffnx Procedure non-continuable-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &non-continuable &violation
  make-non-continuable-violation
  non-continuable-violation?)
@end example

This type indicates that an exception handler invoked via @func{raise}
has returned.
@end deffn


@deffn {Condition Type} {&implementation-restriction}
@deffnx Procedure make-implementation-restriction-violation
@deffnx Procedure implementation-restriction-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &implementation-restriction
    &violation
  make-implementation-restriction-violation
  implementation-restriction-violation?)
@end example

This type describes a violation of an implementation restriction allowed
by the specification, such as the absence of representations for NaNs
and infinities.
@end deffn


@deffn {Condition Type} {&lexical}
@deffnx Procedure make-lexical-violation
@deffnx Procedure lexical-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &lexical &violation
  make-lexical-violation lexical-violation?)
@end example

This type describes syntax violations at the level of the datum syntax.
@end deffn


@deffn {Condition Type} {&syntax}
@deffnx Procedure make-syntax-violation @var{form} @var{subform}
@deffnx Procedure syntax-violation? @var{obj}
@deffnx Procedure syntax-violation-form @var{condition}
@deffnx Procedure syntax-violation-subform @var{condition}
This condition type could be defined by:

@example
(define-condition-type &syntax &violation
  make-syntax-violation syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))
@end example

This type describes syntax violations.  @var{form} should be the
erroneous syntax object or a datum representing the code of the
erroneous form.  @var{subform} should be an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be @false{} to indicate the absence of more precise
information.
@end deffn


@deffn {Condition Type} {&undefined}
@deffnx Procedure make-undefined-violation
@deffnx Procedure undefined-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &undefined &violation
  make-undefined-violation undefined-violation?)
@end example

This type describes unbound identifiers in the program.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io
@chapter Input/output


This chapter describes Scheme's libraries for performing input and
output:

@table @rsixlibrary
@item io ports
it is an I/O layer for conventional, imperative buffered input and
output with text and binary data;

@item io simple
it is a convenience library atop the @rsixlibrary{io ports} library for
textual I/O, compatible with the traditional Scheme I/O procedures.
@end table

The section on conditions defines a condition--type hierarchy that is
exported by both the @rsixlibrary{io ports} and @rsixlibrary{io simple}
libraries.


@menu
* stdlib io conditions::        Condition types.
* stdlib io port::              Port input/output.
* stdlib io simple::            Simple input/output.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib io conditions
@section Condition types


The procedures described in this chapter, when they detect an
exceptional situation that arises from an ``I/O errors'', raise an
exception with condition type @code{&i/o}.

The condition types and corresponding predicates and accessors are
exported by both the @rsixlibrary{io ports} and @rsixlibrary{io simple}
libraries.  They are also exported by the @rsixlibrary{files} library.


@deffn {Condition Type} {&i/o}
@deffnx Procedure {make-i/o-error}
@deffnx Procedure {i/o-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o &error
  make-i/o-error i/o-error?)
@end example

This is a supertype for a set of more specific I/O errors.
@end deffn


@deffn {Condition Type} {&i/o-read}
@deffnx Procedure {make-i/o-read-error}
@deffnx Procedure {i/o-read-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-read &i/o
  make-i/o-read-error i/o-read-error?)
@end example

This condition type describes read errors that occurred during an I/O
operation.
@end deffn


@deffn {Condition Type} {&i/o-write}
@deffnx Procedure {make-i/o-write-error}
@deffnx Procedure {i/o-write-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-write &i/o
  make-i/o-write-error i/o-write-error?)
@end example

This condition type describes write errors that occurred during an I/O
operation.
@end deffn


@deffn {Condition Type} {&i/o-invalid-position}
@deffnx Procedure {make-i/o-invalid-position-error} @var{position}
@deffnx Procedure {i/o-invalid-position-error?} @var{obj}
@deffnx Procedure {i/o-error-position} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-invalid-position &i/o
  make-i/o-invalid-position-error
  i/o-invalid-position-error?
  (position i/o-error-position))
@end example

This condition type describes attempts to set the file position to an
invalid position.  @var{position} should be the file position that the
program intended to set.  This condition describes a range error, but
not an assertion violation.
@end deffn


@deffn {Condition Type} {&i/o-filename}
@deffnx Procedure {make-i/o-filename-error} @var{filename}
@deffnx Procedure {i/o-filename-error?} @var{obj}
@deffnx Procedure {i/o-error-filename} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-filename &i/o
  make-i/o-filename-error i/o-filename-error?
  (filename i/o-error-filename))
@end example

This condition type describes an I/O error that occurred during an
operation on a named file.  @var{filename} should be the name of the
file.
@end deffn


@deffn {Condition Type} {&i/o-file-protection}
@deffnx Procedure {make-i/o-file-protection-error} @var{filename}
@deffnx Procedure {i/o-file-protection-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-protection
    &i/o-filename
  make-i/o-file-protection-error
  i/o-file-protection-error?)
@end example

A condition of this type specifies that an operation tried to operate on
a named file with insufficient access rights.
@end deffn


@deffn {Condition Type} {&i/o-file-is-read-only}
@deffnx Procedure {make-i/o-file-is-read-only-error} @var{filename}
@deffnx Procedure {i/o-file-is-read-only-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-is-read-only
    &i/o-file-protection
  make-i/o-file-is-read-only-error
  i/o-file-is-read-only-error?)
@end example

A condition of this type specifies that an operation tried to operate on
a named read--only file under the assumption that it is writeable.
@end deffn


@deffn {Condition Type} {&i/o-file-already-exists}
@deffnx Procedure {make-i/o-file-already-exists-error} @var{filename}
@deffnx Procedure {i/o-file-already-exists-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-already-exists
    &i/o-filename
  make-i/o-file-already-exists-error
  i/o-file-already-exists-error?)
@end example

A condition of this type specifies that an operation tried to operate on
an existing named file under the assumption that it did not exist.
@end deffn


@deffn {Condition Type} {&i/o-file-does-not-exist}
@deffnx Procedure {make-i/o-file-does-not-exist-error} @var{filename}
@deffnx Procedure {i/o-file-does-not-exist-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-does-not-exist
    &i/o-filename
  make-i/o-file-does-not-exist-error
  i/o-file-does-not-exist-error?)
@end example

A condition of this type specifies that an operation tried to operate on
an non--existent named file under the assumption that it existed.
@end deffn


@deffn {Condition Type} {&i/o-port}
@deffnx Procedure {make-i/o-port-error} @var{port}
@deffnx Procedure {i/o-port-error?} @var{obj}
@deffnx Procedure {i/o-error-port} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-port &i/o
  make-i/o-port-error i/o-port-error?
  (port i/o-error-port))
@end example

This condition type specifies the port with which an I/O error is
associated.  @var{port} should be the port.  Conditions raised by
procedures accepting a port as an argument should include an
@code{&i/o-port-error} condition.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port
@section Port input/output


The @rsixlibrary{io ports} library defines an I/O layer for
conventional, imperative buffered input and output.  A @emph{port}
represents a buffered access object for a data sink or source or both
simultaneously.  The library allows ports to be created from arbitrary
data sources and sinks.

The @rsixlibrary{io ports} library distinguishes between @emph{input
ports} and @emph{output ports}.  An input port is a source for data,
whereas an output port is a sink for data.  A port may be both an input
port and an output port; such a port typically provides simultaneous
read and write access to a file or other data.

The @rsixlibrary{io ports} library also distinguishes between
@emph{binary ports}, which are sources or sinks for uninterpreted bytes,
and @emph{textual ports}, which are sources or sinks for characters and
strings.

This section uses @var{input-port}, @var{output-port},
@var{binary-port}, @var{textual-port}, @var{binary-input-port},
@var{textual-input-port}, @var{binary-output-port},
@var{textual-output-port}, and @var{port} as names for arguments that
must be input ports (or combined input/output ports), output ports (or
combined input/output ports), binary ports, textual ports, binary input
ports, textual input ports, binary output ports, textual output ports,
or any kind of port, respectively.


@menu
* stdlib io port file names::           File names.
* stdlib io port file options::         File options.
* stdlib io port buffer modes::         Buffer modes.
* stdlib io port transcoders::          Transcoders.
* stdlib io port eof object::           End of file object.
* stdlib io port io ports::             Input and output ports.
* stdlib io port input ports::          Input ports.
* stdlib io port binary input::         Binary input.
* stdlib io port textual input::        Textual input.
* stdlib io port output ports::         Output ports.
* stdlib io port binary output::        Binary output.
* stdlib io port textual output::       Textual output.
* stdlib io port input output ports::   Input/output ports.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib io port file names
@subsection File names


Some of the procedures described in this chapter accept a file name as
an argument.  Valid values for such a file name include strings that
name a file using the native notation of filesystem paths on an
implementation's underlying operating system, and may include
implementation--dependent values as well.

A @var{filename} parameter name means that the corresponding argument
must be a file name.


@c ------------------------------------------------------------

@c page
@node stdlib io port file options
@subsection File options


When opening a file, the various procedures in this library accept a
@code{file-options} object that encapsulates flags to specify how the
file is to be opened.  A @code{file-options} object is an enum--set over
the symbols constituting valid file options.  A @var{file-options}
parameter name means that the corresponding argument must be a
file--options object.


@deffn Syntax file-options @meta{file-options symbol} @dots{}
Each @meta{file-options symbol} must be a symbol.  The
@code{file-options} syntax returns a file--options object that
encapsulates the specified options.

When supplied to an operation that opens a file for output, the
file--options object returned by @code{(file-options)} (without
arguments) specifies that the file is created if it does not exist and
an exception with condition type @code{&i/o-file-already-exists} is
raised if it does exist.  The following standard options can be included
to modify the default behavior.

@table @code
@item no-create
If the file does not already exist, it is not created; instead, an
exception with condition type @code{&i/o-file-does-not-exist} is raised.
If the file already exists, the exception with condition type
@code{&i/o-file-already-exists} is not raised and the file is truncated
to zero length.

@item no-fail
If the file already exists, the exception with condition type
@code{&i/o-file-already-exists} is not raised, even if @code{no-create}
is not included, and the file is truncated to zero length.

@item no-truncate
If the file already exists and the exception with condition type
@code{&i/o-file-already-exists} has been inhibited by inclusion of
@code{no-create} or @code{no-fail}, the file is not truncated, but the
port's current position is still set to the beginning of the file.
@end table

These options have no effect when a file is opened only for input.
Symbols other than those listed above may be used as @meta{file-options
symbol}s; they have implementation--specific meaning, if any.

@quotation
@emph{Note:} Only the name of @meta{file-options symbol} is significant.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port buffer modes
@subsection Buffer modes


Each port has an associated buffer mode.  For an output port, the buffer
mode defines when an output operation flushes the buffer associated with
the output port.  For an input port, the buffer mode defines how much
data will be read to satisfy read operations.  The possible buffer modes
are the symbols:

@table @code
@item none
for no buffering,

@item line
for flushing upon line endings and reading up to line endings, or other
implementation--dependent behavior,

@item block
for arbitrary buffering.
@end table

This section uses the parameter name @var{buffer-mode} for arguments
that must be buffer-mode symbols.

If two ports are connected to the same mutable source, both ports are
unbuffered, and reading a byte or character from that shared source via
one of the two ports would change the bytes or characters seen via the
other port, a lookahead operation on one port will render the peeked
byte or character inaccessible via the other port, while a subsequent
read operation on the peeked port will see the peeked byte or character
even though the port is otherwise unbuffered.

In other words, the semantics of buffering is defined in terms of side
effects on shared mutable sources, and a lookahead operation has the
same side effect on the shared source as a read operation.


@deffn Syntax buffer-mode @meta{buffer-mode symbol}
@meta{buffer-mode symbol} must be a symbol whose name is one of
@code{none}, @code{line}, and @code{block}.  The result is the
corresponding symbol, and specifies the associated buffer mode.

@quotation
@emph{Note:} Only the name of @meta{buffer-mode symbol} is significant.
@end quotation
@end deffn


@deffn Procedure {buffer-mode?} @var{obj}
Return @true{} if the argument is a valid buffer--mode symbol, and
returns @false{} otherwise.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port transcoders
@subsection Transcoders


Several different Unicode encoding schemes describe standard ways to
encode characters and strings as byte sequences and to decode those
sequences.  Within this document, a @emph{codec} is an immutable Scheme
object that represents a Unicode or similar encoding scheme.

An @emph{end--of--line style} is a symbol that, if it is not
@code{none}, describes how a textual port transcodes representations of
line endings.

A @emph{transcoder} is an immutable Scheme object that combines a codec
with an end--of--line style and a method for handling decoding errors.
Each transcoder represents some specific bidirectional (but not
necessarily lossless), possibly stateful translation between byte
sequences and Unicode characters and strings.  Every transcoder can
operate in the input direction (bytes to characters) or in the output
direction (characters to bytes).  A @var{transcoder} parameter name
means that the corresponding argument must be a transcoder.

A @emph{binary port} is a port that supports binary I/O, does not have
an associated transcoder and does not support textual I/O.  A
@emph{textual port} is a port that supports textual I/O, and does not
support binary I/O.  A textual port may or may not have an associated
transcoder.


@deffn Procedure latin-1-codec
@deffnx Procedure utf-8-codec
@deffnx Procedure utf-16-codec
These are predefined codecs for the @iso{} 8859-1, @utf{}-8, and
@utf{}-16 encoding schemes.

A call to any of these procedures returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.
@end deffn


@deffn Syntax eol-style @meta{eol-style symbol}
@meta{eol-style symbol} should be a symbol whose name is one of
@code{lf}, @code{cr}, @code{crlf}, @code{nel}, @code{crnel}, @code{ls},
and @code{none}.

The form evaluates to the corresponding symbol.  If the name of
@meta{eol-style symbol} is not one of these symbols, the effect and
result are implementation--dependent; in particular, the result may be
an eol--style symbol acceptable as an @var{eol-style} argument to
@code{make-transcoder}.  Otherwise, an exception is raised.

All eol--style symbols except @code{none} describe a specific
line--ending encoding:

@example
lf              @meta{linefeed}
cr              @meta{carriage return}
crlf            @meta{carriage return} @meta{linefeed}
nel             @meta{next line}
crnel           @meta{carriage return} @meta{next line}
ls              @meta{line separator}
@end example

For a textual port with a transcoder, and whose transcoder has an
eol--style symbol @code{none}, no conversion occurs.  For a textual
input port, any eol--style symbol other than @code{none} means that all
of the above line-ending encodings are recognized and are translated
into a single linefeed.  For a textual output port, @code{none} and
@code{lf} are equivalent.  Linefeed characters are encoded according to
the specified eol-style symbol, and all other characters that
participate in possible line endings are encoded as is.

@quotation
@emph{Note:} Only the name of @meta{eol-style symbol} is significant.
@end quotation
@end deffn


@deffn Procedure native--eol--style
Return the default end--of--line style of the underlying platform, e.g.,
@code{lf} on Unix and @code{crlf} on Windows.
@end deffn


@deffn {Condition Type} {i/o-decoding}
@deffnx Procedure {make-i/o-decoding-error} @var{port}
@deffnx Procedure {i/o-decoding-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-decoding &i/o-port
  make-i/o-decoding-error i/o-decoding-error?)
@end example

An exception with this type is raised when one of the operations for
textual input from a port encounters a sequence of bytes that cannot be
translated into a character or string by the input direction of the
port's transcoder.

When such an exception is raised, the port's position is past the
invalid encoding.
@end deffn


@deffn {Condition Type} {i/o-encoding}
@deffnx Procedure {make-i/o-encoding-error} @var{pobj} @var{cobj}
@deffnx Procedure {i/o-encoding-error?} @var{obj}
@deffnx Procedure {i/o-encoding-error-char} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-encoding &i/o-port
  make-i/o-encoding-error i/o-encoding-error?
  (char i/o-encoding-error-char))
@end example

An exception with this type is raised when one of the operations for
textual output to a port encounters a character that cannot be
translated into bytes by the output direction of the port's transcoder.
@var{cobj} is the character that could not be encoded.
@end deffn


@deffn Syntax error-handling-mode @meta{error-handling-mode symbol}
@meta{error-handling-mode symbol} should be a symbol whose name is one
of @code{ignore}, @code{raise}, and @code{replace}.

The form evaluates to the corresponding symbol.  If
@meta{error-handling-mode symbol} is not one of these identifiers,
effect and result are implementation--dependent: The result may be an
error--handling--mode symbol acceptable as a @var{handling-mode}
argument to @func{make-transcoder}.  If it is not acceptable as a
@var{handling-mode} argument to @func{make-transcoder}, an exception is
raised.

@quotation
@emph{Note:} Only the name of @meta{error-handling-style symbol} is
significant.
@end quotation

The error--handling mode of a transcoder specifies the behavior of
textual I/O operations in the presence of encoding or decoding errors.

If a textual input operation encounters an invalid or incomplete
character encoding, and the error--handling mode is @code{ignore}, an
appropriate number of bytes of the invalid encoding are ignored and
decoding continues with the following bytes.  If the error--handling
mode is @code{replace}, the replacement character @code{U+FFFD} is
injected into the data stream, an appropriate number of bytes are
ignored, and decoding continues with the following bytes.  If the
error--handling mode is @code{raise}, an exception with condition type
@code{&i/o-decoding} is raised.

If a textual output operation encounters a character it cannot encode,
and the error--handling mode is @code{ignore}, the character is ignored
and encoding continues with the next character.  If the error--handling
mode is @code{replace}, a codec--specific replacement character is
emitted by the transcoder, and encoding continues with the next
character.  The replacement character is @code{U+FFFD} for transcoders
whose codec is one of the Unicode encodings, but is the @code{?}
character for the Latin--1 encoding.  If the error--handling mode is
@code{raise}, an exception with condition type @code{&i/o-encoding} is
raised.
@end deffn


@deffn Procedure make-transcoder @var{codec}
@deffnx Procedure make-transcoder @var{codec} @var{eol-style}
@deffnx Procedure make-transcoder @var{codec} @var{eol-style} @var{handling-mode}
@var{codec} must be a codec; @var{eol-style}, if present, an eol--style
symbol; and @var{handling-mode}, if present, an error--handling--mode
symbol.

@var{eol-style} may be omitted, in which case it defaults to the native
end--of--line style of the underlying platform.  @var{handling-mode} may
be omitted, in which case it defaults to @code{replace}.  The result is
a transcoder with the behavior specified by its arguments.
@end deffn


@deffn Procedure native-transcoder
Return an implementation--dependent transcoder that represents a
possibly locale-dependent ``native'' transcoding.
@end deffn


@deffn Procedure transcoder-codec @var{transcoder}
@deffnx Procedure transcoder-eol-style @var{transcoder}
@deffnx Procedure transcoder-error-handling-mode @var{transcoder}
These are accessors for transcoder objects; when applied to a transcoder
returned by @func{make-transcoder}, they return the @var{codec},
@var{eol-style}, and @var{handling-mode} arguments, respectively.
@end deffn


@deffn Procedure {bytevector->string} @var{bytevector} @var{transcoder}
Return the string that results from transcoding the @var{bytevector}
according to the input direction of the transcoder.
@end deffn


@deffn Procedure {string->bytevector} @var{string} @var{transcoder}
Return the bytevector that results from transcoding the @var{string}
according to the output direction of the transcoder.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port eof object
@subsection End--of--file object


The end--of--file object is returned by various I/O procedures when they
reach end of file.


@deffn Procedure eof-object
Return the end--of--file object.

@example
(eqv? (eof-object) (eof-object))        => #t
(eq? (eof-object) (eof-object))         => #t
@end example
@end deffn

@quotation
@emph{Note:} The end--of--file object is not a datum value, and thus has
no external representation.
@end quotation


@deffn Procedure {eof-object?} @var{obj}
Return @true{} if @var{obj} is the end--of--file object, @false{}
otherwise.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port io ports
@subsection Input and output ports


The operations described in this section are common to input and output
ports, both binary and textual.  A port may also have an associated
@emph{position} that specifies a particular place within its data sink
or source, and may also provide operations for inspecting and setting
that place.


@deffn Procedure {port?} @var{obj}
Return @true{} if the argument is a port, @false{} otherwise.
@end deffn


@deffn Procedure port-transcoder @var{port}
Return the transcoder associated with @var{port} if @var{port} is
textual and has an associated transcoder, and returns @false{} if
@var{port} is binary or does not have an associated transcoder.
@end deffn


@deffn Procedure {textual-port?} @var{port}
@deffnx Procedure {binary-port?} @var{port}
The @func{textual-port?} procedure returns @true{} if @var{port} is
textual, and returns @false{} otherwise.

The @func{binary-port?}  procedure returns @true{} if @var{port} is
binary, and returns @false{} otherwise.
@end deffn


@deffn Procedure {transcoded-port} @var{binary-port} @var{transcoder}
The @func{transcoded-port} procedure returns a new textual port with the
specified @var{transcoder}.  Otherwise the new textual port's state is
largely the same as that of @var{binary-port}.

If @var{binary-port} is an input port, the new textual port will be an
input port and will transcode the bytes that have not yet been read from
@var{binary-port}.  If @var{binary-port} is an output port, the new
textual port will be an output port and will transcode output characters
into bytes that are written to the byte sink represented by
@var{binary-port}.

As a side effect, however, @func{transcoded-port} closes
@var{binary-port} in a special way that allows the new textual port to
continue to use the byte source or sink represented by
@var{binary-port}, even though @var{binary-port} itself is closed and
cannot be used by the input and output operations described in this
chapter.
@end deffn


@deffn Procedure {port-has-port-position?} @var{port}
@deffnx Procedure port-position @var{port}
The @func{port-has-port-position?} procedure returns @true{} if the port
supports the @func{port-position} operation, and @false{} otherwise.

For a binary port, the @func{port-position} procedure returns the index
of the position at which the next byte would be read from or written to
the port as an exact non--negative integer object.  For a textual port,
@func{port-position} returns a value of some implementation--dependent
type representing the port's position; this value may be useful only as
the @var{pos} argument to @func{set-port-position!}, if the latter is
supported on the port (see below).

If the port does not support the operation, @func{port-position} raises
an exception with condition type @code{&assertion}.

@quotation
@emph{Note:} For a textual port, the port position may or may not be an
integer object.  If it is an integer object, the integer object does not
necessarily correspond to a byte or character position.
@end quotation
@end deffn


@deffn Procedure {port-has-set-port-position!?} @var{port}
@deffnx Procedure {set-port-position!} @var{port} @var{pos}
If @var{port} is a binary port, @var{pos} should be a non--negative
exact integer object.  If @var{port} is a textual port, @var{pos} should
be the return value of a call to @func{port-position} on @var{port}.

The @func{port-has-set-port-position!?} procedure returns @true{} if the
port supports the @func{set-port-position!} operation, and @false{}
otherwise.

The @func{set-port-position!} procedure raises an exception with
condition type @code{&assertion} if the port does not support the
operation, and an exception with condition type
@code{&i/o-invalid-position} if @var{pos} is not in the range of valid
positions of @var{port}.  Otherwise, it sets the current position of the
port to @var{pos}.  If @var{port} is an output port,
@func{set-port-position!} first flushes @var{port}.

If @var{port} is a binary output port and the current position is set
beyond the current end of the data in the underlying data sink, the
object is not extended until new data is written at that position.  The
contents of any intervening positions are unspecified.  Binary ports
created by @func{open-file-output-port} and
@func{open-file-input/output-port} can always be extended in this manner
within the limits of the underlying operating system.  In other cases,
attempts to set the port beyond the current end of data in the
underlying object may result in an exception with condition type
@code{&i/o-invalid-position}.
@end deffn


@deffn Procedure close-port @var{port}
Closes the port, rendering the port incapable of delivering or accepting
data. If @var{port} is an output port, it is flushed before being
closed.  This has no effect if the port has already been closed.  A
closed port is still a port.  The @func{close-port} procedure returns
unspecified values.
@end deffn


@deffn Procedure call-with-port @var{port} @var{proc}
@var{proc} must accept one argument.  The @func{call-with-port}
procedure calls @var{proc} with @var{port} as an argument.  If
@var{proc} returns, @var{port} is closed automatically and the values
returned by @var{proc} are returned.  If @var{proc} does not return,
@var{port} is not closed automatically, except perhaps when it is
possible to prove that @var{port} will never again be used for an input
or output operation.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port input ports
@subsection Input ports


An input port allows the reading of an infinite sequence of bytes or
characters punctuated by end--of--file objects.  An input port connected
to a finite data source ends in an infinite sequence of end--of--file
objects.

It is unspecified whether a character encoding consisting of several
bytes may have an end of file between the bytes.  If, for example,
@func{get-char} raises an @code{&i/o-decoding} exception because the
character encoding at the port's position is incomplete up to the next
end of file, a subsequent call to @func{get-char} may successfully
decode a character if bytes completing the encoding are available after
the end of file.


@deffn Procedure {input-port?} @var{obj}
Return @true{} if the argument is an input port (or a combined input and
output port), and returns @false{} otherwise.
@end deffn


@deffn Procedure {port-eof?} @var{input-port}
Return @true{} if the @func{lookahead-u8} procedure (if @var{input-port}
is a binary port) or the @func{lookahead-char} procedure (if
@var{input-port} is a textual port) would return the end--of--file
object, and @false{} otherwise.  The operation may block indefinitely if
no data is available but the port cannot be determined to be at end of
file.
@end deffn


@deffn Procedure {open-file-input-port} @var{filename}
@deffnx Procedure {open-file-input-port} @var{filename} @var{file-options}
@deffnx Procedure {open-file-input-port} @var{filename} @var{file-options} @var{buffer-mode}
@deffnx Procedure {open-file-input-port} @var{filename} @var{file-options} @var{buffer-mode} @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-file-input-port} procedure returns an input port for the
named file.  The @var{file-options} and @var{maybe-transcoder} arguments
are optional.

The @var{file-options} argument, which may determine various aspects of
the returned port, defaults to the value of @code{(file-options)}.

The @var{buffer-mode} argument, if supplied, must be one of the symbols
that name a buffer mode.  The @var{buffer-mode} argument defaults to
@code{block}.

If @var{maybe-transcoder} is a transcoder, it becomes the transcoder
associated with the returned port.

If @var{maybe-transcoder} is @false{} or absent, the port will be a
binary port and will support the @func{port-position} and
@func{set-port-position!} operations.  Otherwise the port will be a
textual port, and whether it supports the @func{port-position} and
@func{set-port-position!} operations is implementation-dependent (and
possibly transcoder-dependent).
@end deffn


@deffn Procedure {open-bytevector-input-port} @var{bytevector}
@deffnx Procedure {open-bytevector-input-port} @var{bytevector} @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-bytevector-input-port} procedure returns an input port
whose bytes are drawn from @var{bytevector}.  If @var{transcoder} is
specified, it becomes the transcoder associated with the returned port.

If @var{maybe-transcoder} is @false{} or absent, the port will be a
binary port and will support the @func{port-position} and
@func{set-port-position!} operations.  Otherwise the port will be a
textual port, and whether it supports the @func{port-position} and
@func{set-port-position!} operations will be implementation--dependent
(and possibly transcoder--dependent).

If @var{bytevector} is modified after @code{open-bytevector-input-port}
has been called, the effect on the returned port is unspecified.
@end deffn


@deffn Procedure {open-string-input-port} @var{string}
Return a textual input port whose characters are drawn from
@var{string}.  The port may or may not have an associated transcoder; if
it does, the transcoder is implementation--dependent.  The port should
support the @func{port-position} and @func{set-port-position!}
operations.

If @var{string} is modified after @func{open-string-input-port} has been
called, the effect on the returned port is unspecified.
@end deffn


@deffn Procedure {standard-input-port}
Return a fresh binary input port connected to standard input.  Whether
the port supports the @func{port-position} and @func{set-port-position!}
operations is implementation--dependent.
@end deffn


@deffn Procedure {current-input-port}
This returns a default textual port for input.  Normally, this default
port is associated with standard input, but can be dynamically
re--assigned using the @func{with-input-from-file} procedure from the
@rsixlibrary{io simple} library.  The port may or may not have an
associated transcoder; if it does, the transcoder is
implementation--dependent.
@end deffn


@deffn Procedure make-custom-binary-input-port @var{id} @var{read!} @var{get-position} @var{set-position!} @var{close}
Return a newly created binary input port whose byte source is an
arbitrary algorithm represented by the @func{read!} procedure.  @var{id}
must be a string naming the new port, provided for informational
purposes only.  @var{read!} must be a procedure and should behave as
specified below; it will be called by operations that perform binary
input.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified below.

@table @code
@item (@var{read!} @var{bytevector} @var{start} @var{count})
@var{start} will be a non--negative exact integer object, @var{count}
will be a positive exact integer object, and @var{bytevector} will be a
bytevector whose length is at least @var{start}+@var{count}.

The @var{read!} procedure should obtain up to @var{count} bytes from the
byte source, and should write those bytes into @var{bytevector} starting
at index @var{start}.  The @var{read!} procedure should return an exact
integer object.  This integer object should represent the number of
bytes that it has read.  To indicate an end of file, the @var{read!}
procedure should write no bytes and return 0.

@item (@var{get-position})
The @var{get-position} procedure (if supplied) should return an exact
integer object representing the current position of the input port.  If
not supplied, the custom port will not support the @func{port-position}
operation.

@item (@var{set-position!} @var{pos})
@var{pos} will be a non--negative exact integer object.  The
@var{set-position!} procedure (if supplied) should set the position of
the input port to @var{pos}.  If not supplied, the custom port will not
support the @func{set-port-position!} operation.

@item (@var{close})
The @var{close} procedure (if supplied) should perform any actions that
are necessary when the input port is closed.
@end table

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{read!} and @var{get-position} only when it
actually calls them as part of an I/O operation requested by the
program.  The implementation is not required to check that these
procedures otherwise behave as described.  If they do not, however, the
behavior of the resulting port is unspecified.
@end deffn


@deffn Procedure make-custom-textual-input-port @var{id} @var{read!} @var{get-position} @var{set-position!} @var{close}
Return a newly created textual input port whose character source is an
arbitrary algorithm represented by the @var{read!} procedure.  @var{id}
must be a string naming the new port, provided for informational
purposes only.  @var{read!} must be a procedure and should behave as
specified below; it will be called by operations that perform textual
input.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified below.

@table @code
@item (@var{read!} @var{string} @var{start} @var{count})
@var{start} will be a non--negative exact integer object, @var{count}
will be a positive exact integer object, and @var{string} will be a
string whose length is at least @var{start}+@var{count}.

The @var{read!} procedure should obtain up to @var{count} characters
from the character source, and should write those characters into
@var{string} starting at index @var{start}.  The @var{read!} procedure
should return an exact integer object representing the number of
characters that it has written.  To indicate an end of file, the
@var{read!}  procedure should write no bytes and return 0.

@item (@var{get-position})
The @var{get-position} procedure (if supplied) should return a single
value.  The return value should represent the current position of the
input port.  If not supplied, the custom port will not support the
@func{port-position} operation.

@item (@var{set-position!} @var{pos})
The @var{set-position!} procedure (if supplied) should set the position
of the input port to @var{pos} if @var{pos} is the return value of a
call to @var{get-position}.  If not supplied, the custom port will not
support the @func{set-port-position!} operation.

@item (@var{close})
The @var{close} procedure (if supplied) should perform any actions that
are necessary when the input port is closed.
@end table

The port may or may not have an an associated transcoder; if it does,
the transcoder is implementation--dependent.

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{read!} and @var{get-position} only when it
actually calls them as part of an I/O operation requested by the
program.  The implementation is not required to check that these
procedures otherwise behave as described.  If they do not, however, the
behavior of the resulting port is unspecified.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port binary input
@subsection Binary input


@deffn Procedure get-u8 @var{binary-input-port}
Read from @var{binary-input-port}, blocking as necessary, until a byte
is available from @var{binary-input-port} or until an end of file is
reached.  If a byte becomes available, @code{get-u8} returns the byte as
an octet and updates @var{binary-input-port} to point just past that
byte. If no input byte is seen before an end of file is reached, the
end--of--file object is returned.
@end deffn


@deffn Procedure lookahead-u8 @var{binary-input-port}
The @func{lookahead-u8} procedure is like @code{get-u8}, but it does not
update @var{binary-input-port} to point past the byte.
@end deffn


@deffn Procedure get-bytevector-n @var{binary-input-port} @var{count}
@var{count} must be an exact, non--negative integer object representing
the number of bytes to be read.

The @func{get-bytevector-n} procedure reads from
@var{binary-input-port}, blocking as necessary, until @var{count} bytes
are available from @var{binary-input-port} or until an end of file is
reached.

If @var{count} bytes are available before an end of file,
@func{get-bytevector-n} returns a bytevector of size @var{count}.

If fewer bytes are available before an end of file,
@func{get-bytevector-n} returns a bytevector containing those bytes. In
either case, the input port is updated to point just past the bytes
read.

If an end of file is reached before any bytes are available,
@func{get-bytevector-n} returns the end--of--file object.
@end deffn


@deffn Procedure {get-bytevector-n!} @var{binary-input-port} @var{bytevector} @var{start} @var{count}
@var{count} must be an exact, non--negative integer object, representing
the number of bytes to be read. @var{bytevector} must be a bytevector
with at least @var{start}+@var{count} elements.

The @func{get-bytevector-n!} procedure reads from
@var{binary-input-port}, blocking as necessary, until @var{count} bytes
are available from @var{binary-input-port} or until an end of file is
reached.

If @var{count} bytes are available before an end of file, they are
written into @var{bytevector} starting at index @var{start}, and the
result is @var{count}.

If fewer bytes are available before the next end of file, the available
bytes are written into @var{bytevector} starting at index @var{start},
and the result is a number object representing the number of bytes
actually read.

In either case, the input port is updated to point just past the bytes
read. If an end of file is reached before any bytes are available,
@func{get-bytevector-n!} returns the end--of--file object.
@end deffn


@deffn Procedure get-bytevector-some @var{binary-input-port}
Read from @var{binary-input-port}, blocking as necessary, until bytes
are available from @var{binary-input-port} or until an end of file is
reached.  If bytes become available, @func{get-bytevector-some} returns
a freshly allocated bytevector containing the initial available bytes
(at least one), and it updates @var{binary-input-port} to point just
past these bytes.  If no input bytes are seen before an end of file is
reached, the end--of--file object is returned.
@end deffn


@deffn Procedure get-bytevector-all @var{binary-input-port}
Attempts to read all bytes until the next end of file, blocking as
necessary.  If one or more bytes are read, @func{get-bytevector-all}
returns a bytevector containing all bytes up to the next end of file.
Otherwise, @func{get-bytevector-all} returns the end--of--file object.
The operation may block indefinitely waiting to see if more bytes will
become available, even if some bytes are already available.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port textual input
@subsection Textual input


@deffn Procedure get-char @var{textual-input-port}
Read from @var{textual-input-port}, blocking as necessary, until a
complete character is available from @var{textual-input-port}, or until
an end of file is reached.

If a complete character is available before the next end of file,
@func{get-char} returns that character and updates the input port to
point past the character. If an end of file is reached before any
character is read, @func{get-char} returns the end--of--file object.
@end deffn


@deffn Procedure lookahead-char @var{textual-input-port}
The @func{lookahead-char} procedure is like @func{get-char}, but it does
not update @var{textual-input-port} to point past the character.

@quotation
@emph{Note:} With some of the standard transcoders described in this
document, up to four bytes of lookahead are needed.  Non--standard
transcoders may need even more lookahead.
@end quotation
@end deffn


@deffn Procedure get-string-n @var{textual-input-port} @var{count}
@var{count} must be an exact, non--negative integer object, representing
the number of characters to be read.

The @func{get-string-n} procedure reads from @var{textual-input-port},
blocking as necessary, until @var{count} characters are available, or
until an end of file is reached.

If @var{count} characters are available before end of file,
@func{get-string-n} returns a string consisting of those @var{count}
characters.

If fewer characters are available before an end of file, but one or more
characters can be read, @func{get-string-n} returns a string containing
those characters.

In either case, the input port is updated to point just past the
characters read. If no characters can be read before an end of file, the
end-of-file object is returned.
@end deffn


@deffn Procedure {get-string-n!} @var{textual-input-port} @var{string} @var{start} @var{count}
@var{start} and @var{count} must be exact, non--negative integer
objects, with @var{count} representing the number of characters to be
read.  @var{string} must be a string with at least
@var{start}+@var{count} characters.

The @func{get-string-n!} procedure reads from @var{textual-input-port}
in the same manner as @func{get-string-n}.

If @var{count} characters are available before an end of file, they are
written into @var{string} starting at index @var{start}, and @var{count}
is returned.

If fewer characters are available before an end of file, but one or more
can be read, those characters are written into @var{string} starting at
index @var{start} and the number of characters actually read is returned
as an exact integer object.

If no characters can be read before an end of file, the end--of--file
object is returned.
@end deffn


@deffn Procedure get-string-all @var{textual-input-port}
Read from @var{textual-input-port} until an end of file, decoding
characters in the same manner as @func{get-string-n} and
@func{get-string-n!}.

If characters are available before the end of file, a string containing
all the characters decoded from that data are returned.  If no character
precedes the end of file, the end--of--file object is returned.
@end deffn


@deffn Procedure get-line @var{textual-input-port}
Read from @var{textual-input-port} up to and including the linefeed
character or end of file, decoding characters in the same manner as
@func{get-string-n} and @func{get-string-n!}.

If a linefeed character is read, a string containing all of the text up
to (but not including) the linefeed character is returned, and the port
is updated to point just past the linefeed character.

If an end of file is encountered before any linefeed character is read,
but some characters have been read and decoded as characters, a string
containing those characters is returned.

If an end of file is encountered before any characters are read, the
end--of--file object is returned.

@quotation
@emph{Note:} The end--of--line style, if not @code{none}, will cause all
line endings to be read as linefeed characters.
@end quotation
@end deffn


@deffn Procedure get-datum @var{textual-input-port}
Read an external representation from @var{textual-input-port} and
returns the datum it represents.  The @func{get-datum} procedure returns
the next datum that can be parsed from the given
@var{textual-input-port}, updating @var{textual-input-port} to point
exactly past the end of the external representation of the object.

Any @meta{interlexeme space} (see report section @rsixref{lex
syntax,Lexical syntax}) in the input is first skipped.  If an end of
file occurs after the @meta{interlexeme space}, the end--of--file object
is returned.

If a character inconsistent with an external representation is
encountered in the input, an exception with condition types
@code{&lexical} and @code{&i/o-read} is raised.

Also, if the end of file is encountered after the beginning of an
external representation, but the external representation is incomplete
and therefore cannot be parsed, an exception with condition types
@code{&lexical} and @code{&i/o-read} is raised.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port output ports
@subsection Output ports


An output port is a sink to which bytes or characters are written.  The
written data may control external devices or may produce files and other
objects that may subsequently be opened for input.


@deffn Procedure {output-port?} @var{obj}
Return @true{} if the argument is an output port (or a combined input
and output port), @false{} otherwise.
@end deffn


@deffn Procedure {flush-output-port} @var{output-port}
Flushe any buffered output from the buffer of @var{output-port} to the
underlying file, device, or object.  The @func{flush-output-port}
procedure returns unspecified values.
@end deffn


@deffn Procedure {output-port-buffer-mode} @var{output-port}
Return the symbol that represents the buffer mode of @var{output-port}.
@end deffn


@deffn Procedure open-file-output-port @var{filename}
@deffnx Procedure open-file-output-port @var{filename} @var{file-options}
@deffnx Procedure open-file-output-port @var{filename} @var{file-options} @var{buffer-mode}
@deffnx Procedure open-file-output-port @var{filename} @var{file-options} @var{buffer-mode} @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-file-output-port} procedure returns an output port for
the named file.

The @var{file-options} argument, which may determine various aspects of
the returned port, defaults to the value of @code{(file-options)}.

The @var{buffer-mode} argument, if supplied, must be one of the symbols
that name a buffer mode.  The @var{buffer-mode} argument defaults to
@code{block}.

If @var{maybe-transcoder} is a transcoder, it becomes the transcoder
associated with the port.

If @var{maybe-transcoder} is @false{} or absent, the port will be a
binary port and will support the @func{port-position} and
@func{set-port-position!}  operations.  Otherwise the port will be a
textual port, and whether it supports the @func{port-position} and
@func{set-port-position!} operations is implementation--dependent (and
possibly transcoder--dependent).
@end deffn


@deffn Procedure open-bytevector-output-port
@deffnx Procedure open-bytevector-output-port @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-bytevector-output-port} procedure returns two values: an
output port and an extraction procedure.  The output port accumulates
the bytes written to it for later extraction by the procedure.

If @var{maybe-transcoder} is a transcoder, it becomes the transcoder
associated with the port.  If @var{maybe-transcoder} is @false{} or
absent, the port will be a binary port and will support the
@func{port-position} and @func{set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports the
@code{port-position} and @func{set-port-position!} operations is
implementation--dependent (and possibly transcoder--dependent).

The extraction procedure takes no arguments.  When called, it returns a
bytevector consisting of all the port's accumulated bytes (regardless of
the port's current position), removes the accumulated bytes from the
port, and resets the port's position.
@end deffn


@deffn Procedure call-with-bytevector-output-port @var{proc}
@deffnx Procedure call-with-bytevector-output-port @var{proc} @var{maybe-transcoder}
@var{proc} must accept one argument.  @var{maybe-transcoder} must be
either a transcoder or @false{}.

The @func{call-with-bytevector-output-port} procedure creates an output
port that accumulates the bytes written to it and calls @var{proc} with
that output port as an argument.

Whenever @var{proc} returns, a bytevector consisting of all of the
port's accumulated bytes (regardless of the port's current position) is
returned and the port is closed.

The transcoder associated with the output port is determined as for a
call to @func{open-bytevector-output-port}.
@end deffn


@deffn Procedure open-string-output-port
Return two values: a textual output port and an extraction procedure.
The output port accumulates the characters written to it for later
extraction by the procedure.

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the
@func{port-position} and @func{set-port-position!} operations.

The extraction procedure takes no arguments.  When called, it returns a
string consisting of all of the port's accumulated characters
(regardless of the current position), removes the accumulated characters
from the port, and resets the port's position.
@end deffn


@deffn Procedure call-with-string-output-port @var{proc}
@var{proc} must accept one argument.

The @func{call-with-string-output-port} procedure creates a textual
output port that accumulates the characters written to it and calls
@var{proc} with that output port as an argument.

Whenever @var{proc} returns, a string consisting of all of the port's
accumulated characters (regardless of the port's current position) is
returned and the port is closed.

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the
@func{port-position} and @func{set-port-position!} operations.
@end deffn


@deffn Procedure standard-output-port
@deffnx Procedure standard-error-port
Return a fresh binary output port connected to the standard output or
standard error respectively.  Whether the port supports the
@func{port-position} and @func{set-port-position!} operations is
implementation--dependent.
@end deffn


@deffn Procedure current-output-port
@deffnx Procedure current-error-port
These return default textual ports for regular output and error output.
Normally, these default ports are associated with standard output, and
standard error, respectively.

The return value of @func{current-output-port} can be dynamically
re--assigned using the @func{with-output-to-file} procedure from the
@rsixlibrary{io simple} library.  A port returned by one of these
procedures may or may not have an associated transcoder; if it does, the
transcoder is implementation--dependent.
@end deffn


@deffn Procedure make-custom-binary-output-port @var{id} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created binary output port whose byte sink is an
arbitrary algorithm represented by the @var{write!} procedure.  @var{id}
must be a string naming the new port, provided for informational
purposes only.  @var{write!} must be a procedure and should behave as
specified below; it will be called by operations that perform binary
output.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-binary-input-port}.

@table @code
@item (@var{write!} @var{bytevector} @var{start} @var{count})
@var{start} and @var{count} will be non-negative exact integer objects,
and @var{bytevector} will be a bytevector whose length is at least
@var{start}+@var{count}.

The @var{write!} procedure should write up to @var{count} bytes from
@var{bytevector} starting at index @var{start} to the byte sink.  In any
case, the @var{write!} procedure should return the number of bytes that
it wrote, as an exact integer object.
@end table

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{write!} only when it actually calls
@var{write!} as part of an I/O operation requested by the program.  The
implementation is not required to check that @var{write!} otherwise
behaves as described.  If it does not, however, the behavior of the
resulting port is unspecified.
@end deffn


@deffn Procedure make-custom-textual-output-port @var{id} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created textual output port whose byte sink is an
arbitrary algorithm represented by the @var{write!} procedure.  @var{Id}
must be a string naming the new port, provided for informational
purposes only.  @var{Write!} must be a procedure and should behave as
specified below; it will be called by operations that perform textual
output.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-textual-input-port}.

@table @code
@item (@var{write!} @var{string} @var{start} @var{count})
@var{start} and @var{count} will be non--negative exact integer objects,
and @var{string} will be a string whose length is at least
@var{start}+@var{count}.

The @var{write!} procedure should write up to @var{count} characters
from @var{string} starting at index @var{start} to the character sink.
In any case, the @var{write!} procedure should return the number of
characters that it wrote, as an exact integer object.
@end table

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{write!} only when it actually calls
@var{write!} as part of an I/O operation requested by the program.  The
implementation is not required to check that @var{write!} otherwise
behaves as described.  If it does not, however, the behavior of the
resulting port is unspecified.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port binary output
@subsection Binary output


@deffn Procedure put-u8 @var{binary-output-port} @var{octet}
Write @var{octet} to the output port and returns unspecified values.
@end deffn


@deffn Procedure put-bytevector @var{binary-output-port} @var{bytevector}
@deffnx Procedure put-bytevector @var{binary-output-port} @var{bytevector} @var{start}
@deffnx Procedure put-bytevector @var{binary-output-port} @var{bytevector} @var{start} @var{count}
@var{start} and @var{count} must be non--negative exact integer objects
that default to 0 and:

@example
(- (bytevector-length @var{bytevector}) @var{start})
@end example

@noindent
respectively.  @var{bytevector} must have a length of at least
@var{start}+@var{count}.  The @func{put-bytevector} procedure writes the
@var{count} bytes of the bytevector @var{bytevector} starting at index
@var{start} to the output port.  The @func{put-bytevector} procedure
returns unspecified values.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port textual output
@subsection Textual output


@deffn Procedure put-char @var{textual-output-port} @var{char}
Write @var{char} to the port. The @func{put-char} procedure returns
unspecified values.
@end deffn


@deffn Procedure put-string @var{textual-output-port} @var{string}
@deffnx Procedure put-string @var{textual-output-port} @var{string} @var{start}
@deffnx Procedure put-string @var{textual-output-port} @var{string} @var{start} @var{count}
@var{start} and @var{count} must be non--negative exact integer objects.
@var{String} must have a length of at least @var{start}+@var{count}.

@var{start} defaults to 0.  @var{count} defaults to:

@example
(- (string-length @var{string}) @var{start})
@end example

The @func{put-string} procedure writes the @var{count} characters of
@var{string} starting at index @var{start} to the port.  The
@func{put-string} procedure returns unspecified values.
@end deffn


@deffn Procedure put-datum @var{textual-output-port} @var{datum}
@var{datum} should be a datum value.

The @func{put-datum} procedure writes an external representation of
@var{datum} to @var{textual-output-port}.  The specific external
representation is implementation--dependent.  However, whenever
possible, an implementation should produce a representation for which
@func{get-datum}, when reading the representation, will return an object
equal (in the sense of @func{equal?}) to @var{datum}.

@quotation
@emph{Note:} Not all datums may allow producing an external
representation for which @func{get-datum} will produce an object that is
equal to the original.  Specifically, NaNs contained in @var{datum} may
make this impossible.
@end quotation

@quotation
@emph{Note:} The @func{put-datum} procedure merely writes the external
representation, but no trailing delimiter.  If @func{put-datum} is used
to write several subsequent external representations to an output port,
care should be taken to delimit them properly so they can be read back
in by subsequent calls to @func{get-datum}.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io port input output ports
@subsection Input/output ports


@deffn Procedure {open-file-input/output-port} @var{filename}
@deffnx Procedure {open-file-input/output-port} @var{filename} @var{file-options}
@deffnx Procedure {open-file-input/output-port} @var{filename} @var{file-options} @var{buffer-mode}
@deffnx Procedure {open-file-input/output-port} @var{filename} @var{file-options} @var{buffer-mode} @var{transcoder}
Return a single port that is both an input port and an output port for
the named file.  The optional arguments default as described in the
specification of @func{open-file-output-port}.  If the input/output port
supports @func{port-position} and/or @func{set-port-position!}, the same
port position is used for both input and output.
@end deffn


@deffn Procedure {make-custom-binary-input/output-port} @var{id} @var{read!} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created binary input/output port whose byte source and
sink are arbitrary algorithms represented by the @var{read!} and
@var{write!}  procedures.

@var{id} must be a string naming the new port, provided for
informational purposes only.

@var{read!} and @var{write!} must be procedures, and should behave as
specified for the @func{make-custom-binary-input-port} and
@func{make-custom-binary-output-port} procedures.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-binary-input-port}.
@end deffn


@deffn Procedure {make-custom-textual-input/output-port} @var{id} @var{read!} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created textual input/output port whose textual source
and sink are arbitrary algorithms represented by the @var{read!} and
@var{write!}  procedures.

@var{id} must be a string naming the new port, provided for
informational purposes only.

@var{read!} and @var{write!} must be procedures, and should behave as
specified for the @func{make-custom-textual-input-port} and
@func{make-custom-textual-output-port} procedures.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-textual-input-port}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib io simple
@section Simple input/output


This section describes the @rsixlibrary{io simple} library, which
provides a somewhat more convenient interface for performing textual I/O
on ports.  This library implements most of the I/O procedures of the
previous revision of this report.

The ports created by the procedures of this library are textual ports
associated implementation--dependent transcoders.


@deffn Procedure {eof-object}
@deffnx Procedure {eof-object?} @var{obj}
These are the same as @func{eof-object} and @func{eof-object?} from the
@rsixlibrary{ports} library.
@end deffn


@deffn Procedure call-with-input-file @var{filename} @var{proc}
@deffnx Procedure call-with-output-file @var{filename} @var{proc}
@var{proc} should accept one argument.

These procedures open the file named by @var{filename} for input or for
output, with no specified file options, and call @var{proc} with the
obtained port as an argument.

If @var{proc} returns, the port is closed automatically and the values
returned by @var{proc} are returned.

If @var{proc} does not return, the port is not closed automatically,
unless it is possible to prove that the port will never again be used
for an I/O operation.
@end deffn


@deffn Procedure input-port? @var{obj}
@deffnx Procedure output-port? @var{obj}
These are the same as the @func{input-port?} and @func{output-port?}
procedures in the @rsixlibrary{io ports} library.
@end deffn


@deffn Procedure current-input-port
@deffnx Procedure current-output-port
@deffnx Procedure current-error-port
These are the same as the @func{current-input-port},
@func{current-output-port}, and @func{current-error-port} procedures
from the @rsixlibrary{io ports} library.
@end deffn


@deffn Procedure with-input-from-file @var{filename} @var{thunk}
@deffnx Procedure with-output-to-file @var{filename} @var{thunk}
@var{thunk} must be a procedure and must accept zero arguments.

The file is opened for input or output using empty file options, and
@var{thunk} is called with no arguments.

During the dynamic extent of the call to @var{thunk}, the obtained port
is made the value returned by @func{current-input-port} or
@func{current-output-port} procedures; the previous default values are
reinstated when the dynamic extent is exited.

When @var{thunk} returns, the port is closed automatically.  The values
returned by @var{thunk} are returned.

If an escape procedure is used to escape back into the call to
@var{thunk} after @var{thunk} is returned, the behavior is unspecified.
@end deffn


@deffn Procedure open-input-file @var{filename}
Open @var{filename} for input, with empty file options, and returns the
obtained port.
@end deffn


@deffn Procedure open-output-file @var{filename}
Open @var{filename} for output, with empty file options, and returns the
obtained port.
@end deffn


@deffn Procedure close-input-port @var{input-port}
@deffnx Procedure close-output-port @var{output-port}
Close @var{input-port} or @var{output-port}, respectively.
@end deffn


@deffn Procedure read-char
@deffnx Procedure read-char @var{textual-input-port}
Reads from @var{textual-input-port}, blocking as necessary until a
character is available from @var{textual-input-port}, or the data that
are available cannot be the prefix of any valid encoding, or an end of
file is reached.

If a complete character is available before the next end of file,
@func{read-char} returns that character, and updates the input port to
point past that character.

If an end of file is reached before any data are read, @func{read-char}
returns the end--of--file object.

If @var{textual-input-port} is omitted, it defaults to the value
returned by @func{current-input-port}.
@end deffn


@deffn Procedure peek-char
@deffnx Procedure peek-char @var{textual-input-port}
This is the same as @func{read-char}, but does not consume any data from
the port.
@end deffn


@deffn Procedure read
@deffnx Procedure read @var{textual-input-port}
Read an external representation from @var{textual-input-port} and
returns the datum it represents.

The @func{read} procedure operates in the same way as @func{get-datum}.

If @var{textual-input-port} is omitted, it defaults to the value
returned by @func{current-input-port}.
@end deffn


@deffn Procedure write-char @var{char}
@deffnx Procedure write-char @var{char} @var{textual-output-port}
Write an encoding of the character @var{char} to the
@var{textual-output-port}, and returns unspecified values.

If @var{textual-output-port} is omitted, it defaults to the value
returned by @func{current-output-port}.
@end deffn


@deffn Procedure newline
@deffnx Procedure newline @var{textual-output-port}
This is equivalent to using @func{write-char} to write @code{#\linefeed}
to @var{textual-output-port}.

If @var{textual-output-port} is omitted, it defaults to the value
returned by @func{current-output-port}.
@end deffn


@deffn Procedure display @var{obj}
@deffnx Procedure display @var{obj} @var{textual-output-port}
Write a representation of @var{obj} to the given
@var{textual-output-port}.

Strings that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those strings.

Character objects appear in the representation as if written by
@func{write-char} instead of by @code{write}.

The @func{display} procedure returns unspecified values.

The @var{textual-output-port} argument may be omitted, in which case it
defaults to the value returned by @func{current-output-port}.
@end deffn


@deffn Procedure write @var{obj}
@deffnx Procedure write @var{obj} @var{textual-output-port}
Write the external representation of @var{obj} to
@var{textual-output-port}.

The @func{write} procedure operates in the same way as @func{put-datum}.

If @var{textual-output-port} is omitted, it defaults to the value
returned by @func{current-output-port}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib files
@chapter File system


This chapter describes the @rsixlibrary{files} library for operations on
the file system.  This library, in addition to the procedures described
here, also exports the I/O condition types described in section
@ref{stdlib io conditions}.


@deffn Procedure {file-exists?} @var{filename}
@var{filename} must be a file name.

The @func{file-exists?} procedure returns @true{} if the named file
exists at the time the procedure is called, @false{} otherwise.
@end deffn

@deffn Procedure delete-file @var{filename}
@var{filename} must be a file name.

The @func{delete-file} procedure deletes the named file if it exists and
can be deleted, and returns unspecified values.  If the file does not
exist or cannot be deleted, an exception with condition type
@code{&i/o-filename} is raised.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib programlib
@chapter Command line access and exit values


The procedures described in this section are exported by the
@rsixlibrary{programs} library.


@deffn Procedure command-line
Return a nonempty list of strings.  The first element is an
implementation--specific name for the running top--level program.  The
remaining elements are command--line arguments according to the
operating system's conventions.
@end deffn


@deffn Procedure exit
@deffnx Procedure exit @var{obj}
Exit the running program and communicates an exit value to the operating
system.

If no argument is supplied, the @func{exit} procedure should communicate
to the operating system that the program exited normally.

If an argument is supplied, the @func{exit} procedure should translate
the argument into an appropriate exit value for the operating system.
If @var{obj} is @false{}, the exit is assumed to be abnormal.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib arithmetics
@chapter Arithmetics


This chapter describes Scheme's libraries for more specialized numerical
operations: fixnum and flonum arithmetic, as well as bitwise operations
on exact integer objects.


@menu
* stdlib arithmetics bitwise::          Bitwise operations.
* stdlib arithmetics fixnum::           Fixnums.
* stdlib arithmetics flonum::           Flonums.
* stdlib arithmetics exact bitwise::    Exact bitwise arithmetic.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib arithmetics bitwise
@section Bitwise operations


A number of procedures operate on the binary two's--complement
representations of exact integer objects: Bit positions within an exact
integer object are counted from the right, i.e. bit 0 is the least
significant bit.  Some procedures allow extracting @emph{bit fields},
i.e., number objects representing subsequences of the binary
representation of an exact integer object.  Bit fields are always
positive, and always defined using a finite number of bits.


@c ------------------------------------------------------------

@c page
@node stdlib arithmetics fixnum
@section Fixnums


Every implementation must define its fixnum range as a closed interval:

@example
[-2^(w-1), 2^(w-1)-1]
@end example

@noindent
such that @emph{w} is a (mathematical) integer @emph{w >= 24}.  Every
mathematical integer within an implementation's fixnum range must
correspond to an exact integer object that is representable within the
implementation.  A fixnum is an exact integer object whose value lies
within this fixnum range.

This section describes the @rsixlibrary{arithmetic fixnums} library,
which defines various operations on fixnums.  Fixnum operations perform
integer arithmetic on their fixnum arguments, but raise an exception
with condition type @code{&implementation-restriction} if the result is
not a fixnum.

This section uses @var{fx}, @vari{fx}, @varii{fx}, etc., as names for
arguments that must be fixnums.


@deffn Procedure fixnum? @var{obj}
Return @true{} if @var{obj} is an exact integer object within the fixnum
range, @false{} otherwise.
@end deffn


@deffn Procedure fixnum-width
@deffnx Procedure least-fixnum
@deffnx Procedure greatest-fixnum
These procedures return @emph{w}, @emph{-2^(w-1)} and @emph{2^(w-1)-1}:
the width, minimum and the maximum value of the fixnum range,
respectively.
@end deffn


@deffn Procedure {fx=?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx>?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx<?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx>=?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx<=?} @vari{fx} @varii{fx} @variii{fx} @dots{}
These procedures return @true{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, @false{} otherwise.
@end deffn


@deffn Procedure {fxzero?} @var{fx}
@deffnx Procedure {fxpositive?} @var{fx}
@deffnx Procedure {fxnegative?} @var{fx}
@deffnx Procedure {fxodd?} @var{fx}
@deffnx Procedure {fxeven?} @var{fx}
These numerical predicates test a fixnum for a particular property,
returning @true{} or @false{}.  The five properties tested by these
procedures are: whether the number object is zero, greater than zero,
less than zero, odd, or even.
@end deffn


@deffn Procedure {fxmax} @vari{fx} @varii{fx} @dots{}
@deffnx Procedure {fxmin} @vari{fx} @varii{fx} @dots{}
These procedures return the maximum or minimum of their arguments.
@end deffn


@deffn Procedure {fx+} @vari{fx} @varii{fx}
@deffnx Procedure {fx*} @vari{fx} @varii{fx}
These procedures return the sum or product of their arguments, provided
that sum or product is a fixnum.  An exception with condition type
@code{&implementation-restriction} is raised if that sum or product is
not a fixnum.
@end deffn


@deffn Procedure {fx-} @vari{fx} @varii{fx}
@deffnx Procedure {fx-} @var{fx}
With two arguments, this procedure returns the difference
@vari{fx}-@varii{fx}, provided that difference is a fixnum.

With one argument, this procedure returns the additive inverse of its
argument, provided that integer object is a fixnum.

An exception with condition type @code{&implementation-restriction} is
raised if the mathematically correct result of this procedure is not a
fixnum.

@example
(fx- (least-fixnum))  => exception &assertion
@end example
@end deffn


@deffn Procedure {fxdiv-and-mod} @vari{fx} @varii{fx}
@deffnx Procedure {fxdiv} @vari{fx} @varii{fx}
@deffnx Procedure {fxmod} @vari{fx} @varii{fx}
@deffnx Procedure {fxdiv0-and-mod0} @vari{fx} @varii{fx}
@deffnx Procedure {fxdiv0} @vari{fx} @varii{fx}
@deffnx Procedure {fxmod0} @vari{fx} @varii{fx}
@varii{fx} must be nonzero.

These procedures implement number--theoretic integer division and return
the results of the corresponding mathematical operations specified in
report section``Integer division''.

@example
(fxdiv @vari{fx} @varii{fx})         => @vari{fx} div @varii{fx}
(fxmod @vari{fx} @varii{fx})         => @vari{fx} mod @varii{fx}
(fxdiv-and-mod @vari{fx} @varii{fx}) => @vari{fx} div @varii{fx}, @vari{fx} mod @varii{fx}
                                        ; two return values
(fxdiv0 @vari{fx} @varii{fx})        => @vari{fx} div_0 @varii{fx}
(fxmod0 @vari{fx} @varii{fx})        => @vari{fx} mod_0 @varii{fx}
(fxdiv0-and-mod0 @vari{fx} @varii{fx})
=> @vari{fx} @vari{fx} div_0 @varii{fx}, @vari{fx} mod_0 @varii{fx}
   ; two return values
@end example
@end deffn


@deffn Procedure {fx+/carry} @vari{fx} @varii{fx} @variii{fx}
Return the two fixnum results of the following computation:

@example
(let* ((s (+ @vari{fx} @varii{fx} @variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))
@end example
@end deffn


@deffn Procedure {fx-/carry} @vari{fx} @varii{fx} @variii{fx}
Return the two fixnum results of the following computation:

@example
(let* ((d (- @vari{fx} @varii{fx} @variii{fx}))
       (d0 (mod0 d (expt 2 (fixnum-width))))
       (d1 (div0 d (expt 2 (fixnum-width)))))
  (values d0 d1))
@end example
@end deffn


@deffn Procedure {fx*/carry} @vari{fx} @varii{fx} @variii{fx}
Return the two fixnum results of the following computation:

@example
(let* ((s (+ (* @vari{fx} @varii{fx}) @variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))
@end example
@end deffn


@deffn Procedure {fxnot} @var{fx}
Return the unique fixnum that is congruent mod @emph{2^w} to the
one's--complement of @var{fx}.
@end deffn


@deffn Procedure {fxand} @vari{fx} @dots{}
@deffnx Procedure {fxior} @vari{fx} @dots{}
@deffnx Procedure {fxxor} @vari{fx} @dots{}
These procedures return the fixnum that is the bit--wise ``and'',
``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the fixnum (either @emph{-1} or @emph{0}) that acts as
identity for the operation.
@end deffn


@deffn Procedure {fxif} @vari{fx} @varii{fx} @variii{fx}
Return the fixnum that is the bit--wise ``if'' of the two's complement
representations of its arguments, i.e. for each bit, if it is 1 in
@vari{fx}, the corresponding bit in @varii{fx} becomes the value of the
corresponding bit in the result, and if it is 0, the corresponding bit
in @variii{fx} becomes the corresponding bit in the value of the result.
This is the fixnum result of the following computation:

@example
(fxior (fxand @vari{fx} @varii{fx})
       (fxand (fxnot @vari{fx}) @variii{fx}))
@end example
@end deffn


@deffn Procedure {fxbit-count} @var{fx}
If @var{fx} is non--negative, this procedure returns the number of 1
bits in the two's complement representation of @var{fx}.  Otherwise it
returns the result of the following computation:

@example
(fxnot (fxbit-count (fxnot @var{ei})))
@end example
@end deffn


@deffn Procedure {fxlength} @var{fx}
Return the number of bits needed to represent @var{fx} if it is
positive, and the number of bits needed to represent @code{(fxnot
@var{fx})} if it is negative, which is the fixnum result of the
following computation:

@example
(do ((result 0 (+ result 1))
     (bits (if (fxnegative? @var{fx})
               (fxnot @var{fx})
               @var{fx})
           (fxarithmetic-shift-right bits 1)))
    ((fxzero? bits)
     result))
@end example
@end deffn


@deffn Procedure {fxfirst-bit-set} @var{fx}
Return the index of the least significant 1 bit in the two's complement
representation of @var{fx}.  If @var{fx} is 0, then -1 is returned.

@example
(fxfirst-bit-set 0)        =>  -1
(fxfirst-bit-set 1)        =>  0
(fxfirst-bit-set -4)       =>  2
@end example
@end deffn


@deffn Procedure {fxbit-set?} @vari{fx} @varii{fx}
@varii{fx} must be non--negative and less than @code{(fixnum-width)}.

The @func{fxbit-set?} procedure returns @true{} if the @varii{fx}th bit
is 1 in the two's complement representation of @vari{fx}, and @false{}
otherwise.  This is the fixnum result of the following computation:

@example
(not
  (fxzero?
    (fxand @vari{fx}
           (fxarithmetic-shift-left 1 @varii{fx}))))
@end example
@end deffn


@deffn Procedure {fxcopy-bit} @vari{fx} @varii{fx} @variii{fx}
@varii{fx} must be non--negative and less than @code{(fixnum-width)}.
@variii{Fx} must be 0 or 1.

The @func{fxcopy-bit} procedure returns the result of replacing the
@varii{fx}th bit of @vari{fx} by @variii{fx}, which is the result of the
following computation:

@example
(let* ((mask (fxarithmetic-shift-left 1 @varii{fx})))
  (fxif mask
        (fxarithmetic-shift-left @variii{fx} @varii{fx})
        @vari{fx}))
@end example
@end deffn


@deffn Procedure {fxbit-field} @vari{fx} @varii{fx} @variii{fx}
@varii{fx} and @variii{fx} must be non-negative and less than
@code{(fixnum-width)}.  Moreover, @varii{fx} must be less than or equal
to @variii{fx}.

The @code{fxbit-field} procedure returns the number represented by the
bits at the positions from @varii{fx} (inclusive) to @variii{fx}
(exclusive), which is the fixnum result of the following computation:

@example
(let* ((mask (fxnot
              (fxarithmetic-shift-left -1 @variii{fx}))))
  (fxarithmetic-shift-right (fxand @vari{fx} mask)
                            @varii{fx}))
@end example
@end deffn


@deffn Procedure {fxcopy-bit-field} @vari{fx} @varii{fx} @variii{fx} @variv{fx}
@varii{fx} and @variii{fx} must be non-negative and less than
@code{(fixnum-width)}.  Moreover, @varii{fx} must be less than or equal
to @variii{fx}.

The @func{fxcopy-bit-field} procedure returns the result of replacing in
@vari{fx} the bits at positions from @varii{fx} (inclusive) to
@variii{fx} (exclusive) by the bits in @variv{fx} from position 0
(inclusive) to position @variii{fx}-@varii{fx} (exclusive), which is the
fixnum result of the following computation:

@example
(let* ((to    @vari{fx})
       (start @varii{fx})
       (end   @variii{fx})
       (from  @variv{fx})
       (mask1 (fxarithmetic-shift-left -1 start))
       (mask2 (fxnot (fxarithmetic-shift-left -1 end)))
       (mask  (fxand mask1 mask2))
       (mask3 (fxnot (fxarithmetic-shift-left -1 (- end start)))))
  (fxif mask
        (fxarithmetic-shift-left (fxand from mask3)
                                 start)
        to))
@end example
@end deffn


@deffn Procedure {fxarithmetic-shift} @vari{fx} @varii{fx}
The absolute value of @varii{fx} must be less than
@code{(fixnum-width)}.

If:

@example
(floor (* @vari{fx} (expt 2 @varii{fx})))
@end example

@noindent
is a fixnum, then that fixnum is returned.  Otherwise an exception with
condition type @code{&implementation-restriction} is raised.
@end deffn


@deffn Procedure {fxarithmetic-shift-left} @vari{fx} @varii{fx}
@deffnx Procedure {fxarithmetic-shift-right} @vari{fx} @varii{fx}
@varii{fx} must be non--negative, and less than @code{(fixnum-width)}.


The @func{fxarithmetic-shift-left} procedure behaves the same as
@func{fxarithmetic-shift}, and @code{(fxarithmetic-shift-right @vari{fx}
@varii{fx})} behaves the same as @code{(fxarithmetic-shift @vari{fx}
(fx- @varii{fx}))}.
@end deffn


@deffn Procedure {fxrotate-bit-field} @vari{fx} @varii{fx} @variii{fx} @variv{fx}
@varii{fx}, @variii{fx}, and @variv{fx} must be non--negative and less
than @code{(fixnum-width)}.  @varii{fx} must be less than or equal to
@variii{fx}.  @variv{fx} must be less than the difference between
@variii{fx} and @varii{fx}.

The @func{fxrotate-bit-field} procedure returns the result of cyclically
permuting in @vari{fx} the bits at positions from @varii{fx} (inclusive)
to @variii{fx} (exclusive) by @variv{fx} bits towards the more
significant bits, which is the result of the following computation:

@example
(let* ((n     @vari{fx})
       (start @varii{fx})
       (end   @variii{fx})
       (count @variv{fx})
       (width (fx- end start)))
  (if (fxpositive? width)
      (let* ((count (fxmod count width))
             (field0
               (fxbit-field n start end))
             (field1
               (fxarithmetic-shift-left
                 field0 count))
             (field2
               (fxarithmetic-shift-right
                 field0 (fx- width count)))
             (field (fxior field1 field2)))
        (fxcopy-bit-field n start end field))
      n))
@end example
@end deffn


@deffn Procedure {fxreverse-bit-field} @vari{fx} @varii{fx} @variii{fx}
@varii{fx} and @variii{fx} must be non-negative and less than
@code{(fixnum-width)}.  Moreover, @varii{fx} must be less than or equal
to @variii{fx}.

The @code{fxreverse-bit-field} procedure returns the fixnum obtained
from @vari{fx} by reversing the order of the bits at positions from
@varii{fx} (inclusive) to @variii{fx} (exclusive).

@example
(fxreverse-bit-field #b1010010 1 4)       =>  88 ; #b1011000
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib arithmetics flonum
@section Flonums


This section describes the @rsixlibrary{arithmetic flonums} library.

This section uses @var{fl}, @vari{fl}, @varii{fl}, etc., as parameter
names for arguments that must be flonums, and @var{ifl} as a name for
arguments that must be integer--valued flonums, i.e., flonums for which
the @func{integer-valued?} predicate returns true.


@deffn Procedure {flonum?} @var{obj}
Return @true{} if @var{obj} is a flonum, @false{} otherwise.
@end deffn


@deffn Procedure {real->flonum} @var{x}
Return the best flonum representation of @var{x}.

The value returned is a flonum that is numerically closest to the
argument.

@quotation
@emph{Note:} If flonums are represented in binary floating point, then
implementations should break ties by preferring the floating--point
representation whose least significant bit is zero.
@end quotation
@end deffn


@deffn Procedure {fl=?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl<?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl<=?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl>?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl>=?} @vari{fl} @varii{fl} @variii{fl} @dots{}
These procedures return @true{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, @false{} otherwise.
These predicates must be transitive.

@example
(fl=? +inf.0 +inf.0)           => #t
(fl=? -inf.0 +inf.0)           => #f
(fl=? -inf.0 -inf.0)           => #t
(fl=? 0.0 -0.0)                => #t
(fl<? 0.0 -0.0)                => #f
(fl=? +nan.0 @var{fl})         => #f
(fl<? +nan.0 @var{fl})         => #f
@end example
@end deffn


@deffn Procedure {flinteger?} @var{fl}
@deffnx Procedure {flzero?} @var{fl}
@deffnx Procedure {flpositive?} @var{fl}
@deffnx Procedure {flnegative?} @var{fl}
@deffnx Procedure {flodd?} @var{ifl}
@deffnx Procedure {fleven?} @var{ifl}
@deffnx Procedure {flfinite?} @var{fl}
@deffnx Procedure {flinfinite?} @var{fl}
@deffnx Procedure {flnan?} @var{fl}
These numerical predicates test a flonum for a particular property,
returning @true{} or @false{}:

@table @func
@item flinteger?
procedure tests whether the number object is an integer,

@item flzero?
tests whether it is @func{fl=?} to zero,

@item flpositive?
tests whether it is greater than zero,

@item flnegative?
tests whether it is less than zero,

@item flodd?
tests whether it is odd,

@item fleven?
tests whether it is even,

@item flfinite?
tests whether it is not an infinity and not a NaN,

@item flinfinite?
tests whether it is an infinity,

@item flnan?
tests whether it is a NaN.
@end table

@example
(flnegative? -0.0)              => #f
(flfinite?   +inf.0)            => #f
(flfinite?   5.0)               => #t
(flinfinite? 5.0)               => #f
(flinfinite? +inf.0)            => #t
@end example

@quotation
@emph{Note:} @code{(flnegative? -0.0)} must return @false{}, else it
would lose the correspondence with @code{(fl< -0.0 0.0)}, which is
@false{} according to @ieee{} 754.
@end quotation
@end deffn


@deffn Procedure {flmax} @vari{fl} @varii{fl} @dots{}
@deffnx Procedure {flmin} @vari{fl} @varii{fl} @dots{}
These procedures return the maximum or minimum of their arguments.  They
always return a NaN when one or more of the arguments is a NaN.
@end deffn


@deffn Procedure {fl+} @vari{fl} @dots{}
@deffnx Procedure {fl*} @vari{fl} @dots{}
These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations that
represent flonums using @ieee{} binary floating point, the meaning of
``best'' is defined by the @ieee{} standards.)

@example
(fl+ +inf.0 -inf.0)             =>  +nan.0
(fl+ +nan.0 @var{fl})           =>  +nan.0
(fl* +nan.0 @var{fl})           =>  +nan.0
@end example
@end deffn


@deffn Procedure {fl-} @vari{fl} @varii{fl} @dots{}
@deffnx Procedure {fl-} @var{fl}
@deffnx Procedure {fl/} @vari{fl} @varii{fl} @dots{}
@deffnx Procedure {fl/} @var{fl}
With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.

With one argument, however, they return the additive or multiplicative
flonum inverse of their argument.

In general, they should return the flonum that best approximates the
mathematical difference or quotient.  (For implementations that
represent flonums using @ieee{} binary floating point, the meaning of
``best'' is reasonably well--defined by the @ieee{} standards.)

@example
(fl- +inf.0 +inf.0)      =>  +nan.0
@end example

For undefined quotients, @func{fl/} behaves as specified by the @ieee{}
standards:

@example
(fl/ 1.0 0.0)                   => +inf.0
(fl/ -1.0 0.0)                  => -inf.0
(fl/ 0.0 0.0)                   => +nan.0
@end example
@end deffn


@deffn Procedure {flabs} @var{fl}
Return the absolute value of @var{fl}.
@end deffn


@deffn Procedure {fldiv-and-mod} @vari{fl} @varii{fl}
@deffnx Procedure {fldiv} @vari{fl} @varii{fl}
@deffnx Procedure {flmod} @vari{fl} @varii{fl}
@deffnx Procedure {fldiv0-and-mod0} @vari{fl} @varii{fl}
@deffnx Procedure {fldiv0} @vari{fl} @varii{fl}
@deffnx Procedure {flmod0} @vari{fl} @varii{fl}
These procedures implement number--theoretic integer division and return
the results of the corresponding mathematical operations specified in
report section @rsixref{base math semantics integer,Integer division}.

In the cases where the mathematical requirements in section
@rsixref{base math semantics,Semantics of common operations} cannot be
satisfied by any number object, either an exception is raised with
condition type @code{&implementation-restriction}, or unspecified
flonums (one for @func{fldiv}, @func{flmod}, @func{fldiv0} and
@func{flmod0}, two for @func{fldiv-and-mod} and @func{fldiv0-and-mod0})
are returned.

@example
(fldiv @vari{fl} @varii{fl})         => @vari{fl} div @varii{fl}
(flmod @vari{fl} @varii{fl})         => @vari{fl} mod @varii{fl}
(fldiv-and-mod @vari{fl} @varii{fl}) => @vari{fl} div @varii{fl}, @vari{fl} mod @varii{fl}
                                        ; two return values
(fldiv0 @vari{fl} @varii{fl})        => @vari{fl} div_0 @varii{fl}
(flmod0 @vari{fl} @varii{fl})        => @vari{fl} mod_0 @varii{fl}
(fldiv0-and-mod0 @vari{fl} @varii{fl})
=> @vari{fl} div_0 @varii{fl}, @vari{fl} mod_0 @varii{fl}
   ; two return values
@end example
@end deffn


@deffn Procedure {flnumerator} @var{fl}
@deffnx Procedure {fldenominator} @var{fl}
These procedures return the numerator or denominator of @var{fl} as a
flonum; the result is computed as if @var{fl} was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.

@example
(flnumerator +inf.0)           =>  +inf.0
(flnumerator -inf.0)           =>  -inf.0
(fldenominator +inf.0)         =>  1.0
(fldenominator -inf.0)         =>  1.0
(flnumerator 0.75)             =>  3.0 ; probably
(fldenominator 0.75)           =>  4.0 ; probably
@end example

Implementations should implement following behavior:

@example
(flnumerator -0.0)             => -0.0
@end example
@end deffn


@deffn Procedure {flfloor} @var{fl}
@deffnx Procedure {flceiling} @var{fl}
@deffnx Procedure {fltruncate} @var{fl}
@deffnx Procedure {flround} @var{fl}
These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.

@table @func
@item flfloor
Returns the largest integral flonum not larger than @var{fl}.

@item flceiling
Returns the smallest integral flonum not smaller than @var{fl}.

@item fltruncate
Returns the integral flonum closest to @var{fl} whose absolute value is
not larger than the absolute value of @var{fl}.

@item flround
Returns the closest integral flonum to @var{fl}, rounding to even when
@var{fl} represents a number halfway between two integers.
@end table

Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN:

@example
(flfloor +inf.0)                       =>  +inf.0
(flceiling -inf.0)                     =>  -inf.0
(fltruncate +nan.0)                    =>  +nan.0
@end example
@end deffn


@deffn Procedure {flexp} @var{fl}
@deffnx Procedure {fllog} @var{fl}
@deffnx Procedure {fllog} @vari{fl} @varii{fl}
@deffnx Procedure {flsin} @var{fl}
@deffnx Procedure {flcos} @var{fl}
@deffnx Procedure {fltan} @var{fl}
@deffnx Procedure {flasin} @var{fl}
@deffnx Procedure {flacos} @var{fl}
@deffnx Procedure {flatan} @var{fl}
@deffnx Procedure {flatan} @vari{fl} @varii{fl}
These procedures compute the usual transcendental functions.

@table @func
@item flexp
Computes the base-E exponential of @var{fl}.

@item fllog
With a single argument computes the natural logarithm of @var{fl} (not
the base ten logarithm); @code{(fllog @vari{fl} @varii{fl})} computes
the base--@varii{fl} logarithm of @vari{fl}.

@item flasin
@itemx flacos
@item flatan
Compute arcsine, arccosine, and arctangent, respectively.  @code{(flatan
@vari{fl} @varii{fl})} computes the arc tangent of @vari{fl}/@varii{fl}.
@end table

See report section @rsixref{base math ops trascend,Transcendental
functions} for the underlying mathematical operations.  In the event
that these operations do not yield a real result for the given
arguments, the result may be a NaN, or may be some unspecified flonum.

Implementations that use @ieee{} binary floating--point arithmetic
should follow the relevant standards for these procedures.

@example
(flexp +inf.0)                => +inf.0
(flexp -inf.0)                => 0.0
(fllog +inf.0)                => +inf.0
(fllog 0.0)                   => -inf.0
(fllog -0.0)                  => unspecified ; if -0.0 is distinguished
(fllog -inf.0)                => +nan.0
(flatan -inf.0)               => -1.5707963267948965  ; approximately
(flatan +inf.0)               => 1.5707963267948965   ; approximately
@end example
@end deffn


@deffn Procedure {flsqrt} @var{fl}
Returns the principal square root of @var{fl}. For -0.0, @func{flsqrt}
should return -0.0; for other negative arguments, the result may be a
NaN or some unspecified flonum.

@example
(flsqrt +inf.0)               => +inf.0
(flsqrt -0.0)                 => -0.0
@end example
@end deffn


@deffn Procedure {flexpt} @vari{fl} @varii{fl}
Either @vari{fl} should be non--negative, or, if @vari{fl} is negative,
@varii{fl} should be an integer object.

The @func{flexpt} procedure returns @vari{fl} raised to the power
@varii{fl}.  If @vari{fl} is negative and @varii{fl} is not an integer
object, the result may be a NaN, or may be some unspecified flonum.

If @vari{fl} and @varii{fl} are both zero, the result is @code{1.0}.  If
@vari{fl} is zero and @varii{fl} is positive, the result is zero.  If
@vari{fl} is negative, the result may be a NaN, or may be some
unspecified flonum.
@end deffn


@deffn {Condition Type} {&no-infinities}
@deffnx Procedure {make-no-infinities-violation}
@deffnx Procedure {no-infinities-violation?} @var{obj}
@deffnx {Condition Type} {&no-nans}
@deffnx Procedure {make-no-nans-violation}
@deffnx Procedure {no-nans-violation?} @var{obj}
These condition types could be defined by the following code:

@example
(define-condition-type &no-infinities
    &implementation-restriction
  make-no-infinities-violation
  no-infinities-violation?)

(define-condition-type &no-nans
    &implementation-restriction
  make-no-nans-violation no-nans-violation?)
@end example

These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  @rsixref{base math infinities,Representability of
infinities and NaNs}.
@end deffn


@deffn Procedure {fixnum->flonum} @var{fx}
Return a flonum that is numerically closest to @var{fx}.

@quotation
@emph{Note:} The result of this procedure may not be numerically equal
to @var{fx}, because the fixnum precision may be greater than the flonum
precision.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib arithmetics exact bitwise
@section Exact bitwise arithmetic


This section describes the @rsixlibrary{arithmetic bitwise} library.
The exact bitwise arithmetic provides generic operations on exact
integer objects.  This section uses @var{ei}, @vari{ei}, @varii{ei},
etc., as parameter names that must be exact integer objects.


@deffn Procedure bitwise-not @var{ei}
Returns the exact integer object whose two's complement representation
is the one's complement of the two's complement representation of
@var{ei}.
@end deffn


@deffn Procedure bitwise-and @vari{ei} @dots{}
@deffnx Procedure bitwise-ior @vari{ei} @dots{}
@deffnx Procedure bitwise-xor @vari{ei} @dots{}
These procedures return the exact integer object that is the bit--wise
``and'', ``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the integer object (either -1 or 0) that acts as identity
for the operation.
@end deffn


@deffn Procedure bitwise-if @vari{ei} @varii{ei} @variii{ei}
Return the exact integer object that is the bit-wise ``if'' of the two's
complement representations of its arguments, i.e. for each bit, if it is
1 in @vari{ei}, the corresponding bit in @varii{ei} becomes the value of
the corresponding bit in the result, and if it is 0, the corresponding
bit in @variii{ei} becomes the corresponding bit in the value of the
result.  This is the result of the following computation:

@example
(bitwise-ior (bitwise-and @vari{ei} @varii{ei})
             (bitwise-and (bitwise-not @vari{ei}) @variii{ei}))
@end example
@end deffn


@deffn Procedure bitwise-bit-count @var{ei}
If @var{ei} is non--negative, this procedure returns the number of 1
bits in the two's complement representation of @var{ei}.  Otherwise it
returns the result of the following computation:

@example
(bitwise-not (bitwise-bit-count (bitwise-not @var{ei})))
@end example
@end deffn


@deffn Procedure bitwise-length @var{ei}
Return the number of bits needed to represent @var{ei} if it is
positive, and the number of bits needed to represent @code{(bitwise-not
@var{ei})} if it is negative, which is the exact integer object that is
the result of the following computation:

@example
(do ((result 0 (+ result 1))
     (bits (if (negative? @var{ei})
               (bitwise-not @var{ei})
               @var{ei})
           (bitwise-arithmetic-shift bits -1)))
    ((zero? bits)
     result))
@end example
@end deffn


@deffn Procedure bitwise-first-bit-set @var{ei}
Returns the index of the least significant 1 bit in the two's complement
representation of @var{ei}.  If @var{ei} is 0, then -1 is returned.

@example
(bitwise-first-bit-set 0)        =>  -1
(bitwise-first-bit-set 1)        =>  0
(bitwise-first-bit-set -4)       =>  2
@end example
@end deffn


@deffn Procedure bitwise-bit-set? @vari{ei} @varii{ei}
@varii{ei} must be non--negative.

The @func{bitwise-bit-set?} procedure returns @true{} if the
@varii{ei}th bit is 1 in the two's complement representation of
@vari{ei}, and @false{} otherwise.  This is the result of the following
computation:

@example
(not (zero?
       (bitwise-and
         (bitwise-arithmetic-shift-left 1 @varii{ei})
         @vari{ei})))
@end example
@end deffn


@deffn Procedure bitwise-copy-bit @vari{ei} @varii{ei} @variii{ei}
@varii{ei} must be non--negative, and @variii{ei} must be either 0 or 1.

The @func{bitwise-copy-bit} procedure returns the result of replacing
the @varii{ei}th bit of @vari{ei} by @variii{ei}, which is the result of
the following computation:

@example
(let* ((mask (bitwise-arithmetic-shift-left 1 @varii{ei})))
  (bitwise-if mask
            (bitwise-arithmetic-shift-left @variii{ei} @varii{ei})
            @vari{ei}))
@end example
@end deffn


@deffn Procedure bitwise-bit-field @vari{ei} @varii{ei} @variii{ei}
@varii{ei} and @variii{ei} must be non--negative, and @varii{ei} must be
less than or equal to @variii{ei}.

The @func{bitwise-bit-field} procedure returns the number represented by
the bits at the positions from @varii{ei} (inclusive) to @variii{ei}
(exclusive), which is the result of the following computation:

@example
(let ((mask
       (bitwise-not
        (bitwise-arithmetic-shift-left -1 @variii{ei}))))
  (bitwise-arithmetic-shift-right
    (bitwise-and @vari{ei} mask)
    @varii{ei}))
@end example
@end deffn


@deffn Procedure bitwise-copy-bit-field @vari{ei} @varii{ei} @variii{ei} @variv{ei}
@varii{ei} and @variii{ei} must be non--negative, and @varii{ei} must be
less than or equal to @variii{ei}.

The @func{bitwise-copy-bit-field} procedure returns the result of
replacing in @vari{ei} the bits at positions from @varii{ei} (inclusive)
to @variii{ei} (exclusive) by the bits in @variv{ei} from position 0
(inclusive) to position @variii{ei}-@varii{ei} (exclusive) which is the
result of the following computation:

@example
(let* ((to    @vari{ei})
       (start @varii{ei})
       (end   @variii{ei})
       (from  @variv{ei})
       (mask1
         (bitwise-arithmetic-shift-left -1 start))
       (mask2
         (bitwise-not
           (bitwise-arithmetic-shift-left -1 end)))
       (mask (bitwise-and mask1 mask2)))
  (bitwise-if mask
              (bitwise-arithmetic-shift-left from
                                             start)
              to))
@end example
@end deffn


@deffn Procedure bitwise-arithmetic-shift @vari{ei} @varii{ei}
Return the result of the following computation:

@example
(floor (* @vari{ei} (expt 2 @varii{ei})))
@end example

Examples:

@example
(bitwise-arithmetic-shift -6 -1)    => -3
(bitwise-arithmetic-shift -5 -1)    => -3
(bitwise-arithmetic-shift -4 -1)    => -2
(bitwise-arithmetic-shift -3 -1)    => -2
(bitwise-arithmetic-shift -2 -1)    => -1
(bitwise-arithmetic-shift -1 -1)    => -1
@end example
@end deffn


@deffn Procedure bitwise-arithmetic-shift-left @vari{ei} @varii{ei}
@deffnx Procedure bitwise-arithmetic-shift-right @vari{ei} @varii{ei}
@varii{ei} must be non--negative.

The @func{bitwise-arithmetic-shift-left} procedure returns the same
result as @func{bitwise-arithmetic-shift}, and:

@example
(bitwise-arithmetic-shift-right @vari{ei} @varii{ei})
@end example

@noindent
returns the same result as:

@example
(bitwise-arithmetic-shift @vari{ei} (- @varii{ei}))
@end example
@end deffn


@deffn Procedure bitwise-rotate-bit-field @vari{ei} @varii{ei} @variii{ei} @variv{ei}
@varii{ei}, @variii{ei}, @variv{ei} must be non--negative, @varii{ei}
must be less than or equal to @variii{ei}, and @variv{ei} must be
non-negative.

The procedure returns the result of cyclically permuting in @vari{ei}
the bits at positions from @varii{ei} (inclusive) to @variii{ei}
(exclusive) by @variv{ei} bits towards the more significant bits, which
is the result of the following computation:

@example
(let* ((n     @vari{ei})
       (start @varii{ei})
       (end   @variii{ei})
       (count @variv{ei})
       (width (- end start)))
  (if (positive? width)
      (let* ((count (mod count width))
             (field0
               (bitwise-bit-field n start end))
             (field1 (bitwise-arithmetic-shift-left
                       field0 count))
             (field2 (bitwise-arithmetic-shift-right
                       field0
                       (- width count)))
             (field (bitwise-ior field1 field2)))
        (bitwise-copy-bit-field n start end field))
      n))
@end example
@end deffn


@deffn Procedure bitwise-reverse-bit-field @vari{ei} @varii{ei} @variii{ei}
@varii{ei} and @variii{ei} must be non--negative, and @varii{ei} must be
less than or equal to @variii{ei}.

The @func{bitwise-reverse-bit-field} procedure returns the result
obtained from @vari{ei} by reversing the order of the bits at positions
from @varii{ei} (inclusive) to @variii{ei} (exclusive).

@example
(bitwise-reverse-bit-field #b1010010 1 4)      =>  88 ; #b1011000
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case
@chapter Syntax--case


The @rsixlibrary{syntax-case} library provides support for writing
low--level macros in a high--level style, with automatic syntax
checking, input destructuring, output restructuring, maintenance of
lexical scoping and referential transparency (hygiene), and support for
controlled identifier capture.


@menu
* stdlib syntax-case hygiene::          Hygiene.
* stdlib syntax-case objects::          Syntax objects.
* stdlib syntax-case transformers::     Transformers.
* stdlib syntax-case parsing::          Parsing input and producing
                                        output.
* stdlib syntax-case identifier::       Identifier predicates.
* stdlib syntax-case conversion::       Syntax-object and datum
                                        conversions.
* stdlib syntax-case temporaries::      Generating lists of temporaries.
* stdlib syntax-case derived::          Derived forms and procedures.
* stdlib syntax-case violations::       Syntax violations.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case hygiene
@section Hygiene


Barendregt's @emph{hygiene condition} for the lambda calculus is an
informal notion that requires the free variables of an expression
@emph{N} that is to be substituted into another expression @emph{M} not
to be captured by bindings in @emph{M} when such capture is not
intended.

Kohlbecker, et al. propose a corresponding @emph{hygiene condition for
macro expansion} that applies in all situations where capturing is not
explicit: ``Generated identifiers that become binding instances in the
completely expanded program must only bind variables that are generated
at the same transcription step''.  In the terminology of this document,
the ``generated identifiers'' are those introduced by a transformer
rather than those present in the form passed to the transformer, and a
``macro transcription step'' corresponds to a single call by the
expander to a transformer.  Also, the hygiene condition applies to all
introduced bindings rather than to introduced variable bindings alone.

This leaves open what happens to an introduced identifier that appears
outside the scope of a binding introduced by the same call.  Such an
identifier refers to the lexical binding in effect where it appears
(within a @code{syntax} @hyper{template}) inside the transformer body or
one of the helpers it calls.  This is essentially the referential
transparency property described by Clinger and Rees.  Thus, the hygiene
condition can be restated as follows:

@quotation
A binding for an identifier introduced into the output of a transformer
call from the expander must capture only references to the identifier
introduced into the output of the same transformer call.

A reference to an identifier introduced into the output of a transformer
refers to the closest enclosing binding for the introduced identifier
or, if it appears outside of any enclosing binding for the introduced
identifier, the closest enclosing lexical binding where the identifier
appears (within a @code{syntax} @hyper{template}) inside the transformer
body or one of the helpers it calls.
@end quotation

Explicit captures are handled via @func{datum->syntax}.

Operationally, the expander can maintain hygiene with the help of
@emph{marks}.  Marks are applied selectively by the expander to the
output of each transformer it invokes, and substitutions are applied to
the portions of each binding form that are supposed to be within the
scope of the bound identifiers.  Marks are used to distinguish
like--named identifiers that are introduced at different times (either
present in the source or introduced into the output of a particular
transformer call), and substitutions are used to map identifiers to
their expand-time values.

Each time the expander encounters a macro use, it applies an
@emph{antimark} to the input form, invokes the associated transformer,
then applies a fresh mark to the output.  Marks and antimarks cancel, so
the portions of the input that appear in the output are effectively left
unmarked, while the portions of the output that are introduced are
marked with the fresh mark.

Each time the expander encounters a binding form it creates a set of
substitutions, each mapping one of the (possibly marked) bound
identifiers to information about the binding.  (For a @func{lambda}
expression, the expander might map each bound identifier to a
representation of the formal parameter in the output of the expander.
For a @func{let-syntax} form, the expander might map each bound
identifier to the associated transformer.)  These substitutions are
applied to the portions of the input form in which the binding is
supposed to be visible.

Marks and substitutions together form a @emph{wrap} that is layered on
the form being processed by the expander and pushed down toward the
leaves as necessary.  A wrapped form is referred to as a @emph{wrapped
syntax object}.  Ultimately, the wrap may rest on a leaf that represents
an identifier, in which case the wrapped syntax object is also referred
to as an @emph{identifier}.  An identifier contains a name along with
the wrap.  (Names are typically represented by symbols.)

When a substitution is created to map an identifier to an expand--time
value, the substitution records the name of the identifier and the set
of marks that have been applied to that identifier, along with the
associated expand--time value.  The expander resolves identifier
references by looking for the latest matching substitution to be applied
to the identifier, i.e., the outermost substitution in the wrap whose
name and marks match the name and marks recorded in the substitution.
The name matches if it is the same name (if using symbols, then by
@func{eq?}), and the marks match if the marks recorded with the
substitution are the same as those that appear @emph{below} the
substitution in the wrap, i.e., those that were applied @emph{before}
the substitution.  Marks applied after a substitution, i.e., appear over
the substitution in the wrap, are not relevant and are ignored.

An algebra that defines how marks and substitutions work more precisely
is given in section 2.4 of Oscar Waddell's PhD thesis.


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case objects
@section Syntax objects


A @emph{syntax object} is a representation of a Scheme form that
contains contextual information about the form in addition to its
structure.  This contextual information is used by the expander to
maintain lexical scoping and may also be used by an implementation to
maintain source--object correlation.

A syntax object may be wrapped.  It may also be unwrapped, fully or
partially, i.e., consist of list and vector structure with wrapped
syntax objects or nonsymbol values at the leaves.  More formally, a
syntax object is:

@itemize
@item
a pair of syntax objects,

@item
a vector of syntax objects,

@item
a nonpair, nonvector, nonsymbol value, or

@item
a wrapped syntax object.
@end itemize

The distinction between the terms ``syntax object'' and ``wrapped syntax
object'' is important.  For example, when invoked by the expander, a
transformer must accept a wrapped syntax object but may return any
syntax object, including an unwrapped syntax object.

Syntax objects representing identifiers are always wrapped and are
distinct from other types of values.  Wrapped syntax objects that are
not identifiers may or may not be distinct from other types of values.


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case transformers
@section Transformers


In @func{define-syntax}, @func{let-syntax}, and @func{letrec-syntax}
forms, a binding for a syntactic keyword is an expression that evaluates
to a @emph{transformer}.

A transformer is a @emph{transformation procedure} or a @emph{variable
transformer}.  A transformation procedure is a procedure that must
accept one argument, a wrapped syntax object representing the input, and
return a syntax object representing the output.  The transformer is
called by the expander whenever a reference to a keyword with which it
has been associated is found.  If the keyword appears in the car of a
list--structured input form, the transformer receives the entire
list--structured form, and its output replaces the entire form.  Except
with variable transformers (see below), if the keyword is found in any
other definition or expression context, the transformer receives a
wrapped syntax object representing just the keyword reference, and its
output replaces just the reference.  Except with variable transformers,
an exception with condition type @code{&syntax} is raised if the keyword
appears on the left--hand side of a @func{set!} expression.


@deffn Procedure make-variable-transformer @var{proc}
@var{proc} should accept one argument, a wrapped syntax object, and
return a syntax object.

The @func{make-variable-transformer} procedure creates a @emph{variable
transformer}.  A variable transformer is like an ordinary transformer
except that, if a keyword associated with a variable transformer appears
on the left--hand side of a @func{set!} expression, an exception is not
raised.  Instead, @var{proc} is called with a wrapped syntax object
representing the entire @func{set!} expression as its argument, and its
return value replaces the entire @func{set!}  expression.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} only to the extent performed by applying
it as described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case parsing
@section Parsing input and producing output


Transformers can destructure their input with @func{syntax-case} and
rebuild their output with @code{syntax}.


@deffn Syntax syntax-case @hyper{expression} (@hyper{literal} @dots{}) @hyper{syntax-case clause} @dots{}
@deffnx {Auxiliary Syntax} _
@deffnx {Auxiliary Syntax} {...}
Each @hyper{literal} must be an identifier.  Each @hyper{syntax-case
clause} must take one of the following two forms.

@example
(@hyper{pattern} @hyper{output expression})
(@hyper{pattern} @hyper{fender} @hyper{output expression})
@end example

@hyper{fender} and @hyper{output expression} must be
@hyper{expression}s.

A @hyper{pattern} is an identifier, constant, or one of the following.

@example
(@hyper{pattern} @dots{})
(@hyper{pattern} @hyper{pattern} @dots{} . @hyper{pattern})
(@hyper{pattern} @dots{} @hyper{pattern} @hyper{ellipsis} @hyper{pattern} @dots{})
(@hyper{pattern} @dots{} @hyper{pattern} @hyper{ellipsis} @hyper{pattern} @dots{} . @hyper{pattern})
#(@hyper{pattern} @dots{})
#(@hyper{pattern} @dots{} @hyper{pattern} @hyper{ellipsis} @hyper{pattern} @dots{})
@end example

An @hyper{ellipsis} is the identifier ``@code{...}'' (three periods).

An identifier appearing within a @hyper{pattern} may be an underscore
(@code{_}), a literal identifier listed in the list of literals
@code{(@hyper{literal} @dots{})}, or an ellipsis (@code{...}).  All
other identifiers appearing within a @hyper{pattern} are @emph{pattern
variables}.  It is a syntax violation if an ellipsis or underscore
appears in @code{(@hyper{literal} @dots{})}.

@code{_} and @code{...} are the same as in the @rsixlibrary{base}
library.

Pattern variables match arbitrary input subforms and are used to refer
to elements of the input.  It is a syntax violation if the same pattern
variable appears more than once in a @hyper{pattern}.

Underscores also match arbitrary input subforms but are not pattern
variables and so cannot be used to refer to those elements.  Multiple
underscores may appear in a @hyper{pattern}.

A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.

A subpattern followed by an ellipsis can match zero or more elements of
the input.

More formally, an input form @emph{F} matches a pattern @emph{P} if and
only if one of the following holds:

@itemize
@item
@emph{P} is an underscore (@code{_}).

@item
@emph{P} is a pattern variable.

@item
@emph{P} is a literal identifier and @emph{F} is an equivalent
identifier in the sense of @func{free-identifier=?}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_n)
@end example

@noindent
and @emph{F} is a list of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_n . P_x)
@end example

@noindent
and @emph{F} is a list or improper list of @emph{n} or more elements
whose first @emph{n} elements match @emph{P_1} through @emph{P_n} and
whose @emph{n}th cdr matches @emph{P_x}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_k P_e @hyper{ellipsis} P_(m+1) ... P_n)
@end example

@noindent
where @hyper{ellipsis} is the identifier @code{...}  and @emph{F} is a
proper list of @emph{n} elements whose first @emph{k} elements match
@emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_k P_e @hyper{ellipsis} P_(m+1) ... P_n . P_x)
@end example

@noindent
where @hyper{ellipsis} is the identifier @code{...}  and @emph{F} is a
list or improper list of @emph{n} elements whose first @emph{k} elements
match @emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each
match @emph{P_e}, whose next @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}, and whose @emph{n}th and final cdr matches
@emph{P_x}.

@item
@emph{P} is of the form:

@example
#(P_1 ... P_n)
@end example

@noindent
and @emph{F} is a vector of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
#(P_1 ... P_k P_e @hyper{ellipsis} P_(m+1) ... P_n)
@end example

@noindent
where @hyper{ellipsis} is the identifier @code{...}  and @emph{F} is a
vector of @emph{n} or more elements whose first @emph{k} elements match
@emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item
@emph{P} is a pattern datum (any nonlist, nonvector, nonsymbol datum)
and @emph{F} is equal to @emph{P} in the sense of the @func{equal?}
procedure.
@end itemize

A @func{syntax-case} expression first evaluates @hyper{expression}.  It
then attempts to match the @hyper{pattern} from the first
@hyper{syntax-case clause} against the resulting value, which is
unwrapped as necessary to perform the match.  If the pattern matches the
value and no @hyper{fender} is present, @hyper{output expression} is
evaluated and its value returned as the value of the @func{syntax-case}
expression.  If the pattern does not match the value, @func{syntax-case}
tries the second @hyper{syntax-case clause}, then the third, and so on.
It is a syntax violation if the value does not match any of the
patterns.

If the optional @hyper{fender} is present, it serves as an additional
constraint on acceptance of a clause.  If the @hyper{pattern} of a given
@hyper{syntax-case clause} matches the input value, the corresponding
@hyper{fender} is evaluated.  If @hyper{fender} evaluates to a true
value, the clause is accepted; otherwise, the clause is rejected as if
the pattern had failed to match the value.  Fenders are logically a part
of the matching process, i.e., they specify additional matching
constraints beyond the basic structure of the input.

Pattern variables contained within a clause's @hyper{pattern} are bound
to the corresponding pieces of the input value within the clause's
@hyper{fender} (if present) and @hyper{output expression}.  Pattern
variables can be referenced only within @code{syntax} expressions (see
below).  Pattern variables occupy the same name space as program
variables and keywords.

If the @func{syntax-case} form is in tail context, the @hyper{output
expression}s are also in tail position.
@end deffn


@deffn Syntax syntax @hyper{template}

@quotation
@emph{Note:} @code{#'@hyper{template}} is equivalent to @code{(syntax
@hyper{template})}.
@end quotation

A @func{syntax} expression is similar to a @func{quote} expression
except that:

@enumerate
@item
the values of pattern variables appearing within @hyper{template} are
inserted into @hyper{template},

@item
contextual information associated both with the input and with the
template is retained in the output to support lexical scoping, and

@item
the value of a @func{syntax} expression is a syntax object.
@end enumerate

A @hyper{template} is a pattern variable, an identifier that is not a
pattern variable, a pattern datum, or one of the following.

@example
(@hyper{subtemplate} @dots{})
(@hyper{subtemplate} @dots{} . @hyper{template})
#(@hyper{subtemplate} @dots{})
@end example

A @hyper{subtemplate} is a @hyper{template} followed by zero or more
ellipses.

The value of a @code{syntax} form is a copy of @hyper{template} in which
the pattern variables appearing within the template are replaced with
the input subforms to which they are bound.  Pattern data and
identifiers that are not pattern variables or ellipses are copied
directly into the output.  A subtemplate followed by an ellipsis expands
into zero or more occurrences of the subtemplate.  Pattern variables
that occur in subpatterns followed by one or more ellipses may occur
only in subtemplates that are followed by (at least) as many ellipses.
These pattern variables are replaced in the output by the input subforms
to which they are bound, distributed as specified.  If a pattern
variable is followed by more ellipses in the subtemplate than in the
associated subpattern, the input form is replicated as necessary.  The
subtemplate must contain at least one pattern variable from a subpattern
followed by an ellipsis, and for at least one such pattern variable, the
subtemplate must be followed by exactly as many ellipses as the
subpattern in which the pattern variable appears.  (Otherwise, the
expander would not be able to determine how many times the subform
should be repeated in the output.)  It is a syntax violation if the
constraints of this paragraph are not met.

A template of the form @code{(@hyper{ellipsis} @hyper{template})} is
identical to @hyper{template}, except that ellipses within the template
have no special meaning.  That is, any ellipses contained within
@hyper{template} are treated as ordinary identifiers.  In particular,
the template @code{(... ...)} produces a single ellipsis.  This allows
macro uses to expand into forms containing ellipses.

The output produced by @func{syntax} is wrapped or unwrapped according
to the following rules.

@itemize
@item
the copy of @code{(@hyperi{t} .  @hyperii{t})} is a pair if @hyperi{t}
or @hyperii{t} contain any pattern variables,

@item
the copy of @code{(@hyper{t} @hyper{ellipsis})} is a list if @hyper{t}
contains any pattern variables,

@item
the copy of @code{#(@hyperi{t} ... @hypern{t})} is a vector if any of
@hyperi{t}, @dots{}, @hypern{t} contain any pattern variables, and

@item
the copy of any portion of @hyper{t} not containing any pattern
variables is a wrapped syntax object.
@end itemize

The input subforms inserted in place of the pattern variables are
wrapped if and only if the corresponding input subforms are wrapped.
@end deffn


The following definitions of @func{or} illustrate @func{syntax-case} and
@func{syntax}.  The second is equivalent to the first but uses the
@code{#'} prefix instead of the full @func{syntax} form.

@example
(define-syntax or
  (lambda (x)
    (syntax-case x ()
      [(_) (syntax #f)]
      [(_ e) (syntax e)]
      [(_ e1 e2 e3 ...)
       (syntax (let ([t e1])
                 (if t t (or e2 e3 ...))))])))

(define-syntax or
  (lambda (x)
    (syntax-case x ()
      [(_) #'#f]
      [(_ e) #'e]
      [(_ e1 e2 e3 ...)
       #'(let ([t e1])
           (if t t (or e2 e3 ...)))])))
@end example

The examples below define @emph{identifier macros}, macro uses
supporting keyword references that do not necessarily appear in the
first position of a list--structured form.  The second example uses
@func{make-variable-transformer} to handle the case where the keyword
appears on the left-hand side of a @func{set!}  expression.

@example
(define p (cons 4 5))
(define-syntax p.car
  (lambda (x)
    (syntax-case x ()
      [(_ . rest) #'((car p) . rest)]
      [_  #'(car p)])))

p.car                                   => 4
(set! p.car 15)                         => exception &syntax

(define p (cons 4 5))
(define-syntax p.car
  (make-variable-transformer
    (lambda (x)
      (syntax-case x (set!)
        [(set! _ e) #'(set-car! p e)]
        [(_ . rest) #'((car p) . rest)]
        [_  #'(car p)]))))
(set! p.car 15)

p.car                                   => 15
p                                       => (15 . 5)
@end example


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case identifier
@section Identifier predicates


@deffn Procedure {identifier?} @var{obj}
Return @true{} if @var{obj} is an identifier, i.e., a syntax object
representing an identifier, and @false{} otherwise.

The @func{identifier?} procedure is often used within a fender to verify
that certain subforms of an input form are identifiers, as in the
definition of @code{rec}, which creates self--contained recursive
objects, below.

@example
(define-syntax rec
  (lambda (x)
    (syntax-case x ()
      [(_ x e)
       (identifier? #'x)
       #'(letrec ([x e]) x)])))

(map (rec fact
       (lambda (n)
         (if (= n 0)
             1
             (* n (fact (- n 1))))))
     '(1 2 3 4 5))    => (1 2 6 24 120)

(rec 5 (lambda (x) x)) => exception &syntax
@end example
@end deffn


The procedures @func{bound-identifier=?} and @func{free-identifier=?}
each take two identifier arguments and return @true{} if their arguments
are equivalent and @false{} otherwise.  These predicates are used to
compare identifiers according to their @emph{intended use} as free
references or bound identifiers in a given context.


@deffn Procedure {bound-identifier=?} @vari{id} @varii{id}
@vari{id} and @varii{id} must be identifiers.

The procedure @func{bound-identifier=?} returns @true{} if a binding for
one would capture a reference to the other in the output of the
transformer, assuming that the reference appears within the scope of the
binding, and @false{} otherwise.

In general, two identifiers are @func{bound-identifier=?} only if both
are present in the original program or both are introduced by the same
transformer application (perhaps implicitly, see @func{datum->syntax}).

Operationally, two identifiers are considered equivalent by
@func{bound-identifier=?} if and only if they have the same name and
same marks.

The @func{bound-identifier=?} procedure can be used for detecting
duplicate identifiers in a binding construct or for other preprocessing
of a binding construct that requires detecting instances of the bound
identifiers.
@end deffn


@deffn Procedure {free-identifier=?} @vari{id} @varii{id}
@vari{id} and @varii{id} must be identifiers.

The @func{free-identifier=?} procedure returns @true{} if and only if
the two identifiers would resolve to the same binding if both were to
appear in the output of a transformer outside of any bindings inserted
by the transformer.  (If neither of two like--named identifiers resolves
to a binding, i.e., both are unbound, they are considered to resolve to
the same binding.)

Operationally, two identifiers are considered equivalent by
@func{free-identifier=?} if and only the topmost matching substitution
for each maps to the same binding or the identifiers have the same name
and no matching substitution.

The @func{syntax-case} and @func{syntax-rules} forms internally use
@func{free-identifier=?} to compare identifiers listed in the literals
list against input identifiers.

@example
(let ([fred 17])
  (define-syntax a
    (lambda (x)
      (syntax-case x ()
        [(_ id) #'(b id fred)])))
  (define-syntax b
    (lambda (x)
      (syntax-case x ()
        [(_ id1 id2)
         #`(list
             #,(free-identifier=? #'id1 #'id2)
             #,(bound-identifier=? #'id1 #'id2))])))
  (a fred))
=> (#t #f)
@end example

The following definition of unnamed @func{let} uses
@func{bound-identifier=?} to detect duplicate identifiers.

@example
(define-syntax let
  (lambda (x)
    (define unique-ids?
      (lambda (ls)
        (or (null? ls)
            (and (let notmem?
                        ([x (car ls)] [ls (cdr ls)])
                   (or (null? ls)
                       (and (not (bound-identifier=?
                                   x (car ls)))
                            (notmem? x (cdr ls)))))
                 (unique-ids? (cdr ls))))))
    (syntax-case x ()
      [(_ ((i v) ...) e1 e2 ...)
       (unique-ids? #'(i ...))
       #'((lambda (i ...) e1 e2 ...) v ...)])))
@end example

The argument @code{#'(i ...)} to @func{unique-ids?} is guaranteed to be
a list by the rules given in the description of @func{syntax} above.

With this definition of @func{let}:

@example
(let ([a 3] [a 4]) (+ a a))    => exception &syntax
@end example

However,

@example
(let-syntax
  ([dolet (lambda (x)
            (syntax-case x ()
              [(_ b)
               #'(let ([a 3] [b 4]) (+ a b))]))])
  (dolet a))
=> 7
@end example

@noindent
since the identifier @code{a} introduced by @func{dolet} and the
identifier @code{a} extracted from the input form are not
@func{bound-identifier=?}.

Rather than including @code{else} in the literals list as before, this
version of @func{case} explicitly tests for @code{else} using
@func{free-identifier=?}.

@example
(define-syntax case
  (lambda (x)
    (syntax-case x ()
      [(_ e0 [(k ...) e1 e2 ...] ...
              [else-key else-e1 else-e2 ...])
       (and (identifier? #'else-key)
            (free-identifier=? #'else-key #'else))
       #'(let ([t e0])
           (cond
             [(memv t '(k ...)) e1 e2 ...]
             ...
             [else else-e1 else-e2 ...]))]
      [(_ e0 [(ka ...) e1a e2a ...]
              [(kb ...) e1b e2b ...] ...)
       #'(let ([t e0])
           (cond
             [(memv t '(ka ...)) e1a e2a ...]
             [(memv t '(kb ...)) e1b e2b ...]
             ...))])))
@end example

With either definition of @func{case}, @code{else} is not recognized as
an auxiliary keyword if an enclosing lexical binding for @code{else}
exists.  For example,

@example
(let ([else @false{}])
  (case 0 [else (write "oops")]))    => exception &syntax
@end example

@noindent
since @code{else} is bound lexically and is therefore not the same
@code{else} that appears in the definition of @func{case}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case conversion
@section Syntax--object and datum conversions


@deffn Procedure {syntax->datum} @var{syntax-object}
Strip all syntactic information from a syntax object and returns the
corresponding Scheme datum.

Identifiers stripped in this manner are converted to their symbolic
names, which can then be compared with @func{eq?}.  Thus, a predicate
@code{symbolic-identifier=?} might be defined as follows.

@example
(define symbolic-identifier=?
  (lambda (x y)
    (eq? (syntax->datum x)
         (syntax->datum y))))
@end example
@end deffn


@deffn Procedure {datum->syntax} @var{template-id} @var{datum}
@var{template-id} must be a template identifier and @var{datum} should
be a datum value.

The @func{datum->syntax} procedure returns a syntax-object
representation of @var{datum} that contains the same contextual
information as @var{template-id}, with the effect that the syntax object
behaves as if it were introduced into the code when @var{template-id}
was introduced.

The @func{datum->syntax} procedure allows a transformer to ``bend''
lexical scoping rules by creating @emph{implicit identifiers} that
behave as if they were present in the input form, thus permitting the
definition of macros that introduce visible bindings for or references
to identifiers that do not appear explicitly in the input form.  For
example, the following defines a @func{loop} expression that uses this
controlled form of identifier capture to bind the variable @code{break}
to an escape procedure within the loop body.  (The derived
@func{with-syntax} form is like @func{let} but binds pattern variables.)

@example
(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(k e ...)
       (with-syntax
           ([break (datum->syntax #'k 'break)])
         #'(call-with-current-continuation
             (lambda (break)
               (let f () e ... (f)))))])))

(let ((n 3) (ls '()))
  (loop
    (if (= n 0) (break ls))
    (set! ls (cons 'a ls))
    (set! n (- n 1))))
=> (a a a)
@end example

Were @code{loop} to be defined as:

@example
(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(_ e ...)
       #'(call-with-current-continuation
           (lambda (break)
             (let f () e ... (f))))])))
@end example

@noindent
the variable @code{break} would not be visible in @code{e ...}.

The datum argument @var{datum} may also represent an arbitrary Scheme
form, as demonstrated by the following definition of @func{include}.

@example
(define-syntax include
  (lambda (x)
    (define read-file
      (lambda (fn k)
        (let ([p (open-file-input-port fn)])
          (let f ([x (get-datum p)])
            (if (eof-object? x)
                (begin (close-port p) '())
                (cons (datum->syntax k x)
                      (f (get-datum p))))))))
    (syntax-case x ()
      [(k filename)
       (let ([fn (syntax->datum #'filename)])
         (with-syntax ([(exp ...)
                        (read-file fn #'k)])
           #'(begin exp ...)))])))
@end example

@code{(include "filename")} expands into a @func{begin} expression
containing the forms found in the file named by @code{"filename"}.  For
example, if the file @file{flib.ss} contains:

@example
(define f (lambda (x) (g (* x x))))
@end example

@noindent
and the file @file{glib.ss} contains:

@example
(define g (lambda (x) (+ x x)))
@end example

@noindent
the expression:

@example
(let ()
  (include "flib.ss")
  (include "glib.ss")
  (f 5))
@end example

@noindent
evaluates to @code{50}.

The definition of @func{include} uses @func{datum->syntax} to convert
the objects read from the file into syntax objects in the proper lexical
context, so that identifier references and definitions within those
expressions are scoped where the @func{include} form appears.

Using @func{datum->syntax}, it is even possible to break hygiene
entirely and write macros in the style of old Lisp macros.  The
@func{lisp-transformer} procedure defined below creates a transformer
that converts its input into a datum, calls the programmer's procedure
on this datum, and converts the result back into a syntax object scoped
where the original macro use appeared.

@example
(define lisp-transformer
  (lambda (p)
    (lambda (x)
      (syntax-case x ()
        [(kwd . rest)
         (datum->syntax #'kwd
           (p (syntax->datum x)))]))))
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case temporaries
@section Generating lists of temporaries


Transformers can introduce a fixed number of identifiers into their
output simply by naming each identifier.  In some cases, however, the
number of identifiers to be introduced depends upon some characteristic
of the input expression.  A straightforward definition of @func{letrec},
for example, requires as many temporary identifiers as there are binding
pairs in the input expression.  The procedure
@func{generate-temporaries} is used to construct lists of temporary
identifiers.


@deffn Procedure generate-temporaries @var{l}
@var{l} must be be a list or syntax object representing a
list--structured form; its contents are not important.

The number of temporaries generated is the number of elements in
@var{l}.  Each temporary is guaranteed to be unique, i.e., different
from all other identifiers.

A definition of @func{letrec} equivalent to the one using
@func{syntax-rules} given in report appendix @rsixref{derived,Sample
definitions for derived forms} is shown below.

@example
(define-syntax letrec
  (lambda (x)
    (syntax-case x ()
      ((_ ((i e) ...) b1 b2 ...)
       (with-syntax
           (((t ...) (generate-temporaries #'(i ...))))
         #'(let ((i <undefined>) ...)
             (let ((t e) ...)
               (set! i t) ...
               (let () b1 b2 ...))))))))
@end example

This version uses @func{generate-temporaries} instead of recursively
defined helper to generate the necessary temporaries.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case derived
@section Derived forms and procedures


The forms and procedures described in this section can be defined in
terms of the forms and procedures described in earlier sections of this
chapter.


@deffn Syntax with-syntax ((@hyper{pattern} @hyper{expression}) @dots{}) @hyper{body}
The @func{with-syntax} form is used to bind pattern variables, just as
@func{let} is used to bind variables.  This allows a transformer to
construct its output in separate pieces, then put the pieces together.

Each @hyper{pattern} is identical in form to a @func{syntax-case}
pattern.  The value of each @hyper{expression} is computed and
destructured according to the corresponding @hyper{pattern}, and pattern
variables within the @hyper{pattern} are bound as with
@func{syntax-case} to the corresponding portions of the value within
@hyper{body}.

The @func{with-syntax} form may be defined in terms of
@func{syntax-case} as follows.

@example
(define-syntax with-syntax
  (lambda (x)
    (syntax-case x ()
      ((_ ((p e0) ...) e1 e2 ...)
       (syntax (syntax-case (list e0 ...) ()
                 ((p ...) (let () e1 e2 ...))))))))
@end example

The following definition of @func{cond} demonstrates the use of
@func{with-syntax} to support transformers that employ recursion
internally to construct their output.  It handles all @func{cond} clause
variations and takes care to produce one-armed @func{if} expressions
where appropriate.

@example
(define-syntax cond
  (lambda (x)
    (syntax-case x ()
      [(_ c1 c2 ...)
       (let f ([c1 #'c1] [c2* #'(c2 ...)])
         (syntax-case c2* ()
           [()
            (syntax-case c1 (else =>)
              [(else e1 e2 ...) #'(begin e1 e2 ...)]
              [(e0) #'e0]
              [(e0 => e1)
               #'(let ([t e0]) (if t (e1 t)))]
              [(e0 e1 e2 ...)
               #'(if e0 (begin e1 e2 ...))])]
           [(c2 c3 ...)
            (with-syntax ([rest (f #'c2 #'(c3 ...))])
              (syntax-case c1 (=>)
                [(e0) #'(let ([t e0]) (if t t rest))]
                [(e0 => e1)
                 #'(let ([t e0]) (if t (e1 t) rest))]
                [(e0 e1 e2 ...)
                 #'(if e0
                        (begin e1 e2 ...)
                        rest)]))]))])))
@end example
@end deffn


@deffn Syntax quasisyntax @hyper{template}
@deffnx {Auxiliary Syntax} unsyntax
@deffnx {Auxiliary Syntax} unsyntax-splicing
The @func{quasisyntax} form is similar to @func{syntax}, but it allows
parts of the quoted text to be evaluated, in a manner similar to the
operation of @func{quasiquote} (report section @rsixref{base
quasiquotation,Quasiquotation}).

Within a @func{quasisyntax} @var{template}, subforms of @func{unsyntax}
and @func{unsyntax-splicing} forms are evaluated, and everything else is
treated as ordinary template material, as with @func{syntax}.

The value of each @func{unsyntax} subform is inserted into the output in
place of the @func{unsyntax} form, while the value of each
@func{unsyntax-splicing} subform is spliced into the surrounding list or
vector structure.  Uses of @func{unsyntax} and @func{unsyntax-splicing}
are valid only within @func{quasisyntax} expressions.

A @func{quasisyntax} expression may be nested, with each
@func{quasisyntax} introducing a new level of syntax quotation and each
@func{unsyntax} or @func{unsyntax-splicing} taking away a level of
quotation.  An expression nested within @emph{n} @func{quasisyntax}
expressions must be within @emph{n} @emph{unsyntax} or
@func{unsyntax-splicing} expressions to be evaluated.

As noted in report section @rsixref{lex datum
abbreviations,Abbreviations}, @code{#`@hyper{template}} is equivalent to
@code{(quasisyntax @hyper{template})}, @code{#,@hyper{template}} is
equivalent to @code{(unsyntax @hyper{template})}, and
@code{#,@@@hyper{template}} is equivalent to @code{(unsyntax-splicing
@hyper{template})}.

The @func{quasisyntax} keyword can be used in place of
@func{with-syntax} in many cases.  For example, the definition of
@func{case} shown under the description of @func{with-syntax} above can
be rewritten using @func{quasisyntax} as follows.

@example
(define-syntax case
  (lambda (x)
    (syntax-case x ()
      [(_ e c1 c2 ...)
       #`(let ([t e])
           #,(let f ([c1 #'c1] [cmore #'(c2 ...)])
               (if (null? cmore)
                   (syntax-case c1 (else)
                     [(else e1 e2 ...)
                      #'(begin e1 e2 ...)]
                     [((k ...) e1 e2 ...)
                      #'(if (memv t '(k ...))
                            (begin e1 e2 ...))])
                   (syntax-case c1 ()
                     [((k ...) e1 e2 ...)
                      #`(if (memv t '(k ...))
                            (begin e1 e2 ...)
                            #,(f (car cmore)
                                  (cdr cmore)))]))))])))
@end example

Uses of @func{unsyntax} and @func{unsyntax-splicing} with zero or more
than one subform are valid only in splicing (list or vector) contexts.
@code{(unsyntax @var{template} @dots{})} is equivalent to
@code{(unsyntax @var{template}) ...}, and @code{(unsyntax-splicing
@var{template} ...)} is equivalent to @code{(unsyntax-splicing
@var{template}) ...}.  These forms are primarily useful as intermediate
forms in the output of the @func{quasisyntax} expander.

@quotation
@emph{Note:} Uses of @func{unsyntax} and @func{unsyntax-splicing} with
zero or more than one subform enable certain idioms, such as
@code{#,@@#,@@}, which has the effect of a doubly indirect splicing when
used within a doubly nested and doubly evaluated @func{quasisyntax}
expression, as with the nested @func{quasiquote} examples shown in
section @rsixref{base quasiquotation,Quasiquotation}.
@end quotation
@end deffn

@quotation
@emph{Note:} Any @func{syntax-rules} form can be expressed with
@func{syntax-case} by making the @func{lambda} expression and
@func{syntax} expressions explicit, and @func{syntax-rules} may be
defined in terms of @func{syntax-case} as follows.

@example
(define-syntax syntax-rules
  (lambda (x)
    (syntax-case x ()
      [(_ (lit ...) [(k . p) t] ...)
       (for-all identifier? #'(lit ... k ...))
       #'(lambda (x)
           (syntax-case x (lit ...)
             [(_ . p) #'t] ...))])))
@end example
@end quotation

@quotation
@emph{Note:} The @func{identifier-syntax} form of the base library (see
report section @rsixref{base transformers,Macro transformers}) may be
defined in terms of @func{syntax-case}, @func{syntax}, and
@func{make-variable-transformer} as follows.

@example
(define-syntax identifier-syntax
  (syntax-rules (set!)
    [(_ e)
     (lambda (x)
       (syntax-case x ()
         [id (identifier? #'id) #'e]
         [(_ x (... ...)) #'(e x (... ...))]))]
    [(_ (id exp1) ((set! var val) exp2))
     (and (identifier? #'id) (identifier? #'var))
     (make-variable-transformer
       (lambda (x)
         (syntax-case x (set!)
           [(set! var val) #'exp2]
           [(id x (... ...)) #'(exp1 x (... ...))]
           [id (identifier? #'id) #'exp1])))]))
@end example
@end quotation


@c ------------------------------------------------------------

@c page
@node stdlib syntax-case violations
@section Syntax violations


@deffn Procedure syntax-violation @var{who message form}
@deffnx Procedure syntax-violation @var{who message form subform}
@var{who} must be @false{} or a string or a symbol.  @var{message} must
be a string.  @var{form} must be a syntax object or a datum value.
@var{subform} must be a syntax object or a datum value.

The @func{syntax-violation} procedure raises an exception, reporting a
syntax violation.  @var{who} should describe the macro transformer that
detected the exception.  The @var{message} argument should describe the
violation.  @var{form} should be the erroneous source syntax object or a
datum value representing a form. The optional @var{subform} argument
should be a syntax object or datum value representing a form that more
precisely locates the violation.

If @var{who} is @false{}, @func{syntax-violation} attempts to infer an
appropriate value for the condition object (see below) as follows: When
@var{form} is either an identifier or a list-structured syntax object
containing an identifier as its first element, then the inferred value
is the identifier's symbol.  Otherwise, no value for @var{who} is
provided as part of the condition object.

The condition object provided with the exception has the following
condition types:

@itemize
@item
If @var{who} is not @false{} or can be inferred, the condition has
condition type @code{&who}, with @var{who} as the value of its field.
In that case, @var{who} should identify the procedure or entity that
detected the exception.  If it is @false{}, the condition does not have
condition type @code{&who}.

@item
The condition has condition type @code{&message}, with @var{message} as
the value of its field.

@item
The condition has condition type @code{&syntax} with @var{form} and
@var{subform} as the value of its fields.  If @var{subform} is not
provided, the value of the subform field is @false{}.
@end itemize
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib hashtable
@chapter Hashtables


The @rsixlibrary{hashtables} library provides a set of operations on
hashtables.

A @emph{hashtable} is a data structure that associates keys with values.
Any object can be used as a key, provided a @emph{hash function} and a
suitable @emph{equivalence function} is available.

A hash function is a procedure that maps keys to exact integer objects.
It is the programmer's responsibility to ensure that the hash function
is compatible with the equivalence function, which is a procedure that
accepts two keys and returns true if they are equivalent and @false{}
otherwise.

Standard hashtables for arbitrary objects based on the @func{eq?} and
@func{eqv?} predicates (see report section @rsixref{base
predicates,Equivalence predicates}) are provided.  Also, hash functions
for arbitrary objects, strings, and symbols are provided.

This section uses the @var{hashtable} parameter name for arguments that
must be hashtables, and the @var{key} parameter name for arguments that
must be hashtable keys.


@menu
* stdlib hashtable constructors::       Constructors.
* stdlib hashtable procedures::         Procedures.
* stdlib hashtable inspection::         Inspection.
* stdlib hashtable hash functions::     Hash functions.
@end menu


@c ------------------------------------------------------------

@c page
@node stdlib hashtable constructors
@section Constructors


@deffn Procedure make-eq-hashtable
@deffnx Procedure make-eq-hashtable @var{k}
Return a newly allocated mutable hashtable that accepts arbitrary
objects as keys, and compares those keys with @func{eq?}.  If an
argument is given, the initial capacity of the hashtable is set to
approximately @var{k} elements.
@end deffn


@deffn Procedure make-eqv-hashtable
@deffnx Procedure make-eqv-hashtable @var{k}
Return a newly allocated mutable hashtable that accepts arbitrary
objects as keys, and compares those keys with @func{eqv?}.  If an
argument is given, the initial capacity of the hashtable is set to
approximately @var{k} elements.
@end deffn


@deffn Procedure make-hashtable @var{hash-function} @var{equiv}
@deffnx Procedure make-hashtable @var{hash-function} @var{equiv} @var{k}
@var{hash-function} and @var{equiv} must be procedures.
@var{hash-function} should accept a key as an argument and should return
a non--negative exact integer object.  @var{equiv} should accept two
keys as arguments and return a single value.  Neither procedure should
mutate the hashtable returned by @func{make-hashtable}.

The @func{make-hashtable} procedure returns a newly allocated mutable
hashtable using @var{hash-function} as the hash function and @var{equiv}
as the equivalence function used to compare keys.  If a third argument
is given, the initial capacity of the hashtable is set to approximately
@var{k} elements.

Both @var{hash-function} and @var{equiv} should behave like pure
functions on the domain of keys.  For example, the @func{string-hash}
and @func{string=?} procedures are permissible only if all keys are
strings and the contents of those strings are never changed so long as
any of them continues to serve as a key in the hashtable.  Furthermore,
any pair of keys for which @var{equiv} returns true should be hashed to
the same exact integer objects by @var{hash-function}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{hash-function} and @var{equiv} to the extent
performed by applying them as described.

@quotation
@emph{Note:} Hashtables are allowed to cache the results of calling the
hash function and equivalence function, so programs cannot rely on the
hash function being called for every lookup or update.  Furthermore any
hashtable operation may call the hash function more than once.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib hashtable procedures
@section Procedures


@deffn Procedure {hashtable?} @var{obj}
Return @true{} if @var{obj} is a hashtable, @false{} otherwise.
@end deffn


@deffn Procedure hashtable-size @var{hashtable}
Return the number of keys contained in @var{hashtable} as an exact
integer object.
@end deffn


@deffn Procedure hashtable-ref @var{hashtable} @var{key} @var{default}
Return the value in @var{hashtable} associated with @var{key}.  If
@var{hashtable} does not contain an association for @var{key},
@var{default} is returned.
@end deffn


@deffn Procedure {hashtable-set!} @var{hashtable} @var{key} @var{obj}
Change @var{hashtable} to associate @var{key} with @var{obj}, adding a
new association or replacing any existing association for @var{key}, and
returns unspecified values.
@end deffn


@deffn Procedure {hashtable-delete!} @var{hashtable} @var{key}
Remove any association for @var{key} within @var{hashtable} and returns
unspecified values.
@end deffn


@deffn Procedure {hashtable-contains?} @var{hashtable} @var{key}
Return @true{} if @var{hashtable} contains an association for @var{key},
@false{} otherwise.
@end deffn


@deffn Procedure {hashtable-update!} @var{hashtable} @var{key} @var{proc} @var{default}
@var{proc} should accept one argument, should return a single value, and
should not mutate @var{hashtable}.

The @func{hashtable-update!} procedure applies @var{proc} to the value
in @var{hashtable} associated with @var{key}, or to @var{default} if
@var{hashtable} does not contain an association for @var{key}.  The
@var{hashtable} is then changed to associate @var{key} with the value
returned by @var{proc}.

The behavior of @func{hashtable-update!} is equivalent to the following
code, but may be implemented more efficiently in cases where the
implementation can avoid multiple lookups of the same key:

@example
(hashtable-set!
  hashtable key
  (proc (hashtable-ref
         hashtable key default)))
@end example
@end deffn


@deffn Procedure hashtable-copy @var{hashtable}
@deffnx Procedure hashtable-copy @var{hashtable} @var{mutable}
Return a copy of @var{hashtable}.  If the @var{mutable} argument is
provided and is true, the returned hashtable is mutable; otherwise it is
immutable.
@end deffn


@deffn Procedure {hashtable-clear!} @var{hashtable}
@deffnx Procedure {hashtable-clear!} @var{hashtable} @var{k}
Remove all associations from @var{hashtable} and returns unspecified
values.

If a second argument is given, the current capacity of the hashtable is
reset to approximately @var{k} elements.
@end deffn


@deffn Procedure hashtable-keys @var{hashtable}
Return a vector of all keys in @var{hashtable}.  The order of the vector
is unspecified.
@end deffn


@deffn Procedure hashtable-entries @var{hashtable}
Return two values, a vector of the keys in @var{hashtable}, and a vector
of the corresponding values.

Example:

@example
(let ((h (make-eqv-hashtable)))
  (hashtable-set! h 1 'one)
  (hashtable-set! h 2 'two)
  (hashtable-set! h 3 'three)
  (hashtable-entries h))
=> #(1 2 3) #(one two three) ; two return values
@end example

@noindent
the order of the entries in the result vectors is not known.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib hashtable inspection
@section Inspection


@deffn Procedure hashtable-equivalence-function @var{hashtable}
Return the equivalence function used by @var{hashtable} to compare keys.
For hashtables created with @func{make-eq-hashtable} and
@func{make-eqv-hashtable}, returns @func{eq?} and @func{eqv?}
respectively.
@end deffn


@deffn Procedure hashtable-hash-function @var{hashtable}
Return the hash function used by @var{hashtable}.  For hashtables
created by @func{make-eq-hashtable} or @func{make-eqv-hashtable},
@false{} is returned.
@end deffn


@deffn Procedure {hashtable-mutable?} @var{hashtable}
Return @true{} if @var{hashtable} is mutable, otherwise @false{}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib hashtable hash functions
@section Hash functions


The @func{equal-hash}, @func{string-hash}, and @func{string-ci-hash}
procedures of this section are acceptable as the hash functions of a
hashtable only if the keys on which they are called are not mutated
while they remain in use as keys in the hashtable.


@deffn Procedure equal-hash @var{obj}
Return an integer hash value for @var{obj}, based on its structure and
current contents.  This hash function is suitable for use with
@func{equal?} as an equivalence function.

@quotation
@emph{Note:} Like @func{equal?}, the @func{equal-hash} procedure must
always terminate, even if its arguments contain cycles.
@end quotation
@end deffn


@deffn Procedure string-hash @var{string}
Return an integer hash value for @var{string}, based on its current
contents.  This hash function is suitable for use with @func{string=?}
as an equivalence function.
@end deffn


@deffn Procedure string-ci-hash @var{string}
Return an integer hash value for @var{string} based on its current
contents, ignoring case.  This hash function is suitable for use with
@func{string-ci=?} as an equivalence function.
@end deffn


@deffn Procedure symbol-hash @var{symbol}
Return an integer hash value for @var{symbol}.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib enum
@chapter Enumerations


This chapter describes the @rsixlibrary{enums} library for dealing with
enumerated values and sets of enumerated values.  Enumerated values are
represented by ordinary symbols, while finite sets of enumerated values
form a separate type, known as the @emph{enumeration sets}.  The
enumeration sets are further partitioned into sets that share the same
@emph{universe} and @emph{enumeration type}.  These universes and
enumeration types are created by the @func{make-enumeration} procedure.
Each call to that procedure creates a new enumeration type.

This library interprets each enumeration set with respect to its
specific universe of symbols and enumeration type.  This facilitates
efficient implementation of enumeration sets and enables the complement
operation.

In the descriptions of the following procedures, @var{enum-set} ranges
over the enumeration sets, which are defined as the subsets of the
universes that can be defined using @func{make-enumeration}.


@deffn Procedure make-enumeration @var{symbol-list}
@var{symbol-list} must be a list of symbols.

The @func{make-enumeration} procedure creates a new enumeration type
whose universe consists of those symbols (in canonical order of their
first appearance in the list) and returns that universe as an
enumeration set whose universe is itself and whose enumeration type is
the newly created enumeration type.
@end deffn


@deffn Procedure enum-set-universe @var{enum-set}
Return the set of all symbols that comprise the universe of its
argument, as an enumeration set.
@end deffn


@deffn Procedure enum-set-indexer @var{enum-set}
Return a unary procedure that, given a symbol that is in the universe of
@var{enum-set}, returns its 0--origin index within the canonical
ordering of the symbols in the universe; given a symbol not in the
universe, the unary procedure returns @false{}.

@example
(let* ((e (make-enumeration '(red green blue)))
       (i (enum-set-indexer e)))
  (list (i 'red) (i 'green) (i 'blue) (i 'yellow)))
=> (0 1 2 #f)
@end example

The @func{enum-set-indexer} procedure could be defined as follows using
the @func{memq} procedure from the @rsixlibrary{lists} library:

@example
(define (enum-set-indexer set)
  (let* ((symbols (enum-set->list
                    (enum-set-universe set)))
         (cardinality (length symbols)))
    (lambda (x)
      (cond
       ((memq x symbols)
        => (lambda (probe)
             (- cardinality (length probe))))
       (else #f)))))
@end example
@end deffn


@deffn Procedure enum-set-constructor @var{enum-set}
Return a unary procedure that, given a list of symbols that belong to
the universe of @var{enum-set}, returns a subset of that universe that
contains exactly the symbols in the list.  The values in the list must
all belong to the universe.
@end deffn


@deffn Procedure enum-set->list @var{enum-set}
Return a list of the symbols that belong to its argument, in the
canonical order of the universe of @var{enum-set}.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list (c '(blue red))))    => (red blue)
@end example
@end deffn


@deffn Procedure {enum-set-member?} @var{symbol} @var{enum-set}
@deffnx Procedure {enum-set-subset?} @vari{enum-set} @varii{enum-set}
@deffnx Procedure {enum-set=?} @vari{enum-set} @varii{enum-set}
The @func{enum-set-member?} procedure returns @true{} if its first
argument is an element of its second argument, @false{} otherwise.

The @func{enum-set-subset?} procedure returns @true{} if the universe of
@vari{enum-set} is a subset of the universe of @varii{enum-set}
(considered as sets of symbols) and every element of @vari{enum-set} is
a member of @varii{enum-set}.  It returns @false{} otherwise.

The @func{enum-set=?} procedure returns @true{} if @vari{enum-set} is a
subset of @varii{enum-set} and vice versa, as determined by the
@func{enum-set-subset?} procedure.  This implies that the universes of
the two sets are equal as sets of symbols, but does not imply that they
are equal as enumeration types.  Otherwise, @false{} is returned.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list
   (enum-set-member? 'blue (c '(red blue)))
   (enum-set-member? 'green (c '(red blue)))
   (enum-set-subset? (c '(red blue)) e)
   (enum-set-subset? (c '(red blue)) (c '(blue red)))
   (enum-set-subset? (c '(red blue)) (c '(red)))
   (enum-set=? (c '(red blue)) (c '(blue red)))))
=> (#t #f #t #t #f #t)
@end example
@end deffn


@deffn Procedure enum-set-union @vari{enum-set} @varii{enum-set}
@deffnx Procedure enum-set-intersection @vari{enum-set} @varii{enum-set}
@deffnx Procedure enum-set-difference @vari{enum-set} @varii{enum-set}
@vari{enum-set} and @varii{enum-set} must be enumeration sets that have
the same enumeration type.

The @func{enum-set-union} procedure returns the union of @vari{enum-set}
and @varii{enum-set}.  The @func{enum-set-intersection} procedure
returns the intersection of @vari{enum-set} and @varii{enum-set}.  The
@func{enum-set-difference} procedure returns the difference of
@vari{enum-set} and @varii{enum-set}.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list (enum-set->list
         (enum-set-union (c '(blue)) (c '(red))))
        (enum-set->list
         (enum-set-intersection (c '(red green))
                                (c '(red blue))))
        (enum-set->list
         (enum-set-difference (c '(red green))
                              (c '(red blue))))))
=> ((red blue) (red) (green))
@end example
@end deffn


@deffn Procedure enum-set-complement @var{enum-set}
Return @var{enum-set}'s complement with respect to its universe.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list
    (enum-set-complement (c '(red)))))
=> (green blue)
@end example
@end deffn


@deffn Procedure enum-set-projection @vari{enum-set} @varii{enum-set}
Project @vari{enum-set} into the universe of @varii{enum-set}, dropping
any elements of @vari{enum-set} that do not belong to the universe of
@varii{enum-set}.  (If @vari{enum-set} is a subset of the universe of
its second, no elements are dropped, and the injection is returned.)

@example
(let ((e1 (make-enumeration
            '(red green blue black)))
      (e2 (make-enumeration
            '(red black white))))
  (enum-set->list
    (enum-set-projection e1 e2))))
=> (red black)
@end example
@end deffn


@deffn Syntax define-enumeration @hyper{type-name} (@hyper{symbol} @dots{}) @hyper{constructor-syntax}
The @func{define-enumeration} form defines an enumeration type and
provides two macros for constructing its members and sets of its
members.

A @func{define-enumeration} form is a definition and can appear anywhere
any other @hyper{definition} can appear.

@hyper{type-name} is an identifier that is bound as a syntactic keyword;
@hyper{symbol} @dots{} are the symbols that comprise the universe of the
enumeration (in order).

@code{(@hyper{type-name} @hyper{symbol})} checks at macro-expansion time
whether the name of @hyper{symbol} is in the universe associated with
@hyper{type-name}.  If it is, @code{(@hyper{type-name} @hyper{symbol})}
is equivalent to @code{@hyper{symbol}}.  It is a syntax violation if it
is not.

@hyper{constructor-syntax} is an identifier that is bound to a macro
that, given any finite sequence of the symbols in the universe, possibly
with duplicates, expands into an expression that evaluates to the
enumeration set of those symbols.

@code{(@hyper{constructor-syntax} @hyper{symbol} ...)} checks at
macro-expansion time whether every @hyper{symbol} ... is in the universe
associated with @hyper{type-name}.  It is a syntax violation if one or
more is not.  Otherwise:

@example
(@hyper{constructor-syntax} @hyper{symbol} ...)
@end example

@noindent
is equivalent to:

@example
((enum-set-constructor (@hyper{constructor-syntax}))
 '(@hyper{symbol} ...))
@end example

Example:

@example
(define-enumeration color
  (black white purple maroon)
  color-set)

(color black)                      => black
(color purpel)                     => exception &syntax
(enum-set->list (color-set))       => ()
(enum-set->list
  (color-set maroon white))        => (white maroon)
@end example

@quotation
@emph{Note:} In @code{(@hyper{type-name} @hyper{symbol})} and
@code{(@hyper{constructor-syntax} @hyper{symbol} ...)} forms, only the
names of the @hyper{symbol}s are significant.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib complib
@chapter Composite library


The @rsixlibrary{} library is a composite of most of the libraries
described in this report.  The only exceptions are:

@table @rsixlibrary
@item eval
@item mutable-pairs
@item mutable-strings
@item r5rs
@end table

The library exports all procedures and syntactic forms provided by the
component libraries.

All of the bindings exported by @rsixlibrary{} are exported for both
@code{run} and @code{expand}; see report section @rsixref{library import
export,Import and export levels}.


@c ------------------------------------------------------------

@c page
@node stdlib eval
@chapter Evaluation


The @rsixlibrary{eval} library allows a program to create Scheme
expressions as data at run time and evaluate them.


@deffn Procedure eval @var{expression} @var{environment}
Evaluate @var{expression} in the specified environment and returns its
value.  @var{expression} must be a syntactically valid Scheme expression
represented as a datum value, and @var{environment} must be an
@emph{environment}, which can be created using the @func{environment}
procedure described below.

If the first argument to @code{eval} is determined not to be a
syntactically correct expression, then @func{eval} must raise an
exception with condition type @code{&syntax}.  Specifically, if the
first argument to @code{eval} is a definition or a splicing @func{begin}
form containing a definition, it must raise an exception with condition
type @code{&syntax}.
@end deffn


@deffn Procedure environment @var{import-spec} @dots{}
@var{import-spec} must be a datum representing an @hyper{import spec}
(see report section @rsixref{library form,Library form}).

The @func{environment} procedure returns an environment corresponding to
@var{import-spec}.

The bindings of the environment represented by the specifier are
immutable: If @func{eval} is applied to an expression that is determined
to contain an assignment to one of the variables of the environment,
then @func{eval} must raise an exception with a condition type
@code{&syntax}.
@ignore
The errata corrige says to append the following here:

  for consistency with treatement of similar situations as syntax
  violations in section 7.1 of the base document.

but I see no &syntax in section 7.1 of R6RS document.
@end ignore

@example
(library (foo)
  (export)
  (import (rnrs)
          (rnrs eval))
  (write
    (eval '(let ((x 3)) x)
          (environment '(rnrs)))))      ;; writes 3

(library (foo)
  (export)
  (import (rnrs)
          (rnrs eval))
  (write
    (eval
      '(eval:car (eval:cons 2 4))
      (environment
        '(prefix (only (rnrs) car cdr cons null?)
                 eval:)))))             ;; writes 2
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib mutable pairs
@chapter Mutable pairs


The procedures provided by the @rsixlibrary{mutable-pairs} library allow
new values to be assigned to the car and cdr fields of previously
allocated pairs.


@deffn Procedure {set-car!} @var{pair} @var{obj}
Store @var{obj} in the car field of @var{pair}.  The @func{set-car!}
procedure returns unspecified values.

@example
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             => unspecified
(set-car! (g) 3)             => unspecified
                                ; should raise exception &assertion
@end example

If an immutable pair is passed to @func{set-car!}, an exception with
condition type @code{&assertion} should be raised.
@end deffn


@deffn Procedure {set-cdr!} @var{pair} @var{obj}
Store @var{obj} in the cdr field of @var{pair}.  The @func{set-cdr!}
procedure returns unspecified values.

If an immutable pair is passed to @func{set-cdr!}, an exception with
condition type @code{&assertion} should be raised.

@example
(let ((x (list 'a 'b 'c 'a))
      (y (list 'a 'b 'c 'a 'b 'c 'a)))
  (set-cdr! (list-tail x 2) x)
  (set-cdr! (list-tail y 5) y)
  (list
   (equal? x x)
   (equal? x y)
   (equal? (list x y 'a) (list y x 'b))))    =>  (#t #t #f)
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib mutable strings
@chapter Mutable strings


The @func{string-set!} procedure provided by the
@rsixlibrary{mutable-strings} library allows mutating the characters of
a string in--place.


@deffn Procedure {string-set!} @var{string} @var{k} @var{char}
@var{k} must be a valid index of @var{string}.

The @func{string-set!} procedure stores @var{char} in element @var{k} of
@var{string} and returns unspecified values.

Passing an immutable string to @func{string-set!} should cause an
exception with condition type @code{&assertion} to be raised.

@example
(define (f) (make-string 3 #\*))
(define (g) "***")
(string-set! (f) 0 #\?)                 => unspecified
(string-set! (g) 0 #\?)                 => unspecified
                                ; should raise exception &assertion

(string-set! (symbol->string 'immutable)
             0
             #\?)                       => unspecified
                                ; should raise exception &assertion
@end example

@quotation
@emph{Note:} Implementors should make @func{string-set!} run in constant
time.
@end quotation
@end deffn


@deffn Procedure {string-fill!} @var{string} @var{char}
Store @var{char} in every element of the given @var{string} and returns
unspecified values.
@end deffn


@c ------------------------------------------------------------

@c page
@node stdlib rfive compat
@chapter @rnrs{5} compatibility


The features described in this chapter are exported from the
@rsixlibrary{r5rs} library and provide some functionality of the
preceding revision of this report that was omitted from the main part of
the current report.


@deffn Procedure exact->inexact @var{z}
@deffnx Procedure inexact->exact @var{z}
These are the same as the @code{inexact} and @code{exact} procedures;
see report section @rsixref{base math ops exactness,Generic
conversions}.
@end deffn


@deffn Procedure quotient @vari{n} @varii{n}
@deffnx Procedure remainder @vari{n} @varii{n}
@deffnx Procedure modulo @vari{n} @varii{n}
These procedures implement number--theoretic (integer) division.
@varii{N} must be non--zero.  All three procedures return integer
objects.  If @vari{n}/@varii{n} is an integer object:

@example
(quotient @vari{n} @varii{n})   => @vari{n}/@varii{n}
(remainder @vari{n} @varii{n})  => 0
(modulo @vari{n} @varii{n})     => 0
@end example

If @vari{n}/@varii{n} is not an integer object:

@example
(quotient @vari{n} @varii{n})   => @var{n$_q$}
(remainder @vari{n} @varii{n})  => @var{n$_r$}
(modulo @vari{n} @varii{n})     => @var{n$_m$}
@end example

@noindent
where @var{n_q} is @vari{n}/@varii{n} rounded towards zero,

@example
0 < |@var{n_r}| < |@varii{n}|
0 < |@var{n_m}| < |@varii{n}|
@end example

@noindent
@var{n_r} and @var{n_m} differ from @vari{n} by a multiple of @varii{n},
@var{n_r} has the same sign as @vari{n}, and @var{n_m} has the same sign
as @varii{n}.

Consequently, for integer objects @vari{n} and @varii{n} with @varii{n}
not equal to 0,

@example
(= @vari{n} (+ (* @varii{n} (quotient @vari{n} @varii{n}))
               (remainder @vari{n} @varii{n})))
=> #t
@end example

@noindent
provided all number object involved in that computation are exact.

@example
(modulo 13 4)           =>  1
(remainder 13 4)        =>  1

(modulo -13 4)          =>  3
(remainder -13 4)       =>  -1

(modulo 13 -4)          =>  -3
(remainder 13 -4)       =>  1

(modulo -13 -4)         =>  -1
(remainder -13 -4)      =>  -1

(remainder -13 -4.0)    =>  -1.0
@end example

@quotation
@emph{Note:} These procedures could be defined in terms of @func{div}
and @func{mod} (see report section @rsixref{base math ops
arithmetic,Arithmetic operations}) as follows (without checking of the
argument types):

@example
(define (sign n)
  (cond
    ((negative? n) -1)
    ((positive? n) 1)
    (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
@end example
@end quotation
@end deffn


@deffn Syntax delay @hyper{expression}
The @func{delay} construct is used together with the procedure
@func{force} to implement @emph{lazy evaluation} or @emph{call by need}.

@code{(delay @hyper{expression})} returns an object called a
@emph{promise} which at some point in the future may be asked (by the
@func{force} procedure) to evaluate @hyper{expression}, and deliver the
resulting value.  The effect of @hyper{expression} returning multiple
values is unspecified.
@end deffn


@deffn Procedure force @var{promise}
@var{promise} must be a promise.

The @func{force} procedure forces the value of @var{promise}.  If no
value has been computed for the promise, then a value is computed and
returned.  The value of the promise is cached (or ``memoized'') so that
if it is forced a second time, the previously computed value is
returned.

@example
(force (delay (+ 1 2)))                 =>  3

(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))           =>  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))           =>  2
@end example

Promises are mainly intended for programs written in functional style.
The following examples should not be considered to illustrate good
programming style, but they illustrate the property that only one value
is computed for a promise, no matter how many times it is forced.

@example
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     =>  a promise
(force p)             =>  6
p                     =>  a promise, still
(begin (set! x 10)
       (force p))     =>  6
@end example

Here is a possible implementation of @func{delay} and @func{force}.
Promises are implemented here as procedures of no arguments, and
@func{force} simply calls its argument:

@example
(define force
  (lambda (object)
    (object)))
@end example

The expression:

@example
(delay @hyper{expression})
@end example

@noindent
has the same meaning as the procedure call:

@example
(make-promise (lambda () @hyper{expression}))
@end example

@noindent
as follows:

@example
(define-syntax delay
  (syntax-rules ()
    ((delay expression)
     (make-promise (lambda () expression)))))
@end example

@noindent
where @func{make-promise} is defined as follows:

@example
(define make-promise
  (lambda (proc)
    (let ((result-ready?  #f)
          (result         #f))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? #t)
                         (set! result x)
                         result))))))))
@end example
@end deffn


@deffn Procedure null-environment @var{n}
@var{n} must be the exact integer object 5.

The @func{null-environment} procedure returns an environment specifier
suitable for use with @func{eval} representing an environment that is
empty except for the (syntactic) bindings for all keywords described in
the previous revision of this report, including bindings for @code{=>},
@code{...}, @code{else}, and @code{_} that are the same as those in the
@rsixlibrary{base} library.
@end deffn


@deffn Procedure scheme-report-environment @var{n}
@var{n} must be the exact integer object 5.

The @func{scheme-report-environment} procedure returns an environment
specifier for an environment that is empty except for the bindings for
the identifiers described in the previous revision of this report,
omitting @func{load}, @func{interaction-environment},
@func{transcript-on}, @func{transcript-off}, and @func{char-ready?}.

The variable bindings have as values the procedures of the same names
described in this report, and the keyword bindings, including @code{=>},
@code{...}, @code{else}, and @code{_} are the same as those described in
this report.
@end deffn


@c ------------------------------------------------------------

@c page
@node references
@appendix Bibliography and references


@center @strong{OMITTED (sorry but there are so many of them)}


@c ------------------------------------------------------------

@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye


@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
