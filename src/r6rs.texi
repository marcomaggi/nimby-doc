\input texinfo.tex
@c %**start of header
@setfilename r6rs.info
@settitle Revised^6 Report on the Algorithmic Language Scheme
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Generic macros.
@c ------------------------------------------------------------

@macro version{}
2008-11-04-10-21-34
@end macro

@macro errataupdatedate{}
2008-11-04-10-51-44
@end macro

@macro rfive{}
@emph{Revised^5 Report on the Algorithmic Language Scheme}
@end macro

@macro rsix{}
@emph{Revised^6 Report on the Algorithmic Language Scheme}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro cite{NAME}
[@sc{\NAME\}]
@end macro

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@macro rnrs{NUMBER}
@acronym{R\NUMBER\RS}
@end macro

@c ------------------------------------------------------------

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro api{}
@acronym{API}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro utf{}
@acronym{UTF}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro false{}
@code{#f}
@end macro

@macro true{}
@code{#t}
@end macro

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro

@macro library{NAME}
@code{(\NAME\)}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      Revised^6 Report on the Algorithmic Language Scheme

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    R6RS

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
The report gives a defining description of the programming language
Scheme.  Scheme is a statically scoped and properly tail--recursive
dialect of the Lisp programming language invented by Guy Lewis Steele
Jr. and Gerald Jay Sussman.  It was designed to have an exceptionally
clear and simple semantics and few different ways to form expressions.

@noindent
MICHAEL SPERBER@*
R. KENT DYBVIG, MATTHEW FLATT, ANTON VAN STRAATEN@*
(Editors)

@noindent
RICHARD KELSEY, WILLIAM CLINGER, JONATHAN REES@*
(Editors, Revised^5 Report on the Algorithmic Language Scheme)

@noindent
ROBERT BRUCE FINDLER, JACOB MATTHEWS@*
(Authors, formal semantics)

@noindent
26 September 2007

The original version of this document, and its errata, are
available at:

@center @url{http://www.r6rs.org/}
@center @url{http://www.r6rs.org/r6rs-errata.html}

This document is version @version{} (with errata corrige update date
@errataupdatedate{}) of the Texinfo reformatting of the original sources
of the @rnrs{6} document; author and maintainer of the reformatted
version is @value{AUTHOR} @value{AUTHOR_EMAIL}.  This document is
slightly modified to allow for more readability in Info format, where
(for example) too many cross references would make the text ugly.
@end copying

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Documentation
@direntry
* r6rs: (r6rs).                 Revised^6 Report on the Algorithmic
                                Language Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore

@c ------------------------------------------------------------

@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* summary::                     Summary.
* introduction::                Introduction.

Description of the language

* overview::                    Overview of Scheme.
* requirements::                Requirement levels.
* numbers::                     Numbers.
* lex::                         Lexical syntax and datum syntax.
* basic::                       Semantic concepts.
* entry::                       Entry format.
* library::                     Libraries.
* programs::                    Top-level programs.
* syntax::                      Primitive syntax.
* expansion::                   Expansion process.
* base::                        Base library.

Appendices
* semantics::                   Formal semantics.
* derived::                     Sample definitions for derived
                                forms.
* repository::                  Additional material.
* example::                     Example.
* changes::                     Language changes.
* references::                  Bibliography and references.

Indexes

* concept index::               An entry for each concept. 
* function index::              An entry for each function. 
* variable index::              An entry for each variable. 
* type index::                  An entry for each type. 

@detailmenu
 --- The Detailed Node Listing ---

Overview of Scheme

* overview basic types::        Basic types.
* overview expressions::        Expressions.
* overview variables::          Variables and binding.
* overview definitions::        Definitions.
* overview forms::              Forms.
* overview procedures::         Procedures.
* overview syntax::             Procedure calls and syntactic keywords.
* overview assignment::         Assignment.
* overview macros::             Derived forms and macros.
* overview data::               Syntactic data and datum values.
* overview continuations::      Continuations.
* overview libraries::          Libraries.
* overview programs::           Top--level programs.

Numbers

* numbers tower::               Numerical tower.
* numbers exactness::           Exactness.
* numbers fix flo::             Fixnums and flonums.
* numbers requirements::        Implementation requirements.
* numbers inf nan::             Infinities and NaNs.
* numbers minus zero::          Distinguished @code{-0.0}.

Lexical syntax and datum syntax

* lex notation::                Notation.
* lex syntax::                  Lexical syntax.
* lex datum::                   Datum syntax.

Lexical syntax

* lex syntax formal account::           Formal account.
* lex syntax line endings::             Line endings.
* lex syntax whitespace and comments::  Whitespace and comments.
* lex syntax identifiers::              Identifiers.
* lex syntax booleans::                 Booleans.
* lex syntax characters::               Characters.
* lex syntax strings::                  Strings.
* lex syntax numbers::                  Numbers.

Datum syntax

* lex datum formal account::            Formal account.
* lex datum pairs and lists::           Pairs and lists.
* lex datum vectors::                   Vectors.
* lex datum bytevectors::               Bytevectors.
* lex datum abbreviations::             Abbreviations.

Semantic concepts

* basic programs and libraries::        Programs and libraries.
* basic variables keywords regions::    Variables, keywords,
                                        and regions.
* basic exceptions::                    Exceptional situations.
* basic argument checking::             Argument checking.
* basic syntax violations::             Syntax violations.
* basic safety::                        Safety.
* basic boolean values::                Boolean values.
* basic multiple return values::        Multiple return values.
* basic unspecified behavior::          Unspecified behavior.
* basic storage model::                 Storage model.
* basic proper tail recursion::         Proper tail recursion.
* basic dynamic extent::                Dynamic extent and the
                                        dynamic environment.

Entry format

* entry syntax::                Syntax entries.
* entry procedure::             Procedure entries.
* entry implementation resp::   Implementation responsibilities.
* entry other kinds::           Other kinds of entries.
* entry equivalent::            Equivalent entries.
* entry evaluation examples::   Evaluation examples.
* entry naming conventions::    Naming conventions.

Libraries

* library form::                Library form.
* library import export::       Import and export levels.
* library examples::            Examples.

Top--level programs

* programs syntax::             Top-level program syntax.
* programs semantics::          Top-level program semantics.

Primitive syntax

* syntax primitive::            Primitive expression types.
* syntax macros::               Macros.

Base library

* base types::                  Base types.
* base definitions::            Definitions.
* base bodies::                 Bodies.
* base expressions::            Expressions.
* base predicates::             Equivalence and procedure
                                predicates.
* base math::                   Mathematics.
* base booleans::               Booleans.
* base lists::                  Pairs and lists.
* base symbols::                Symbols.
* base characters::             Characters.
* base strings::                Strings.
* base vectors::                Vectors.
* base errors::                 Errors and violations.
* base control::                Control features.
* base iteration::              Iteration.
* base quasiquotation::         Quasiquotation.
* base syntax binding::         Binding constructs for syntactic
                                keywords.
* base transformers::           Macro transformers.
* base tail call::              Tail calls and tail contexts.

Definitions

* base definitions variables::  Variables definitions.
* base definitions syntax::     Syntax definitions.

Expressions

* base expressions quotation::          Quotation.
* base expressions procedures::         Procedures.
* base expressions conditionals::       Conditionals.
* base expressions assignments::        Assignments.
* base expressions derived cond::       Derived conditionals.
* base expressions binding::            Binding constructs.
* base expressions sequencing::         Sequencing.

Mathematics

* base math exactness::         Propagation of exactness and
                                inexactness.
* base math infinities::        Representability of infinities
                                and NaNs.
* base math semantics::         Semantics of common operations.
* base math ops::               Numerical operations.
* base math string::            Numerical input and output.

Semantics of common operations

* base math semantics integer::         Integer division.
* base math semantics trascend::        Transcendental functions.

Numerical operations

* base math ops type pred::             Numerical type predicates.
* base math ops exactness::             Generic conversion.
* base math ops value pred::            Value predicates.
* base math ops comparison::            Comparison.
* base math ops arithmetic::            Arithmetic operations.
* base math ops part::                  Part separation.
* base math ops trascend::              Trascendental functions.
* base math ops exponentiation::        Exponentiation functions.
* base math ops complex::               Complex numbers functions.

@end detailmenu
@end menu

@end ifnottex

@c ------------------------------------------------------------

@c page
@node summary
@chapheading Summary


@noindent
The report gives a defining description of the programming language
Scheme.  Scheme is a statically scoped and properly tail--recursive
dialect of the Lisp programming language invented by Guy Lewis Steele
Jr. and Gerald Jay Sussman.  It was designed to have an exceptionally
clear and simple semantics and few different ways to form expressions.
A wide variety of programming paradigms, including functional,
imperative, and message passing styles, find convenient expression in
Scheme.

This report is accompanied by a report describing standard libraries;
references to this document are identified by designations such as
``library section'' or ``library chapter''.  It is also accompanied by a
report containing non--normative appendices.  A fourth report gives some
historical background and rationales for many aspects of the language
and its libraries.

The individuals listed above are not the sole authors of the text of the
report.  Over the years, the following individuals were involved in
discussions contributing to the design of the Scheme language, and were
listed as authors of prior reports:

@quotation
Hal Abelson, Norman Adams, David Bartley, Gary Brooks, William Clinger,
R. Kent Dybvig, Daniel Friedman, Robert Halstead, Chris Hanson,
Christopher Haynes, Eugene Kohlbecker, Don Oxley, Kent Pitman, Jonathan
Rees, Guillermo Rozas, Guy L. Steele Jr., Gerald Jay Sussman, and
Mitchell Wand.
@end quotation

In order to highlight recent contributions, they are not listed as
authors of this version of the report.  However, their contribution and
service is gratefully acknowledged.

We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as a
starting point for manuals and other documentation, modifying it as
necessary.

@c ------------------------------------------------------------

@c page
@node introduction
@chapheading Introduction


@noindent
Programming languages should be designed not by piling feature on top of
feature, but by removing the weaknesses and restrictions that make
additional features appear necessary.  Scheme demonstrates that a very
small number of rules for forming expressions, with no restrictions on
how they are composed, suffice to form a practical and efficient
programming language that is flexible enough to support most of the
major programming paradigms in use today.

Scheme was one of the first programming languages to incorporate
first--class procedures as in the lambda calculus, thereby proving the
usefulness of static scope rules and block structure in a dynamically
typed language.  Scheme was the first major dialect of Lisp to
distinguish procedures from lambda expressions and symbols, to use a
single lexical environment for all variables, and to evaluate the
operator position of a procedure call in the same way as an operand
position.

By relying entirely on procedure calls to express iteration, Scheme
emphasized the fact that tail--recursive procedure calls are essentially
gotos that pass arguments.  Scheme was the first widely used programming
language to embrace first--class escape procedures, from which all
previously known sequential control structures can be synthesized.  A
subsequent version of Scheme introduced the concept of exact and inexact
number objects, an extension of Common Lisp's generic arithmetic.  More
recently, Scheme became the first programming language to support
hygienic macros, which permit the syntax of a block--structured language
to be extended in a consistent and reliable manner.

@section Guiding principles


@noindent
To help guide the standardization effort, the editors have adopted a set
of principles, presented below.  Like the Scheme language defined in
@rfive{}, the language described in this report is intended to:

@itemize
@item
allow programmers to read each other's code, and allow development of
portable programs that can be executed in any conforming implementation
of Scheme;

@item
derive its power from simplicity, a small number of generally useful
core syntactic forms and procedures, and no unnecessary restrictions on
how they are composed;
  
@item
allow programs to define new procedures and new hygienic syntactic
forms;
  
@item
support the representation of program source code as data;
  
@item
make procedure calls powerful enough to express any form of sequential
control, and allow programs to perform non--local control operations
without the use of global program transformations;
  
@item
allow interesting, purely functional programs to run indefinitely
without terminating or running out of memory on finite--memory machines;
  
@item
allow educators to use the language to teach programming effectively, at
various levels and with a variety of pedagogical approaches; and

@item
allow researchers to use the language to explore the design,
 implementation, and semantics of programming languages.
@end itemize

In addition, this report is intended to:

@itemize
@item
allow programmers to create and distribute substantial programs and
libraries, e.g., implementations of Scheme Requests for Implementation,
that run without modification in a variety of Scheme implementations;
  
@item
support procedural, syntactic, and data abstraction more fully by
allowing programs to define hygiene--bending and hygiene--breaking
syntactic abstractions and new unique datatypes along with procedures
and hygienic macros in any scope;
  
@item
allow programmers to rely on a level of automatic run--time type and
bounds checking sufficient to ensure type safety; and

@item
allow implementations to generate efficient code, without requiring
programmers to use implementation--specific operators or declarations.
@end itemize

While it was possible to write portable programs in Scheme as described
in @rfive{}, and indeed portable Scheme programs were written prior to
this report, many Scheme programs were not, primarily because of the
lack of substantial standardized libraries and the proliferation of
implementation--specific language additions.

In general, Scheme should include building blocks that allow a wide
variety of libraries to be written, include commonly used user--level
features to enhance portability and readability of library and
application code, and exclude features that are less commonly used and
easily implemented in separate libraries.

The language described in this report is intended to also be backward
compatible with programs written in Scheme as described in @rfive{} to
the extent possible without compromising the above principles and future
viability of the language.  With respect to future viability, the
editors have operated under the assumption that many more Scheme
programs will be written in the future than exist in the present, so the
future programs are those with which we should be most concerned.

@c ------------------------------------------------------------

@section Acknowledgements


@noindent
Many people contributed significant help to this revision of the report.
Specifically, we thank Aziz Ghuloum and Andre van Tonder for
contributing reference implementations of the library system.  We thank
Alan Bawden, John Cowan, Sebastian Egner, Aubrey Jaffer, Shiro Kawai,
Bradley Lucier, and Andre van Tonder for contributing insights on
language design.  Marc Feeley, Martin Gasbichler, Aubrey Jaffer, Lars T
Hansen, Richard Kelsey, Olin Shivers, and Andre van Tonder wrote SRFIs
that served as direct input to the report.  Marcus Crestani, David
Frese, Aziz Ghuloum, Arthur A. Gleckler, Eric Knauel, Jonathan Rees, and
Andre van Tonder thoroughly proofread early versions of the report.

We would also like to thank the following people for their help in
creating this report: Lauri Alanko, Eli Barzilay, Alan Bawden, Brian C.
Barnes, Per Bothner, Trent Buck, Thomas Bushnell, Taylor Campbell,
Ludovic Courtes, Pascal Costanza, John Cowan, Ray Dillinger, Jed Davis,
J.A. ``Biep'' Durieux, Carl Eastlund, Sebastian Egner, Tom Emerson, Marc
Feeley, Matthias Felleisen, Andy Freeman, Ken Friedenbach, Martin
Gasbichler, Arthur A. Gleckler, Aziz Ghuloum, Dave Gurnell, Lars T
Hansen, Ben Harris, Sven Hartrumpf, Dave Herman, Nils M. Holm, Stanislav
Ievlev, James Jackson, Aubrey Jaffer, Shiro Kawai, Alexander Kjeldaas,
Eric Knauel, Michael Lenaghan, Felix Klock, Donovan Kolbly, Marcin
Kowalczyk, Thomas Lord, Bradley Lucier, Paulo J. Matos, Dan Muresan,
Ryan Newton, Jason Orendorff, Erich Rast, Jeff Read, Jonathan Rees,
Jorgen Schafer, Paul Schlie, Manuel Serrano, Olin Shivers, Jonathan
Shapiro, Jens Axel Soegaard, Jay Sulzberger, Pinku Surana, Mikael
Tillenius, Sam Tobin--Hochstadt, David Van Horn, Andre van Tonder,
Reinder Verlinde, Alan Watson, Andrew Wilcox, Jon Wilson, Lynn
Winebarger, Keith Wright, and Chongkai Zhu.

We would like to thank the following people for their help in creating
the previous revisions of this report: Alan Bawden, Michael Blair,
George Carrette, Andy Cromarty, Pavel Curtis, Jeff Dalton, Olivier
Danvy, Ken Dickey, Bruce Duba, Marc Feeley, Andy Freeman, Richard
Gabriel, Yekta Gursel, Ken Haase, Robert Hieb, Paul Hudak, Morry Katz,
Chris Lindblad, Mark Meyer, Jim Miller, Jim Philbin, John Ramsdell, Mike
Shaff, Jonathan Shapiro, Julie Sussman, Perry Wagle, Daniel Weise, Henry
Wu, and Ozan Yigit.

We thank Carol Fessenden, Daniel Friedman, and Christopher Haynes for
permission to use text from the Scheme 311 version 4 reference manual.
We thank Texas Instruments, Inc. for permission to use text from the
@emph{TI Scheme Language Reference Manual}.  We gladly acknowledge the
influence of manuals for @acronym{MIT} Scheme, T, Scheme 84, Common
Lisp, Chez Scheme, PLT Scheme, and Algol 60.

We also thank Betty Dexter for the extreme effort she put into setting
this report in TeX, and Donald Knuth for designing the program that
caused her troubles.

The Artificial Intelligence Laboratory of the Massachusetts Institute of
Technology, the Computer Science Department of Indiana University, the
Computer and Information Sciences Department of the University of
Oregon, and the @acronym{NEC} Research Institute supported the
preparation of this report.  Support for the @acronym{MIT} work was
provided in part by the Advanced Research Projects Agency of the
Department of Defense under Office of Naval Research contract
N00014-80-C-0505.  Support for the Indiana University work was provided
by @acronym{NSF} grants NCS 83-04567 and NCS 83-03325.

@c ------------------------------------------------------------

@c page
@node overview
@chapter Overview of Scheme

@c originally this chapter was the "struct" file.

@menu
* overview basic types::        Basic types.
* overview expressions::        Expressions.
* overview variables::          Variables and binding.
* overview definitions::        Definitions.
* overview forms::              Forms.
* overview procedures::         Procedures.
* overview syntax::             Procedure calls and syntactic keywords.
* overview assignment::         Assignment.
* overview macros::             Derived forms and macros.
* overview data::               Syntactic data and datum values.
* overview continuations::      Continuations.
* overview libraries::          Libraries.
* overview programs::           Top--level programs.
@end menu


@noindent
This chapter gives an overview of Scheme's semantics.  The purpose of
this overview is to explain enough about the basic concepts of the
language to facilitate understanding of the subsequent chapters of the
report, which are organized as a reference manual.  Consequently, this
overview is not a complete introduction to the language, nor is it
precise in all respects or normative in any way.

Following Algol, Scheme is a statically scoped programming language.
Each use of a variable is associated with a lexically apparent binding
of that variable.

Scheme has latent as opposed to manifest types @cite{WaiteGoos}.  Types
are associated with objects (also called values) rather than with
variables.  (Some authors refer to languages with latent types as
untyped, weakly typed or dynamically typed languages.)  Other languages
with latent types are Python, Ruby, Smalltalk, and other dialects of
Lisp.  Languages with manifest types (sometimes referred to as strongly
typed or statically typed languages) include Algol 60, C, C#, Java,
Haskell, and ML.

All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.  No Scheme object
is ever destroyed.  The reason that implementations of Scheme do not
(usually!) run out of storage is that they are permitted to reclaim the
storage occupied by an object if they can prove that the object cannot
possibly matter to any future computation.  Other languages in which
most objects have unlimited extent include C#, Java, Haskell, most Lisp
dialects, ML, Python, Ruby, and Smalltalk.

Implementations of Scheme must be properly tail--recursive.  This allows
the execution of an iterative computation in constant space, even if the
iterative computation is described by a syntactically recursive
procedure.  Thus with a properly tail--recursive implementation,
iteration can be expressed using the ordinary procedure--call mechanics,
so that special iteration constructs are useful only as syntactic sugar.

Scheme was one of the first languages to support procedures as objects
in their own right.  Procedures can be created dynamically, stored in
data structures, returned as results of procedures, and so on.  Other
languages with these properties include Common Lisp, Haskell, ML, Ruby,
and Smalltalk.

One distinguishing feature of Scheme is that continuations, which in
most other languages only operate behind the scenes, also have
``first--class'' status.  First--class continuations are useful for
implementing a wide variety of advanced control constructs, including
non--local exits, backtracking, and coroutines.

In Scheme, the argument expressions of a procedure call are evaluated
before the procedure gains control, whether the procedure needs the
result of the evaluation or not.  C, C#, Common Lisp, Python, Ruby, and
Smalltalk are other languages that always evaluate argument expressions
before invoking a procedure.  This is distinct from the lazy--evaluation
semantics of Haskell, or the call--by--name semantics of Algol 60, where
an argument expression is not evaluated unless its value is needed by
the procedure.

Scheme's model of arithmetic provides a rich set of numerical types and
operations on them.  Furthermore, it distinguishes @emph{exact} and
@emph{inexact} number objects: Essentially, an exact number object
corresponds to a number exactly, and an inexact number object is the
result of a computation that involved rounding or other errors.

@c ------------------------------------------------------------

@c page
@node overview basic types
@section Basic types


@noindent
Scheme programs manipulate @emph{objects}, which are also referred to as
@emph{values}.  Scheme objects are organized into sets of values called
@emph{types}.  This section gives an overview of the fundamentally
important types of the Scheme language.  More types are described in
later chapters.

@quotation
@emph{Note:} As Scheme is latently typed, the use of the term
@emph{type} in this report differs from the use of the term in the
context of other languages, particularly those with manifest typing.
@end quotation

@subsubheading Booleans

@noindent
A boolean is a truth value, and can be either true or false.  In Scheme,
the object for ``false'' is written @false{}.  The object for ``true''
is written @true{}.  In most places where a truth value is expected,
however, any object different from @false{} counts as true.

@subsubheading Numbers

@noindent
Scheme supports a rich variety of numerical data types, including
objects representing integers of arbitrary precision, rational numbers,
complex numbers, and inexact numbers of various kinds.  @ref{numbers}
gives an overview of the structure of Scheme's numerical tower.

@subsubheading Characters

@noindent
Scheme characters mostly correspond to textual characters.  More
precisely, they are isomorphic to the @emph{scalar values} of the
Unicode standard.

@subsubheading Strings

@noindent
Strings are finite sequences of characters with fixed length and thus
represent arbitrary Unicode texts.

@subsubheading Symbols

@noindent
A symbol is an object representing a string, the symbol's @emph{name}.
Unlike strings, two symbols whose names are spelled the same way are
never distinguishable.  Symbols are useful for many applications; for
instance, they may be used the way enumerated values are used in other
languages.

@subsubheading Pairs and lists

@noindent
A pair is a data structure with two components.  The most common use of
pairs is to represent (singly linked) lists, where the first component
(the ``car'') represents the first element of the list, and the second
component (the ``cdr'') the rest of the list.  Scheme also has a
distinguished empty list, which is the last cdr in a chain of pairs that
form a list.

@subsubheading Vectors

@noindent
Vectors, like lists, are linear data structures representing finite
sequences of arbitrary objects.  Whereas the elements of a list are
accessed sequentially through the chain of pairs representing it, the
elements of a vector are addressed by integer indices.  Thus, vectors
are more appropriate than lists for random access to elements.

@subsubheading Procedures

@noindent
Procedures are values in Scheme.

@c ------------------------------------------------------------

@c page
@node overview expressions
@section Expressions


@noindent
The most important elements of Scheme code are @emph{expressions}.
Expressions can be @emph{evaluated}, producing a @emph{value}.
(Actually, any number of values; @ref{basic multiple return values}.)
The most fundamental expressions are literal expressions:

@example
#t => #t
23 => 23
@end example

This notation means that the expression @true{} evaluates to @true{},
that is, the value for ``true'', and that the expression @code{23}
evaluates to a number object representing the number 23.

Compound expressions are formed by placing parentheses around their
subexpressions.  The first subexpression identifies an operation; the
remaining subexpressions are operands to the operation:

@example
(+ 23 42) => 65
(+ 14 (* 23 42)) => 980
@end example

In the first of these examples, @func{+} is the name of the built--in
operation for addition, and @code{23} and @code{42} are the operands.
The expression @code{(+ 23 42)} reads as ``the sum of 23 and 42''.
Compound expressions can be nested---the second example reads as ``the
sum of 14 and the product of 23 and 42''.

As these examples indicate, compound expressions in Scheme are always
written using the same prefix notation.  As a consequence, the
parentheses are needed to indicate structure.  Consequently,
``superfluous'' parentheses, which are often permissible in mathematical
notation and also in many programming languages, are not allowed in
Scheme.

As in many other languages, whitespace (including line endings) is not
significant when it separates subexpressions of an expression, and can
be used to indicate structure.

@c ------------------------------------------------------------

@c page
@node overview variables
@section Variables and binding


@noindent
Scheme allows identifiers to stand for locations containing values.
These identifiers are called variables.  In many cases, specifically
when the location's value is never modified after its creation, it is
useful to think of the variable as standing for the value directly.

@example
(let ((x 23)
      (y 42))
  (+ x y)) => 65
@end example

In this case, the expression starting with @func{let} is a binding
construct.  The parenthesized structure following the @func{let} lists
variables alongside expressions: the variable @code{x} alongside
@code{23}, and the variable @code{y} alongside @code{42}.  The
@func{let} expression binds @code{x} to 23, and @code{y} to 42.  These
bindings are available in the @emph{body} of the @func{let} expression,
@code{(+ x y)}, and only there.

@c ------------------------------------------------------------

@c page
@node overview definitions
@section Definitions


@noindent
The variables bound by a @func{let} expression are @emph{local}, because
their bindings are visible only in the @func{let}'s body.  Scheme also
allows creating top--level bindings for identifiers as follows:

@example
(define x 23)
(define y 42)
(+ x y) => 65
@end example

@noindent
(These are actually ``top--level'' in the body of a top--level program
or library; @ref{library}.)

The first two parenthesized structures are @emph{definitions}; they
create top--level bindings, binding @code{x} to 23 and @code{y} to 42.
Definitions are not expressions, and cannot appear in all places where
an expression can occur.  Moreover, a definition has no value.

Bindings follow the lexical structure of the program: When several
bindings with the same name exist, a variable refers to the binding that
is closest to it, starting with its occurrence in the program and going
from inside to outside, and referring to a top--level binding if no
local binding can be found along the way:

@example
(define x 23)
(define y 42)
(let ((y 43))
  (+ x y)) => 66

(let ((y 43))
  (let ((y 44))
    (+ x y))) => 67
@end example

@c ------------------------------------------------------------

@c page
@node overview forms
@section Forms


@noindent
While definitions are not expressions, compound expressions and
definitions exhibit similar syntactic structure:

@example
(define x 23)
(* x 2)
@end example

While the first line contains a definition, and the second an
expression, this distinction depends on the bindings for @func{let}
and @func{*}.  At the purely syntactical level, both are @emph{forms},
and @emph{form} is the general name for a syntactic part of a Scheme
program.  In particular, @code{23} is a @emph{subform} of the form
@code{(define x 23)}.

@c ------------------------------------------------------------

@c page
@node overview procedures
@section Procedures


@noindent
Definitions can also be used to define procedures:

@example
(define (f x)
  (+ x 42))

(f 23) => 65
@end example

A procedure is, slightly simplified, an abstraction of an expression
over objects.  In the example, the first definition defines a procedure
called @code{f}.  (Note the parentheses around @code{f x}, which
indicate that this is a procedure definition.)  The expression @code{(f
23)} is a procedure call, meaning, roughly, ``evaluate @code{(+ x 42)}
(the body of the procedure) with @code{x} bound to 23''.

As procedures are objects, they can be passed to other procedures:

@example
(define (f x)
  (+ x 42))

(define (g p x)
  (p x))

(g f 23) => 65
@end example

In this example, the body of @code{g} is evaluated with @code{p} bound
to @code{f} and @code{x} bound to 23, which is equivalent to @code{(f
23)}, which evaluates to 65.

In fact, many predefined operations of Scheme are provided not by
syntax, but by variables whose values are procedures.  The @func{+}
operation, for example, which receives special syntactic treatment in
many other languages, is just a regular identifier in Scheme, bound to a
procedure that adds number objects.  The same holds for @func{*} and
many others:

@example
(define (h op x y)
  (op x y))

(h + 23 42) => 65
(h * 23 42) => 966
@end example

Procedure definitions are not the only way to create procedures.  A
@func{lambda} expression creates a new procedure as an object, with no
need to specify a name:

@example
((lambda (x) (+ x 42)) 23) => 65
@end example

The entire expression in this example is a procedure call; @code{(lambda
(x) (+ x 42))}, evaluates to a procedure that takes a single number
object and adds 42 to it.

@c ------------------------------------------------------------

@c page
@node overview syntax
@section Procedure calls and syntactic keywords


@noindent
Whereas @code{(+ 23 42)}, @code{(f 23)}, and @code{((lambda (x) (+ x
42)) 23)} are all examples of procedure calls, @func{lambda} and
@func{let} expressions are not.  This is because @func{let}, even though
it is an identifier, is not a variable, but is instead a @emph{syntactic
keyword}.  A form that has a syntactic keyword as its first
subexpression obeys special rules determined by the keyword.  The
@func{let} identifier in a definition is also a syntactic keyword.
Hence, definitions are also not procedure calls.

The rules for the @func{lambda} keyword specify that the first subform
is a list of parameters, and the remaining subforms are the body of the
procedure.  In @func{let} expressions, the first subform is a list of
binding specifications, and the remaining subforms constitute a body of
expressions.

Procedure calls can generally be distinguished from these @emph{special
forms} by looking for a syntactic keyword in the first position of a
form: if the first position does not contain a syntactic keyword, the
expression is a procedure call.  (So--called @emph{identifier macros}
allow creating other kinds of special forms, but are comparatively
rare.)  The set of syntactic keywords of Scheme is fairly small, which
usually makes this task fairly simple.  It is possible, however, to
create new bindings for syntactic keywords; @ref{overview macros} below.

@c ------------------------------------------------------------

@c page
@node overview assignment
@section Assignment


@noindent
Scheme variables bound by definitions or @func{let} or @func{lambda}
expressions are not actually bound directly to the objects specified in
the respective bindings, but to locations containing these objects.  The
contents of these locations can subsequently be modified destructively
via @emph{assignment}:

@example
(let ((x 23))
  (set! x 42)
  x) => 42
@end example

In this case, the body of the @func{let} expression consists of two
expressions which are evaluated sequentially, with the value of the
final expression becoming the value of the entire @func{let} expression.
The expression @code{(set! x 42)} is an assignment, saying ``replace the
object in the location referenced by @code{x} with 42''.  Thus, the
previous value of @code{x}, 23, is replaced by 42.

@c ------------------------------------------------------------

@c page
@node overview macros
@section Derived forms and macros


@noindent
Many of the special forms specified in this report can be translated
into more basic special forms.  For example, a @func{let} expression can
be translated into a procedure call and a @func{lambda} expression.  The
following two expressions are equivalent:

@example
(let ((x 23)
      (y 42))
  (+ x y)) => 65

((lambda (x y) (+ x y)) 23 42)    => 65
@end example

Special forms like @func{let} expressions are called @emph{derived
forms} because their semantics can be derived from that of other kinds
of forms by a syntactic transformation.  Some procedure definitions are
also derived forms.  The following two definitions are equivalent:

@example
(define (f x)
  (+ x 42))

(define f
  (lambda (x)
    (+ x 42)))
@end example

In Scheme, it is possible for a program to create its own derived forms
by binding syntactic keywords to macros:

@example
(define-syntax def
  (syntax-rules ()
    ((def f (p ...) body)
     (define (f p ...)
       body))))

(def f (x)
  (+ x 42))
@end example

The @func{define-syntax} construct specifies that a parenthesized
structure matching the pattern @code{(def f (p ...) body)}, where
@func{f}, @code{p}, and @code{body} are pattern variables, is translated
to @code{(define (f p ...) body)}.  Thus, the @code{def} form appearing
in the example gets translated to:

@example
(define (f x)
  (+ x 42))
@end example

The ability to create new syntactic keywords makes Scheme extremely
flexible and expressive, allowing many of the features built into other
languages to be derived forms in Scheme.

@c ------------------------------------------------------------

@c page
@node overview data
@section Syntactic data and datum values


@noindent
A subset of the Scheme objects is called @emph{datum values}.  These
include booleans, number objects, characters, symbols, and strings as
well as lists and vectors whose elements are data.  Each datum value may
be represented in textual form as a @emph{syntactic datum}, which can be
written out and read back in without loss of information.  A datum value
may be represented by several different syntactic data.  Moreover, each
datum value can be trivially translated to a literal expression in a
program by prepending a @code{'} (single quote) to a corresponding
syntactic datum:

@example
'23 => 23
'@true{} => @true{}
'foo => foo
'(1 2 3) => (1 2 3)
'#(1 2 3) => #(1 2 3)
@end example

The @code{'} shown in the previous examples is not needed for
representations of number objects or booleans.  The syntactic datum
@code{foo} represents a symbol with name ``foo'', and @code{'foo} is a
literal expression with that symbol as its value.  @code{(1 2 3)} is a
syntactic datum that represents a list with elements 1, 2, and 3, and
@code{'(1 2 3)} is a literal expression with this list as its value.
Likewise, @code{#(1 2 3)} is a syntactic datum that represents a vector
with elements 1, 2 and 3, and @code{'#(1 2 3)} is the corresponding
literal.

The syntactic data are a superset of the Scheme forms.  Thus, data can
be used to represent Scheme forms as data objects.  In particular,
symbols can be used to represent identifiers.

@example
'(+ 23 42) => (+ 23 42)
'(define (f x) (+ x 42))    => (define (f x) (+ x 42))
@end example

This facilitates writing programs that operate on Scheme source code, in
particular interpreters and program transformers.

@c ------------------------------------------------------------

@c page
@node overview continuations
@section Continuations


@noindent
Whenever a Scheme expression is evaluated there is a @emph{continuation}
wanting the result of the expression.  The continuation represents an
entire (default) future for the computation.  For example, informally
the continuation of @code{3} in the expression

@example
(+ 1 3)
@end example

@noindent
adds 1 to it.  Normally these ubiquitous continuations are hidden behind
the scenes and programmers do not think much about them.  On rare
occasions, however, a programmer may need to deal with continuations
explicitly.

The @func{call-with-current-continuation} procedure (@ref{base control})
allows Scheme programmers to do that by creating a procedure that
reinstates the current continuation.

The @func{call-with-current-continuation} procedure accepts a procedure,
calls it immediately with an argument that is an @emph{escape
procedure}.  This escape procedure can then be called with an argument
that becomes the result of the call to
@func{call-with-current-continuation}.  That is, the escape procedure
abandons its own continuation, and reinstates the continuation of the
call to @func{call-with-current-continuation}.

In the following example, an escape procedure representing the
continuation that adds 1 to its argument is bound to @code{escape}, and
then called with 3 as an argument.  The continuation of the call to
@code{escape} is abandoned, and instead the 3 is passed to the
continuation that adds 1:

@example
(+ 1 (call-with-current-continuation
       (lambda (escape)
         (+ 2 (escape 3)))))    => 4
@end example

An escape procedure has unlimited extent: It can be called after the
continuation it captured has been invoked, and it can be called multiple
times.  This makes @func{call-with-current-continuation} significantly
more powerful than typical non--local control constructs such as
exceptions in other languages.

@c ------------------------------------------------------------

@c page
@node overview libraries
@section Libraries


@noindent
Scheme code can be organized in components called @emph{libraries}.
Each library contains definitions and expressions.  It can import
definitions from other libraries and export definitions to other
libraries.

The following library called @code{(hello)} exports a definition called
@func{hello-world}, and imports the base library (@ref{base}) and the
simple I/O library (see library section ``Simple I/O'').  The
@func{hello-world} export is a procedure that displays @code{Hello
World} on a separate line:

@example
(library (hello)
  (export hello-world)
  (import (rnrs base)
          (rnrs io simple))
  (define (hello-world)
    (display "Hello World")
    (newline)))
@end example

@c ------------------------------------------------------------

@c page
@node overview programs
@section Top--level programs


@noindent
A Scheme program is invoked via a @emph{top--level program}.  Like a
library, a top--level program contains imports, definitions and
expressions, and specifies an entry point for execution.  Thus a
top--level program defines, via the transitive closure of the libraries
it imports, a Scheme program.

The following top--level program obtains the first argument from the
command line via the @code{command-line} procedure from the
@rsixlibrary{programs} library (see library chapter ``Command--line
access and exit values'').  It then opens the file using
@func{open-file-input-port} (see library section ``Port IO''), yielding
a @emph{port}, i.e. a connection to the file as a data source, and calls
the @func{get-bytes-all} procedure to obtain the contents of the file as
binary data.  It then uses @func{put-bytes} to output the contents of
the file to standard output:

@example
#!r6rs
(import (rnrs base)
        (rnrs io ports)
        (rnrs programs))
(let ((p (standard-output-port)))
  (put-bytevector p
                  (call-with-port
                      (open-file-input-port
                        (cadr (command-line)))
                    get-bytevector-all))
  (close-port p))
@end example

@c ------------------------------------------------------------

@c page
@node requirements
@chapter Requirement levels


@noindent
The key words ``must'', ``must not'', ``should'', ``should not'',
``recommended'', ``may'', and ``optional'' in this report are to be
interpreted as described in @acronym{RFC} 2119.  Specifically:

@table @strong
@item must
This word means that a statement is an absolute requirement of the
specification.

@item must not
This phrase means that a statement is an absolute prohibition of the
specification.

@item should
This word, or the adjective ``recommended'', means that valid reasons
may exist in particular circumstances to ignore a statement, but that
the implications must be understood and weighed before choosing a
different course.

@item should not
This phrase, or the phrase ``not recommended'', means that valid reasons
may exist in particular circumstances when the behavior of a statement
is acceptable, but that the implications should be understood and
weighed before choosing the course described by the statement.

@item may
This word, or the adjective ``optional'', means that an item is truly
optional.
@end table

In particular, this report occasionally uses ``should'' to designate
circumstances that are outside the specification of this report, but
cannot be practically detected by an implementation; @ref{basic argument
checking}.  In such circumstances, a particular implementation may allow
the programmer to ignore the recommendation of the report and even
exhibit reasonable behavior.  However, as the report does not specify
the behavior, these programs may be unportable, that is, their execution
might produce different results on different implementations.

Moreover, this report occasionally uses the phrase ``not required'' to note the
absence of an absolute requirement.

@c ------------------------------------------------------------

@c page
@node numbers
@chapter Numbers


@menu
* numbers tower::               Numerical tower.
* numbers exactness::           Exactness.
* numbers fix flo::             Fixnums and flonums.
* numbers requirements::        Implementation requirements.
* numbers inf nan::             Infinities and NaNs.
* numbers minus zero::          Distinguished @code{-0.0}.
@end menu


@noindent
This chapter describes Scheme's model for numbers.  It is important to
distinguish between the mathematical numbers, the Scheme objects that
attempt to model them, the machine representations used to implement the
numbers, and notations used to write numbers.

In this report, the term @emph{number} refers to a mathematical number,
and the term @emph{number object} refers to a Scheme object representing
a number.  This report uses the types @emph{complex}, @emph{real},
@emph{rational}, and @emph{integer} to refer to both mathematical
numbers and number objects.  The @emph{fixnum} and @emph{flonum} types
refer to special subsets of the number objects, as determined by common
machine representations, as explained below.


@c ------------------------------------------------------------

@c page
@node numbers tower
@section Numerical tower


@noindent
Numbers may be arranged into a tower of subsets in which each level is a
subset of the level above it:

@example
number
  complex
  real
  rational
  integer
@end example

For example, 5 is an integer.  Therefore 5 is also a rational, a real,
and a complex.  The same is true of the number objects that model 5.

Number objects are organized as a corresponding tower of subtypes
defined by the predicates @code{number?}, @code{complex?}, @code{real?},
@code{rational?}, and @code{ integer?}; @ref{base math ops type pred}.
Integer number objects are also called @emph{integer objects}.

There is no simple relationship between the subset that contains a
number and its representation inside a computer.  For example, the
integer 5 may have several representations.  Scheme's numerical
operations treat number objects as abstract data, as independent of
their representation as possible.  Although an implementation of Scheme
may use many different representations for numbers, this should not be
apparent to a casual programmer writing simple programs.


@c ------------------------------------------------------------

@c page
@node numbers exactness
@section Exactness


@noindent
It is useful to distinguish between number objects that are known to
correspond to a number exactly, and those number objects whose
computation involved rounding or other errors.  For example, index
operations into data structures may need to know the index exactly, as
may some operations on polynomial coefficients in a symbolic algebra
system.  On the other hand, the results of measurements are inherently
inexact, and irrational numbers may be approximated by rational and
therefore inexact approximations.  In order to catch uses of numbers
known only inexactly where exact numbers are required, Scheme explicitly
distinguishes @emph{exact} from @emph{inexact} number objects.  This
distinction is orthogonal to the dimension of type.

A number object is exact if it is the value of an exact numerical
literal or was derived from exact number objects using only exact
operations.  Exact number objects correspond to mathematical numbers in
the obvious way.

Conversely, a number object is inexact if it is the value of an inexact
numerical literal, or was derived from inexact number objects, or was
derived using inexact operations.  Thus inexactness is contagious.

Exact arithmetic is reliable in the following sense: If exact number
objects are passed to any of the arithmetic procedures described in
section ``Propagation of exactness and inexactness'', and an exact
number object is returned, then the result is mathematically correct.
This is generally not true of computations involving inexact number
objects because approximate methods such as floating--point arithmetic
may be used, but it is the duty of each implementation to make the
result as close as practical to the mathematically ideal result.

@c ------------------------------------------------------------

@c page
@node numbers fix flo
@section Fixnums and flonums


@noindent
A @emph{fixnum} is an exact integer object that lies within a certain
implementation--dependent subrange of the exact integer objects.
(Library section on ``Fixnums'' describes a library for computing with
fixnums.)  Likewise, every implementation must designate a subset of its
inexact real number objects as @emph{flonums}, and to convert certain
external representations into flonums.  (Library section on ``Flonums''
describes a library for computing with flonums.)  Note that this does
not imply that an implementation must use floating--point
representations.


@c ------------------------------------------------------------

@c page
@node numbers requirements
@section Implementation requirements


@noindent
Implementations of Scheme must support number objects for the entire
tower of subtypes given in section ``Numerical tower''.  Moreover,
implementations must support exact integer objects and exact rational
number objects of practically unlimited size and precision, and to
implement certain procedures (listed in ``Propagation of exactness and
inexactness'') so they always return exact results when given exact
arguments.  (``Practically unlimited'' means that the size and precision
of these numbers should only be limited by the size of the available
memory.)

Implementations may support only a limited range of inexact number
objects of any type, subject to the requirements of this section.  For
example, an implementation may limit the range of the inexact real
number objects (and therefore the range of inexact integer and rational
number objects) to the dynamic range of the flonum format.  Furthermore
the gaps between the inexact integer objects and rationals are likely to
be very large in such an implementation as the limits of this range are
approached.

An implementation may use floating point and other approximate
representation strategies for @emph{inexact} numbers.  This report
recommends, but does not require, that the @acronym{IEEE}
floating--point standards be followed by implementations that use
floating--point representations, and that implementations using other
representations should match or exceed the precision achievable using
these floating--point standards @cite{ieee}.

In particular, implementations that use floating--point representations
must follow these rules: A floating--point result must be represented
with at least as much precision as is used to express any of the inexact
arguments to that operation.  Potentially inexact operations such as
@func{sqrt}, when applied to exact arguments, should produce exact
answers whenever possible (for example the square root of an exact 4
ought to be an exact 2).  However, this is not required.  If, on the
other hand, an exact number object is operated upon so as to produce an
inexact result (as by @func{sqrt}), and if the result is represented in
floating point, then the most precise floating--point format available
must be used; but if the result is represented in some other way then
the representation must have at least as much precision as the most
precise floating--point format available.

It is the programmer's responsibility to avoid using inexact number
objects with magnitude or significand too large to be represented in the
implementation.

@c ------------------------------------------------------------

@c page
@node numbers inf nan
@section Infinities and NaNs


@noindent
Some Scheme implementations, specifically those that follow the
@acronym{IEEE} floating--point standards, distinguish special number
objects called, @emph{negative infinity}, and @emph{NaN}.

Positive infinity is regarded as an inexact real (but not rational)
number object that represents an indeterminate number greater than the
numbers represented by all rational number objects.  Negative infinity
is regarded as an inexact real (but not rational) number object that
represents an indeterminate number less than the numbers represented by
all rational numbers.

A NaN is regarded as an inexact real (but not rational) number object so
indeterminate that it might represent any real number, including
positive or negative infinity, and might even be greater than positive
infinity or less than negative infinity.

@c ------------------------------------------------------------

@c page
@node numbers minus zero
@section Distinguished @code{-0.0}


@noindent
Some Scheme implementations, specifically those that follow the
@acronym{IEEE} floating--point standards, distinguish between number
objects for @code{0.0} and @code{-0.0}, i.e., positive and negative
inexact zero.  This report will sometimes specify the behavior of
certain arithmetic operations on these number objects.  These
specifications are marked with ``if @code{-0.0} is distinguished'' or
``implementations that distinguish @code{-0.0}''.


@c ------------------------------------------------------------

@c page
@node lex
@chapter Lexical syntax and datum syntax


@menu
* lex notation::                Notation.
* lex syntax::                  Lexical syntax.
* lex datum::                   Datum syntax.
@end menu


@noindent
The syntax of Scheme code is organized in three levels:

@enumerate
@item
the @emph{lexical syntax} that describes how a program text is split
into a sequence of lexemes,

@item
the @emph{datum syntax}, formulated in terms of the lexical syntax, that
structures the lexeme sequence as a sequence of @emph{syntactic data},
where a syntactic datum is a recursively structured entity,

@item
the @emph{program syntax} formulated in terms of the datum syntax,
imposing further structure and assigning meaning to syntactic data.
@end enumerate

Syntactic data (also called @emph{external representations}) double as a
notation for objects, and Scheme's @rsixlibrary{io ports} library
(library section ``Port I/O'') provides the @func{get-datum} and
@func{put-datum} procedures for reading and writing syntactic data,
converting between their textual representation and the corresponding
objects.  Each syntactic datum represents a corresponding @emph{datum
value}.  A syntactic datum can be used in a program to obtain the
corresponding datum value using @code{quote} (@ref{base expressions
quotation}).

Scheme source code consists of syntactic data and (non--significant)
comments.  Syntactic data in Scheme source code are called @emph{forms}.
(A form nested inside another form is called a @emph{subform}.)
Consequently, Scheme's syntax has the property that any sequence of
characters that is a form is also a syntactic datum representing some
object.  This can lead to confusion, since it may not be obvious out of
context whether a given sequence of characters is intended to be a
representation of objects or the text of a program.  It is also a source
of power, since it facilitates writing programs such as interpreters or
compilers that treat programs as objects (or vice versa).

A datum value may have several different external representations.  For
example, both @code{#e28.000} and @code{#x1c} are syntactic data
representing the exact integer object 28, and the syntactic data
@code{(8 13)}, @code{( 08 13 )}, @code{(8 . (13 . ()))} all represent a
list containing the exact integer objects 8 and 13.  Syntactic data that
represent equal objects (in the sense of @func{equal?}; @ref{base
predicates}) are always equivalent as forms of a program.

Because of the close correspondence between syntactic data and datum
values, this report sometimes uses the term @emph{datum} for either a
syntactic datum or a datum value when the exact meaning is apparent from
the context.

An implementation must not extend the lexical or datum syntax in any
way, with one exception: it need not treat the syntax
@code{#!<identifier>}, for any <identifier> (@ref{lex syntax
identifiers}) that is not @code{r6rs}, as a syntax violation, and it may
use specific @code{#!}--prefixed identifiers as flags indicating that
subsequent input contains extensions to the standard lexical or datum
syntax.  The syntax @code{#!r6rs} may be used to signify that the input
afterward is written with the lexical syntax and datum syntax described
by this report.  @code{#!r6rs} is otherwise treated as a comment;
@ref{lex syntax whitespace and comments}.

@c ------------------------------------------------------------

@c page
@node lex notation
@section Notation


@noindent
The formal syntax for Scheme is written in an extended @acronym{BNF}.
Non--terminals are written using angle brackets.  Case is insignificant
for non--terminal names.

All spaces in the grammar are for legibility.  @meta{Empty} stands for
the empty string.

The following extensions to @acronym{BNF} are used to make the
description more concise: @arbno{@meta{thing}} means zero or more
occurrences of @meta{thing}, and @atleastone{@meta{thing}} means at
least one @meta{thing}.

Some non-terminal names refer to the Unicode scalar values of the same
name: @meta{character tabulation} (U+0009), @meta{linefeed} (U+000A),
@meta{carriage return} (U+000D), @meta{line tabulation} (U+000B),
@meta{form feed} (U+000C), @meta{space} (U+0020), @meta{next line}
(U+0085), @meta{line separator} (U+2028), and @meta{paragraph separator}
(U+2029).

@c ------------------------------------------------------------

@c page
@node lex syntax
@section Lexical syntax


@menu
* lex syntax formal account::           Formal account.
* lex syntax line endings::             Line endings.
* lex syntax whitespace and comments::  Whitespace and comments.
* lex syntax identifiers::              Identifiers.
* lex syntax booleans::                 Booleans.
* lex syntax characters::               Characters.
* lex syntax strings::                  Strings.
* lex syntax numbers::                  Numbers.
@end menu


@noindent
The lexical syntax determines how a character sequence is split into a
sequence of lexemes, omitting non--significant portions such as comments
and whitespace.  The character sequence is assumed to be text according
to the Unicode standard @cite{Unicode}.  Some of the lexemes, such as
identifiers, representations of number objects, strings etc., of the
lexical syntax are syntactic data in the datum syntax, and thus
represent objects.  Besides the formal account of the syntax, this
section also describes what datum values are represented by these
syntactic data.

The lexical syntax, in the description of comments, contains a forward
reference to @meta{datum}, which is described as part of the datum
syntax.  Being comments, however, these @meta{datum}s do not play a
significant role in the syntax.

Case is significant except in representations of booleans, number
objects, and in hexadecimal numbers specifying Unicode scalar values.
For example, @code{#x1A} and @code{#X1a} are equivalent.  The identifier
@code{Foo} is, however, distinct from the identifier @code{FOO}.


@c ------------------------------------------------------------

@c page
@node lex syntax formal account
@subsection Formal account


@noindent
@meta{Interlexeme space} may occur on either side of any lexeme, but not
within a lexeme.

@meta{Identifier}s, @code{.}, @meta{number}s, @meta{character}s, and
@meta{boolean}s, must be terminated by a @meta{delimiter} or by the end
of the input.

The following two characters are reserved for future extensions to the
language: @code{@{ @}}

@example
<lexeme> -> <identifier> | <boolean> | <number>
         | <character> | <string>
         | ( | ) | [ | ] | #( | #vu8( | ' | ` | , | ,@@ | .
         | #' | #` | #, | #,@@
<delimiter> -> ( | ) | [ | ] | " | ; | #
         | <whitespace>
<whitespace> -> <character tabulation>
         | <linefeed> | <line tabulation> | <form feed>
         | <carriage return> | <next line>
         | <any character whose category is Zs, Zl, or Zp>
<line ending> -> <linefeed> | <carriage return>
         | <carriage return> <linefeed> | <next line>
         | <carriage return> <next line> | <line separator>
<comment> -> ; <all subsequent characters up to a <line ending>
                or <paragraph separator> >
         | <nested comment>
         | #; <interlexeme space> <datum>
         | #!r6rs
<nested comment> -> #| <comment text>
         <comment cont>* |#
<comment text> -> character sequence not containing #| or |#
<comment cont> -> <nested comment> <comment text>
<atmosphere> -> <whitespace> | <comment>
<interlexeme space> -> <atmosphere>*

<identifier> -> <initial> <subsequent>*
         | <peculiar identifier>
<initial> -> <constituent> | <special initial>
         | <inline hex escape>
<letter> -> a | b | c | ... | z
         | A | B | C | ... | Z
<constituent> -> <letter>
         | <any character whose Unicode scalar value is greater than
             127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,
             Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co>
<special initial> -> ! | $ | % | & | * | / | : | < | =
         | > | ? | ^ | _ | ~
<subsequent> -> <initial> | <digit>
         | <any character whose category is Nd, Mc, or Me>
         | <special subsequent>
<digit> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<hex digit> -> <digit>
         | a | A | b | B | c | C | d | D | e | E | f | F
<special subsequent> -> + | - | . | @@
<inline hex escape> -> \x<hex scalar value>;
<hex scalar value> -> <hex digit>+
<peculiar identifier> -> + | - | ... | -> <subsequent>*
<boolean> -> #t | #T | #f | #F
<character> -> #\<any character>
         | #\<character name>
         | #\x<hex scalar value>
<character name> -> nul | alarm | backspace | tab
         | linefeed | newline | vtab | page | return
         | esc | space | delete
<string> -> " <string element>* "
<string element> -> <any character other than " or \>
         | \a | \b | \t | \n | \v | \f | \r
         | \" | \\
         | \<intraline whitespace>* <line ending>
            <intraline whitespace>*
         | <inline hex escape>
<intraline whitespace> -> <character tabulation>
         | <any character whose category is Zs>
@end example

A @meta{hex scalar value} represents a Unicode scalar value between
@code{0} and @code{#x10FFFF}, excluding the range @code{[#D800,
#xDFFF]}.

The rules for @meta{num R}, @meta{complex R}, @meta{real R}, @meta{ureal
R}, @meta{uinteger R}, and @meta{prefix R} below should be replicated
for R = 2, 8, 10, and 16.  There are no rules for @meta{decimal 2},
@meta{decimal 8}, and @meta{decimal 16}, which means that number
representations containing decimal points or exponents must be in
decimal radix.

@example
<number> -> <num 2> | <num 8>
         | <num 10> | <num 16>
<num R> -> <prefix R> <complex R>
<complex R> -> <real R> | <real R> @@ <real R>
         | <real R> + <ureal R> i | <real R> - <ureal R> i
         | <real R> + <naninf> i | <real R> - <naninf> i
         | <real R> + i | <real R> - i
         | + <ureal R> i | - <ureal R> i
         | + <naninf> i | - <naninf> i
         | + i | - i
<real R> -> <sign> <ureal R>
         | + <naninf> | - <naninf>
<naninf> -> nan.0 | inf.0
<ureal R> -> <uinteger R>
         | <uinteger R> / <uinteger R>
         | <decimal R> <mantissa width>
<decimal 10> -> <uinteger 10> <suffix>
         | . <digit 10>+ <suffix>
         | <digit 10>+ . <digit 10>* <suffix>
         | <digit 10>+ . <suffix>
<uinteger R> -> <digit R>+
<prefix R> -> <radix R> <exactness>
         | <exactness> <radix R>

<suffix> -> <empty>
         | <exponent marker> <sign> <digit 10>+
<exponent marker> -> e | E | s | S | f | F
         | d | D | l | L
<mantissa width> -> <empty>
         | | <digit 10>+
<sign> -> <empty> | + | -
<exactness> -> <empty>
         | #i| #I | #e| #E
<radix 2> -> #b| #B
<radix 8> -> #o| #O
<radix 10> -> <empty> | #d | #D
<radix 16> -> #x| #X
<digit 2> -> 0 | 1
<digit 8> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
<digit 10> -> <digit>
<digit 16> -> <hex digit>
@end example

@c ------------------------------------------------------------

@c page
@node lex syntax line endings
@subsection Line endings


@noindent
Line endings are significant in Scheme in single--line comments
(@ref{lex syntax whitespace and comments}) and within string literals.
In Scheme source code, any of the line endings in @meta{line ending}
marks the end of a line.  Moreover, the two--character line endings
@meta{carriage return} @meta{linefeed} and @meta{carriage return}
@meta{next line} each count as a single line ending.

In a string literal, a @meta{line ending} not preceded by a @code{\}
stands for a linefeed character, which is the standard line--ending
character of Scheme.

@c ------------------------------------------------------------

@c page
@node lex syntax whitespace and comments
@subsection Whitespace and comments


@noindent
@emph{Whitespace} characters are spaces, linefeeds, carriage returns,
character tabulations, form feeds, line tabulations, and any other
character whose category is Zs, Zl, or Zp.  Whitespace is used for
improved readability and as necessary to separate lexemes from each
other.  Whitespace may occur between any two lexemes, but not within a
lexeme.  Whitespace may also occur inside a string, where it is
significant.

The lexical syntax includes several comment forms.  In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an identifier
or representation of a number object.

A semicolon (@code{;}) indicates the start of a line comment.  The
comment continues to the end of the line on which the semicolon appears.

Another way to indicate a comment is to prefix a @meta{datum} (cf.
section ``Formal account'') with @code{#;}, possibly with
@meta{interlexeme space} before the @meta{datum}.  The comment consists
of the comment prefix @code{#;} and the @meta{datum} together.  This
notation is useful for ``commenting out'' sections of code.

Block comments may be indicated with properly nested @code{#|} and
@code{|#} pairs.

@example
#|
   The FACT procedure computes the factorial of a
   non-negative integer.
|#
(define fact
  (lambda (n)
    ;; base case
    (if (= n 0)
        #;(= n 1)
        1       ; identity of *
        (* n (fact (- n 1))))))
@end example

The lexeme @code{#!r6rs}, which signifies that the program text that
follows is written with the lexical and datum syntax described in this
report, is also otherwise treated as a comment.

@c ------------------------------------------------------------

@c page
@node lex syntax identifiers
@subsection Identifiers


@noindent
Most identifiers allowed by other programming languages are also
acceptable to Scheme.  In general, a sequence of letters, digits, and
``extended alphabetic characters'' is an identifier when it begins with
a character that cannot begin a representation of a number object.  In
addition, @code{+}, @code{-}, and @code{...} are identifiers, as is a
sequence of letters, digits, and extended alphabetic characters that
begins with the two--character sequence @code{->}.  Here are some
examples of identifiers:

@example
lambda         q                soup
list->vector   +                V17a
<=             a34kTMNs         ->-
the-word-recursion-has-many-meanings
@end example

Extended alphabetic characters may be used within identifiers as if they
were letters.  The following are extended alphabetic characters:

@example
! $ % & * + - . / : < = > ? @@ ^ _ ~
@end example

Moreover, all characters whose Unicode scalar values are greater than
127 and whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd,
Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co can be used within
identifiers.  In addition, any character can be used within an
identifier when specified via an @meta{inline hex escape}.  For example,
the identifier @code{H\x65;llo} is the same as the identifier
@code{Hello}.
@c , and the identifier @code{\x3BB;} is the same as the
@c identifier $\lambda$.

Any identifier may be used as a variable or as a syntactic keyword
(@ref{basic variables keywords regions} and @ref{syntax macros}) in a
Scheme program.  Any identifier may also be used as a syntactic datum,
in which case it represents a @emph{symbol} (@ref{base symbols}).

@c ------------------------------------------------------------

@c page
@node lex syntax booleans
@subsection Booleans


@noindent
The standard boolean objects for true and false have external
representations @true{} and @false{}.

@c ------------------------------------------------------------

@c page
@node lex syntax characters
@subsection Characters


@noindent
Characters are represented using the notation @code{#\<character>} or
@code{#<character name>} or @code{#x<hex scalar value>}.

For example:

@example
#\a             lower case letter a
#\A             upper case letter A
#\(             left parenthesis
#\              space character
#\nul           U+0000
#\alarm         U+0007
#\backspace     U+0008
#\tab           U+0009
#\linefeed      U+000A
#\newline       U+000A
#\vtab          U+000B
#\page          U+000C
#\return        U+000D
#\esc           U+001B
#\space         U+0020 preferred way to write a space
#\delete        U+007F
#\xFF           U+00FF
#\x03BB         U+03BB
#\x00006587     U+6587
#\x0001z        &lexical exception
#\alarmx        &lexical exception
#\alarm x       U+0007 followed by x
#\Alarm         &lexical exception
#\alert         &lexical exception
#\xA            U+000A
#\xFF           U+00FF
#\xff           U+00FF
#\x ff          U+0078 followed by another datum, ff
#\x(ff)         U+0078 followed by another datum, a parenthesized ff
#\(x)           &lexical exception
#\(x            &lexical exception
#\((x)          U+0028 followed by another datum, parenthesized x
#\x00110000     &lexical exception out of range
#\x000000001    U+0001
#\xD800         &lexical exception in excluded range 
@end example

(The notation @code{&lexical} means that the line in question is a
lexical syntax violation.)

Case is significant in @code{#\<character>}, and in @code{#\<character
name>}, but not in the @code{<hex scalar value>} of @code{#\x<hex scalar
value>}.  A @meta{character} must be followed by a @meta{delimiter} or
by the end of the input.  This rule resolves various ambiguous cases
involving named characters, requiring, for example, the sequence of
characters @code{#\space} to be interpreted as the space character
rather than as the character @code{#\s} followed by the identifier
@code{pace}.

@quotation
@emph{Note:} The @code{#\newline} notation is retained for backward
compatibility.  Its use is deprecated; @code{#\linefeed} should be used
instead.
@end quotation

@c ------------------------------------------------------------

@c page
@node lex syntax strings
@subsection Strings


@noindent
String are represented by sequences of characters enclosed within
doublequotes (@code{"}).  Within a string literal, various escape
sequences represent characters other than themselves.  Escape sequences
always start with a backslash (@code{\}):

@table @code
@item \a
alarm, U+0007
@item \b
backspace, U+0008 
@item \t
character tabulation, U+0009 
@item \n
linefeed, U+000A 
@item \v
line tabulation, U+000B 
@item \f
formfeed, U+000C 
@item \r
return, U+000D 
@item \"
doublequote, U+0022 
@item \
backslash, U+005C 
@item \<intraline whitespace><line ending> <intraline whitespace>
nothing
@item \x<hex scalar value>;
specified character (note the terminating semi--colon).
@end table

These escape sequences are case-sensitive, except that the alphabetic
digits of a @meta{hex scalar value} can be uppercase or lowercase.

Any other character in a string after a backslash is a syntax violation.
Except for a line ending, any character outside of an escape sequence
and not a doublequote stands for itself in the string literal.
@c For example the single--character string literal {\tt "$\lambda$"}
@c (doublequote, a lower case lambda, doublequote) represents the same
@c string as {\tt "\{}x03bb;"}.
A line ending that does not follow a backslash stands for a linefeed
character.

Examples:

@example
"abc"           U+0061, U+0062, U+0063
"\x41;bc"       "Abc" ; U+0041, U+0062, U+0063
"\x41; bc"      "A bc"
                U+0041, U+0020, U+0062, U+0063
"\x41bc;"       U+41BC
"\x41"          &lexical exception
"\x;"           &lexical exception
"\x41bx;"       &lexical exception
"\x00000041;"   "A" ; U+0041
"\x0010FFFF;"   U+10FFFF
"\x00110000;"   &lexical exception
                out of range
"\x000000001;"  U+0001
"\xD800;"       &lexical exception
                in excluded range
"A
bc"             U+0041, U+000A, U+0062, U+0063
                if no space occurs after the A
@end example

@c ------------------------------------------------------------

@c page
@node lex syntax numbers
@subsection Numbers


@noindent
The syntax of external representations for number objects is described
formally by the @meta{number} rule in the formal grammar.  Case is not
significant in external representations of number objects.

A representation of a number object may be written in binary, octal,
decimal, or hexadecimal by the use of a radix prefix.  The radix
prefixes are @code{#b} (binary), @code{#o} (octal), @code{#d} (decimal),
and @code{#x} (hexadecimal).  With no radix prefix, a representation of
a number object is assumed to be expressed in decimal.

A representation of a number object may be specified to be either exact
or inexact by a prefix.  The prefixes are @code{#e} for exact, and
@code{#i} for inexact.  An exactness prefix may appear before or after
any radix prefix that is used.  If the representation of a number object
has no exactness prefix, the constant is inexact if it contains a
decimal point, an exponent, or a nonempty mantissa width; otherwise it
is exact.

In systems with inexact number objects of varying precisions, it may be
useful to specify the precision of a constant.  For this purpose,
representations of number objects may be written with an exponent marker
that indicates the desired precision of the inexact representation.  The
letters @code{s}, @code{f}, @code{d}, and @code{l} specify the use of
@emph{short}, @emph{single}, @emph{double}, and @emph{long} precision,
respectively.  (When fewer than four internal inexact representations
exist, the four size specifications are mapped onto those available.
For example, an implementation with two internal representations may map
short and single together and long and double together.)  In addition,
the exponent marker @code{e} specifies the default precision for the
implementation.  The default precision has at least as much precision as
@emph{double}, but implementations may wish to allow this default to be
set by the user.

@example
3.1415926535898F0 
       Round to single, perhaps 3.141593
0.6L0
       Extend to long, perhaps .600000000000000
@end example

A representation of a number object with nonempty mantissa width,
@code{x|p}, represents the best binary floating--point approximation of
@emph{x} using a @emph{p}--bit significand.  For example, @code{1.1|53}
is a representation of the best approximation of 1.1 in @acronym{IEEE}
double precision.  If @emph{x} is an external representation of an
inexact real number object that contains no vertical bar, then its
numerical value should be computed as though it had a mantissa width of
53 or more.

Implementations that use binary floating--point representations of real
number objects should represent @code{x|p} using a @emph{p}--bit
significand if practical, or by a greater precision if a @emph{p}--bit
significand is not practical, or by the largest available precision if
@emph{p} or more bits of significand are not practical within the
implementation.

@quotation
@emph{Note} The precision of a significand should not be confused with
the number of bits used to represent the significand.  In the
@acronym{IEEE} floating--point standards, for example, the significand's
most significant bit is implicit in single and double precision but is
explicit in extended precision.  Whether that bit is implicit or
explicit does not affect the mathematical precision.  In implementations
that use binary floating point, the default precision can be calculated
by calling the following procedure:

@example
(define (precision)
  (do ([n 0 (+ n 1)]
       [x 1.0 (/ x 2.0)])
    ((= 1.0 (+ 1.0 x)) n)))
@end example
@end quotation      

@quotation
@emph{Note} When the underlying floating--point representation is
@acronym{IEEE} double precision, the @code{|p} suffix should not always
be omitted: Denormalized floating--point numbers have diminished
precision, and therefore their external representations should carry a
@code{|p} suffix with the actual width of the significand.
@end quotation

The literals @code{+inf.0} and @code{-inf.0} represent positive and
negative infinity, respectively.  The @code{+nan.0} literal represents
the NaN that is the result of @code{(/ 0.0 0.0)}, and may represent
other NaNs as well.  The @code{-nan.0} literal also represents a NaN.

If @emph{x} is an external representation of an inexact real number
object and contains no vertical bar and no exponent marker other than
@code{e}, the inexact real number object it represents is a flonum (see
library section ``Flonums'').  Some or all of the other external
representations of inexact real number objects may also represent
flonums, but that is not required by this report.

@c ------------------------------------------------------------

@c page
@node lex datum
@section Datum syntax


@menu
* lex datum formal account::            Formal account.
* lex datum pairs and lists::           Pairs and lists.
* lex datum vectors::                   Vectors.
* lex datum bytevectors::               Bytevectors.
* lex datum abbreviations::             Abbreviations.
@end menu


@noindent
The datum syntax describes the syntax of syntactic data in terms of a
sequence of @meta{lexeme}s, as defined in the lexical syntax.

Syntactic data include the lexeme data described in the previous section
as well as the following constructs for forming compound data:

@itemize
@item
pairs and lists, enclosed by @code{( )} or @code{[ ]};

@item
vectors;

@item
bytevectors.
@end itemize

@c ------------------------------------------------------------

@c page
@node lex datum formal account
@subsection Formal account

@noindent
The following grammar describes the syntax of syntactic data in terms of
various kinds of lexemes defined in the grammar in section ``Lexical
Syntax'':

@example
<datum> -> <lexeme datum>
         | <compound datum>
<lexeme datum> -> <boolean> | <number>
         | <character> | <string> | <symbol>
<symbol> -> <identifier>
<compound datum> -> <list> | <vector> | <bytevector>
<list> -> (<datum>*) | [<datum>*]
         | (<datum>+ . <datum>) | [<datum>+ . <datum>]
         | <abbreviation>
<abbreviation> -> <abbrev prefix> <datum>
<abbrev prefix> -> ' | ` | , | ,@@
         | #' | #` | #, | #,@@
<vector> -> #(<datum>*)
<bytevector> -> #vu8(<u8>*)
<u8> -> <any <number> representing an exact integer in @{0, ..., 255@}>
@end example

@c ------------------------------------------------------------

@c page
@node lex datum pairs and lists
@subsection Pairs and lists


@noindent
List and pair data, representing pairs and lists of values are
represented using parentheses or brackets.  Matching pairs of brackets
that occur in the rules of @meta{list} are equivalent to matching pairs
of parentheses.

The most general notation for Scheme pairs as syntactic data is the
``dotted'' notation @code{(<datum1> . <datum2>)} where @meta{datum1} is
the representation of the value of the car field and @meta{datum2} is
the representation of the value of the cdr field.  For example @code{(4
. 5)} is a pair whose car is 4 and whose cdr is 5.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list is represented by @code{( )}.  For example,

@example
(a b c d e)
@end example

@noindent
and:

@example
(a . (b . (c . (d . (e . ())))))
@end example

@noindent
are equivalent notations for a list of symbols.

The general rule is that, if a dot is followed by an open parenthesis,
the dot, open parenthesis, and matching closing parenthesis can be
omitted in the external representation.

The sequence of characters @code{(4 . 5)} is the external representation
of a pair, not an expression that evaluates to a pair.  Similarly, the
sequence of characters @code{(+ 2 6)} is @emph{not} an external
representation of the integer 8, even though it @emph{is} an expression
(in the language of the @rsixlibrary{base} library) evaluating to the
integer 8; rather, it is a syntactic datum representing a three--element
list, the elements of which are the symbol @code{+} and the integers 2
and 6.

@c ------------------------------------------------------------

@c page
@node lex datum vectors
@subsection Vectors


@noindent
Vector data, representing vectors of objects, are represented using the
notation @code{#(<datum> ...)}.  For example, a vector of length 3
containing the number object for zero in element 0, the list @code{(2 2
2 2)} in element 1, and the string @code{"Anna"} in element 2 can be
represented as follows:

@example
#(0 (2 2 2 2) "Anna")
@end example

This is the external representation of a vector, not an expression that
evaluates to a vector.

@c ------------------------------------------------------------

@c page
@node lex datum bytevectors
@subsection Bytevectors


@noindent
Bytevector data, representing bytevectors (see library chapter
``Bytevectors''), are represented using the notation @code{#vu8(<u8>
...)}, where the @meta{u8}s represent the octets of the bytevector.  For
example, a bytevector of length 3 containing the octets 2, 24, and 123
can be represented as follows:

@example
#vu8(2 24 123)
@end example

This is the external representation of a bytevector, and also an
expression that evaluates to a bytevector.

@c ------------------------------------------------------------

@c page
@node lex datum abbreviations
@subsection Abbreviations


@example
 '<datum>        `<datum>        ,<datum>
,@@<datum>       #'<datum>       #`<datum>
#,<datum>      #,@@<datum>
@end example

Each of these is an abbreviation:

@table @code
@item '<datum>     
for @code{(quote <datum>)},

@item `<datum>     
for @code{(quasiquote <datum>)},

@item ,<datum>     
for @code{(unquote <datum>)},

@item ,@@<datum>     
for @code{(unquote-splicing <datum>)},

@item #'<datum>     
for @code{(syntax <datum>)},

@item #`<datum>     
for @code{(quasisyntax <datum>)},

@item #,<datum>     
for @code{(unsyntax <datum>)}, and

@item #,@@<datum>
for @code{(unsyntax-splicing <datum>)}.
@end table

@c ------------------------------------------------------------

@c page

@c page
@node basic
@chapter Semantic concepts

@ignore
In the original document this chapter was the "basic.tex" file.
@end ignore

@menu
* basic programs and libraries::        Programs and libraries.
* basic variables keywords regions::    Variables, keywords,
                                        and regions.
* basic exceptions::                    Exceptional situations.
* basic argument checking::             Argument checking.
* basic syntax violations::             Syntax violations.
* basic safety::                        Safety.
* basic boolean values::                Boolean values.
* basic multiple return values::        Multiple return values.
* basic unspecified behavior::          Unspecified behavior.
* basic storage model::                 Storage model.
* basic proper tail recursion::         Proper tail recursion.
* basic dynamic extent::                Dynamic extent and the
                                        dynamic environment.
@end menu


@c ------------------------------------------------------------

@c page
@node basic programs and libraries
@section Programs and libraries


A Scheme program consists of a @emph{top--level} program together with a
set of @emph{libraries}, each of which defines a part of the program
connected to the others through explicitly specified exports and
imports.

@itemize
@item
A library consists of a set of export and import specifications and a
body, which consists of definitions, and expressions.

@item
A top--level program is similar to a library, but has no export
specifications.
@end itemize

Chapters ``Libraries'' and ``Top--level programs'' describe the syntax
and semantics of libraries and top--level programs, respectively.
Chapter ``Base library'' describes a base library that defines many of
the constructs traditionally associated with Scheme.  A separate report
@cite{R6RS-libraries} describes the various @emph{standard libraries}
provided by a Scheme system.

The division between the base library and the other standard libraries
is based on use, not on construction.  In particular, some facilities
that are typically implemented as ``primitives'' by a compiler or the
run--time system rather than in terms of other standard procedures or
syntactic forms are not part of the base library, but are defined in
separate libraries.  Examples include the fixnums and flonums libraries,
the exceptions and conditions libraries, and the libraries for records.


@c ------------------------------------------------------------

@c page
@node basic variables keywords regions
@section Variables, keywords, and regions


@cindex Keyword, definition of
@cindex Definition of keyword

@cindex Variable, definition of
@cindex Definition of variable

@cindex Environment, definition of
@cindex Definition of environment

@cindex Binding constructs, definition of
@cindex Definition of binding constructs

@cindex Definitions, definition of
@cindex Definition of definitions

@cindex Region, definition of
@cindex Definition of region


Within the body of a library or top--level program, an identifier may
name a kind of syntax, or it may name a location where a value can be
stored.  An identifier that names a kind of syntax is called a
@emph{keyword}, and is said to be @emph{bound} to that kind of syntax
(or, in the case of a syntactic abstraction, a @emph{transformer} that
translates the syntax into more primitive forms).  An identifier that
names a location is called a @emph{variable} and is said to be
@emph{bound} to that location.  At each point within a top--level
program or a library, a specific, fixed set of identifiers is bound.
The set of these identifiers, the set of @emph{visible bindings}, is
known as the @emph{environment} in effect at that point.

Certain forms are used to create syntactic abstractions and to bind
keywords to transformers for those new syntactic abstractions, while
other forms create new locations and bind variables to those locations.
Collectively, these forms are called @emph{binding constructs}.  Some
binding constructs take the form of @emph{definitions}, while others are
expressions.  With the exception of exported library bindings, a binding
created by a definition is visible only within the body in which the
definition appears, e.g. the body of a library, top--level program, or
@func{lambda} expression.  Exported library bindings are also visible
within the bodies of the libraries and top--level programs that import
them.

Expressions that bind variables include the @func{lambda}, @func{let},
@func{let*}, @func{letrec}, @func{letrec*}, @func{let-values}, and
@func{let*-values} forms from the base library.  Of these, @func{lambda}
is the most fundamental.  Variable definitions appearing within the body
of such an expression, or within the bodies of a library or top--level
program, are treated as a set of @func{letrec*} bindings.  In addition,
for library bodies, the variables exported from the library can be
referenced by importing libraries and top--level programs.

Expressions that bind keywords include the @func{let-syntax} and
@func{letrec-syntax} forms.  A @func{define} form is a definition that
creates a variable binding, and a @code{define-syntax} form is a
definition that creates a keyword binding.

Scheme is a statically scoped language with block structure.  To each
place in a top--level program or library body where an identifier is
bound there corresponds a @emph{region} of code within which the binding
is visible.  The region is determined by the particular binding
construct that establishes the binding; if the binding is established by
a @func{lambda} expression, for example, then its region is the entire
@func{lambda} expression.  Every mention of an identifier refers to the
binding of the identifier that establishes the innermost of the regions
containing the use.  If a use of an identifier appears in a place where
none of the surrounding expressions contains a binding for the
identifier, the use may refer to a binding established by a definition
or import at the top of the enclosing library or top--level program.  If
there is no binding for the identifier, it is said to be @emph{unbound}.

@c ------------------------------------------------------------

@c page
@node basic exceptions
@section Exceptional situations


A variety of exceptional situations are distinguished in this report,
among them violations of syntax, violations of a procedure's
specification, violations of implementation restrictions, and
exceptional situations in the environment.  When an exceptional
situation is detected by the implementation, an @emph{exception is
raised}, which means that a special procedure called the @emph{current
exception handler} is called.  A program can also raise an exception,
and override the current exception handler; see library section
``Exceptions''.

When an exception is raised, an object is provided that describes the
nature of the exceptional situation.  The report uses the condition
system described in library section ``Conditions'' to describe
exceptional situations, classifying them by condition types.

Some exceptional situations allow continuing the program if the
exception handler takes appropriate action.  The corresponding
exceptions are called @emph{continuable}.  For most of the exceptional
situations described in this report, portable programs cannot rely upon
the exception being continuable at the place where the situation was
detected.  For those exceptions, the exception handler that is invoked
by the exception should not return.  In some cases, however, continuing
is permissible, and the handler may return.  See library section
``Exceptions''.

Implementations must raise an exception when they are unable to continue
correct execution of a correct program due to some @emph{implementation
restriction}.  For example, an implementation that does not support
infinities must raise an exception with condition type
@code{&implementation-restriction} when it evaluates an expression whose
result would be an infinity.

Some possible implementation restrictions such as the lack of
representations for NaNs and infinities are anticipated by this report,
and implementations typically must raise an exception of the appropriate
condition type if they encounter such a situation.

This report uses the phrase ``an exception is raised'' synonymously with
``an exception must be raised''.  This report uses the phrase ``an
exception with condition type @var{t}'' to indicate that the object
provided with the exception is a condition object of the specified type.
The phrase ``a continuable exception is raised'' indicates an
exceptional situation that permits the exception handler to return.


@c ------------------------------------------------------------

@c page
@node basic argument checking
@section Argument checking


Many procedures specified in this report or as part of a standard
library restrict the arguments they accept.  Typically, a procedure
accepts only specific numbers and types of arguments.  Many syntactic
forms similarly restrict the values to which one or more of their
subforms can evaluate.  These restrictions imply responsibilities for
both the programmer and the implementation.  Specifically, the
programmer is responsible for ensuring that the values indeed adhere to
the restrictions described in the specification.  The implementation
must check that the restrictions in the specification are indeed met, to
the extent that it is reasonable, possible, and necessary to allow the
specified operation to complete successfully.

Note that it is not always possible for an implementation to completely
check the restrictions set forth in a specification.  For example, if an
operation is specified to accept a procedure with specific properties,
checking of these properties is undecidable in general.  Similarly, some
operations accept both lists and procedures that are called by these
operations.  Since lists can be mutated by the procedures through the
@rsixlibrary{mutable-pairs} library, an argument that is a list when the
operation starts may become a non--list during the execution of the
operation.

Also, the procedure might escape to a different continuation, preventing
the operation from performing more checks.  Requiring the operation to
check that the argument is a list after each call to such a procedure
would be impractical.  Furthermore, some operations that accept lists
only need to traverse these lists partially to perform their function;
requiring the implementation to traverse the remainder of the list to
verify that all specified restrictions have been met might violate
reasonable performance assumptions.  For these reasons, the programmer's
obligations may exceed the checking obligations of the implementation.

When an implementation detects a violation of a restriction for an
argument, it must raise an exception with condition type
@code{&assertion} in a way consistent with the safety of execution as
described in section ``Safety''.

@c ------------------------------------------------------------

@c page
@node basic syntax violations
@section Syntax violations


The subforms of a special form usually need to obey certain syntactic
restrictions.  As forms may be subject to macro expansion, which may not
terminate, the question of whether they obey the specified restrictions
is undecidable in general.

When macro expansion terminates, however, implementations must detect
violations of the syntax.  A @emph{syntax violation} is an error with
respect to the syntax of library bodies, top--level bodies, or the
``syntax'' entries in the specification of the base library or the
standard libraries.  Moreover, attempting to assign to an immutable
variable (i.e. the variables exported by a library) is also considered a
syntax violation.

If a top--level or library form in a program is not syntactically
correct, then the implementation must raise an exception with condition
type @code{&syntax}, and execution of that top--level program or library
must not be allowed to begin.

@c ------------------------------------------------------------

@c page
@node basic safety
@section Safety


The standard libraries whose exports are described by this document are
said to be @emph{safe libraries}.  Libraries and top--level programs
that import only from safe libraries are also said to be safe.

As defined by this document, the Scheme programming language is safe in
the following sense: The execution of a safe top--level program cannot
go so badly wrong as to crash or to continue to execute while behaving
in ways that are inconsistent with the semantics described in this
document, unless an exception is raised.

Violations of an implementation restriction must raise an exception with
condition type @code{&implementation-restriction}, as must all
violations and errors that would otherwise threaten system integrity in
ways that might result in execution that is inconsistent with the
semantics described in this document.

The above safety properties are guaranteed only for top--level programs
and libraries that are said to be safe.  In particular, implementations
may provide access to unsafe libraries in ways that cannot guarantee
safety.

@c ------------------------------------------------------------

@c page
@node basic boolean values
@section Boolean values


Although there is a separate boolean type, any Scheme value can be used
as a boolean value for the purpose of a conditional test.  In a
conditional test, all values count as true in such a test except for
@false{}.  This report uses the word ``true'' to refer to any Scheme
value except @false{}, and the word ``false'' to refer to @false{}.


@c ------------------------------------------------------------

@c page
@node basic multiple return values
@section Multiple return values


A Scheme expression can evaluate to an arbitrary finite number of
values.  These values are passed to the expression's continuation.

Not all continuations accept any number of values. For example, a
continuation that accepts the argument to a procedure call is guaranteed
to accept exactly one value.  The effect of passing some other number of
values to such a continuation is unspecified.  The
@func{call-with-values} procedure makes it possible to create
continuations that accept specified numbers of return values.  If the
number of return values passed to a continuation created by a call to
@func{call-with-values} is not accepted by its consumer that was passed
in that call, then an exception is raised.  A more complete description
of the number of values accepted by different continuations and the
consequences of passing an unexpected number of values is given in the
description of the @func{values} procedure.

A number of forms in the base library have sequences of expressions as
subforms that are evaluated sequentially, with the return values of all
but the last expression being discarded.  The continuations discarding
these values accept any number of values.

@c ------------------------------------------------------------

@c page
@node basic unspecified behavior
@section Unspecified behavior


If an expression is said to ``return unspecified values'', then the
expression must evaluate without raising an exception, but the values
returned depend on the implementation; this report explicitly does not
say how many or what values should be returned.  Programmers should not
rely on a specific number of return values or the specific values
themselves.


@c ------------------------------------------------------------

@c page
@node basic storage model
@section Storage model


Variables and objects such as pairs, vectors, bytevectors, strings,
hashtables, and records implicitly refer to locations or sequences of
locations.  A string, for example, contains as many locations as there
are characters in the string.  (These locations need not correspond to a
full machine word.) A new value may be stored into one of these
locations using the @func{string-set!} procedure, but the string
contains the same locations as before.

An object fetched from a location, by a variable reference or by a
procedure such as @func{car}, @func{vector-ref}, or @func{string-ref},
is equivalent in the sense of @func{eqv?} to the object last stored in
the location before the fetch.

Every location is marked to show whether it is in use.  No variable or
object ever refers to a location that is not in use.  Whenever this
report speaks of storage being allocated for a variable or object, what
is meant is that an appropriate number of locations are chosen from the
set of locations that are not in use, and the chosen locations are
marked to indicate that they are now in use before the variable or
object is made to refer to them.

It is desirable for constants (i.e. the values of literal expressions)
to reside in read-only memory.  To express this, it is convenient to
imagine that every object that refers to locations is associated with a
flag telling whether that object is mutable.  Literal constants, the
strings returned by @func{symbol->string}, records with no mutable
fields, and other values explicitly designated as immutable are
immutable objects, while all objects created by the other procedures
listed in this report are mutable.  An attempt to store a new value into
a location referred to by an immutable object should raise an exception
with condition type @code{&assertion}.


@c ------------------------------------------------------------

@c page
@node basic proper tail recursion
@section Proper tail recursion


Implementations of Scheme must be @emph{properly tail--recursive}.
Procedure calls that occur in certain syntactic contexts called
@emph{tail contexts} are @emph{tail calls}.

A Scheme implementation is properly tail--recursive if it supports an
unbounded number of active tail calls.  A call is @emph{active} if the
called procedure may still return.  Note that this includes regular
returns as well as returns through continuations captured earlier by
@func{call-with-current-continuation} that are later invoked.  In the
absence of captured continuations, calls could return at most once and
the active calls would be those that had not yet returned.  A formal
definition of proper tail recursion can be found in Clinger's paper
``Proper tail recursion and and space efficiency''.  The rules for
identifying tail calls in constructs from the @rsixlibrary{base} library
are described in section ``Tail calls and tail contexts''.


@c ------------------------------------------------------------

@c page
@node basic dynamic extent
@section Dynamic extent and the dynamic environment


@cindex Dynamic extent, definition of
@cindex Definition of dynamic extent

@cindex Dynamic environment, definition of
@cindex Definition of dynamic environment


For a procedure call, the time between when it is initiated and when it
returns is called its @emph{dynamic extent}.  In Scheme,
@func{call-with-current-continuation} allows reentering a dynamic extent
after its procedure call has returned.  Thus, the dynamic extent of a
call may not be a single, connected time period.

Some operations described in the report acquire information in addition
to their explicit arguments from the @emph{dynamic environment}.  For
example, @func{call-with-current-continuation} accesses an implicit
context established by @func{dynamic-wind}, and the @func{raise}
procedure accesses the current exception handler.

The operations that modify the dynamic environment do so dynamically,
for the dynamic extent of a call to a procedure like @func{dynamic-wind}
or @func{with-exception-handler}.  When such a call returns, the
previous dynamic environment is restored.  The dynamic environment can
be thought of as part of the dynamic extent of a call.  Consequently, it
is captured by @func{call-with-current-continuation}, and restored by
invoking the escape procedure it creates.


@c ------------------------------------------------------------

@c page
@node entry
@chapter Entry format

@ignore
In the original document, this chapter was the "entry.tex" file.
@end ignore

The chapters that describe bindings in the base library and the standard
libraries are organized into entries.  Each entry describes one language
feature or a group of related features, where a feature is either a
syntactic construct or a built--in procedure.  An entry begins with one
or more header lines of the form

@deffn Category template
@dots{}
@end deffn

The @emph{Category} defines the kind of binding described by the entry,
typically either ``Syntax'' or ``Procedure''.  An entry may specify
various restrictions on subforms or arguments.


@menu
* entry syntax::                Syntax entries.
* entry procedure::             Procedure entries.
* entry implementation resp::   Implementation responsibilities.
* entry other kinds::           Other kinds of entries.
* entry equivalent::            Equivalent entries.
* entry evaluation examples::   Evaluation examples.
* entry naming conventions::    Naming conventions.
@end menu


@c ------------------------------------------------------------

@c page
@node entry syntax
@section Syntax entries


If @emph{category} is ``Syntax'', the entry describes a special
syntactic construct, and the template gives the syntax of the forms of
the construct.  The template is written in a notation similar to a
right--hand side of the @acronym{BNF} rules in chapter ``Lexical syntax
and datum syntax'', and describes the set of forms equivalent to the
forms matching the template as syntactic data.  Some ``Syntax'' entries
carry a suffix (@code{expand}), specifying that the syntactic keyword of
the construct is exported with level 1.  Otherwise, the syntactic
keyword is exported with level 0; @ref{library import export}.

Components of the form described by a template are designated by
syntactic variables, which are written using angle brackets, for
example, @meta{expression}, @meta{variable}.  Case is insignificant in
syntactic variables.  Syntactic variables stand for other forms, or
sequences of them.  A syntactic variable may refer to a non--terminal in
the grammar for syntactic data, in which case only forms matching that
non--terminal are permissible in that position.  For example,
@meta{identifier} stands for a form which must be an identifier.  Also,
@meta{expression} stands for any form which is a syntactically valid
expression.  Other non--terminals that are used in templates are defined
as part of the specification.

The notation

@example
@hyperi{thing} ...
@end example

@noindent
indicates zero or more occurrences of a @meta{thing}, and

@example
@hyperi{thing} @hyperii{thing} ...
@end example

@noindent
indicates one or more occurrences of a @meta{thing}.

It is the programmer's responsibility to ensure that each component of a
form has the shape specified by a template.  Descriptions of syntax may
express other restrictions on the components of a form.  Typically, such
a restriction is formulated as a phrase of the form ``@meta{x} must be a
@dots{}''.  Again, these specify the programmer's responsibility.  It is
the implementation's responsibility to check that these restrictions are
satisfied, as long as the macro transformers involved in expanding the
form terminate.  If the implementation detects that a component does not
meet the restriction, an exception with condition type @code{&syntax}
is raised.

@c ------------------------------------------------------------

@c page
@node entry procedure
@section Procedure entries


If @emph{Category} is ``Procedure'', then the entry describes a
procedure, and the header line gives a template for a call to the
procedure.  Parameter names in the template are shown like this:
@var{parm}.  Thus the header line:

@deffn Procedure vector-ref @var{vector} @var{k}
@dots{}
@end deffn


@noindent
indicates that the built--in procedure @func{vector-ref} takes two
arguments, a vector @var{vector} and an exact non--negative integer
object @var{k} (see below).  The header lines:

@deffn Procedure make-vector @var{k}
@dots{}
@end deffn

@deffn Procedure make-vector @var{k} @var{fill}
@dots{}
@end deffn

@noindent
indicate that the @func{make-vector} procedure takes either one or two
arguments.  The parameter names are case--insensitive.

As with syntax templates, an ellipsis @dots{} at the end of a header
line, as in:

@deffn Procedure = @vari{z} @varii{z} @variii{z} ...
@dots{}
@end deffn

@noindent
indicates that the procedure takes arbitrarily many arguments of the
same type as specified for the last parameter name.  In this case,
@code{=} accepts two or more arguments that must all be complex number
objects.

A procedure that detects an argument that it is not specified to handle
must raise an exception with condition type @code{&assertion}.  Also,
the argument specifications are exhaustive: if the number of arguments
provided in a procedure call does not match any number of arguments
accepted by the procedure, an exception with condition type
@code{&assertion} must be raised.

For succinctness, the report follows the convention that if a parameter
name is also the name of a type, then the corresponding argument must be
of the named type.  For example, the header line for @func{vector-ref}
given above dictates that the first argument to @func{vector-ref} must
be a vector.  The following naming conventions imply type restrictions:

@table @var
@item obj
any object;

@item z
complex number object;

@item x
real number object;

@item y
real number object;

@item q
rational number object;

@item n
integer object;

@item k
exact non--negative integer object;

@item bool
boolean (@false{} or @true{});

@item octet
exact integer object in @{0, @dots{}, 255@};

@item byte
exact integer object in @{-128, @dots{}, 127@};

@item char
character;

@item pair
pair;

@item vector
vector;

@item string
string;

@item condition
condition;

@item bytevector
bytevector;

@item proc
procedure.
@end table

Other type restrictions are expressed through parameter--naming
conventions that are described in specific chapters.  For example,
library chapter ``Arithmetic'' uses a number of special parameter
variables for the various subsets of the numbers.

With the listed type restrictions, it is the programmer's responsibility
to ensure that the corresponding argument is of the specified type.  It
is the implementation's responsibility to check for that type.

A parameter called @var{list} means that it is the programmer's
responsibility to pass an argument that is a list.  It is the
implementation's responsibility to check that the argument is
appropriately structured for the operation to perform its function, to
the extent that this is possible and reasonable.  The implementation
must at least check that the argument is either an empty list or a pair.

Descriptions of procedures may express other restrictions on the
arguments of a procedure.  Typically, such a restriction is formulated
as a phrase of the form ``@var{x} must be a @dots{}'' (or otherwise
using the word ``must'').

@c ------------------------------------------------------------

@c page
@node entry implementation resp
@section Implementation responsibilities


In addition to the restrictions implied by naming conventions, an entry
may list additional explicit restrictions.  These explicit restrictions
usually describe both the programmer's responsibilities, who must ensure
that the subforms of a form are appropriate, or that an appropriate
argument is passed, and the implementation's responsibilities, which
must check that subform adheres to the specified restrictions (if macro
expansion terminates), or if the argument is appropriate.

A description may explicitly list the implementation's responsibilities
for some arguments or subforms in a paragraph labeled ``Implementation
responsibilities''.  In this case, the responsibilities specified for
these subforms or arguments in the rest of the description are only for
the programmer.  A paragraph describing implementation responsibility
does not affect the implementation's responsibilities for checking
subforms or arguments not mentioned in the paragraph.


@c ------------------------------------------------------------

@c page
@node entry other kinds
@section Other kinds of entries


If @emph{Category} is something other than ``Syntax'' and ``Procedure'',
then the entry describes a non--procedural value, and the
@emph{category} describes the type of that value.  The header line:

@deffn {Condition Type} {&who}
@dots{}
@end deffn

@noindent
indicates that @code{&who} is a condition type.  The header line:

@deffn {Auxiliary Syntax} unquote
@dots{}
@end deffn

@noindent
indicates that @func{unquote} is a syntax binding that may occur only as
part of specific surrounding expressions.  Any use as an independent
syntactic construct or identifier is a syntax violation.  As with
``Syntax'' entries, some ``Auxiliary Syntax'' entries carry a suffix
(@code{expand}), specifying that the syntactic keyword of the construct
is exported with level 1.

@c ------------------------------------------------------------

@c page
@node entry equivalent
@section Equivalent entries


The description of an entry occasionally states that it is @emph{the
same} as another entry.  This means that both entries are equivalent.
Specifically, it means that if both entries have the same name and are
thus exported from different libraries, the entries from both libraries
can be imported under the same name without conflict.


@c ------------------------------------------------------------

@c page
@node entry evaluation examples
@section Evaluation examples


The symbol @code{=>} used in program examples can be read ``evaluates
to''.  For example:

@example
(* 5 8)
=> 40
@end example

@noindent
means that the expression @code{(* 5 8)} evaluates to the object
@code{40}.  Or, more precisely: the expression given by the sequence of
characters @code{(* 5 8)} evaluates, in an environment that imports the
relevant library, to an object that may be represented externally by the
sequence of characters @code{40}.

The @code{=>} symbol is also used when the evaluation of an expression
causes a violation.  For example:

@example
(integer->char #xD800)
=> &assertion exception
@end example

@noindent
means that the evaluation of the expression @code{(integer->char
#xD800)} must raise an exception with condition type @code{&assertion}.

Moreover, the @code{=>} symbol is also used to explicitly say that the
value of an expression in unspecified.  For example:

@example
(eqv? "" "")
=> unspecified
@end example

Mostly, examples merely illustrate the behavior specified in the entry.
In some cases, however, they disambiguate otherwise ambiguous
specifications and are thus normative.  Note that, in some cases,
specifically in the case of inexact number objects, the return value is
only specified conditionally or approximately.  For example:

@example
(atan -inf.0)
=> -1.5707963267948965 ; approximately
@end example

@c ------------------------------------------------------------

@c page
@node entry naming conventions
@section Naming conventions


By convention, the names of procedures that store values into previously
allocated locations usually end in @code{!}.

By convention, @code{->} appears within the names of procedures that
take an object of one type and return an analogous object of another
type.  For example, @func{list->vector} takes a list and returns a
vector whose elements are the same as those of the list.

By convention, the names of predicates (procedures that always return a
boolean value) end in @code{?} when the name contains any letters;
otherwise, the predicate's name does not end with a question mark.

By convention, the components of compound names are separated by
@code{-}.  In particular, prefixes that are actual words or can be
pronounced as though they were actual words are followed by a hyphen,
except when the first character following the hyphen would be something
other than a letter, in which case the hyphen is omitted.  Short,
unpronounceable prefixes (@code{fx} and @code{fl}) are not followed by a
hyphen.

By convention, the names of condition types start with @code{&}.

@c ------------------------------------------------------------

@c page
@node library
@chapter Libraries


@ignore
In the original document this chapter was the "library.tex" file.
@end ignore

Libraries are parts of a program that can be distributed independently.
The library system supports macro definitions within libraries, macro
exports, and distinguishes the phases in which definitions and imports
are needed.  This chapter defines the notation for libraries and a
semantics for library expansion and execution.

@menu
* library form::                Library form.
* library import export::       Import and export levels.
* library examples::            Examples.
@end menu


@c ------------------------------------------------------------

@c page
@node library form
@section Library form


A library definition must have the following form:

@example
(library @meta{library name}
  (export @meta{export spec} @dots{})
  (import @meta{import spec} @dots{})
  @meta{library body})
@end example

A library declaration contains the following elements:

@itemize
@item 
The @meta{library name} specifies the name of the library (possibly with
version).

@item 
The @code{export} subform specifies a list of exports, which name a
subset of the bindings defined within or imported into the library.

@item 
The @code{import} subform specifies the imported bindings as a list of
import dependencies, where each dependency specifies:

@itemize -
@item 
the imported library's name, and, optionally, constraints on its
version,

@item 
the relevant levels, e.g. expand or run time,

@item 
the subset of the library's exports to make available within the
importing library, and the local names to use within the importing
library for each of the library's exports.
@end itemize

@item 
The @meta{library body} is the library body, consisting of a sequence of
definitions followed by a sequence of expressions.  The definitions may
be both for local (unexported) and exported bindings, and the
expressions are initialization expressions to be evaluated for their
effects.
@end itemize

An identifier can be imported with the same local name from two or more
libraries or for two levels from the same library only if the binding
exported by each library is the same (i.e., the binding is defined in
one library, and it arrives through the imports only by exporting and
re--exporting).  Otherwise, no identifier can be imported multiple
times, defined multiple times, or both defined and imported.  No
identifiers are visible within a library except for those explicitly
imported into the library or defined within the library.

A @meta{library name} uniquely identifies a library within an
implementation, and is globally visible in the @code{import} clauses
(see below) of all other libraries within an implementation.  A
@meta{library name} has the following form:

@example
(@hyperi{identifier} @hyperii{identifier} @dots{} @meta{version})
@end example

@noindent
where @meta{version} is empty or has the following form:

@example
(@meta{sub-version} @dots{})
@end example

Each @meta{sub-version} must represent an exact nonnegative integer
object.  An empty @meta{version} is equivalent to @code{()}.

An @meta{export spec} names a set of imported and locally defined
bindings to be exported, possibly with different external names.  An
@meta{export spec} must have one of the following forms:

@example
@meta{identifier}
(rename (@hyperi{identifier} @hyperii{identifier}) @dots{})
@end example

In an @meta{export spec}, an @meta{identifier} names a single binding
defined within or imported into the library, where the external name for
the export is the same as the name of the binding within the library.  A
@func{rename} spec exports the binding named by @hyperi{identifier} in
each @code{(@hyperi{identifier} @hyperii{identifier})} pairing, using
@hyperii{identifier} as the external name.

Each @meta{import spec} specifies a set of bindings to be imported into
the library, the levels at which they are to be available, and the local
names by which they are to be known.  An @meta{import spec} must be one
of the following:

@example
@meta{import set}
(for @meta{import set} @meta{import level} @dots{})
@end example

An @meta{import level} is one of the following:

@example
run
expand
(meta @meta{level})
@end example

@noindent
where @meta{level} represents an exact integer object.

As an @meta{import level}, @code{run} is an abbreviation for @code{(meta
0)}, and @code{expand} is an abbreviation for @code{(meta 1)}.

An @meta{import set} names a set of bindings from another library and
possibly specifies local names for the imported bindings.  It must be
one of the following:

@example
@meta{library reference}
(library @meta{library reference})
(only @meta{import set} @meta{identifier} ...)
(except @meta{import set} @meta{identifier} ...)
(prefix @meta{import set} @meta{identifier})
(rename @meta{import set} (@hyperi{identifier} @hyperii{identifier}) ...)
@end example

A @meta{library reference} identifies a library by its name and
optionally by its version.  It has one of the following forms:

@example
(@hyperi{identifier} @hyperii{identifier} ...)
(@hyperi{identifier} @hyperii{identifier} ... @meta{version reference})
@end example

A @meta{library reference} whose first @meta{identifier} is @code{for},
@code{library}, @code{only}, @code{except}, @code{prefix}, or
@code{rename} is permitted only within a @code{library} @meta{import
set}.  The @meta{import set} @code{(library @meta{library reference})}
is otherwise equivalent to @meta{library reference}.

A @meta{library reference} with no @meta{version reference} (first form
above) is equivalent to a @meta{library reference} with a @meta{version
reference} of @code{()}.

A @meta{version reference} specifies a set of @meta{version}s that it
matches.  The @meta{library reference} identifies all libraries of the
same name and whose version is matched by the @meta{version reference}.
A @meta{version reference} has the following form:

@example
(@hyperi{sub-version reference} ... @hypern{sub-version reference})
(and @meta{version reference} ...)
(or @meta{version reference} @dots{})
(not @meta{version reference})
@end example

A @meta{version reference} of the first form matches a @meta{version}
with at least @var{n} elements, whose @meta{sub-version reference}s
match the corresponding @meta{sub-version}s.  An @code{and}
@hyper{version reference} matches a version if all @meta{version
references} following the @code{and} match it.  Correspondingly, an
@code{or} @meta{version reference} matches a version if one of
@meta{version references} following the @code{or} matches it, and a
@code{not} @meta{version reference} matches a version if the
@meta{version reference} following it does not match it.

A @meta{sub-version reference} has one of the following forms:

@example
@meta{sub-version}
(>= @meta{sub-version})
(<= @meta{sub-version})
(and @meta{sub-version reference} @dots{})
(or @meta{sub-version reference} @dots{})
(not @meta{sub-version reference})
@end example

A @meta{sub-version reference} of the first form matches a
@meta{sub-version} if it is equal to it.  A @code{>=} @meta{sub-version
reference} of the first form matches a sub--version if it is greater or
equal to the @meta{sub-version} following it; analogously for @code{<=}.
An @code{and} @meta{sub-version reference} matches a sub--version if all
of the subsequent @hyper{sub-version reference}s match it.

Correspondingly, an @code{or} @meta{sub-version reference} matches a
sub--version if one of the subsequent @meta{sub-version reference}s
matches it, and a @code{not} @meta{sub-version reference} matches a
sub--version if the subsequent @meta{sub-version reference} does not
match it.

Examples:

@multitable {abcdefghilmnopqrstuvz} {abcdefghi} {match?}
@headitem version reference @tab version @tab match?
@item @code{()} @tab @code{(1)} @tab yes
@item @code{(1)} @tab @code{(1)} @tab yes
@item @code{(1)} @tab @code{(2)} @tab no
@item @code{(2 3)} @tab @code{(2)} @tab no
@item @code{(2 3)} @tab @code{(2 3)} @tab yes
@item @code{(2 3)} @tab @code{(2 3 5)} @tab yes
@item @code{(or (1 (>= 1)) (2))} @tab @code{(2)} @tab yes
@item @code{(or (1 (>= 1)) (2))} @tab @code{(1 1)} @tab yes
@item @code{(or (1 (>= 1)) (2))} @tab @code{(1 0)} @tab no
@item @code{((or 1 2 3))} @tab @code{(1)} @tab yes
@item @code{((or 1 2 3))} @tab @code{(2)} @tab yes
@item @code{((or 1 2 3))} @tab @code{(3)} @tab yes
@item @code{((or 1 2 3))} @tab @code{(4)} @tab no
@end multitable

When more than one library is identified by a library reference, the
choice of libraries is determined in some implementation-dependent
manner.

To avoid problems such as incompatible types and replicated state,
implementations should prohibit the two libraries whose library names
consist of the same sequence of identifiers but whose versions do not
match to co--exist in the same program.

By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the
bindings by the imported library.  The precise set of bindings to be
imported and the names of those bindings can be adjusted with the
@code{only}, @code{except}, @code{prefix}, and @code{ rename} forms as
described below.

@itemize
@item 
An @code{only} form produces a subset of the bindings from another
@meta{import set}, including only the listed @meta{identifier}s.  The
included @meta{identifier}s must be in the original @meta{import set}.

@item 
An @code{except} form produces a subset of the bindings from another
@meta{import set}, including all but the listed @meta{identifier}s.  All
of the excluded @meta{identifier}s must be in the original @meta{import
set}.

@item 
A @code{prefix} form adds the @meta{identifier} prefix to each name from
another @meta{import set}.

@item 
A @code{rename} form:

@example
(rename (@hyperi{identifier} @hyperii{identifier}) @dots{})
@end example

@noindent
removes the bindings for @code{@hyperi{identifier} @dots{}} to form an
intermediate @meta{import set}, then adds the bindings back for the
corresponding @code{@hyperii{identifier} @dots{}} to form the final
@meta{import set}.  Each @hyperi{identifier} must be in the original
@meta{import set}, each @hyperii{identifier} must not be in the
intermediate @meta{import set}, and the @hyperii{identifier}s must be
distinct.
@end itemize

It is a syntax violation if a constraint given above is not met.

The @meta{library body} of a @code{library} form consists of forms that
are classified as @emph{definitions} or @emph{expressions}.  Which forms
belong to which class depends on the imported libraries and the result
of expansion.  Generally, forms that are not definitions are
expressions.

A @meta{library body} is like a @meta{body} except that a @meta{library
body}s need not include any expressions.  It must have the following
form:

@example
@meta{definition} @dots{} @meta{expression} @dots{}
@end example

When @func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms
occur in a top--level body prior to the first expression, they are
spliced into the body.  Some or all of the body, including portions
wrapped in @func{begin}, @func{let-syntax}, or @func{letrec-syntax}
forms, may be specified by a syntactic abstraction.

The transformer expressions and bindings are evaluated and created from
left to right, as described in chapter ``Expansion process''.  The
expressions of variable definitions are evaluated from left to right, as
if in an implicit @func{letrec*}, and the body expressions are also
evaluated from left to right after the expressions of the variable
definitions.  A fresh location is created for each exported variable and
initialized to the value of its local counterpart.  The effect of
returning twice to the continuation of the last body expression is
unspecified.

@quotation
@emph{Note:} 
The names @code{library}, @code{export}, @code{import}, @code{for},
@code{run}, @code{expand}, @code{meta}, @code{import}, @code{ export},
@code{only}, @code{except}, @code{prefix}, @code{rename}, @code{and},
@code{or}, @code{not}, @code{>=}, and @code{<=} appearing in the library
syntax are part of the syntax and are not reserved, i.e., the same names
can be used for other purposes within the library or even exported from
or imported into a library with different meanings, without affecting
their use in the @code{library} form.
@end quotation

Bindings defined with a library are not visible in code outside of the
library, unless the bindings are explicitly exported from the library.
An exported macro may, however, @emph{implicitly export} an otherwise
unexported identifier defined within or imported into the library.  That
is, it may insert a reference to that identifier into the output code it
produces.

All explicitly exported variables are immutable in both the exporting
and importing libraries.  It is thus a syntax violation if an explicitly
exported variable appears on the left--hand side of a @func{set!}
expression, either in the exporting or importing libraries.

All implicitly exported variables are also immutable in both the
exporting and importing libraries.  It is thus a syntax violation if a
variable appears on the left-hand side of a @code{set!}  expression in
any code produced by an exported macro outside of the library in which
the variable is defined.  It is also a syntax violation if a reference
to an assigned variable appears in any code produced by an exported
macro outside of the library in which the variable is defined, where an
assigned variable is one that appears on the left--hand side of a
@func{set!} expression in the exporting library.

All other variables defined within a library are mutable.

@c ------------------------------------------------------------

@c page
@node library import export
@section Import and export levels


Expanding a library may require run--time information from another
library.  For example, if a macro transformer calls a procedure from
library @emph{A}, then the library @emph{A} must be instantiated before
expanding any use of the macro in library @emph{B}.  Library @emph{A}
may not be needed when library @emph{B} is eventually run as part of a
program, or it may be needed for run time of library @emph{B}, too.  The
library mechanism distinguishes these times by phases, which are
explained in this section.

Every library can be characterized by expand--time information
(minimally, its imported libraries, a list of the exported keywords, a
list of the exported variables, and code to evaluate the transformer
expressions) and run--time information (minimally, code to evaluate the
variable definition right--hand--side expressions, and code to evaluate
the body expressions).  The expand--time information must be available
to expand references to any exported binding, and the run--time
information must be available to evaluate references to any exported
variable binding.

A @emph{phase} is a time at which the expressions within a library are
evaluated.  Within a library body, top--level expressions and the
right--hand sides of @func{define} forms are evaluated at run time,
i.e. phase @emph{0}, and the right--hand sides of @func{define-syntax}
forms are evaluated at expand time, i.e. phase @emph{1}.  When
@func{define-syntax}, @func{let-syntax}, or @func{letrec-syntax} forms
appear within code evaluated at phase @emph{n}, the right--hand sides
are evaluated at phase @emph{n+1}.

These phases are relative to the phase in which the library itself is
used.  An @emph{instance} of a library corresponds to an evaluation of
its variable definitions and expressions in a particular phase relative
to another library---a process called @emph{instantiation}.  For
example, if a top--level expression in a library @emph{B} refers to a
variable export from another library @emph{A}, then it refers to the
export from an instance of @emph{A} at phase @emph{0} (relative to the
phase of @emph{B}).  But if a phase @emph{1} expression within @emph{B}
refers to the same binding from @emph{A}, then it refers to the export
from an instance of @emph{A} at phase @emph{1} (relative to the phase of
@emph{B}).

A @emph{visit} of a library corresponds to the evaluation of its syntax
definitions in a particular phase relative to another library; a process
called @emph{visiting}.  For example, if a top--level expression in a
library @emph{B} refers to a macro export from another library @emph{A},
then it refers to the export from a visit of @emph{A} at phase @emph{0}
(relative to the phase of @emph{B}), which corresponds to the evaluation
of the macro's transformer expression at phase @emph{1}.

A @emph{level} is a lexical property of an identifier that determines in
which phases it can be referenced.  The level for each identifier bound
by a definition within a library is @emph{0}; that is, the identifier
can be referenced only at phase @emph{0} within the library.  The level
for each imported binding is determined by the enclosing @code{for} form
of the @code{import} in the importing library, in addition to the levels
of the identifier in the exporting library.  Import and export levels
are combined by pairwise addition of all level combinations.  For
example, references to an imported identifier exported for levels
@emph{p_a} and @emph{p_b} and imported for levels @emph{q_a},
@emph{q_b}, and @emph{q_c} are valid at levels @emph{p_a + q_a},
@emph{p_a + q_b}, @emph{p_a + q_c}, @emph{p_b + q_a}, @emph{p_b + q_b},
and @emph{p_b + q_c}.  An @meta{import set} without an enclosing
@code{for} is equivalent to @code{(for @meta{import set} run)}, which is
the same as @code{(for @meta{import set} (meta 0))}.

The export level of an exported binding is @emph{0} for all bindings
that are defined within the exporting library.  The export levels of a
reexported binding, i.e. an export imported from another library, are
the same as the effective import levels of that binding within the
reexporting library.

For the libraries defined in the library report, the export level is
@emph{0} for nearly all bindings.  The exceptions are
@func{syntax-rules}, @func{identifier-syntax}, @code{...}, and @code{_}
from the @rsixlibrary{base} library, which are exported with level
@emph{1}, @func{set!} from the @rsixlibrary{base} library, which is
exported with levels @emph{0} and @emph{1}, and all bindings from the
composite @code{(rnrs (6))} library, which are exported with levels
@emph{0} and @emph{1}.

Macro expansion within a library can introduce a reference to an
identifier that is not explicitly imported into the library.  In that
case, the phase of the reference must match the identifier's level as
shifted by the difference between the phase of the source library (i.e.,
the library that supplied the identifier's lexical context) and the
library that encloses the reference.  For example, suppose that
expanding a library invokes a macro transformer, and the evaluation of
the macro transformer refers to an identifier that is exported from
another library (so the phase @emph{1} instance of the library is used);
suppose further that the value of the binding is a syntax object
representing an identifier with only a level @emph{n} binding; then, the
identifier must be used only at phase @emph{n+1} in the library being
expanded.  This combination of levels and phases is why negative levels
on identifiers can be useful, even though libraries exist only at
non--negative phases.

If any of a library's definitions are referenced at phase @emph{0} in
the expanded form of a program, then an instance of the referenced
library is created for phase @emph{0} before the program's definitions
and expressions are evaluated.  This rule applies transitively: if the
expanded form of one library references at phase @emph{0} an identifier
from another library, then before the referencing library is
instantiated at phase @emph{n}, the referenced library must be
instantiated at phase @emph{n}.  When an identifier is referenced at any
phase @emph{n} greater than @emph{0}, in contrast, then the defining
library is instantiated at phase @emph{n} at some unspecified time
before the reference is evaluated.  Similarly, when a macro keyword is
referenced at phase @emph{n} during the expansion of a library, then the
defining library is visited at phase @emph{n} at some unspecified time
before the reference is evaluated.

An implementation may distinguish instances/visits of a library for
different phases or to use an instance/visit at any phase as an
instance/visit at any other phase.  An implementation may further expand
each @code{library} form with distinct visits of libraries in any phase
and/or instances of libraries in phases above @emph{0}.  An
implementation may create instances/visits of more libraries at more
phases than required to satisfy references.  When an identifier appears
as an expression in a phase that is inconsistent with the identifier's
level, then an implementation may raise an exception either at expand
time or run time, or it may allow the reference.  Thus, a library whose
meaning depends on whether the instances of a library are distinguished
or shared across phases or @code{library} expansions may be unportable.


@c ------------------------------------------------------------

@c page
@node library examples
@section Examples


Examples for various @meta{import spec}s and @meta{export spec}s:

@example
(library (stack)
  (export make push! pop! empty!)
  (import (rnrs)
          (rnrs mutable-pairs))

  (define (make)
    (list '()))
  (define (push! s v)
    (set-car! s (cons v (car s))))
  (define (pop! s)
    (let ([v (caar s)])
      (set-car! s (cdar s))
      v))
  (define (empty! s)
    (set-car! s '())))

(library (balloons)
  (export make push pop)
  (import (rnrs))

  (define (make w h)
    (cons w h))
  (define (push b amt)
    (cons (- (car b) amt)
          (+ (cdr b) amt)))
  (define (pop b)
    (display "Boom! ") 
    (display (* (car b) (cdr b))) 
    (newline)))

(library (party)
  ;; Total exports:
  ;; make, push, push!, make-party, pop!
  (export (rename (balloon:make make)
                  (balloon:push push))
          push!
          make-party
          (rename (party-pop! pop!)))
  (import (rnrs)
          (only (stack) make push! pop!) ; not empty!
          (prefix (balloons) balloon:))

  ;; Creates a party as a stack of balloons,
  ;; starting with two balloons
  (define (make-party)
    (let ([s (make)]) ; from stack
      (push! s (balloon:make 10 10))
      (push! s (balloon:make 12 9))
      s))
  (define (party-pop! p)
    (balloon:pop (pop! p))))


(library (main)
  (export)
  (import (rnrs) (party))

  (define p (make-party))
  (pop! p)        ; displays "Boom! 108"
  (push! p (push (make 5 5) 1))
  (pop! p))       ; displays "Boom! 24"
@end example

Examples for macros and phases:

@example
(library (my-helpers id-stuff)
  (export find-dup)
  (import (rnrs))

  (define (find-dup l)
    (and (pair? l)
         (let loop ((rest (cdr l)))
           (cond
            [(null? rest) (find-dup (cdr l))]
            [(bound-identifier=? (car l) (car rest)) 
             (car rest)]
            [else (loop (cdr rest))])))))

(library (my-helpers values-stuff)
  (export mvlet)
  (import (rnrs) (for (my-helpers id-stuff) expand))

  (define-syntax mvlet
    (lambda (stx)
      (syntax-case stx ()
        [(_ [(id ...) expr] body0 body ...)
         (not (find-dup (syntax (id ...))))
         (syntax
           (call-with-values
               (lambda () expr) 
             (lambda (id ...) body0 body ...)))]))))

(library (let-div)
  (export let-div)
  (import (rnrs)
          (my-helpers values-stuff)
          (rnrs r5rs))

  (define (quotient+remainder n d)
    (let ([q (quotient n d)])
      (values q (- n (* q d)))))
  (define-syntax let-div
    (syntax-rules ()
      [(_ n d (q r) body0 body ...)
       (mvlet [(q r) (quotient+remainder n d)]
         body0 body ...)])))
@end example


@c ------------------------------------------------------------

@c page
@node programs
@chapter Top--level programs


@ignore
In the original document this chapter is the "programs.tex" file.
@end ignore


A ``top--level program'' specifies an entry point for defining and
running a Scheme program.  A top--level program specifies a set of
libraries to import and code to run.  Through the imported libraries,
whether directly or through the transitive closure of importing, a
top--level program defines a complete Scheme program.


@menu
* programs syntax::             Top-level program syntax.
* programs semantics::          Top-level program semantics.
@end menu


@c ------------------------------------------------------------

@c page
@node programs syntax
@section Top--level program syntax


A top--level program is a delimited piece of text, typically a file,
that has the following form:

@example
@meta{import form} @hyper{top-level body}
@end example

An @meta{import form} has the following form:

@example
(import @meta{import spec} @dots{})
@end example

A @meta{top-level body} has the following form:

@example
@meta{top-level body form} @dots{}
@end example

A @meta{top-level body form} is either a @hyper{definition} or an
@meta{expression}.

The @meta{import form} is identical to the import clause in libraries,
and specifies a set of libraries to import.  A @meta{top-level body} is
like a @meta{library body}, except that definitions and expressions may
occur in any order.  Thus, the syntax specified by @meta{top-level body
form} refers to the result of macro expansion.

When uses of @func{begin}, @func{let-syntax}, or @func{letrec-syntax}
from the @rsixlibrary{base} library occur in a top--level body prior to
the first expression, they are spliced into the body.  Some or all of
the body, including portions wrapped in @func{begin}, @func{let-syntax},
or @func{letrec-syntax} forms, may be specified by a syntactic
abstraction.

@c ------------------------------------------------------------


@c page
@node programs semantics
@section Top--level program semantics


A top--level program is executed by treating the program similarly to a
library, and evaluating its definitions and expressions.  The semantics
of a top--level body may be roughly explained by a simple translation
into a library body: Each @meta{expression} that appears before a
definition in the top-level body is converted into a dummy definition

@example
(define @meta{variable}
  (begin @meta{expression} @meta{unspecified}))
@end example

where @meta{variable} is a fresh identifier and @meta{unspecified} is a
side--effect--free expression returning an unspecified value.  (It is
generally impossible to determine which forms are definitions and
expressions without concurrently expanding the body, so the actual
translation is somewhat more complicated.)

On platforms that support it, a top--level program may access its
command line by calling the @func{command-line} procedure (see library
section ``Command--line access and exit values'').


@c ------------------------------------------------------------

@c page
@node syntax
@chapter Primitive syntax


@ignore
In the original document this chapter is the "syntax.tex" file.
@end ignore

After the @code{import} form within a @code{library} form or a
top--level program, the forms that constitute the body of the library or
the top--level program depend on the libraries that are imported.  In
particular, imported syntactic keywords determine the available
syntactic abstractions and whether each form is a definition or
expression.  A few form types are always available independent of
imported libraries, however, including constant literals, variable
references, procedure calls, and macro uses.

@menu
* syntax primitive::            Primitive expression types.
* syntax macros::               Macros.
@end menu


@c ------------------------------------------------------------

@c page
@node syntax primitive
@section Primitive expression types


The entries in this section all describe expressions, which may occur in
the place of @meta{expression} syntactic variables.


@subsubheading Constant literals

@deffn Syntax @meta{number}
@deffnx Syntax @meta{boolean}
@deffnx Syntax @meta{character}
@deffnx Syntax @meta{string}
@deffnx Syntax @meta{bytevector}
An expression consisting of a representation of a number object, a
boolean, a character, a string, or a bytevector, evaluates ``to
itself''.

@example
145932          =>  145932
#t              =>  #t
"abc"           =>  "abc"
#vu8(2 24 123)  => #vu8(2 24 123)
@end example

As noted in section ``Storage model'', the value of a literal expression
is immutable.
@end deffn

@c ------------------------------------------------------------

@subsubheading Variable references

@deffn Syntax @meta{variable}
An expression consisting of a variable is a variable reference if it is
not a macro use (see below).  The value of the variable reference is the
value stored in the location to which the variable is bound.  It is a
syntax violation to reference an unbound variable.

The following example examples assumes the base library has been
imported:

@example
(define x 28)
x   =>  28
@end example
@end deffn

@c ------------------------------------------------------------

@subsubheading Procedure calls

@deffn Syntax (@meta{operator} @hyperi{operand} @dots{})
A procedure call consists of expressions for the procedure to be called
and the arguments to be passed to it, with enclosing parentheses.  A
form in an expression context is a procedure call if @meta{operator} is
not an identifier bound as a syntactic keyword.

When a procedure call is evaluated, the operator and operand expressions
are evaluated (in an unspecified order) and the resulting procedure is
passed the resulting arguments.

The following examples assume the @rsixlibrary{base} library has been
imported:

@example
(+ 3 4)                 =>  7
((if #f + *) 3 4)       =>  12
@end example

If the value of @meta{operator} is not a procedure, an exception with
condition type @code{&assertion} is raised.  Also, if @meta{operator}
does not accept as many arguments as there are @meta{operand}s, an
exception with condition type @code{&assertion} is raised.

@quotation
@emph{Note:} In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.

Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure
call.
@end quotation

@quotation
@emph{Note:} In many dialects of Lisp, the form @code{()} is a
legitimate expression.  In Scheme, expressions written as list/pair
forms must have at least one subexpression, so @code{()} is not a
syntactically valid expression.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node syntax macros
@section Macros


@cindex Transformer, definition of
@cindex Definition of transformer
@cindex Macro transformer, definition of
@cindex Definition of macro transformer


Libraries and top--level programs can define and use new kinds of
derived expressions and definitions called @emph{syntactic abstractions}
or @emph{macros}.  A syntactic abstraction is created by binding a
keyword to a @emph{macro transformer} or, simply, @emph{transformer}.

The transformer determines how a use of the macro (called a @emph{macro
use}) is transcribed into a more primitive form.

Most macro uses have the form:

@example
(@meta{keyword} @meta{datum} @dots{})
@end example

@noindent
where @meta{keyword} is an identifier that uniquely determines the kind
of form.  This identifier is called the @emph{syntactic keyword}, or
simply @emph{keyword}.  The number of @meta{datum}s and the syntax of
each depends on the syntactic abstraction.

Macro uses can also take the form of improper lists, singleton
identifiers, or @func{set!} forms, where the second subform of the
@func{set!} is the keyword:

@example
(@meta{keyword} @meta{datum} @dots{} . @meta{datum})
@meta{keyword}
(set! @meta{keyword} @meta{datum})
@end example

The @func{define-syntax}, @func{let-syntax} and @func{letrec-syntax}
forms create bindings for keywords, associate them with macro
transformers, and control the scope within which they are visible.

The @func{syntax-rules} and @func{identifier-syntax} forms create
transformers via a pattern language.  Moreover, the @func{syntax-case}
form allows creating transformers via arbitrary Scheme code.

Keywords occupy the same name space as variables.  That is, within the
same scope, an identifier can be bound as a variable or keyword, or
neither, but not both, and local bindings of either kind may shadow
other bindings of either kind.

Macros defined using @func{syntax-rules} and @func{identifier-syntax}
are ``hygienic'' and ``referentially transparent'' and thus preserve
Scheme's lexical scoping.

@itemize
@item 
If a macro transformer inserts a binding for an identifier (variable or
keyword) not appearing in the macro use, the identifier is in effect
renamed throughout its scope to avoid conflicts with other identifiers.

@item 
If a macro transformer inserts a free reference to an identifier, the
reference refers to the binding that was visible where the transformer
was specified, regardless of any local bindings that may surround the
use of the macro.
@end itemize

Macros defined using the @func{syntax-case} facility are also hygienic
unless @func{datum->syntax} is used.


@c ------------------------------------------------------------

@c page
@node expansion
@chapter Expansion process


@ignore
In the original document this chapter is the file "expansion.tex".
@end ignore


Macro uses are expanded into @emph{core forms} at the start of
evaluation (before compilation or interpretation) by a syntax
@emph{expander}.  The set of core forms is implementation--dependent, as
is the representation of these forms in the expander's output.  If the
expander encounters a syntactic abstraction, it invokes the associated
transformer to expand the syntactic abstraction, then repeats the
expansion process for the form returned by the transformer.  If the
expander encounters a core form, it recursively processes its subforms
that are in expression or definition context, if any, and reconstructs
the form from the expanded subforms.  Information about identifier
bindings is maintained during expansion to enforce lexical scoping for
variables and keywords.

To handle definitions, the expander processes the initial forms in a
@meta{body} or @meta{library body} from left to right.  How the expander
processes each form encountered depends upon the kind of form.

@table @asis
@item macro use
The expander invokes the associated transformer to transform the macro
use, then recursively performs whichever of these actions are
appropriate for the resulting form.

@item @func{define-syntax} form
The expander expands and evaluates the right--hand--side expression and
binds the keyword to the resulting transformer.

@item @func{define} form
The expander records the fact that the defined identifier is a variable
but defers expansion of the right--hand--side expression until after all
of the definitions have been processed.

@item @func{begin} form
The expander splices the subforms into the list of body forms it is
processing.

@item @func{let-syntax} or @func{letrec-syntax} form
The expander splices the inner body forms into the list of (outer) body
forms it is processing, arranging for the keywords bound by the
@func{let-syntax} and @func{letrec-syntax} to be visible only in the
inner body forms.

@item expression, i.e., nondefinition
The expander completes the expansion of the deferred right--hand--side
expressions and the current and remaining expressions in the body, and
then creates the equivalent of a @func{letrec*} form from the defined
variables, expanded right--hand--side expressions, and expanded body
expressions.
@end table

For the right--hand side of the definition of a variable, expansion is
deferred until after all of the definitions have been seen.
Consequently, each keyword and variable reference within the right--hand
side resolves to the local binding, if any.

A definition in the sequence of forms must not define any identifier
whose binding is used to determine the meaning of the undeferred
portions of the definition or any definition that precedes it in the
sequence of forms.  For example, the bodies of the following expressions
violate this restriction.

@example
(let ()
  (define define 17)
  (list define))

(let-syntax ([def0 (syntax-rules ()
                     [(_ x) (define x 0)])])
  (let ([z 3])
    (def0 z)
    (define def0 list)
    (list z)))

(let ()
  (define-syntax foo
    (lambda (e)
      (+ 1 2)))
  (define + 2)
  (foo))%
@end example

The following do not violate the restriction.

@example
(let ([x 5])
  (define lambda list)
  (lambda x x))         =>  (5 5)

(let-syntax ([def0 (syntax-rules ()
                     [(_ x) (define x 0)])])
  (let ([z 3])
    (define def0 list)
    (def0 z)
    (list z)))          =>  (3)

(let ()
  (define-syntax foo
    (lambda (e)
      (let ([+ -]) (+ 1 2))))
  (define + 2)
  (foo))                =>  -1%
@end example

The implementation should treat a violation of the restriction as a
syntax violation.

Note that this algorithm does not directly reprocess any form.  It
requires a single left--to--right pass over the definitions followed by
a single pass (in any order) over the body expressions and deferred
right--hand sides.

Example:

@example
(lambda (x)
  (define-syntax defun
    (syntax-rules ()
      [(_ x a e) (define x (lambda a e))]))
  (defun even? (n) (or (= n 0) (odd? (- n 1))))
  (define-syntax odd?
    (syntax-rules () [(_ n) (not (even? n))]))
  (odd? (if (odd? x) (* x x) x)))
@end example

In the example:

@enumerate
@item
The definition of @func{defun} is encountered first, and the keyword
@func{defun} is associated with the transformer resulting from the
expansion and evaluation of the corresponding right--hand side.

@item
A use of @func{defun} is encountered next and expands into a
@func{define} form.  Expansion of the right--hand side of this
@func{define} form is deferred.

@item
The definition of @func{odd?} is next and results in the association of
the keyword @func{odd?} with the transformer resulting from expanding
and evaluating the corresponding right--hand side.

@item
A use of @func{odd?}  appears next and is expanded; the resulting call
to @func{not} is recognized as an expression because @func{not} is bound
as a variable.

@item
At this point, the expander completes the expansion of the current
expression (the call to @func{not}) and the deferred right--hand side of
the @func{even?}  definition; the uses of @func{odd?} appearing in these
expressions are expanded using the transformer associated with the
keyword @func{odd?}.

@item
The final output is the equivalent of:

@example
(lambda (x)
  (letrec* ([even?
              (lambda (n)
                (or (= n 0)
                    (not (even? (- n 1)))))])
    (not (even? (if (not (even? x)) (* x x) x)))))
@end example

@noindent
although the structure of the output is implementation-dependent.
@end enumerate

Because definitions and expressions can be interleaved in a
@meta{top-level body}, the expander's processing of a @meta{top-level
body} is somewhat more complicated.  It behaves as described above for a
@meta{body} or @meta{library body} with the following exceptions:

@itemize
@item
When the expander finds a nondefinition, it defers its expansion and
continues scanning for definitions.

@item
Once it reaches the end of the set of forms, it processes the deferred
right--hand--side and body expressions, then generates the equivalent of
a @func{letrec*} form from the defined variables, expanded
right--hand--side expressions, and expanded body expressions.

@item
For each body expression @meta{expression} that appears before a
variable definition in the body, a dummy binding is created at the
corresponding place within the set of @func{letrec*} bindings, with a
fresh temporary variable on the left--hand side and the equivalent of:

@example
(begin @meta{expression} @meta{unspecified})
@end example

@noindent
where @meta{unspecified} is a side--effect--free expression returning an
unspecified value, on the right--hand side, so that left--to--right
evaluation order is preserved.  The @func{begin} wrapper allows
@meta{expression} to evaluate to an arbitrary number of values.
@end itemize


@c ------------------------------------------------------------

@c page
@node base
@chapter Base library


@ignore
In the original document this chapter is the "base.tex" file.
@end ignore

This chapter describes Scheme's @rsixlibrary{base} library, which
exports many of the procedure and syntax bindings that are traditionally
associated with Scheme.


@menu
* base types::                  Base types.
* base definitions::            Definitions.
* base bodies::                 Bodies.
* base expressions::            Expressions.
* base predicates::             Equivalence and procedure
                                predicates.
* base math::                   Mathematics.
* base booleans::               Booleans.
* base lists::                  Pairs and lists.
* base symbols::                Symbols.
* base characters::             Characters.
* base strings::                Strings.
* base vectors::                Vectors.
* base errors::                 Errors and violations.
* base control::                Control features.
* base iteration::              Iteration.
* base quasiquotation::         Quasiquotation.
* base syntax binding::         Binding constructs for syntactic
                                keywords.
* base transformers::           Macro transformers.
* base tail call::              Tail calls and tail contexts.
@end menu


@c ------------------------------------------------------------

@c page
@node base types
@section Base types


No object satisfies more than one of the following predicates:

@example
boolean?          pair?
symbol?           number?
char?             string?
vector?           procedure?
null?
@end example

These predicates define the base types @emph{boolean}, @emph{pair},
@emph{symbol}, @emph{number}, @emph{char} (or @emph{character}),
@emph{string}, @emph{vector}, and @emph{procedure}.  Moreover, the empty
list is a special object of its own type.

Note that, although there is a separate boolean type, any Scheme value
can be used as a boolean value for the purpose of a conditional test.


@c ------------------------------------------------------------

@c page
@node base definitions
@section Definitions


Definitions may appear within a @meta{top-level body}, at the top of a
@meta{library body}, or at the top of a @meta{body}.

A @meta{definition} may be a variable definition or keyword definition.
Macro uses that expand into definitions or groups of definitions
(packaged in a @func{begin}, @func{let-syntax}, or @func{letrec-syntax}
form) may also appear wherever other definitions may appear.


@menu
* base definitions variables::  Variables definitions.
* base definitions syntax::     Syntax definitions.
@end menu


@c ------------------------------------------------------------

@c page
@node base definitions variables
@subsection Variables definitions


The @func{define} form described in this section is a @meta{definition}
used to create variable bindings and may appear anywhere other
definitions may appear.


@deffn Syntax define @meta{variable} @hyper{expression}
@deffnx Syntax define @meta{variable}
@deffnx Syntax define @meta{variable} @hyper{formals}) @hyper{body}
@deffnx Syntax define (@meta{variable} . @hyper{formal}) @hyper{body})
The first from of @func{define} binds @meta{variable} to a new location
before assigning the value of @meta{expression} to it.

@example
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            =>  6
(define first car)
(first '(1 2))                      =>  1
@end example

The continuation of @meta{expression} should not be invoked more than
once.

@strong{Implementation responsibilities:} Implementations should detect
that the continuation of @meta{expression} is invoked more than once.
If the implementation detects this, it must raise an exception with
condition type @code{&assertion}.

The second form of @func{define} is equivalent to:

@example
(define @meta{variable} @hyper{unspecified})
@end example

@noindent
where @meta{unspecified} is a side--effect--free expression returning an
unspecified value.

In the third form of @func{define}, @meta{formals} must be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a dot @code{.} and another variable (as in a
lambda expression).  This form is equivalent to:

@example
(define @meta{variable}
  (lambda (@meta{formals}) @hyper{body}))
@end example

In the fourth form of @func{define}, @meta{formal} must be a single
variable.  This form is equivalent to:

@example
(define @meta{variable}
  (lambda @meta{formal} @hyper{body}))
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base definitions syntax
@subsection Syntax definitions


The @code{define-syntax} form described in this section is a
@meta{definition} used to create keyword bindings and may appear
anywhere other definitions may appear.


@deffn Syntax define-syntax @meta{keyword} @hyper{expression}
Binds @meta{keyword} to the value of @meta{expression}, which must
evaluate, at macro--expansion time, to a transformer.  Macro
transformers can be created using the @func{syntax-rules} and
@func{identifier-syntax} forms.

Keyword bindings established by @func{define-syntax} are visible
throughout the body in which they appear, except where shadowed by other
bindings, and nowhere else, just like variable bindings established by
@func{define}.  All bindings established by a set of definitions,
whether keyword or variable definitions, are visible within the
definitions themselves.

@strong{Implementation responsibilities:} The implementation should
detect if the value of @meta{expression} cannot possibly be a
transformer.

Example:

@example
(let ()
  (define even?
    (lambda (x)
      (or (= x 0) (odd? (- x 1)))))
  (define-syntax odd?
    (syntax-rules ()
      ((odd?  x) (not (even? x)))))
  (even? 10))
=> #t
@end example

An implication of the left--to--right processing order is that one
definition can affect whether a subsequent form is also a definition.

Example:

@example
(let ()
  (define-syntax bind-to-zero
    (syntax-rules ()
      ((bind-to-zero id) (define id 0))))
  (bind-to-zero x)
  x)
=> 0
@end example

The behavior is unaffected by any binding for @func{bind-to-zero} that
might appear outside of the @func{let} expression.
@end deffn


@c ------------------------------------------------------------

@c page
@node base bodies
@section Bodies


The @meta{body} of a @func{lambda}, @func{let}, @func{let*},
@func{let-values}, @func{let*-values}, @func{letrec}, or @func{letrec*}
expression, or that of a definition with a body consists of zero or more
definitions followed by one or more expressions.

@example
@meta{definition} @dots{} @hyperi{expression} @hyperii{expression} @dots{}
@end example

Each identifier defined by a definition is local to the @meta{body}.
That is, the identifier is bound, and the region of the binding is the
entire @meta{body}.

Example:

@example
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))
=>  45
@end example

When @func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms
occur in a body prior to the first expression, they are spliced into the
body.  Some or all of the body, including portions wrapped in
@func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms, may be
specified by a macro use.

An expanded @meta{body} containing variable definitions can always be
converted into an equivalent @func{letrec*} expression.  For example,
the @func{let} expression in the above example is equivalent to

@example
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
@end example


@c ------------------------------------------------------------

@c page
@node base expressions
@section Expressions


The entries in this section describe the expressions of the
@rsixlibrary{base} library, which may occur in the position of the
@meta{expression} syntactic variable in addition to the primitive
expression types.


@menu
* base expressions quotation::          Quotation.
* base expressions procedures::         Procedures.
* base expressions conditionals::       Conditionals.
* base expressions assignments::        Assignments.
* base expressions derived cond::       Derived conditionals.
* base expressions binding::            Binding constructs.
* base expressions sequencing::         Sequencing.
@end menu


@c ------------------------------------------------------------

@c page
@node base expressions quotation
@subsection Quotation


@deffn Syntax quote @meta{datum}
@meta{Datum} should be a syntactic datum.  @code{(quote @meta{datum})}
evaluates to the datum value represented by @meta{datum}.  This notation
is used to include constants.

@example
(quote a)               =>  a
(quote #(a b c))        =>  #(a b c)
(quote (+ 1 2))         =>  (+ 1 2)
@end example

@code{(quote @meta{datum})} may be abbreviated as @code{'@meta{datum}}:

@example
'"abc"               =>  "abc"
'145932              =>  145932
'a                   =>  a
'#(a b c)            =>  #(a b c)
'()                  =>  ()
'(+ 1 2)             =>  (+ 1 2)
'(quote a)           =>  (quote a)
''a                  =>  (quote a)
@end example

Constants are immutable.

@quotation
@emph{Note:} Different constants that are the value of a @func{quote}
expression may share the same locations.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base expressions procedures
@subsection Procedures


@deffn Syntax lambda @meta{formals} @hyper{body}
@meta{formals} must be a formal parameter list as described below, and
@meta{body} must be as described in @ref{base bodies}.

A @func{lambda} evaluates to a procedure.  The environment in effect
when the @func{lambda} is evaluated is remembered as part of the
procedure.  When the procedure is later called with some arguments, the
environment in which the @func{lambda} was evaluated is extended by
binding the variables in the parameter list to fresh locations, and the
resulting argument values are stored in those locations.  Then, the
expressions in the body of the @func{lambda} (which may contain
definitions and thus represent a @func{letrec*} form) are evaluated
sequentially in the extended environment.  The results of the last
expression in the body are returned as the results of the procedure
call.

@example
(lambda (x) (+ x x))      =>  a procedure
((lambda (x) (+ x x)) 4)  =>  8

((lambda (x)
   (define (p y)
     (+ y 1))
   (+ (p x) x))
 5) => 11

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         =>  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        =>  10
@end example

@meta{formals} must have one of the following forms:

@table @code
@item (@hyperi{variable} @dots{})
The procedure takes a fixed number of arguments; when the procedure is
called, the arguments are stored in the bindings of the corresponding
variables.

@item @meta{variable}
The procedure takes any number of arguments; when the procedure is
called, the sequence of arguments is converted into a newly allocated
list, and the list is stored in the binding of the @meta{variable}.

@item (@hyperi{variable} @dots{} @meta{variableN} . @meta{variableN+1})
If a period @code{.} precedes the last variable, then the procedure
takes @var{n} or more arguments, where @var{n} is the number of
parameters before the period (there must be at least one).  The value
stored in the binding of the last variable is a newly allocated list of
the arguments left over after all the other arguments have been matched
up against the other parameters.

@example
((lambda x x) 3 4 5 6)          =>  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       =>  (5 6)
@end example
@end table

Any @meta{variable} must not appear more than once in @meta{formals}.
@end deffn


@c ------------------------------------------------------------

@c page
@node base expressions conditionals
@subsection Conditionals


@deffn Syntax if @meta{test} @meta{consequent} @meta{alternate}
@deffnx Syntax if @meta{test} @meta{consequent}
@meta{test}, @meta{consequent}, and @meta{alternate} must be
expressions.

An @func{if} expression is evaluated as follows: first, @meta{test} is
evaluated.  If it yields a true value, then @meta{consequent} is
evaluated and its values are returned.  Otherwise @meta{alternate} is
evaluated and its values are returned.  If @meta{test} yields @false{}
and no @meta{alternate} is specified, then the result of the expression
is unspecified.

@example
(if (> 3 2) 'yes 'no)           => yes
(if (> 2 3) 'yes 'no)           => no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    => 1
(if #f #f)                      => unspecified
@end example

The @meta{consequent} and @meta{alternate} expressions are in tail
context if the @func{if} expression itself is.
@end deffn


@c ------------------------------------------------------------

@c page
@node base expressions assignments
@subsection Assignments


@deffn Syntax set! @meta{variable} @meta{expression}
@meta{expression} is evaluated, and the resulting value is stored in the
location to which @meta{variable} is bound.  @meta{variable} must be
bound either in some region expression or at the top level.  The result
of the @func{set!} expression is unspecified.

@example
(let ((x 2))
  (+ x 1)
  (set! x 4)
  (+ x 1)) =>  5
@end example

It is a syntax violation if @meta{variable} refers to an immutable
binding.

@quotation
@emph{Note:} The identifier @func{set!} is exported with level @emph{1}
as well.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base expressions derived cond
@subsection Derived conditionals


@deffn Syntax cond @hyperi{cond clause} @hyperii{cond clause} @dots{}
@deffnx {Auxiliary Syntax} {=>}
@deffnx {Auxiliary Syntax} else
Each @meta{cond clause} must be of the form:

@example
(@meta{test} @hyperi{expression} @dots{})
@end example

@noindent
where @meta{test} is an expression.  Alternatively, a @meta{cond clause}
may be of the form:

@example
(@meta{test} => @meta{expression})
@end example

The last @meta{cond clause} may be an ``@code{else} clause'', which has
the form:

@example
(else @hyperi{expression} @hyperii{expression} @dots{})
@end example

A @func{cond} expression is evaluated by evaluating the @meta{test}
expressions of successive @meta{cond clause}s in order until one of them
evaluates to a true value.  When a @meta{test} evaluates to a true
value, then the remaining @meta{expression}s in its @meta{cond clause}
are evaluated in order, and the results of the last @meta{expression} in
the @meta{cond clause} are returned as the results of the entire
@func{cond} expression.

If the selected @meta{cond clause} contains only the @meta{test} and no
@meta{expression}s, then the value of the @meta{test} is returned as the
result.  If the selected @meta{cond clause} uses the @code{=>} alternate
form, then the @meta{expression} is evaluated.  Its value must be a
procedure.  This procedure should accept one argument; it is called on
the value of the @meta{test} and the values returned by this procedure
are returned by the @func{cond} expression.

If all @meta{test}s evaluate to @false{}, and there is no @code{else}
clause, then the conditional expression returns unspecified values; if
there is an @code{else} clause, then its @meta{expression}s are
evaluated, and the values of the last one are returned.

@example
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))          => greater

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            => equal

(cond ('(1 2 3) => cadr)
      (else #f))                => 2
@end example

For a @meta{cond clause} of one of the following forms:

@example
(@meta{test} @hyperi{expression} @dots{})
(else @hyperi{expression} @hyperii{expression} @dots{})
@end example

@noindent
the last @meta{expression} is in tail context if the @func{cond} form
itself is.  For a @meta{cond clause} of the form:

@example
(@meta{test} => @meta{expression})
@end example

@noindent
the (implied) call to the procedure that results from the evaluation of
@meta{expression} is in a tail context if the @func{cond} form itself
is.
@end deffn


@deffn Syntax case @meta{key} @hyperi{case clause} @hyperii{case clause} @dots{}
@meta{key} must be an expression.  Each @meta{case clause} must have one
of the following forms:

@example
((@hyperi{datum} @dots{}) @hyperi{expression} @hyperii{expression} @dots{})
(else @hyperi{expression} @hyperii{expression} @dots{})
@end example

The second form, which specifies an ``@code{else} clause'', may only
appear as the last @meta{case clause}.  Each @meta{datum} is an external
representation of some object.  The data represented by the
@meta{datum}s need not be distinct.

A @func{case} expression is evaluated as follows.

@enumerate
@item
@meta{key} is evaluated and its result is compared using @func{eqv?}
against the data represented by the @meta{datum}s of each @meta{case
clause} in turn, proceeding in order from left to right through the set
of clauses.

@item
If the result of evaluating @meta{key} is equivalent to a datum of a
@meta{case clause}, the corresponding @meta{expression}s are evaluated
from left to right and the results of the last expression in the
@meta{case clause} are returned as the results of the @func{case}
expression.  Otherwise, the comparison process continues.

@item
If the result of evaluating @meta{key} is different from every datum in
each set, then if there is an @code{else} clause its expressions are
evaluated and the results of the last are the results of the @func{case}
expression; otherwise the @func{case} expression returns unspecified
values.
@end enumerate

@example
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     => composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     => unspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))            => consonant
@end example

The last @meta{expression} of a @meta{case clause} is in tail context if
the @func{case} expression itself is.
@end deffn


@deffn Syntax and @hyperi{test} @dots{}
The @meta{test}s must be expressions.

If there are no @meta{test}s, @true{} is returned.  Otherwise, the
@meta{test} expressions are evaluated from left to right until a
@meta{test} returns @false{} or the last @meta{test} is reached.  In the
former case, the @func{and} expression returns @false{} without
evaluating the remaining expressions.  In the latter case, the last
expression is evaluated and its values are returned.

@example
(and (= 2 2) (> 2 1))           =>  #t
(and (= 2 2) (< 2 1))           =>  #f
(and 1 2 'c '(f g))             =>  (f g)
(and)                           =>  #t
@end example

The @func{and} keyword could be defined in terms of @func{if} using
@func{syntax-rules} as follows:

@example
(define-syntax and
  (syntax-rules ()
    ((and) #t)
    ((and test) test)
    ((and test1 test2 ...)
     (if test1 (and test2 ...) #t))))
@end example

The last @meta{test} expression is in tail context if the @func{and}
expression itself is.
@end deffn


@deffn Syntax or @hyperi{test} @dots{}
The @meta{test}s must be expressions.

If there are no @meta{test}s, @false{} is returned.  Otherwise, the
@meta{test} expressions are evaluated from left to right until a
@meta{test} returns a true value @var{val} or the last @meta{test} is
reached.  In the former case, the @func{or} expression returns @var{val}
without evaluating the remaining expressions.  In the latter case, the
last expression is evaluated and its values are returned.

@example
(or (= 2 2) (> 2 1))            => #t
(or (= 2 2) (< 2 1))            => #t
(or #f #f #f)                   => #f
(or '(b c) (/ 3 0))             => (b c)
@end example

The @func{or} keyword could be defined in terms of @func{if} using
@func{syntax-rules} as follows:

@example
(define-syntax or
  (syntax-rules ()
    ((or) #f)
    ((or test) test)
    ((or test1 test2 ...)
     (let ((x test1))
       (if x x (or test2 ...))))))
@end example

The last @meta{test} expression is in tail context if the @func{or}
expression itself is.
@end deffn


@c ------------------------------------------------------------

@c page
@node base expressions binding
@subsection Binding constructs


The binding constructs described in this section create local bindings
for variables that are visible only in a delimited region.  The syntax
of the constructs @func{let}, @func{let*}, @func{letrec}, and
@func{letrec*} is identical, but they differ in the regions they
establish for their variable bindings and in the order in which the
values for the bindings are computed.

@itemize
@item
In a @func{let} expression, the initial values are computed before any
of the variables become bound; in a @func{let*} expression, the bindings
and evaluations are performed sequentially.

@item
In a @func{letrec} or @func{letrec*} expression, all the bindings are in
effect while their initial values are being computed, thus allowing
mutually recursive definitions.

@item
In a @func{letrec} expression, the initial values are computed before
being assigned to the variables; in a @func{letrec*}, the evaluations
and assignments are performed sequentially.
@end itemize

In addition, the binding constructs @func{let-values} and
@func{let*-values} generalize @func{let} and @func{let*} to allow
multiple variables to be bound to the results of expressions that
evaluate to multiple values.  They are analogous to @func{let} and
@func{let*} in the way they establish regions: in a @func{let-values}
expression, the initial values are computed before any of the variables
become bound; in a @func{let*-values} expression, the bindings are
performed sequentially.

@deffn Syntax let @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{base bodies}.  Any variable must not appear more than once in
the @meta{variable}s.

The @meta{init}s are evaluated in the current environment (in some
unspecified order), the @meta{variable}s are bound to fresh locations
holding the results, the @meta{body} is evaluated in the extended
environment, and the values of the last expression of @meta{body} are
returned.  Each binding of a @meta{variable} has @meta{body} as its
region.

@example
(let ((x 2) (y 3))
  (* x y))                      => 6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   => 35
@end example

See also named @func{let}.
@end deffn


@deffn Syntax {let*} @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{base bodies}.

The @func{let*} form is similar to @func{let}, but the @meta{init}s are
evaluated and bindings created sequentially from left to right, with the
region of each binding including the bindings to its right as well as
@meta{body}.  Thus the second @meta{init} is evaluated in an environment
in which the first binding is visible and initialized, and so on.

@example
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             => 70
@end example

@quotation
@emph{Note:} While the variables bound by a @func{let} expression must
be distinct, the variables bound by a @func{let*} expression need not be
distinct.
@end quotation
@end deffn


@deffn Syntax letrec @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{base bodies}.  Any variable must not appear more than once in
the @meta{variable}s.

The @meta{variable}s are bound to fresh locations, the @meta{init}s are
evaluated in the resulting environment (in some unspecified order), each
@meta{variable} is assigned to the result of the corresponding
@meta{init}, the @meta{body} is evaluated in the resulting environment,
and the values of the last expression in @meta{body} are returned.  Each
binding of a @meta{variable} has the entire @func{letrec} expression as
its region, making it possible to define mutually recursive procedures.

@example
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))   
=> #t
@end example

It should be possible to evaluate each @meta{init} without assigning or
referring to the value of any @meta{variable}.  In the most common uses
of @func{letrec}, all the @meta{init}s are @func{lambda}s and the
restriction is satisfied automatically.  Another restriction is that the
continuation of each @meta{init} should not be invoked more than once.

@strong{Implementation responsibilities:} Implementations must detect
references to a @meta{variable} during the evaluation of the @meta{init}
expressions (using one particular evaluation order and order of
evaluating the @meta{init} expressions).  If an implementation detects
such a violation of the restriction, it must raise an exception with
condition type @code{&assertion}.  Implementations may or may not detect
that the continuation of each @meta{init} is invoked more than once.
However, if the implementation detects this, it must raise an exception
with condition type @code{&assertion}.
@end deffn

@deffn Syntax {letrec*} @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{base bodies}.  Any variable must not appear more than once in
the @meta{variable}s.

The @meta{variable}s are bound to fresh locations, each @meta{variable}
is assigned in left--to--right order to the result of evaluating the
corresponding @meta{init}, the @meta{body} is evaluated in the resulting
environment, and the values of the last expression in @meta{body} are
returned.  Despite the left--to--right evaluation and assignment order,
each binding of a @meta{variable} has the entire @func{letrec*}
expression as its region, making it possible to define mutually
recursive procedures.

@example
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
=>  5
@end example

It must be possible to evaluate each @meta{init} without assigning or
referring to the value of the corresponding @meta{variable} or the
@meta{variable} of any of the bindings that follow it in
@meta{bindings}.  Another restriction is that the continuation of each
@meta{init} should not be invoked more than once.

@strong{Implementation responsibilities:} Implementations must, during
the evaluation of an @meta{init} expression, detect references to the
value of the corresponding @meta{variable} or the @meta{variable} of any
of the bindings that follow it in @meta{bindings}.  If an implementation
detects such a violation of the restriction, it must raise an exception
with condition type @code{&assertion}.  Implementations may or may not
detect that the continuation of each @meta{init} is invoked more than
once.  However, if the implementation detects this, it must raise an
exception with condition type @code{&assertion}.
@end deffn


@deffn Syntax let-values @meta{mv-bindings} @meta{body}
@meta{mv-bindings} must have the form:

@example
((@hyperi{formals} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{base bodies}.  Any variable must not appear more than once in
the set of @meta{formals}.

The @meta{init}s are evaluated in the current environment (in some
unspecified order), and the variables occurring in the @meta{formals}
are bound to fresh locations containing the values returned by the
@meta{init}s, where the @meta{formals} are matched to the return values
in the same way that the @meta{formals} in a @func{lambda} are matched
to the arguments in a procedure call.  Then, the @meta{body} is
evaluated in the extended environment, and the values of the last
expression of @meta{body} are returned.  Each binding of a variable has
@meta{body} as its region.  If the @meta{formals} do not match, an
exception with condition type @code{&assertion} is raised.

@example
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d))
=> (1 2 3 4)

(let-values (((a b . c) (values 1 2 3 4)))
  (list a b c))
=> (1 2 (3 4))

(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let-values (((a b) (values x y))
               ((x y) (values a b)))
    (list a b x y)))
=> (x y a b)
@end example
@end deffn


@deffn Syntax {let*-values} @meta{mv-bindings} @meta{body}
@meta{mv-bindings} must have the form:

@example
((@hyperi{formals} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{base bodies}.  In each @meta{formals}, any variable must not
appear more than once.

The @func{let*-values} form is similar to @func{let-values}, but the
@meta{init}s are evaluated and bindings created sequentially from left
to right, with the region including the bindings to its right as well as
@meta{body}.  Thus the second @meta{init} is evaluated in an environment
in which the bindings of the first @meta{formals} is visible and
initialized, and so on.

@example
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))
=> (x y x y)
@end example

@quotation
@emph{Note:} While all of the variables bound by a @func{let-values}
expression must be distinct, the variables bound by different
@meta{formals} of a @func{let*-values} expression need not be distinct.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base expressions sequencing
@subsection Sequencing


@deffn Syntax begin @meta{form} @dots{}
@deffnx Syntax begin @meta{expression} @meta{expression} @dots{}
The @meta{begin} keyword has two different roles, depending on its
context:

@itemize
@item 
It may appear as a form in a @meta{body}, @meta{library body}, or
@meta{top-level body}, or directly nested in a @func{begin} form that
appears in a body.  In this case, the @func{begin} form must have the
shape specified in the first header line.  This use of @func{begin} acts
as a @emph{splicing} form: the forms inside the @meta{body} are spliced
into the surrounding body, as if the @func{begin} wrapper were not
actually present.
  
A @func{begin} form in a @meta{body} or @meta{library body} must be
non--empty if it appears after the first @meta{expression} within the
body.

@item 
It may appear as an ordinary expression and must have the shape
specified in the second header line.  In this case, the
@meta{expression}s are evaluated sequentially from left to right, and
the values of the last @meta{expression} are returned.  This expression
type is used to sequence side effects such as assignments or input and
output.
@end itemize

@example
(define x 0)

(begin (set! x 5)
       (+ x 1))
=>  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))
=>  unspecified and prints 4 plus 1 equals 5
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base predicates
@section Equivalence and procedure predicates


A @emph{predicate} is a procedure that always returns a boolean value
(@true{} or @false{}).  An @emph{equivalence predicate} is the
computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, @func{eq?} is the finest or most
discriminating, and @func{equal?} is the coarsest.  The @func{eqv?}
predicate is slightly less discriminating than @func{eq?}.


@deffn Procedure {eqv?} @vari{obj} @varii{obj}
The @func{eqv?} procedure defines a useful equivalence relation on
objects.  Briefly, it returns @true{} if @vari{obj} and @varii{obj}
should normally be regarded as the same object and @false{} otherwise.
This relation is left slightly open to interpretation, but the following
partial specification of @func{eqv?} must hold for all implementations.

The @func{eqv?} procedure returns @true{} if one of the following holds:

@itemize
@item 
@vari{obj} and @varii{obj} are both booleans and are the same according
to the @func{boolean=?} procedure.

@item 
@vari{obj} and @varii{obj} are both symbols and are the same according
to the @func{symbol=?} procedure.

@item 
@vari{obj} and @varii{obj} are both exact number objects and are
numerically equal (see @code{=}).

@item 
@vari{obj} and @varii{obj} are both inexact number objects, are
numerically equal (see @code{=}), and yield the same results (in the
sense of @func{eqv?}) when passed as arguments to any other procedure
that can be defined as a finite composition of Scheme's standard
arithmetic procedures.

@item 
@vari{obj} and @varii{obj} are both characters and are the same
character according to the @code{char=?} procedure.

@item 
Both @vari{obj} and @varii{obj} are the empty list.

@item 
@vari{obj} and @varii{obj} are objects such as pairs, vectors,
bytevectors (library chapter ``Bytevectors''), strings, hashtables,
records (library chapter ``Records''), ports (library section ``Port
I/O''), or hashtables (library chapter ``Hash tables'') that refer to
the same locations in the store.

@item 
@vari{obj} and @varii{obj} are record--type descriptors that are
specified to be @func{eqv?} in library section ``Procedural layer''.
@end itemize

The @func{eqv?} procedure returns @false{} if one of the following
holds:

@itemize
@item 
@vari{obj} and @varii{obj} are of different types.

@item 
@vari{obj} and @varii{obj} are booleans for which the @func{boolean=?}
procedure returns @false{}.

@item 
@vari{Obj} and @varii{obj} are symbols for which the @func{symbol=?}
procedure returns @false{}.

@item 
One of @vari{obj} and @varii{obj} is an exact number object but the
other is an inexact number object.

@item 
@vari{obj} and @varii{obj} are rational number objects for which the
@code{=} procedure returns @false{}.

@item 
@vari{Obj} and @varii{obj} yield different results (in the sense of
@func{eqv?}) when passed as arguments to any other procedure that can be
defined as a finite composition of Scheme's standard arithmetic
procedures.

@item 
@vari{obj} and @varii{obj} are characters for which the @func{char=?}
procedure returns @false{}.

@item 
One of @vari{obj} and @varii{obj} is the empty list, but the other is
not.

@item 
@vari{obj} and @varii{obj} are objects such as pairs, vectors,
bytevectors (library chapter ``Bytevectors''), strings, records (library
chapter ``Records''), ports (library section ``Port I/O''), or
hashtables (library chapter ``Hashtables'') that refer to distinct
locations.

@item 
@vari{obj} and @varii{obj} are pairs, vectors, strings, or records, or
hashtables, where the applying the same accessor (i.e. @func{car},
@func{cdr}, @func{vector-ref}, @func{string-ref}, or record accessors)
to both yields results for which @func{eqv?} returns @false{}.

@item 
@vari{obj} and @varii{obj} are procedures that would behave differently
(return different values or have different side effects) for some
arguments.
@end itemize

@quotation
@emph{Note:} The @func{eqv?} procedure returning @true{} when @vari{obj}
and @varii{obj} are number objects does not imply that @code{=} would
also return @true{} when called with @vari{obj} and @varii{obj} as
arguments.
@end quotation

@example
(eqv? 'a 'a)                     =>  #t
(eqv? 'a 'b)                     =>  #f
(eqv? 2 2)                       =>  #t
(eqv? '() '())                   =>  #t
(eqv? 100000000 100000000)       =>  #t
(eqv? (cons 1 2) (cons 1 2))     =>  #f
(eqv? (lambda () 1)
      (lambda () 2))             =>  #f
(eqv? #f 'nil)                   =>  #f
@end example

The following examples illustrate cases in which the above rules do not
fully specify the behavior of @func{eqv?}.  All that can be said about
such cases is that the value returned by @func{eqv?} must be a boolean.

@example
(let ((p (lambda (x) x)))
  (eqv? p p))                   => unspecified

(eqv? "" "")                    => unspecified

(eqv? '#() '#())                => unspecified

(eqv? (lambda (x) x)
      (lambda (x) x))           => unspecified

(eqv? (lambda (x) x)
      (lambda (y) y))           => unspecified

(eqv? +nan.0 +nan.0)            => unspecified
@end example

The next set of examples shows the use of @func{eqv?} with procedures
that have local state.  Calls to @func{gen-counter} must return a
distinct procedure every time, since each procedure has its own internal
counter.  Calls to @func{gen-loser} return procedures that behave
equivalently when called.  However, @func{eqv?} may not detect this
equivalence.

@example
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           =>  unspecified
(eqv? (gen-counter) (gen-counter))
                        =>  #f
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           =>  unspecified
(eqv? (gen-loser) (gen-loser))
                        =>  unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g)) => unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g)) => #f
@end example

Implementations may share structure between constants where appropriate.
Furthermore, a constant may be copied at any time by the implementation
so as to exist simultaneously in different sets of locations.  Thus the
value of @func{eqv?} on constants is sometimes
implementation--dependent.

@example
(eqv? '(a) '(a))                 => unspecified
(eqv? "a" "a")                   => unspecified
(eqv? '(b) (cdr '(a b)))         => unspecified
(let ((x '(a)))
  (eqv? x x))                    => #t
@end example
@end deffn


@deffn Procedure eq? @vari{obj} @varii{obj}
The @func{eq?} predicate is similar to @func{eqv?} except that in some
cases it is capable of discerning distinctions finer than those
detectable by @func{eqv?}.

The @func{eq?} and @func{eqv?} predicates are guaranteed to have the
same behavior on symbols, booleans, the empty list, pairs, procedures,
non--empty strings, bytevectors, vectors, and records.  The behavior of
@func{eq?} on number objects and characters is
implementation--dependent, but it always returns either @true{} or
@false{}, and returns @true{} only when @func{eqv?} would also return
@true{}.  The @func{eq?} predicate may also behave differently from
@func{eqv?} on empty vectors, empty bytevectors, and empty strings.

@example
(eq? 'a 'a)                     => #t
(eq? '(a) '(a))                 => unspecified
(eq? (list 'a) (list 'a))       => #f
(eq? "a" "a")                   => unspecified
(eq? "" "")                     => unspecified
(eq? '() '())                   => #t
(eq? 2 2)                       => unspecified
(eq? #\A #\A)                   => unspecified
(eq? car car)                   => #t
(let ((n (+ 2 3)))
  (eq? n n))                    => unspecified
(let ((x '(a)))
  (eq? x x))                    => #t
(let ((x '#()))
  (eq? x x))                    => unspecified
(let ((p (lambda (x) x)))
  (eq? p p))                    => unspecified
@end example
@end deffn


@deffn Procedure {equal?} @vari{obj} @varii{obj}
The @func{equal?}  predicate returns @true{} if and only if the
(possibly infinite) unfoldings of its arguments into regular trees are
equal as ordered trees.

The @func{equal?} predicate treats pairs and vectors as nodes with
outgoing edges, uses @func{string=?} to compare strings, uses
@func{bytevector=?} to compare bytevectors (see library chapter
``Bytevectors''), and uses @func{eqv?} to compare other nodes.

@example
(equal? 'a 'a)                  =>  #t

(equal? '(a) '(a))              =>  #t

(equal? '(a (b) c)
        '(a (b) c))             =>  #t

(equal? "abc" "abc")            =>  #t

(equal? 2 2)                    =>  #t

(equal? (make-vector 5 'a)
        (make-vector 5 'a))     =>  #t

(equal? '#vu8(1 2 3 4 5)
        (u8-list->bytevector
         '(1 2 3 4 5))          =>  #t

(equal? (lambda (x) x)
        (lambda (y) y))         =>  unspecified

(let* ((x (list 'a))
       (y (list 'a))
       (z (list x y)))
  (list (equal? z (list y x))
        (equal? z (list x x)))) =>  (#t #t)
@end example

@quotation
@emph{Note:} The @func{equal?} procedure must always terminate, even if
its arguments contain cycles.
@end quotation
@end deffn


@c ------------------------------------------------------------

@subsubheading Procedure predicate


@deffn Procedure {procedure?} @var{obj}
Return @true{} if @var{obj} is a procedure, otherwise return @false{}.

@example
(procedure? car)                        => #t
(procedure? 'car)                       => #f
(procedure? (lambda (x) (* x x)))       => #t
(procedure? '(lambda (x) (* x x)))      => #f
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base math
@section Mathematics


The procedures described here implement arithmetic that is generic over
the numerical tower.  The generic procedures described in this section
accept both exact and inexact number objects as arguments, performing
coercions and selecting the appropriate operations as determined by the
numeric subtypes of their arguments.


@menu
* base math exactness::         Propagation of exactness and
                                inexactness.
* base math infinities::        Representability of infinities
                                and NaNs.
* base math semantics::         Semantics of common operations.
* base math ops::               Numerical operations.
* base math string::            Numerical input and output.
@end menu


@c ------------------------------------------------------------

@c page
@node base math exactness
@subsection Propagation of exactness and inexactness


The procedures listed below must return the mathematically correct exact
result provided all their arguments are exact:

@example
+            -            *
max          min          abs
numerator    denominator  gcd
lcm          floor        ceiling
truncate     round        rationalize
real-part    imag-part    make-rectangular
@end example

The procedures listed below must return the correct exact result
provided all their arguments are exact, and no divisors are zero:

@example
/
div          mod           div-and-mod
div0         mod0          div0-and-mod0
@end example

Moreover, the procedure @func{expt} must return the correct exact result
provided its first argument is an exact real number object and its
second argument is an exact integer object.

The general rule is that the generic operations return the correct exact
result when all of their arguments are exact and the result is
mathematically well--defined, but return an inexact result when any
argument is inexact.  Exceptions to this rule include:

@example
sqrt            exp             log
sin             cos             tan
asin            acos            atan
expt            make-polar      magnitude
angle
@end example

@noindent
which may (but are not required to) return inexact results even when
given exact arguments, as indicated in the specification of these
procedures.

One general exception to the rule above is that an implementation may
return an exact result despite inexact arguments if that exact result
would be the correct result for all possible substitutions of exact
arguments for the inexact ones.  An example is @code{(* 1.0 0)} which
may return either @code{0} (exact) or @code{0.0} (inexact).


@c ------------------------------------------------------------

@c page
@node base math infinities
@subsection Representability of infinities and NaNs


The specification of the numerical operations is written as though
infinities and NaNs are representable, and specifies many operations
with respect to these number objects in ways that are consistent with
the @ieee{} 754 standard for binary floating--point arithmetic.

An implementation of Scheme may or may not represent infinities and
NaNs; however, an implementation must raise a continuable exception with
condition type @code{&no-infinities} or @code{&no-nans} (respectively;
see library section ``Flonums'') whenever it is unable to represent an
infinity or NaN as specified.  In this case, the continuation of the
exception handler is the continuation that otherwise would have received
the infinity or NaN value.  This requirement also applies to conversions
between number objects and external representations, including the
reading of program source code.


@c ------------------------------------------------------------

@c page
@node base math semantics
@subsection Semantics of common operations


Some operations are the semantic basis for several arithmetic
procedures.  The behavior of these operations is described in this
section for later reference.


@menu
* base math semantics integer::         Integer division.
* base math semantics trascend::        Transcendental functions.
@end menu


@c ------------------------------------------------------------

@c page
@node base math semantics integer
@subsubsection Integer division


Scheme's operations for performing integer division rely on mathematical
operations @emph{div}, @emph{mod}, @emph{div_0}, and @emph{mod_0}, that
are defined as follows:

@itemize
@item
@emph{div}, @emph{mod}, @emph{div_0}, and @emph{mod_0} each accept two
real numbers @emph{x_1} and @emph{x_2} as operands, where @emph{x_2}
must be nonzero.

@item
@emph{div} returns an integer, and @emph{mod} returns a real.  Their
results are specified by:

@example
x_1 div x_2 = n_d
x_1 mod x_2 = x_m
@end example

@noindent
where:

@example
x_1 = n_d * x_2 + x_m
0  <= x_m < |x_2|
@end example

Examples:

@example
 123 div  10 =  12
 123 mod  10 =   3
 123 div -10 = -12
 123 mod -10 =   3
-123 div  10 = -13
-123 mod  10 =   7
-123 div -10 =  13
-123 mod -10 =   7
@end example

@item
@emph{div_0} and @emph{mod_0} are like @emph{div} and @emph{mod}, except
the result of @emph{mod_0} lies within a half--open interval centered on
zero.  The results are specified by:

@example
x_1 div_0 x_2 = n_d
x_1 mod_0 x_2 = x_m
@end example

@noindent
where:

@example
x_1 = n_d * x_2 + x_m
-|x_2/2| <= x_m < |x_2/2|
@end example

Examples:

@example
 123 div_0  10 =  12
 123 mod_0  10 =   3
 123 div_0 -10 = -12
 123 mod_0 -10 =   3
-123 div_0  10 = -12
-123 mod_0  10 =  -3
-123 div_0 -10 =  12
-123 mod_0 -10 =  -3
@end example
@end itemize


@c ------------------------------------------------------------

@c page
@node base math semantics trascend
@subsubsection Transcendental functions


In general, the transcendental functions @emph{log}, @emph{sin^(-1)}
(arcsine), @emph{cos^(-1)} (arccosine), and @emph{tan^(-1)} are multiply
defined.  The value of @code{log z} is defined to be the one whose
imaginary part lies in the range from @code{-pi} (inclusive if
@code{-0.0} is distinguished, exclusive otherwise) to @code{pi}
(inclusive).  @code{log 0} is undefined.

The value of @code{log z} for non--real @var{z} is defined in terms of
log on real numbers as:

@example
log z = log |z| + (angle z) i
@end example

@noindent
where @code{angle z} is the angle of @code{z = a * e^(i * b)} specified
as:

@example
angle z = b + 2 pi n
@end example

with @code{-pi <= angle z <= \pi} and @code{angle z = b + 2 pi n} for
some integer @var{n}.

With the one--argument version of @emph{log} defined this way, the
values of the two--argument--version of @emph{log}, @code{sin^(-1) z},
@code{cos^(-1) z}, @code{tan^(-1) z}, and the two--argument version
of @code{tan^(-1)} are according to the following formulae:

@example
log_b z = (log z)/(log b)
sin^(-1) z = -i log (i z + sqrt(1 - z^2))
cos^(-1) z = pi/2 - sin^(-1) z
tan^(-1) z = (log (1 + i z) - log (1 - i z)) / (2 i)
tan^(-1) x y = angle(x + yi)
@end example

The range of @code{tan^(-1) x y} is as in the following table.  The
asterisk (*) indicates that the entry applies to implementations that
distinguish minus zero.

@multitable {*} {@emph{y} condition} {@emph{x} condition} {range of result @emph{r}}
@headitem @tab @emph{y} condition @tab @emph{x} condition @tab range of result @emph{r}
@item @tab y = 0.0 @tab x > 0.0 @tab 0.0
@item * @tab y = +0.0  @tab x > 0.0 @tab +0.0
@item * @tab y = -0.0 @tab x > 0.0 @tab -0.0
@item @tab y > 0.0 @tab x > 0.0 @tab 0.0 < r < pi/2
@item @tab y > 0.0 @tab x = 0.0 @tab pi/2
@item @tab y > 0.0 @tab x < 0.0 @tab pi/2 < r < pi
@item @tab y = 0.0 @tab x < 0 @tab pi
@item * @tab y = +0.0 @tab x < 0.0 @tab pi
@item * @tab y = -0.0 @tab x < 0.0 @tab -pi
@item @tab y < 0.0 @tab x < 0.0 @tab -pi< r < -pi/2
@item @tab y < 0.0 @tab x = 0.0 @tab -pi/2
@item @tab y < 0.0 @tab x > 0.0 @tab -pi/2 < r < 0.0
@item @tab y = 0.0 @tab x = 0.0 @tab undefined
@item * @tab y = +0.0 @tab x = +0.0 @tab +0.0
@item * @tab y = -0.0 @tab x = +0.0 @tab -0.0
@item * @tab y = +0.0 @tab x = -0.0 @tab pi
@item * @tab y = -0.0 @tab x = -0.0 @tab -pi
@item * @tab y = +0.0 @tab x = 0 @tab pi/2
@item * @tab y = -0.0 @tab x = 0 @tab -pi/2
@end multitable


@c ------------------------------------------------------------

@c page
@node base math ops
@subsection Numerical operations


@menu
* base math ops type pred::             Numerical type predicates.
* base math ops exactness::             Generic conversion.
* base math ops value pred::            Value predicates.
* base math ops comparison::            Comparison.
* base math ops arithmetic::            Arithmetic operations.
* base math ops part::                  Part separation.
* base math ops trascend::              Trascendental functions.
* base math ops exponentiation::        Exponentiation functions.
* base math ops complex::               Complex numbers functions.
@end menu


@c ------------------------------------------------------------

@c page
@node base math ops type pred
@subsubsection Numerical type predicates


@deffn Procedure {number?} @var{obj}
@deffnx Procedure {complex?} @var{obj}
@deffnx Procedure {real?} @var{obj}
@deffnx Procedure {rational?} @var{obj}
@deffnx Procedure {integer?} @var{obj}
These numerical type predicates can be applied to any kind of argument.
They return @true{} if the object is a number object of the named type,
and @false{} otherwise.  In general, if a type predicate is true of a
number object then all higher type predicates are also true of that
number object.  Consequently, if a type predicate is false of a number
object, then all lower type predicates are also false of that number
object.

If @var{z} is a complex number object, then @code{(real? @var{z})} is
true if and only if @code{(zero? (imag-part @var{z}))} and @code{(exact?
(imag-part @var{z}))} are both true.

If @var{x} is a real number object, then @code{(rational? @var{x})} is
true if and only if there exist exact integer objects @vari{k} and
@varii{k} such that @code{(= @var{x} (/ @vari{k} @varii{k}))} and
@code{(= (numerator @var{x}) @vari{k})} and @code{(= (denominator
@var{x}) @varii{k})} are all true.  Thus infinities and NaNs are not
rational number objects.

If @var{q} is a rational number objects, then @code{(integer? @var{q})}
is true if and only if @code{(= (denominator @var{q}) 1)} is true.  If
@var{q} is not a rational number object, then @code{(integer? @var{q})}
is @false{}.

@example
(complex? 3+4i)                        => #t
(complex? 3)                           => #t
(real? 3)                              => #t
(real? -2.5+0.0i)                      => #f
(real? -2.5+0i)                        => #t
(real? -2.5)                           => #t
(real? #e1e10)                         => #t
(rational? 6/10)                       => #t
(rational? 6/3)                        => #t
(rational? 2)                          => #t
(integer? 3+0i)                        => #t
(integer? 3.0)                         => #t
(integer? 8/4)                         => #t

(number? +nan.0)                       => #t
(complex? +nan.0)                      => #t
(real? +nan.0)                         => #t
(rational? +nan.0)                     => #f
(complex? +inf.0)                      => #t
(real? -inf.0)                         => #t
(rational? -inf.0)                     => #f
(integer? -inf.0)                      => #f
@end example

@quotation
@emph{Note:} Except for @func{number?}, the behavior of these type
predicates on inexact number objects is unreliable, because any
inaccuracy may affect the result.
@end quotation
@end deffn


@deffn Procedure {real-valued?} @var{obj}
@deffnx Procedure {rational-valued?} @var{obj}
@deffnx Procedure {integer-valued?} @var{obj}
These numerical type predicates can be applied to any kind of argument.
The @func{real-valued?} procedure returns @true{} if the object is a
number object and is equal in the sense of @code{=} to some real number
object, or if the object is a NaN, or a complex number object whose real
part is a NaN and whose imaginary part is zero in the sense of
@func{zero?}.  The @func{rational-valued?} and @func{integer-valued?}
procedures return @true{} if the object is a number object and is equal
in the sense of @code{=} to some object of the named type, and otherwise
they return @false{}.

@example
(real-valued? +nan.0)                  => #t
(real-valued? +nan.0+0i)               => #t
(real-valued? -inf.0)                  => #t
(real-valued? 3)                       => #t
(real-valued? -2.5+0.0i)               => #t
(real-valued? -2.5+0i)                 => #t
(real-valued? -2.5)                    => #t
(real-valued? #e1e10)                  => #t

(rational-valued? +nan.0)              => #f
(rational-valued? -inf.0)              => #f
(rational-valued? 6/10)                => #t
(rational-valued? 6/10+0.0i)           => #t
(rational-valued? 6/10+0i)             => #t
(rational-valued? 6/3)                 => #t

(integer-valued? 3+0i)                 => #t
(integer-valued? 3+0.0i)               => #t
(integer-valued? 3.0)                  => #t
(integer-valued? 3.0+0.0i)             => #t
(integer-valued? 8/4)                  => #t
@end example

@quotation
@emph{Note:} These procedures test whether a given number object can be
coerced to the specified type without loss of numerical accuracy.
Specifically, the behavior of these predicates differs from the behavior
of @func{real?}, @func{rational?}, and @func{integer?} on complex number
objects whose imaginary part is inexact zero.
@end quotation

@quotation
@emph{Note:} The behavior of these type predicates on inexact number
objects is unreliable, because any inaccuracy may affect the result.
@end quotation
@end deffn


@deffn Procedure {exact?} @var{z}
@deffnx Procedure {inexact?} @var{z}
These numerical predicates provide tests for the exactness of a
quantity.  For any number object, precisely one of these predicates is
true.

@example
(exact? 5)                   => #t
(inexact? +inf.0)            => #t
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base math ops exactness
@subsubsection Exactness conversion


These procedures implement the natural one--to-one correspondence
between exact and inexact integer objects throughout an
implementation--dependent range.  The @func{inexact} and @func{exact}
procedures are idempotent.


@deffn Procedure inexact @var{z}
The @func{inexact} procedure returns an inexact representation of
@var{z}.  If inexact number objects of the appropriate type have bounded
precision, then the value returned is an inexact number object that is
nearest to the argument.  If an exact argument has no reasonably close
inexact equivalent, an exception with condition type
@code{&implementation-violation} may be raised.

@quotation
@emph{Note:} For a real number object whose magnitude is finite but so
large that it has no reasonable finite approximation as an inexact
number, a reasonably close inexact equivalent may be @code{+inf.0} or
@code{-inf.0}.  Similarly, the inexact representation of a complex
number object whose components are finite may have infinite components.
@end quotation
@end deffn


@deffn Procedure exact @var{z}
The @func{exact} procedure returns an exact representation of @var{z}.
The value returned is the exact number object that is numerically
closest to the argument; in most cases, the result of this procedure
should be numerically equal to its argument.  If an inexact argument has
no reasonably close exact equivalent, an exception with condition type
@code{&implementation-violation} may be raised.
@end deffn


@c ------------------------------------------------------------

@c page
@node base math ops value pred
@subsubsection Value predicates


@deffn Procedure = @vari{z} @varii{z} @variii{z} @dots{}
@deffnx Procedure < @vari{x} @varii{x} @variii{x} @dots{}
@deffnx Procedure > @vari{x} @varii{x} @variii{x} @dots{}
@deffnx Procedure <= @vari{x} @varii{x} @variii{x} @dots{}
@deffnx Procedure >= @vari{x} @varii{x} @variii{x} @dots{}
These procedures return @true{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, and @false{} otherwise.

Examples:

@example
(= +inf.0 +inf.0)               => #t
(= -inf.0 +inf.0)               => #f
(= -inf.0 -inf.0)               => #t
@end example

@noindent
for any real number object @var{x} that is neither infinite nor NaN:

@example
(< -inf.0 @var{x} +inf.0)       => #t
(> +inf.0 @var{x} -inf.0)       => #t
@end example

@noindent
for any number object @var{z}:

@example
(= +nan.0 @var{z})              => #f
@end example

For any real number object @var{x}:

@example
(< +nan.0 @var{x})              => #f
(> +nan.0 @var{x})              => #f
@end example

These predicates must be transitive.

@quotation
@emph{Note:} The traditional implementations of these predicates in
Lisp--like languages are not transitive.
@end quotation

@quotation
@emph{Note:} While it is possible to compare inexact number objects
using these predicates, the results may be unreliable because a small
inaccuracy may affect the result; this is especially true of @code{=}
and @func{zero?}  (below).

When in doubt, consult a numerical analyst.
@end quotation
@end deffn


@deffn Procedure {zero?} @var{z}
@deffnx Procedure {positive?} @var{x}
@deffnx Procedure {negative?} @var{x}
@deffnx Procedure {odd?} @var{n}
@deffnx Procedure {even?} @var{n}
@deffnx Procedure {finite?} @var{x}
@deffnx Procedure {infinite?} @var{x}
@deffnx Procedure {nan?} @var{x}
These numerical predicates test a number object for a particular
property, returning @true{} or @false{}.

@table @func
@item zero?
Tests if the number object is @code{=} to zero.

@item positive?
Tests whether it is greater than zero.

@item negative?
Tests whether it is less than zero.

@item odd?
Tests whether it is odd.

@item even?
Tests whether it is even.

@item finite?
Tests whether it is not an infinity and not a NaN.

@item infinite?
Tests whether it is an infinity.

@item nan?
Tests whether it is a NaN.
@end table

@example
(zero? +0.0)                  => #t
(zero? -0.0)                  => #t
(zero? +nan.0)                => #f
(positive? +inf.0)            => #t
(negative? -inf.0)            => #t
(positive? +nan.0)            => #f
(negative? +nan.0)            => #f
(finite? +inf.0)              => #f
(finite? 5)                   => #t
(finite? 5.0)                 => #t
(infinite? 5.0)               => #f
(infinite? +inf.0)            => #t
@end example

@quotation
@emph{Note:} As with the predicates above, the results may be unreliable
because a small inaccuracy may affect the result.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base math ops comparison
@subsubsection Comparison


@deffn Procedure max @vari{x} @varii{x} @dots{}
@deffnx Procedure min @vari{x} @varii{x} @dots{}
These procedures return the maximum or minimum of their arguments.

@example
(max 3 4)                       =>  4
(max 3.9 4)                     =>  4.0
@end example

For any real number object @var{x} that is not a NaN:

@example
(max +inf.0 @var{x})            =>  +inf.0
(min -inf.0 @var{x})            =>  -inf.0
@end example

@quotation
@emph{Note:} If any argument is inexact, then the result is also inexact
(unless the procedure can prove that the inaccuracy is not large enough
to affect the result, which is possible only in unusual
implementations).  If @func{min} or @func{max} is used to compare number
objects of mixed exactness, and the numerical value of the result cannot
be represented as an inexact number object without loss of accuracy,
then the procedure may raise an exception with condition type
@code{&implementation-restriction}.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base math ops arithmetic
@subsubsection Arithmetic operations


@deffn Procedure + @vari{z} @dots{}
@deffnx Procedure * @vari{z} @dots{}
These procedures return the sum or product of their arguments.

@example
(+ 3 4)                                =>  7
(+ 3)                                  =>  3
(+)                                    =>  0
(+ +inf.0 +inf.0)                      =>  +inf.0
(+ +inf.0 -inf.0)                      =>  +nan.0

(* 4)                                  =>  4
(*)                                    =>  1
(* 5 +inf.0)                           =>  +inf.0
(* -5 +inf.0)                          =>  -inf.0
(* +inf.0 +inf.0)                      =>  +inf.0
(* +inf.0 -inf.0)                      =>  -inf.0
(* 0 +inf.0)                           =>  0 or +nan.0
(* 0 +nan.0)                           =>  0 or +nan.0
(* 1.0 0)                              =>  0 or 0.0
@end example

For any real number object @var{x} that is neither infinite nor NaN:

@example
(+ +inf.0 @var{x})                           =>  +inf.0
(+ -inf.0 @var{x})                           =>  -inf.0
@end example

For any real number object @var{x}:

@example
(+ +nan.0 @var{x})                           =>  +nan.0
@end example

For any real number object @var{x} that is not an exact 0:

@example
(* +nan.0 @var{x})                           =>  +nan.0
@end example

If any of these procedures are applied to mixed non--rational real and
non--real complex arguments, they either raise an exception with
condition type @code{&implementation-restriction} or return an
unspecified number object.

Implementations that distinguish @code{-0.0} should adopt behavior
consistent with the following examples:

@example
(+  0.0 -0.0)  =>  0.0
(+ -0.0  0.0)  =>  0.0
(+  0.0  0.0)  =>  0.0
(+ -0.0 -0.0)  => -0.0
@end example
@end deffn


@deffn Procedure - @var{z}
@deffnx Procedure - @vari{z} @varii{z} @variii{z} @dots{}
With two or more arguments, this procedures returns the difference of
its arguments, associating to the left.  With one argument, however, it
returns the additive inverse of its argument.

@example
(- 3 4)                                =>  -1
(- 3 4 5)                              =>  -6
(- 3)                                  =>  -3
(- +inf.0 +inf.0)                      =>  +nan.0
@end example

If this procedure is applied to mixed non--rational real and non--real
complex arguments, it either raises an exception with condition type
@code{&implementation-restriction} or returns an unspecified number
object.

Implementations that distinguish @code{-0.0} should adopt behavior
consistent with the following examples:

@example
(-  0.0)       => -0.0
(- -0.0)       =>  0.0
(-  0.0 -0.0)  =>  0.0
(- -0.0  0.0)  => -0.0
(-  0.0  0.0)  =>  0.0
(- -0.0 -0.0)  =>  0.0
@end example
@end deffn


@deffn Procedure / @var{z}
@deffnx Procedure / @vari{z} @varii{z} @variii{z} @dots{}
If all of the arguments are exact, then the divisors must all be
nonzero.  With two or more arguments, this procedure returns the
quotient of its arguments, associating to the left.  With one argument,
however, it returns the multiplicative inverse of its argument.

@example
(/ 3 4 5)                              =>  3/20
(/ 3)                                  =>  1/3
(/ 0.0)                                =>  +inf.0
(/ 1.0 0)                              =>  +inf.0
(/ -1 0.0)                             =>  -inf.0
(/ +inf.0)                             =>  0.0
(/ 0 0)                                =>  exception &assertion
(/ 3 0)                                =>  exception &assertion
(/ 0 3.5)                              =>  0.0
(/ 0 0.0)                              =>  +nan.0
(/ 0.0 0)                              =>  +nan.0
(/ 0.0 0.0)                            =>  +nan.0
@end example

If this procedure is applied to mixed non--rational real and non--real
complex arguments, it either raises an exception with condition type
@code{&implementation-restriction} or returns an unspecified number
object.
@end deffn


@deffn Procedure abs @var{x}
Returns the absolute value of its argument.

@example
(abs -7)                               =>  7
(abs -inf.0)                           =>  +inf.0
@end example
@end deffn


@deffn Procedure div-and-mod @vari{x} @varii{x}
@deffnx Procedure div @vari{x} @varii{x}
@deffnx Procedure mod @vari{x} @varii{x}
@deffnx Procedure div0-and-mod0 @vari{x} @varii{x}
@deffnx Procedure div0 @vari{x} @varii{x}
@deffnx Procedure mod0 @vari{x} @varii{x}
These procedures implement number--theoretic integer division and return
the results of the corresponding mathematical operations specified in
@ref{base math semantics integer}.  If @vari{x} and @varii{x} are exact,
@varii{x} must be nonzero. In the cases where the mathematical
requirements in @ref{base math semantics integer} cannot be satisfied by
any number object, either an exception is raised with condition type
@code{&implementation-restriction}, or unspecified number objects (one
for for @func{div}, @func{mod}, @func{div0} and @func{mod0}, two for
@func{div-and-mod} and @func{div0-and-mod0}) are returned.

@example
(div @vari{x} @varii{x})                => @vari{x} div @varii{x}
(mod @vari{x} @varii{x})                => @vari{x} mod @varii{x}

(div-and-mod @vari{x} @varii{x})
=> @vari{x} div @varii{x}, @vari{x} mod @varii{x} ;; two return values

(div0 @vari{x} @varii{x})               => @vari{x} div_0 @varii{x}
(mod0 @vari{x} @varii{x})               => @vari{x} mod_0 @varii{x}

(div0-and-mod0 @vari{x} @varii{x})
=> @vari{x} div_0 @varii{x}, @vari{x} mod_0 @varii{x} ;; two return values
@end example
@end deffn


@deffn Procedure gcd @vari{n} @dots{}
@deffnx Procedure lcm @vari{n} @dots{}
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non--negative.

@example
(gcd 32 -36)                           =>  4
(gcd)                                  =>  0
(lcm 32 -36)                           =>  288
(lcm 32.0 -36)                         =>  288.0
(lcm)                                  =>  1
@end example
@end deffn

@c ------------------------------------------------------------

@c page
@node base math ops part
@subsubsection Part separation


@deffn Procedure numerator @var{q}
@deffnx Procedure denominator @var{q}
These procedures return the numerator or denominator of their argument;
the result is computed as if the argument was represented as a fraction
in lowest terms.  The denominator is always positive.  The denominator
of @code{0} is defined to be @code{1}.

@example
(numerator   (/ 6 4))                  =>  3
(denominator (/ 6 4))                  =>  2
(denominator (inexact (/ 6 4)))        =>  2.0
@end example
@end deffn


@deffn Procedure floor @var{x}
@deffnx Procedure ceiling @var{x}
@deffnx Procedure truncate @var{x}
@deffnx Procedure round @var{x}
These procedures return inexact integer objects for inexact arguments
that are not infinities or NaNs, and exact integer objects for exact
rational arguments.

@table @func
@item floor
Returns the largest integer object not larger than @var{x}.

@item ceiling
Returns the smallest integer object not smaller than @var{x}.

@item truncate
Returns the integer object closest to @var{x} whose absolute value is
not larger than the absolute value of @var{x}.

@item round
Returns the closest integer object to @var{x}, rounding to even when
@var{x} represents a number halfway between two integers.
@end table

If the argument to one of these procedures is inexact, then the result
is also inexact.  If an exact value is needed, the result should be
passed to the @func{exact} procedure.

Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN.

@example
(floor -4.3)                           =>  -5.0
(ceiling -4.3)                         =>  -4.0
(truncate -4.3)                        =>  -4.0
(round -4.3)                           =>  -4.0

(floor 3.5)                            =>  3.0
(ceiling 3.5)                          =>  4.0
(truncate 3.5)                         =>  3.0
(round 3.5)                            =>  4.0

(round 7/2)                            =>  4
(round 7)                              =>  7

(floor +inf.0)                         =>  +inf.0
(ceiling -inf.0)                       =>  -inf.0
(round +nan.0)                         =>  +nan.0
@end example
@end deffn


@deffn Procedure rationalize @vari{x} @varii{x}
The @func{rationalize} procedure returns a number object representing
the @emph{simplest} rational number differing from @vari{x} by no more
than @varii{x}.

A rational number @emph{r_1} is @emph{simpler} than another rational
number @emph{r_2} if @code{r_1 = p_1/q_1} and @code{r_2 = p_2/q_2} (in
lowest terms) and @code{|p_1| <= |p_2|} and @code{|q_1| <= |q_2|}.  Thus
@code{3/5} is simpler than @code{4/7}.

Although not all rationals are comparable in this ordering (consider
@code{2/7} and @code{3/5}) any interval contains a rational number that
is simpler than every other rational number in that interval (the
simpler @code{2/5} lies between @code{2/7} and @code{3/5}).

Note that @code{0 = 0/1} is the simplest rational of all.

@example
(rationalize (exact .3) 1/10)          => 1/3
(rationalize .3 1/10)                  => #i1/3  ; approximately

(rationalize +inf.0 3)                 =>  +inf.0
(rationalize +inf.0 +inf.0)            =>  +nan.0
(rationalize 3 +inf.0)                 =>  0.0
@end example

The first two examples hold only in implementations whose inexact real
number objects have sufficient precision.
@end deffn

@c ------------------------------------------------------------

@c page
@node base math ops trascend
@subsubsection Trascendental functions


@deffn Procedure exp @var{z}
@deffnx Procedure log @var{z}
@deffnx Procedure log @vari{z} @varii{z}
@deffnx Procedure sin @var{z}
@deffnx Procedure cos @var{z}
@deffnx Procedure tan @var{z}
@deffnx Procedure asin @var{z}
@deffnx Procedure acos @var{z}
@deffnx Procedure atan @var{z}
@deffnx Procedure atan @vari{x} @varii{x}
These procedures compute the usual transcendental functions.

The @func{exp} procedure computes the base--@var{e} exponential of
@var{z}.

The @func{log} procedure with a single argument computes the natural
logarithm of @var{z} (@strong{not} the base--10 logarithm); @code{(log
@vari{z} @varii{z})} computes the base--@varii{z} logarithm of @vari{z}.

The @func{asin}, @func{acos}, and @func{atan} procedures compute
arcsine, arccosine, and arctangent, respectively.  The two--argument
variant of @func{atan} computes:

@example
(angle (make-rectangular @varii{x} @vari{x}))
@end example

These procedures may return inexact results even when given exact
arguments.

@example
(exp +inf.0)    => +inf.0
(exp -inf.0)    => 0.0
(log +inf.0)    => +inf.0
(log 0.0)       => -inf.0
(log 0)         => exception &assertion
(log -inf.0)    => +inf.0+3.141592653589793i    ; approximately
(atan -inf.0)   => -1.5707963267948965          ; approximately
(atan +inf.0)   => 1.5707963267948965           ; approximately
(log -1.0+0.0i) => 0.0+3.141592653589793i       ; approximately
(log -1.0-0.0i) => 0.0-3.141592653589793i       ; approximately
                                                ; if -0.0 is distinguished
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base math ops exponentiation
@subsubsection Exponentiation functions


@deffn Procedure sqrt @var{z}
Return the principal square root of @var{z}.  For rational @var{z}, the
result has either positive real part, or zero real part and
non--negative imaginary part.  With @emph{log} defined as in @ref{base
math semantics trascend}, the value of @code{(sqrt @var{z})} could be
expressed as:

@example
e^((log z)/2)
@end example

The @func{sqrt} procedure may return an inexact result even when given
an exact argument.

@example
(sqrt -5)                   =>  0.0+2.23606797749979i ; approximately
(sqrt +inf.0)               =>  +inf.0
(sqrt -inf.0)               =>  +inf.0i
@end example
@end deffn


@deffn Procedure exact-integer-sqrt @var{k}
The @func{exact-integer-sqrt} procedure returns two non--negative exact
integer objects @emph{s} and @emph{r} where @code{@var{k} = s^2 + r} and
@code{@var{k} < (s+1)^2}.

@example
(exact-integer-sqrt 4)  => 2 0 ; two return values
(exact-integer-sqrt 5)  => 2 1 ; two return values
@end example
@end deffn


@deffn Procedure expt @vari{z} @varii{z}
Return @vari{z} raised to the power @varii{z}.  For non--zero @vari{z},
this is @code{e^(z_2 log z_1)}.  @code{0.0^z} is @code{1.0} if
@code{@var{z} = 0.0}, and @code{0.0} if @code{(real-part @var{z})} is
positive.  For other cases in which the first argument is zero, either
an exception is raised with condition type
@code{&implementation-restriction}, or an unspecified number object is
returned.

For an exact real number object @vari{z} and an exact integer object
@varii{z}, @code{(expt @vari{z} @varii{z})} must return an exact result.
For all other values of @vari{z} and @varii{z}, @code{(expt @vari{z}
@varii{z})} may return an inexact result, even when both @vari{z} and
@varii{z} are exact.

@example
(expt 5 3)                  =>  125
(expt 5 -3)                 =>  1/125
(expt 5 0)                  =>  1
(expt 0 5)                  =>  0
(expt 0 5+.0000312i)        =>  0.0
(expt 0 -5)                 =>  unspecified
(expt 0 -5+.0000312i)       =>  unspecified
(expt 0 0)                  =>  1
(expt 0.0 0.0)              =>  1.0
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base math ops complex
@subsubsection Complex numbers functions


@deffn Procedure make-rectangular @vari{x} @varii{x}
@deffnx Procedure make-polar @variii{x} @variv{x}
@deffnx Procedure real-part @var{z}
@deffnx Procedure imag-part @var{z}
@deffnx Procedure magnitude @var{z}
@deffnx Procedure angle @var{z}
Suppose @emph{a_1}, @emph{a_2}, @emph{a_3}, and @emph{a_4} are real
numbers, and @emph{c} is a complex number such that the following holds:

@example
c = a_1 + a_2 i = a_3 e^(i a_4)
@end example

Then, if @vari{x}, @varii{x}, @variii{x}, and @variv{x} are number
objects representing @emph{a_1}, @emph{a_2}, @emph{a_3}, and @emph{a_4},
respectively, @code{(make-rectangular @vari{x} @varii{x})} returns
@emph{c}, and @code{(make-polar @variii{x} @variv{x})} returns @emph{c}.

@example
(make-rectangular 1.1 2.2)    => 1.1+2.2i ; approximately
(make-polar 1.1 2.2)          => 1.1@@2.2 ; approximately
@end example

Conversely, if @code{-pi <= a_4 <= pi}, and if @emph{z} is a number
object representing @emph{c}, then @code{(real-part @var{z})} returns
@emph{a_1}, @code{(imag-part @var{z})} returns @emph{a_2},
@code{(magnitude @var{z})} returns @emph{a_3}, and @code{(angle
@var{z})} returns @emph{a_4}.

@example
(real-part 1.1+2.2i)              => 1.1  ; approximately
(imag-part 1.1+2.2i)              => 2.2  ; approximately
(magnitude 1.1@@2.2)              => 1.1  ; approximately
(angle     1.1@@2.2)              => 2.2  ; approximately

(angle -1.0)            => 3.141592653589793 ; approximately
(angle -1.0+0.0i)       => 3.141592653589793 ; approximately
(angle -1.0-0.0i)       => -3.141592653589793
                        ; approximately if -0.0 is distinguished
(angle +inf.0)          => 0.0
(angle -inf.0)          => 3.141592653589793 ; approximately
@end example

Moreover, suppose @vari{x}, @varii{x} are such that either @vari{x} or
@varii{x} is an infinity, then

@example
(make-rectangular @vari{x} @varii{x})   => @var{z}
(magnitude @var{z})                     => +inf.0
@end example

The @func{make-polar}, @func{magnitude}, and @func{angle} procedures may
return inexact results even when given exact arguments.

@example
(angle -1)              => 3.141592653589793 ; approximately
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base math string
@subsection Numerical Input and Output


@deffn Procedure {number->string} @var{z}
@deffnx Procedure {number->string} @var{z} @var{radix}
@deffnx Procedure {number->string} @var{z} @var{radix} @var{precision}
The @func{number->string} procedure takes a number object and a radix
and returns as a string an external representation of the given number
object in the given radix such that:

@example
(let ((number   @var{z})
      (radix    @var{radix}))
  (eqv?
    (string->number (number->string number radix) radix)
    number))
@end example

@noindent
is true.  If no possible result makes this expression true, an exception
with condition type @code{&implementation-restriction} is raised.

@var{radix} must be an exact integer object, either @code{2}, @code{8},
@code{10}, or @code{16}.  If omitted, @var{radix} defaults to @code{10}.
If a @var{precision} is specified, then @var{z} must be an inexact
complex number object, @var{precision} must be an exact positive integer
object, and @var{radix} must be @code{10}.

@quotation
@emph{Note:} The error case can occur only when @var{z} is not a complex
number object or is a complex number object with a non--rational real or
imaginary part.
@end quotation

If a @var{precision} is specified, then the representations of the
inexact real components of the result, unless they are infinite or NaN,
specify an explicit @meta{mantissa width} @var{p}, and @var{p} is the
least @emph{@var{p} >= @var{precision}} for which the above expression
is true.

If @var{z} is inexact, the radix is @code{10}, and the above expression
and condition can be satisfied by a result that contains a decimal
point, then the result contains a decimal point and is expressed using
the minimum number of digits (exclusive of exponent, trailing zeroes,
and mantissa width) needed to make the above expression and condition
true; otherwise the format of the result is unspecified.

The result returned by @func{number->string} never contains an explicit
radix prefix.
@end deffn


@deffn Procedure {string->number} @var{string}
@deffnx Procedure {string->number} @var{string} @var{radix}
Return a number object with maximally precise representation expressed
by the given @var{string}.

@var{radix} must be an exact integer object, either @code{2}, @code{8},
@code{10}, or @code{16}.  If supplied, @var{radix} is a default radix
that may be overridden by an explicit radix prefix in @var{string}
(e.g. @code{#o177}).  If @var{radix} is not supplied, then the default
radix is @code{10}.

If @var{string} is not a syntactically valid notation for a number
object or a notation for a rational number object with a zero
denominator, then @func{string->number} returns @false{}.

@example
(string->number "100")                 => 100
(string->number "100" 16)              => 256
(string->number "1e2")                 => 100.0
(string->number "0/0")                 => #f
(string->number "+inf.0")              => +inf.0
(string->number "-inf.0")              => -inf.0
(string->number "+nan.0")              => +nan.0
@end example

@quotation
@emph{Note:} The @func{string->number} procedure always returns a number
object or @false{}; it never raises an exception.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base booleans
@section Booleans


The standard boolean objects for true and false have external
representations @true{} and @false{}.  However, of all objects, only
@false{} counts as false in conditional expressions.

@quotation
@emph{Note:} Programmers accustomed to other dialects of Lisp should be
aware that Scheme distinguishes both @false{} and the empty list from
each other and from the symbol @code{nil}.
@end quotation


@deffn Procedure not @var{obj}
Return @true{} if @var{obj} is @false{}, or @false{} otherwise.

@example
(not #t)         => #f
(not 3)          => #f
(not (list 3))   => #f
(not #f)         => #t
(not '())        => #f
(not (list))     => #f
(not 'nil)       => #f
@end example
@end deffn


@deffn Procedure {boolean?} @var{obj}
Return @true{} if @var{obj} is either @true{} or @false{}, or @false{}
otherwise.

@example
(boolean? #f)   => #t
(boolean? 0)    => #f
(boolean? '())  => #f
@end example
@end deffn


@deffn Procedure {boolean=?} @vari{bool} @varii{bool} @variii{bool} @dots{}
Return @true{} if the booleans are the same.
@end deffn


@c ------------------------------------------------------------

@c page
@node base lists
@section Pairs and lists


A @emph{pair} is a compound structure with two fields called the car and
cdr fields (for historical reasons).  Pairs are created by the procedure
@func{cons}.  The car and cdr fields are accessed by the procedures
@func{car} and @func{cdr}.

Pairs are used primarily to represent lists.  A list can be defined
recursively as either the empty list or a pair whose cdr is a list.
More precisely, the set of lists is defined as the smallest set @var{X}
such that:

@itemize
@item 
The empty list is in @var{X}.

@item 
If @var{list} is in @var{X}, then any pair whose cdr field contains
@var{list} is also in @var{X}.
@end itemize

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two--element list is a pair whose
car is the first element and whose cdr is a pair whose car is the second
element and whose cdr is the empty list.  The length of a list is the
number of elements, which is the same as the number of pairs.

The empty list is a special object of its own type.  It is not a pair.
It has no elements and its length is zero.

@quotation
@emph{Note:} The above definitions imply that all lists have finite
length and are terminated by the empty list.
@end quotation

A chain of pairs not ending in the empty list is called an
@emph{improper list}.  Note that an improper list is not a list.  The
list and dotted notations can be combined to represent improper lists:

@example
(a b c . d)
@end example

@noindent
is equivalent to

@example
(a . (b . (c . d)))
@end example

Whether a given pair is a list depends upon what is stored in the cdr
field.


@deffn Procedure {pair?} @var{obj}
Return @true{} if @var{obj} is a pair, @false{} otherwise.

@example
(pair? '(a . b))        => #t
(pair? '(a b c))        => #t
(pair? '())             => #f
(pair? '#(a b))         => #f
@end example
@end deffn


@deffn Procedure cons @vari{obj} @varii{obj}
Return a newly allocated pair whose car is @vari{obj} and whose cdr is
@varii{obj}.  The pair is guaranteed to be different (in the sense of
@func{eqv?}) from every existing object.

@example
(cons 'a '())           =>  (a)
(cons '(a) '(b c d))    =>  ((a) b c d)
(cons "a" '(b c))       =>  ("a" b c)
(cons 'a 3)             =>  (a . 3)
(cons '(a b) 'c)        =>  ((a b) . c)
@end example
@end deffn


@deffn Procedure car @var{pair}
Return the contents of the car field of @var{pair}.

@example
(car '(a b c))          => a
(car '((a) b c d))      => (a)
(car '(1 . 2))          => 1
(car '())               => exception &assertion
@end example
@end deffn


@deffn Procedure cdr @var{pair}
Return the contents of the cdr field of @var{pair}.

@example
(cdr '((a) b c d))      => (b c d)
(cdr '(1 . 2))          => 2
(cdr '())               => exception &assertion
@end example
@end deffn


@deffn Procedure caar @var{pair}
@deffnx Procedure cadr @var{pair}
@deffnx Procedure ...
@deffnx Procedure cdddar @var{pair}
@deffnx Procedure cddddr @var{pair}
These procedures are compositions of @func{car} and @func{cdr}, where
for example @func{caddr} could be defined by

@example
(define caddr (lambda (x) (car (cdr (cdr x)))))
@end example

Arbitrary compositions, up to four deep, are provided.  There are
twenty--eight of these procedures in all.
@end deffn


@deffn Procedure {null?} @var{obj}
Return @true{} if @var{obj} is the empty list, @false{} otherwise.
@end deffn


@deffn Procedure {list?} @var{obj}
Return @true{} if @var{obj} is a list, @false{} otherwise.  By
definition, all lists are chains of pairs that have finite length and
are terminated by the empty list.

@example
(list? '(a b c))     => #t
(list? '())          => #t
(list? '(a . b))     => #f
@end example
@end deffn


@deffn Procedure list @var{obj} @dots{}
Return a newly allocated list of its arguments.

@example
(list 'a (+ 3 4) 'c)    => (a 7 c)
(list)                  => ()
@end example
@end deffn


@deffn Procedure length @var{list}
Return the length of @var{list}.

@example
(length '(a b c))               =>  3
(length '(a (b) (c d e)))       =>  3
(length '())                    =>  0
@end example
@end deffn


@deffn Procedure append
@deffnx Procedure append @var{list} @dots{} @var{obj}
Return a possibly improper list consisting of the elements of the first
@var{list} followed by the elements of the other @var{list}s, with
@var{obj} as the cdr of the final pair.  An improper list results if
@var{obj} is not a list.

@example
(append '(x) '(y))              =>  (x y)
(append '(a) '(b c d))          =>  (a b c d)
(append '(a (b)) '((c)))        =>  (a (b) (c))
(append '(a b) '(c . d))        =>  (a b c . d)
(append '() 'a)                 =>  a
@end example

If @func{append} constructs a non--empty chain of pairs, it is always
newly allocated.  If no pairs are allocated, @var{obj} is returned.
@end deffn


@deffn Procedure reverse @var{list}
Return a newly allocated list consisting of the elements of @var{list}
in reverse order.

@example
(reverse '(a b c))              => (c b a)
(reverse '(a (b c) d (e (f))))  => ((e (f)) d (b c) a)
@end example
@end deffn


@deffn Procedure list-tail @var{list} @var{k}
@var{list} should be a list of size at least @var{k}.  Return the
subchain of pairs of @var{list} obtained by omitting the first @var{k}
elements.

@example
(list-tail '(a b c d) 2)        =>  (c d)
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs whose length is at least @var{k}.
It should not check that it is a chain of pairs beyond this length.
@end deffn


@deffn Procedure list-ref @var{list} @var{k}
@var{list} must be a list whose length is at least @emph{@var{k} + 1}.
The @func{list-tail} procedure returns the @var{k}th element of
@var{list}.

@example
(list-ref '(a b c d) 2)         => c
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs whose length is at least
@emph{@var{k} + 1}.  It should not check that it is a list of pairs
beyond this length.
@end deffn


@deffn Procedure map @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s should all have the same length.  @var{proc} should
accept as many arguments as there are @var{list}s and return a single
value.  @var{proc} should not mutate any of the @var{list}s.

The @func{map} procedure applies @var{proc} element--wise to the
elements of the @var{list}s and returns a list of the results, in order.
@var{proc} is always called in the same dynamic environment as
@func{map} itself.  The order in which @var{proc} is applied to the
elements of the @var{list}s is unspecified.  If multiple returns occur
from @func{map}, the values returned by earlier returns are not mutated.

@example
(map cadr '((a b) (d e) (g h)))         =>  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                      =>  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))               =>  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                         =>  (1 2) or (2 1)
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{proc} to the extent performed by
applying it as described.  An implementation may check whether
@var{proc} is an appropriate argument before applying it.
@end deffn


@deffn Procedure for-each @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s should all have the same length.  @var{proc} should
accept as many arguments as there are @var{list}s.  @var{proc} should
not mutate any of the @var{list}s.

The @func{for-each} procedure applies @var{proc} element--wise to the
elements of the @var{list}s for its side effects, in order from the
first elements to the last.  @var{proc} is always called in the same
dynamic environment as @func{for-each} itself.  The return values of
@func{for-each} are unspecified.

@example
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)
=>  #(0 1 4 9 16)

(for-each (lambda (x) x) '(1 2 3 4))
=> unspecified

(for-each even? '())
=> unspecified
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{proc} to the extent performed by
applying it as described.  An implementation may check whether
@var{proc} is an appropriate argument before applying it.

@quotation
@emph{Note:} Implementations of @code{for-each} may or may not
tail--call @var{proc} on the last elements.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base symbols
@section Symbols


Symbols are objects whose usefulness rests on the fact that two symbols
are identical (in the sense of @func{eq?}, @func{eqv?} and
@func{equal?}) if and only if their names are spelled the same way.  A
symbol literal is formed using @func{quote}.


@deffn Procedure {symbol?} @var{obj}
Return @true{} if @var{obj} is a symbol, @false{} otherwise.

@example
(symbol? 'foo)          => #t
(symbol? (car '(a b)))  => #t
(symbol? "bar")         => #f
(symbol? 'nil)          => #t
(symbol? '())           => #f
(symbol? #f)            => #f
@end example
@end deffn


@deffn Procedure {symbol->string} @var{symbol}
Return the name of @var{symbol} as an immutable string.

@example
(symbol->string 'flying-fish)                   =>  "flying-fish"
(symbol->string 'Martin)                        =>  "Martin"
(symbol->string (string->symbol "Malvina"))     =>  "Malvina"
@end example
@end deffn


@deffn Procedure {symbol=?} @vari{symbol} @varii{symbol} @variii{symbol} @dots{}
Return @true{} if the symbols are the same, i.e., if their names are
spelled the same.
@end deffn


@deffn Procedure {string->symbol} @var{string}
Return the symbol whose name is @var{string}.

@example
(eq? 'mISSISSIppi 'mississippi)
=> #f

(string->symbol "mISSISSIppi")
=> the symbol with name "mISSISSIppi"

(eq? 'bitBlt (string->symbol "bitBlt"))
=> #t

(eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
=> #t

(string=? "K. Harper, M.D."
          (symbol->string (string->symbol "K. Harper, M.D.")))
=> #t
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base characters
@section Characters


@emph{Characters} are objects that represent Unicode scalar values.

@quotation
Unicode defines a standard mapping between sequences of @emph{Unicode
scalar values} (integers in the range @code{0} to @code{#x10FFFF},
excluding the range @code{#xD800} to @code{#xDFFF}) in the latest
version of the standard and human--readable ``characters''.

More precisely, Unicode distinguishes between glyphs, which are printed
for humans to read, and characters, which are abstract entities that map
to glyphs (sometimes in a way that's sensitive to surrounding
characters).  Furthermore, different sequences of scalar values
sometimes correspond to the same character.  The relationships among
scalar, characters, and glyphs are subtle and complex.

Despite this complexity, most things that a literate human would call a
``character'' can be represented by a single Unicode scalar value
(although several sequences of Unicode scalar values may represent that
same character).  For example, Roman letters, Cyrillic letters, Hebrew
consonants, and most Chinese characters fall into this category.
  
Unicode scalar values exclude the range @code{#xD800} to @code{#xDFFF},
which are part of the range of Unicode @emph{code points}.  However, the
Unicode code points in this range, the so--called @emph{surrogates}, are
an artifact of the @utf{}--16 encoding, and can only appear in specific
Unicode encodings, and even then only in pairs that encode scalar
values.  Consequently, all characters represent code points, but the
surrogate code points do not have representations as characters.
@end quotation


@deffn Procedure {char?} @var{obj}
Return @true{} if @var{obj} is a character, @false{} otherwise.
@end deffn


@deffn Procedure {char->integer} @var{char}
@deffnx Procedure {integer->char} @var{sv}
@var{sv} must be a Unicode scalar value, i.e., a non--negative exact
integer object in @code{[0, #xD7FF] union [#xE000, #x10FFFF]}.

Given a character, @func{char->integer} returns its Unicode scalar value
as an exact integer object.  For a Unicode scalar value @var{sv},
@func{integer->char} returns its associated character.

@example
(integer->char 32) =>                   #\space
(char->integer (integer->char 5000))    => 5000
(integer->char #\xD800)                 => exception &assertion
@end example
@end deffn


@deffn Procedure {char=?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char<?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char>?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char<=?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char>=?} @vari{char} @varii{char} @variii{char} @dots{}
These procedures impose a total ordering on the set of characters
according to their Unicode scalar values.

@example
@c (char<? #\z #\\ss)      => #t
(char<? #\z #\Z)        => #f
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base strings
@section Strings


Strings are sequences of characters.  The @emph{length} of a string is
the number of characters that it contains.  This number is fixed when
the string is created.  The @emph{valid indices} of a string are the
integers less than the length of the string.  The first character of a
string has index 0, the second has index 1, and so on.


@deffn Procedure {string?} @var{obj}
Return @true{} if @var{obj} is a string, @false{} otherwise.
@end deffn


@deffn Procedure make-string @var{k}
@deffnx Procedure make-string @var{k} @var{char}
Return a newly allocated string of length @var{k}.  If @var{char} is
given, then all elements of the string are initialized to @var{char},
otherwise the contents of the @var{string} are unspecified.
@end deffn


@deffn Procedure string @var{char} @dots{}
Return a newly allocated string composed of the arguments.
@end deffn


@deffn Procedure string-length @var{string}
Return the number of characters in the given @var{string} as an exact
integer object.
@end deffn


@deffn Procedure string-ref @var{string} @var{k}
@var{k} must be a valid index of @var{string}.  The @func{string-ref}
procedure returns character @var{k} of @var{string} using zero--origin
indexing.

@quotation
@emph{Note:} Implementors should make @func{string-ref} run in constant
time.
@end quotation
@end deffn


@deffn Procedure {string=?} @vari{string} @varii{string} @variii{string} @dots{}
Return @true{} if the strings are the same length and contain the same
characters in the same positions.  Otherwise, the @func{string=?}
procedure returns @false{}.

@example
(string=? "Strause" "Strasse")    => #f
@end example
@end deffn


@deffn Procedure {string<?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string>?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string<=?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string>=?} @vari{string} @varii{string} @variii{string} @dots{}
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, @func{string<?} is
the lexicographic ordering on strings induced by the ordering
@func{char<?} on characters.  If two strings differ in length but are
the same up to the length of the shorter string, the shorter string is
considered to be lexicographically less than the longer string.

@example
(string<? "z" "a")      => #t
(string<? "z" "zz")     => #t
(string<? "z" "Z")      => #f
@end example
@end deffn


@deffn Procedure substring @var{string} @var{start} @var{end}
@var{string} must be a string, and @var{start} and @var{end} must be
exact integer objects satisfying:

@example
0 <= @var{start} <= @var{end} <= (string-length @var{string})
@end example

The @func{substring} procedure returns a newly allocated string formed
from the characters of @var{string} beginning with index @var{start}
(inclusive) and ending with index @var{end} (exclusive).
@end deffn


@deffn Procedure string-append @var{string} @dots{}
Return a newly allocated string whose characters form the concatenation
of the given strings.
@end deffn


@deffn Procedure string->list @var{string}
@deffnx Procedure list->string @var{list}
@var{list} must be a list of characters.

The @func{string->list} procedure returns a newly allocated list of the
characters that make up the given string.

The @func{list->string} procedure returns a newly allocated string
formed from the characters in @var{list}.

The @func{string->list} and @func{list->string} procedures are inverses
so far as @func{equal?} is concerned.
@end deffn


@deffn Procedure string-for-each @var{proc} @vari{string} @varii{string} @dots{}
The @var{string}s must all have the same length.  @var{proc} should
accept as many arguments as there are @var{string}s.

The @func{string-for-each} procedure applies @var{proc} element--wise to
the characters of the @var{string}s for its side effects, in order from
the first characters to the last.  @var{proc} is always called in the
same dynamic environment as @func{string-for-each} itself.  The return
values of @func{string-for-each} are unspecified.

Analogous to @func{for-each}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure string-copy @var{string}
Returns a newly allocated copy of the given @var{string}.
@end deffn


@c ------------------------------------------------------------

@c page
@node base vectors
@section Vectors


Vectors are heterogeneous structures whose elements are indexed by
integers.  A vector typically occupies less space than a list of the
same length, and the average time needed to access a randomly chosen
element is typically less for the vector than for the list.

The @emph{length} of a vector is the number of elements that it
contains.  This number is a non--negative integer that is fixed when the
vector is created.  The @emph{valid indices} of a vector are the exact
non--negative integer objects less than the length of the vector.  The
first element in a vector is indexed by zero, and the last element is
indexed by one less than the length of the vector.

Like list constants, vector constants must be quoted:

@example
'#(0 (2 2 2 2) "Anna")     =>  #(0 (2 2 2 2) "Anna")
@end example


@deffn Procedure vector? @var{obj}
Return @true{} if @var{obj} is a vector, @false{} otherwise.
@end deffn


@deffn Procedure make-vector @var{k}
@deffnx Procedure make-vector @var{k} @var{fill}
Return a newly allocated vector of @var{k} elements.  If a second
argument is given, then each element is initialized to @var{fill}.
Otherwise the initial contents of each element is unspecified.
@end deffn


@deffn Procedure vector @var{obj} @dots{}
Return a newly allocated vector whose elements contain the given
arguments.  Analogous to @code{list}.

@example
(vector 'a 'b 'c)               =>  #(a b c)
@end example
@end deffn


@deffn Procedure vector-length @var{vector}
Return the number of elements in @var{vector} as an exact integer
object.
@end deffn


@deffn Procedure vector-ref @var{vector} @var{k}
@var{k} must be a valid index of @var{vector}.  The @func{vector-ref}
procedure returns the contents of element @var{k} of @var{vector}.

@example
(vector-ref '#(1 1 2 3 5 8 13 21) 5)     =>  8
@end example
@end deffn


@deffn Procedure vector-set! @var{vector} @var{k} @var{obj}
@var{k} must be a valid index of @var{vector}.  The @func{vector-set!}
procedure stores @var{obj} in element @var{k} of @var{vector}, and
returns unspecified.

Passing an immutable vector to @func{vector-set!} should cause an
exception with condition type @code{&assertion} to be raised.

@example
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)
=>  #(0 ("Sue" "Sue") "Anna")

(vector-set! '#(0 1 2) 1 "doe")
=>  unspecified
    ;; constant vector
    ;; should raise exception &assertion
@end example
@end deffn


@deffn Procedure vector->list @var{vector}
@deffnx Procedure list->vector @var{list}
The @func{vector->list} procedure returns a newly allocated list of the
objects contained in the elements of @var{vector}.

The @func{list->vector} procedure returns a newly created vector
initialized to the elements of the list @var{list}.

@example
(vector->list '#(dah dah didah))        =>  (dah dah didah)
(list->vector '(dididit dah))           =>  #(dididit dah)
@end example
@end deffn


@deffn Procedure {vector-fill!} @var{vector fill}
Store @var{fill} in every element of @var{vector} and returns
unspecified.
@end deffn


@deffn Procedure vector-map @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} should
accept as many arguments as there are @var{vector}s and return a single
value.

The @func{vector-map} procedure applies @var{proc} element--wise to the
elements of the @var{vector}s and returns a vector of the results, in
order.  @var{proc} is always called in the same dynamic environment as
@func{vector-map} itself.  The order in which @var{proc} is applied to
the elements of the @var{vector}s is unspecified.  If multiple returns
occur from @func{vector-map}, the return values returned by earlier
returns are not mutated.

Analogous to @func{map}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure vector-for-each @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} should
accept as many arguments as there are @var{vector}s.  The
@code{vector-for-each} procedure applies @var{proc} element--wise to the
elements of the @var{vector}s for its side effects, in order from the
first elements to the last.  @var{proc} is always called in the same
dynamic environment as @func{vector-for-each} itself.  The return values
of @func{vector-for-each} are unspecified.

Analogous to @func{for-each}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@c ------------------------------------------------------------

@c page
@node base errors
@section Errors and violations


@deffn Procedure error @var{who} @var{message} @vari{irritant} @dots{}
@deffnx Procedure assertion-violation @var{who} @var{message} @vari{irritant} @dots{}
@var{who} must be a string or a symbol or @false{}.  @var{message} must
be a string.  The @var{irritant}s are arbitrary objects.

These procedures raise an exception.  The @func{error} procedure should
be called when an error has occurred, typically caused by something that
has gone wrong in the interaction of the program with the external world
or the user.  The @func{assertion-violation} procedure should be called
when an invalid call to a procedure was made, either passing an invalid
number of arguments, or passing an argument that it is not specified to
handle.

The @var{who} argument should describe the procedure or operation that
detected the exception.  The @var{message} argument should describe the
exceptional situation.  The @var{irritant}s should be the arguments to
the operation that detected the operation.

The condition object provided with the exception has the following
condition types:

@itemize
@item 
If @var{who} is not @false{}, the condition has condition type
@code{&who}, with @var{who} as the value of its field.  In that case,
@var{who} should be the name of the procedure or entity that detected
the exception.  If it is @false{}, the condition does not have condition
type @code{&who}.

@item 
The condition has condition type @code{&message}, with @var{message} as
the value of its field.

@item 
The condition has condition type @code{&irritants}, and its field has as
its value a list of the @var{irritant}s.
@end itemize

Moreover, the condition created by @func{error} has condition type
@code{&error}, and the condition created by @func{assertion-violation}
has condition type @code{&assertion}.

@example
(define (fac n)
  (if (not (integer-valued? n))
      (assertion-violation
       'fac "non-integral argument" n))
  (if (negative? n)
      (assertion-violation
       'fac "negative argument" n))
  (letrec
    ((loop (lambda (n r)
             (if (zero? n)
                 r
                 (loop (- n 1) (* r n))))))
      (loop n 1)))

(fac 5)         => 120
(fac 4.5)       => exception &assertion
(fac -3)        => exception &assertion
@end example
@end deffn


@deffn Syntax assert @meta{expression}
An @func{assert} form is evaluated by evaluating @meta{expression}.  If
@meta{expression} returns a true value, that value is returned from the
@func{assert} expression.  If @meta{expression} returns @false{}, an
exception with condition types @code{&assertion} and @code{&message} is
raised.  The message provided in the condition object is
implementation--dependent.

@quotation
@emph{Note:} Implementations should exploit the fact that @func{assert}
is syntax to provide as much information as possible about the location
of the assertion failure.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base control
@section Control features

 
This chapter describes various primitive procedures which control the
flow of program execution in special ways.


@deffn Procedure apply @var{proc} @vari{arg} @dots{} @var{rest-args}
@var{rest-args} must be a list.  @var{proc} should accept @emph{n}
arguments, where @emph{n} is number of @var{arg}s plus the length of
@var{rest-args}.  The @func{apply} procedure calls @var{proc} with the
elements of the list:

@example
(append (list @vari{arg} @dots{}) @var{rest-args})
@end example

@noindent
as the actual arguments.

If a call to @func{apply} occurs in a tail context, the call to
@var{proc} is also in a tail context.

@example
(apply + (list 3 4))                    =>  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)                =>  30
@end example
@end deffn


@deffn Procedure call-with-current-continuation @var{proc}
@deffnx Procedure call/cc @var{proc}
@var{proc} should accept one argument.  The procedure @func{call/cc}
(which is the same as the procedure
@func{call-with-current-continuation}) packages the current continuation
as an ``escape procedure'' and passes it as an argument to @var{proc}.

The escape procedure is a Scheme procedure that, if it is later called,
will abandon whatever continuation is in effect at that later time and
will instead reinstate the continuation that was in effect when the
escape procedure was created.

Calling the escape procedure may cause the invocation of @var{before}
and @var{after} procedures installed using @func{dynamic-wind}.

The escape procedure accepts the same number of arguments as the
continuation of the original call to @func{call/cc}.

The escape procedure that is passed to @var{proc} has unlimited extent
just like any other procedure in Scheme.  It may be stored in variables
or data structures and may be called as many times as desired.

If a call to @func{call/cc} occurs in a tail context, the call to
@var{proc} is also in a tail context.

The following examples show only some ways in which @func{call/cc} is
used.  If all real uses were as simple as these examples, there would be
no need for a procedure with the power of @func{call/cc}.

@example
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    #t))
=>  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return #f))))))
          (r obj))))))

(list-length '(1 2 3 4))                        =>  4
(list-length '(a b . c))                        => #f
(call-with-current-continuation procedure?)     => #t
@end example

@quotation
@emph{Note:} Calling an escape procedure reenters the dynamic extent of
the call to @func{call/cc}, and thus restores its dynamic environment.
@end quotation
@end deffn


@deffn Procedure values @var{obj} @dots{}
Delivers all of its arguments to its continuation.  The @func{values}
procedure might be defined as follows:

@example
(define (values . things)
  (call-with-current-continuation 
    (lambda (cont) (apply cont things))))
@end example

The continuations of all non--final expressions within a sequence of
expressions, such as in @func{lambda}, @func{begin}, @func{let},
@func{let*}, @func{letrec}, @func{letrec*}, @func{let-values},
@func{let*-values}, @func{case}, and @func{cond} forms, usually take an
arbitrary number of values.

Except for these and the continuations created by
@func{call-with-values}, @func{let-values}, and @func{let*-values},
continuations implicitly accepting a single value, such as the
continuations of @meta{operator} and @meta{operand}s of procedure calls
or the @meta{test} expressions in conditionals, take exactly one value.
The effect of passing an inappropriate number of values to such a
continuation is undefined.
@end deffn


@deffn Procedure call-with-values @var{producer} @var{consumer}
@var{producer} must be a procedure and should accept zero arguments.
@var{consumer} must be a procedure and should accept as many values as
@var{producer} returns.  The @func{call-with-values} procedure calls
@var{producer} with no arguments and a continuation that, when passed
some values, calls the @var{consumer} procedure with those values as
arguments.  The continuation for the call to @var{consumer} is the
continuation of the call to @func{call-with-values}.

@example
(call-with-values
    (lambda () (values 4 5))
  (lambda (a b) b))
=>  5

(call-with-values * -)
=>  -1
@end example

If a call to @code{call-with-values} occurs in a tail context, the call
to @var{consumer} is also in a tail context.

@strong{Implementation responsibilities:} After @var{producer} returns,
the implementation must check that @var{consumer} accepts as many values
as @var{consumer} has returned.
@end deffn


@deffn Procedure dynamic-wind @var{before} @var{thunk} @var{after}
@var{before}, @var{thunk}, and @var{after} must be procedures, and each
should accept zero arguments.  These procedures may return any number of
values.

The @func{dynamic-wind} procedure calls @var{thunk} without arguments,
returning the results of this call.  Moreover, @func{dynamic-wind} calls
@var{before} without arguments whenever the dynamic extent of the call
to @var{thunk} is entered, and @var{after} without arguments whenever
the dynamic extent of the call to @var{thunk} is exited.  Thus, in the
absence of calls to escape procedures created by @func{call/cc},
@func{dynamic-wind} calls @var{before}, @var{thunk}, and @var{after}, in
that order.

While the calls to @var{before} and @var{after} are not considered to be
within the dynamic extent of the call to @var{thunk}, calls to the
@var{before} and @var{after} procedures of any other calls to
@func{dynamic-wind} that occur within the dynamic extent of the call to
@var{thunk} are considered to be within the dynamic extent of the call
to @var{thunk}.

More precisely, an escape procedure transfers control out of the dynamic
extent of a set of zero or more active @func{dynamic-wind} calls @emph{x
@dots{}} and transfer control into the dynamic extent of a set of zero
or more active @func{dynamic-wind} calls @emph{y @dots{}}.  It leaves
the dynamic extent of the most recent @emph{x} and calls without
arguments the corresponding @var{after} procedure.  If the @var{after}
procedure returns, the escape procedure proceeds to the next most recent
@emph{x}, and so on.  Once each @emph{x} has been handled in this
manner, the escape procedure calls without arguments the @var{before}
procedure corresponding to the least recent @emph{y}.  If the
@var{before} procedure returns, the escape procedure reenters the
dynamic extent of the least recent @emph{y} and proceeds with the next
least recent @emph{y}, and so on.  Once each @emph{y} has been handled
in this manner, control is transferred to the continuation packaged in
the escape procedure.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{thunk} and @var{after} only if they are
actually called.

@example
(let ((path '())
      (c #f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
=> (connect talk1 disconnect connect talk2 disconnect)

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        (lambda ()
          (set! n (+ n 1))
          (k))
        (lambda ()
          (set! n (+ n 2)))
        (lambda ()
          (set! n (+ n 4))))))
  n)
=> 1

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        values
        (lambda ()
          (dynamic-wind
            values
            (lambda ()
              (set! n (+ n 1))
              (k))
            (lambda ()
              (set! n (+ n 2))
              (k))))
        (lambda ()
          (set! n (+ n 4))))))
  n)
=> 7
@end example

@quotation
@emph{Note:} Entering a dynamic extent restores its dynamic environment.
@end quotation
@end deffn


@c ------------------------------------------------------------

@c page
@node base iteration
@section Iteration


@cindex Named let


@deffn Syntax let @meta{variable} @meta{bindings} @meta{body}
``Named @func{let}'' is a variant on the syntax of @func{let} that
provides a general looping construct and may also be used to express
recursion.  It has the same syntax and semantics as ordinary @func{let}
except that @meta{variable} is bound within @meta{body} to a procedure
whose parameters are the bound variables and whose body is @meta{body}.
Thus the execution of @meta{body} may be repeated by invoking the
procedure named by @meta{variable}.

@example
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg))))) 
=>  ((6 1 3) (-5 -2))
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base quasiquotation
@section Quasiquotation


@deffn Syntax quasiquote @meta{qq template}
@deffnx {Auxiliary Syntax} unquote
@deffnx {Auxiliary Syntax} unquote-splicing
``Backquote'' or ``quasiquote'' expressions are useful for constructing
a list or vector structure when some but not all of the desired
structure is known in advance.

@meta{qq template} should be as specified by the grammar at the end of
this entry.

If no @func{unquote} or @func{unquote-splicing} forms appear within the
@meta{qq template}, the result of evaluating @code{(quasiquote @meta{qq
template})} is equivalent to the result of evaluating @code{(quote
@meta{qq template})}.

If an @code{(unquote @meta{expression} @dots{})} form appears inside a
@meta{qq template}, however, the @meta{expression}s are evaluated
(``unquoted'') and their results are inserted into the structure instead
of the @code{unquote} form.

If an @code{(unquote-splicing @meta{expression} @dots{})} form appears
inside a @meta{qq template}, then the @meta{expression}s must evaluate
to lists; the opening and closing parentheses of the lists are then
``stripped away'' and the elements of the lists are inserted in place of
the @func{unquote-splicing} form.

Any @func{unquote-splicing} or multi--operand @func{unquote} form must
appear only within a list or vector @meta{qq template}.

The following abbreviations may be used:

@example
(quasiquote @meta{qq template})       =  `@meta{qq template}
(unquote @meta{expression})           =  ,@meta{expression}
(unquote-splicing @meta{expression})  =  ,@@@meta{expression}
@end example

Examples:

@example
`(list ,(+ 1 2) 4)                      => (list 3 4)

(let ((name 'a))
  `(list ,name ',name))                 => (list a (quote a))

`(a ,(+ 1 2) ,@@(map abs '(4 -5 6)) b)   => (a 3 4 5 6 b)

`((foo ,(- 10 3))
  ,@@(cdr '(c)) . ,(car '(cons)))        => ((foo 7) . cons)

`#(10 5 ,(sqrt 4) ,@@(map sqrt '(16 9)) 8)      
                                        => #(10 5 2 4 3 8)

(let ((name 'foo))
  `((unquote name name name)))          => (foo foo foo)

(let ((name '(foo)))
  `((unquote-splicing name name name))) => (foo foo foo)

(let ((q '((append x y) (sqrt 9))))
  ``(foo ,,@@q))
=> `(foo (unquote (append x y) (sqrt 9)))

(let ((x '(2 3))
      (y '(4 5)))
  `(foo (unquote (append x y) (sqrt 9))))
=> (foo (2 3 4 5) 3)
@end example

Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level as the outermost
@func{quasiquote}.  The nesting level increases by one inside each
successive quasiquotation, and decreases by one inside each unquotation.

@example
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
=>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)

(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e))
=>  (a `(b ,x ,'y d) e)
@end example

A @func{quasiquote} expression may return either fresh, mutable objects
or literal structure for any structure that is constructed at run time
during the evaluation of the expression.  Portions that do not need to
be rebuilt are always literal.  Thus:

@example
(let ((a 3))
  `((1 2) ,a ,4 ,'five 6))
@end example

@noindent
may be equivalent to either of the following expressions:

@example
'((1 2) 3 4 five 6)

(let ((a 3)) 
  (cons '(1 2)
        (cons a (cons 4 (cons 'five '(6))))))
@end example

However, it is not equivalent to this expression:

@example
(let ((a 3))
  (list (list 1 2) a 4 'five 6))
@end example

It is a syntax violation if any of the identifiers @func{quasiquote},
@func{unquote}, or @func{unquote-splicing} appear in positions within a
@meta{qq template} other than as described above.

The following grammar for quasiquote expressions is not context--free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for @emph{D =
1, 2, 3, @dots{}}.  @emph{D} keeps track of the nesting depth.

@example
@meta{qq template} -> @meta{qq template 1}
@meta{qq template 0} -> @meta{expression}
@meta{quasiquotation @emph{D}} -> (quasiquote @meta{qq template @emph{D}})
@meta{qq template @emph{D}} -> @meta{lexeme datum}
    | @meta{list qq template @emph{D}}
    | @meta{vector qq template @emph{D}}
    | @meta{unquotation @emph{D}}
@meta{list qq template @emph{D}} -> (@arbno{@meta{qq template or splice @emph{D}}})
    | (@atleastone{@meta{qq template or splice @emph{D}}} . @meta{qq template @emph{D}})
    | @meta{quasiquotation @emph{D+1}}
@meta{vector qq template @emph{D}} -> #(@arbno{@meta{qq template or splice @emph{D}}})
@meta{unquotation @emph{D}} -> (unquote @meta{qq template @emph{D-1}})
@meta{qq template or splice @emph{D}} -> @meta{qq template @emph{D}}
    | @meta{splicing unquotation @emph{D}}
@meta{splicing unquotation @emph{D}} ->
      (unquote-splicing @arbno{@meta{qq template @emph{D-1}}})
    | (unquote @arbno{@meta{qq template @emph{D-1}}}) 
@end example

In @func{quasiquotation}s, a @meta{list qq template @emph{D}} can
sometimes be confused with either an @meta{unquotation @emph{D}} or a
@meta{splicing unquotation @emph{D}}.  The interpretation as an
@meta{unquotation} or @meta{splicing unquotation @emph{D}} takes
precedence.
@end deffn


@c ------------------------------------------------------------

@c page
@node base syntax binding
@section Binding constructs for syntactic keywords


@cindex Binding syntactic keywords
@cindex Syntactic keywords, binding


The @func{let-syntax} and @func{letrec-syntax} forms bind keywords.
Like a @func{begin} form, a @func{let-syntax} or @func{letrec-syntax}
form may appear in a definition context, in which case it is treated as
a definition, and the forms in the body must also be definitions.  A
@func{let-syntax} or @func{letrec-syntax} form may also appear in an
expression context, in which case the forms within their bodies must be
expressions.


@deffn Syntax let-syntax @meta{bindings} @meta{form} @dots{}
@meta{bindings} must have the form:

@example
((@meta{keyword} @meta{expression}) @dots{})
@end example

Each @meta{keyword} is an identifier, and each @meta{expression} is an
expression that evaluates, at macro--expansion time, to a
@emph{transformer}.  Transformers may be created by @func{syntax-rules}
or @func{identifier-syntax} or by one of the other mechanisms described
in library chapter ``@func{syntax-case}''.  It is a syntax violation for
@meta{keyword} to appear more than once in the list of keywords being
bound.

The @meta{form}s are expanded in the syntactic environment obtained by
extending the syntactic environment of the @func{let-syntax} form with
macros whose keywords are the @meta{keyword}s, bound to the specified
transformers.  Each binding of a @meta{keyword} has the @meta{form}s as
its region.

The @meta{form}s of a @func{let-syntax} form are treated, whether in
definition or expression context, as if wrapped in an implicit
@func{begin}.  Thus definitions in the result of expanding the
@meta{form}s have the same region as any definition appearing in place
of the @func{let-syntax} form would have.

@strong{Implementation responsibilities:} The implementation should
detect if the value of @meta{expression} cannot possibly be a
transformer.

@example
(let-syntax ([when (syntax-rules ()
                     ((when test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))])
  (let ([if #t])
    (when if (set! if 'now))
    if))
=>  now

(let ([x 'outer])
  (let-syntax ([m (syntax-rules () ((m) x))])
    (let ([x 'inner])
      (m))))
=>  outer

(let ()
  (let-syntax ([def (syntax-rules ()
                      [(def stuff ...) (define stuff ...)])])
    (def foo 42))
  foo)
=> 42

(let ()
  (let-syntax ())
  5)
=> 5
@end example
@end deffn


@deffn Syntax letrec-syntax @meta{bindings} @meta{form} @dots{}
Same as for @func{let-syntax}.

The @meta{form}s are expanded in the syntactic environment obtained by
extending the syntactic environment of the @func{letrec-syntax} form
with macros whose keywords are the @meta{keyword}s, bound to the
specified transformers.  Each binding of a @meta{keyword} has the
@meta{bindings} as well as the @meta{form}s within its region, so the
transformers can transcribe forms into uses of the macros introduced by
the @func{letrec-syntax} form.

The @meta{form}s of a @func{letrec-syntax} form are treated, whether in
definition or expression context, as if wrapped in an implicit
@func{begin}.  Thus definitions in the result of expanding the
@meta{form}s have the same region as any definition appearing in place
of the @func{letrec-syntax} form would have.

@strong{Implementation responsibilities:} The implementation should
detect if the value of @meta{expression} cannot possibly be a
transformer.

@example
(letrec-syntax
    ([my-or (syntax-rules ()
              [(my-or)    #f]
              [(my-or e)  e]
              [(my-or e1 e2 ...)  (let ([temp e1])
                                    (if temp
                                        temp
                                     (my-or e2 ...)))])])
  (let ([x      #f]
        [y      7]
        [temp   8]
        [let    odd?]
        [if     even?])
    (my-or x (let temp) (if y) y)))
=> 7
@end example

The following example highlights how @func{let-syntax} and
@func{letrec-syntax} differ.

@example
(let ([f (lambda (x) (+ x 1))])
  (let-syntax ([f (syntax-rules ()
                    [(f x) x])]
               [g (syntax-rules ()
                    [(g x) (f x)])])
    (list (f 1) (g 1))))
=> (1 2)

(let ([f (lambda (x) (+ x 1))])
  (letrec-syntax ([f (syntax-rules ()
                       [(f x) x])]
                  [g (syntax-rules ()
                       [(g x) (f x)])])
    (list (f 1) (g 1))))
=> (1 1)
@end example

The two expressions are identical except that the @func{let-syntax} form
in the first expression is a @func{letrec-syntax} form in the second.
In the first expression, the @code{f} occurring in @code{g} refers to
the @func{let}-bound variable @code{f}, whereas in the second it refers
to the keyword @code{f} whose binding is established by the
@func{letrec-syntax} form.
@end deffn


@c ------------------------------------------------------------

@c page
@node base transformers
@section Macro transformers


@cindex Macro transformers
@cindex Transformers, macro


@deffn {Syntax @code{(expand)}} syntax-rules (@meta{literal} @dots{}) @meta{syntax rule} @dots{}
@deffnx {Auxiliary Syntax @code{(expand)}} _
@deffnx {Auxiliary Syntax @code{(expand)}} ...
Each @meta{literal} must be an identifier.  Each @meta{syntax rule} must
have the following form:

@example
(@meta{srpattern} @meta{template})
@end example

An @meta{srpattern} is a restricted form of @meta{pattern}, namely, a
nonempty @meta{pattern} in one of four parenthesized forms below whose
first subform is an identifier or an underscore @code{_}.  A
@meta{pattern} is an identifier, constant, or one of the following.

@example
(@meta{pattern} @dots{})
(@meta{pattern} @meta{pattern} @dots{} . @meta{pattern})
(@meta{pattern} @dots{} @meta{pattern} @meta{ellipsis} @meta{pattern} @dots{})
(@meta{pattern} @dots{} @meta{pattern} @meta{ellipsis} @meta{pattern} @dots{} . @meta{pattern})
#(@meta{pattern} @dots{})
#(@meta{pattern} @dots{} @meta{pattern} @meta{ellipsis} @meta{pattern} @dots{})
@end example

An @meta{ellipsis} is the identifier @code{...} (three periods).

A @meta{template} is a pattern variable, an identifier that is not a
pattern variable, a pattern datum, or one of the following.

@example
(@meta{subtemplate} @dots{})
(@meta{subtemplate} @dots{} . @meta{template})
#(@meta{subtemplate} @dots{})
@end example

A @meta{subtemplate} is a @meta{template} followed by zero or more
ellipses.

An instance of @func{syntax-rules} evaluates, at macro--expansion time,
to a new macro transformer by specifying a sequence of hygienic rewrite
rules.  A use of a macro whose keyword is associated with a transformer
specified by @func{syntax-rules} is matched against the patterns
contained in the @meta{syntax rule}s, beginning with the leftmost
@meta{syntax rule}.  When a match is found, the macro use is transcribed
hygienically according to the template.  It is a syntax violation when
no match is found.

An identifier appearing within a @meta{pattern} may be an underscore
(@code{_}), a literal identifier listed in the list of literals
@code{(@meta{literal} @dots{})}, or an ellipsis (@code{...}).  All other
identifiers appearing within a @meta{pattern} are @emph{pattern
variables}.  It is a syntax violation if an ellipsis or underscore
appears in @code{(@meta{literal} @dots{})}.

While the first subform of @meta{srpattern} may be an identifier, the
identifier is not involved in the matching and is not considered a
pattern variable or literal identifier.

Pattern variables match arbitrary input subforms and are used to refer
to elements of the input.  It is a syntax violation if the same pattern
variable appears more than once in a @meta{pattern}.

Underscores also match arbitrary input subforms but are not pattern
variables and so cannot be used to refer to those elements.  Multiple
underscores may appear in a @meta{pattern}.

A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.

A subpattern followed by an ellipsis can match zero or more elements of
the input.

More formally, an input form @emph{F} matches a pattern @emph{P} if and
only if one of the following holds:

@itemize
@item 
@emph{P} is an underscore (@code{_}).

@item 
@emph{P} is a pattern variable.

@item 
@emph{P} is a literal identifier and @emph{F} is an identifier such that
both @emph{P} and @emph{F} would refer to the same binding if both were
to appear in the output of the macro outside of any bindings inserted
into the output of the macro.  (If neither of two like--named
identifiers refers to any binding, i.e., both are undefined, they are
considered to refer to the same binding.)

@item 
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_n})
@end example

@noindent
and @emph{F} is a list of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item 
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_n} . @emph{P_x})
@end example

@noindent
and @emph{F} is a list or improper list of @emph{n} or more elements
whose first @emph{n} elements match @emph{P_1} through @emph{P_n} and
whose @emph{n}th cdr matches @emph{P_x}.

@item 
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_k} @emph{P_e} @meta{ellipsis} @emph{P_(m+1)} @dots{} @emph{P_n})
@end example

@noindent
where @meta{ellipsis} is the identifier @code{...}  and @emph{F} is a
list of @emph{n} elements whose first @emph{k} elements match @emph{P_1}
through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item 
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_k} @emph{P_e} @meta{ellipsis} @emph{P_(m+1)} @dots{} @emph{P_n} . @emph{P_x})
@end example

@noindent
where @meta{ellipsis} is the identifier @code{...} and @emph{F} is a
list or improper list of @emph{n} elements whose first @emph{k} elements
match @emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each
match @emph{P_e}, whose next @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}, and whose @emph{n}th and final cdr matches
@emph{P_x}.

@item 
@emph{P} is of the form:

@example
#(@emph{P_1} @dots{} @emph{P_n})
@end example

@noindent
and @emph{F} is a vector of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item 
@emph{P} is of the form:

@example
#(@emph{P_1} @dots{} @emph{P_k} @emph{P_e} @meta{ellipsis} @emph{P_(m+1)} @dots{} @emph{P_n})
@end example

@noindent
where @meta{ellipsis} is the identifier @code{...} and @emph{F} is a
vector of @emph{n} or more elements whose first @emph{k} elements match
@emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item 
@emph{P} is a pattern datum (any nonlist, nonvector, nonsymbol datum)
and @emph{F} is equal to @emph{P} in the sense of the @func{equal?}
procedure.
@end itemize

When a macro use is transcribed according to the template of the
matching @meta{syntax rule}, pattern variables that occur in the
template are replaced by the subforms they match in the input.

Pattern data and identifiers that are not pattern variables or ellipses
are copied into the output.  A subtemplate followed by an ellipsis
expands into zero or more occurrences of the subtemplate.  Pattern
variables that occur in subpatterns followed by one or more ellipses may
occur only in subtemplates that are followed by (at least) as many
ellipses.  These pattern variables are replaced in the output by the
input subforms to which they are bound, distributed as specified.  If a
pattern variable is followed by more ellipses in the subtemplate than in
the associated subpattern, the input form is replicated as necessary.
The subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses
as the subpattern in which the pattern variable appears.  (Otherwise,
the expander would not be able to determine how many times the subform
should be repeated in the output.)  It is a syntax violation if the
constraints of this paragraph are not met.

A template of the form @code{(@meta{ellipsis} @meta{template})} is
identical to @meta{template}, except that ellipses within the template
have no special meaning.  That is, any ellipses contained within
@meta{template} are treated as ordinary identifiers.  In particular, the
template @code{(... ...)} produces a single ellipsis, @code{...}.  This
allows syntactic abstractions to expand into forms containing ellipses.

@example
(define-syntax be-like-begin
  (syntax-rules ()
    [(be-like-begin name)
     (define-syntax name
       (syntax-rules ()
         ((name expr (... ...))
          (begin expr (... ...)))))]))

(be-like-begin sequence)
(sequence 1 2 3 4) => 4
@end example

As an example for hygienic use of auxiliary identifier, if @func{let}
and @func{cond} are defined as in @ref{base expressions binding} and
@ref{derived} then they are hygienic (as required) and the following is
not an error.

@example
(let ((=> #f))
  (cond (#t => 'ok)))           => ok
@end example

The macro transformer for @func{cond} recognizes @code{=>} as a local
variable, and hence an expression, and not as the identifier @code{=>},
which the macro transformer treats as a syntactic keyword.  Thus the
example expands into:

@example
(let ((=> #f))
  (if #t (begin => 'ok)))
@end example

@noindent
instead of:

@example
(let ((=> #f))
  (let ((temp #t))
    (if temp ('ok temp))))
@end example

@noindent
which would result in an assertion violation.
@end deffn


@deffn {Syntax @code{(expand)}} identifier-syntax @meta{template}
@deffnx {Syntax @code{(expand)}} identifier-syntax (@hyperi{id} @metai{template}) ((set! @hyperii{id} @meta{pattern}) @hyperii{template})
@deffnx {Auxiliary Syntax @code{(expand)}} set!
The @meta{id}s must be identifiers.  The @meta{template}s must be as for
@func{syntax-rules}.

When a keyword is bound to a transformer produced by the first form of
@func{identifier-syntax}, references to the keyword within the scope of
the binding are replaced by @meta{template}.

@example
(define p (cons 4 5))
(define-syntax p.car (identifier-syntax (car p)))
p.car => 4
(set! p.car 15) => exception &syntax
@end example

The second, more general, form of @func{identifier-syntax} permits the
transformer to determine what happens when @code{set!} is used.  In this
case, uses of the identifier by itself are replaced by
@hyperi{template}, and uses of @code{set!} with the identifier are
replaced by @hyperii{template}.

@example
(define p (cons 4 5))
(define-syntax p.car
  (identifier-syntax
    [_ (car p)]
    [(set! _ e) (set-car! p e)]))
(set! p.car 15)
p.car           => 15
p               => (15 . 5)
@end example
@end deffn


@c ------------------------------------------------------------

@c page
@node base tail call
@section Tail calls and tail contexts


@cindex Tail call
@cindex Tail contexts


A @emph{tail call} is a procedure call that occurs in a @emph{tail
context}.  Tail contexts are defined inductively.  Note that a tail
context is always determined with respect to a particular lambda
expression.

@itemize
@item 
The last expression within the body of a lambda expression, shown as
@meta{tail expression} below, occurs in a tail context.

@example
(lambda @meta{formals}
  @arbno{@meta{definition}}
  @arbno{@meta{expression}} @meta{tail expression})
@end example

@item 
If one of the following expressions is in a tail context, then the
subexpressions shown as @meta{tail expression} are in a tail context.
These were derived from specifications of the syntax of the forms
described in this chapter by replacing some occurrences of
@meta{expression} with @meta{tail expression}.  Only those rules that
contain tail contexts are shown here.

@example
(if @meta{expression} @meta{tail expression} @meta{tail expression})
(if @meta{expression} @meta{tail expression})

(cond @atleastone{@meta{cond clause}})
(cond @arbno{@meta{cond clause}} (else @meta{tail sequence}))

(case @meta{expression}
  @atleastone{@meta{case clause}})
(case @meta{expression}
  @arbno{@meta{case clause}}
  (else @meta{tail sequence}))

(and @arbno{@meta{expression}} @meta{tail expression})
(or @arbno{@meta{expression}} @meta{tail expression})

(let @meta{bindings} @meta{tail body})
(let @meta{variable} @meta{bindings} @meta{tail body})
(let* @meta{bindings} @meta{tail body})
(letrec* @meta{bindings} @meta{tail body})
(letrec @meta{bindings} @meta{tail body})
(let-values @meta{mv-bindings} @meta{tail body})
(let*-values @meta{mv-bindings} @meta{tail body})

(let-syntax @meta{bindings} @meta{tail body})
(letrec-syntax @meta{bindings} @meta{tail body})

(begin @meta{tail sequence})
@end example

A @meta{cond clause} is:

@example
(@meta{test} @meta{tail sequence})
@end example

@noindent
a @meta{case clause} is:

@example
((@arbno{@meta{datum}}) @meta{tail sequence})
@end example

@noindent
a @meta{tail body} is:

@example
@arbno{@meta{definition}} @meta{tail sequence}
@end example

@noindent
and a @meta{tail sequence} is:

@example
@arbno{@meta{expression}} @meta{tail expression}
@end example

@item
If a @func{cond} expression is in a tail context, and has a clause of
the form @code{(@hyperi{expression} => @hyperii{expression})} then the
(implied) call to the procedure that results from the evaluation of
@hyperii{expression} is in a tail context.  @hyperii{expression} itself
is not in a tail context.
@end itemize

Certain built--in procedures must also perform tail calls.  The first
argument passed to @func{apply} and to @func{call/cc}, and the second
argument passed to @func{call-with-values}, must be called via a tail
call.

In the following example the only tail call is the call to @func{f}.
None of the calls to @func{g} or @func{h} are tail calls.  The reference
to @code{x} is in a tail context, but it is not a call and thus is not a
tail call.

@example
(lambda ()
  (if (g)
      (let ((x (h)))
        x)
      (and (g) (f))))
@end example

@quotation
@emph{Note:} Implementations may recognize that some non--tail calls,
such as the call to @func{h} above, can be evaluated as though they were
tail calls.  In the example above, the @func{let} expression could be
compiled as a tail call to @func{h}.  (The possibility of @func{h}
returning an unexpected number of values can be ignored, because in that
case the effect of the @func{let} is explicitly unspecified and
implementation--dependent.)
@end quotation


@c ------------------------------------------------------------

@c page
@node semantics
@appendix Formal semantics


@center @strong{OMITTED}


@c ------------------------------------------------------------

@c page
@node derived
@appendix Sample definitions for derived forms


@ignore
In the original document this appendix is the file "derived.tex".
@end ignore


This appendix contains sample definitions for some of the keywords
described in this report in terms of simpler forms:


@c ------------------------------------------------------------

@subsubheading @func{cond}

The @func{cond} keyword could be defined in terms of @func{if},
@func{let} and @func{begin} using @func{syntax-rules} as follows:

@example
(define-syntax cond
  (syntax-rules (else =>)
    ((cond (else result1 result2 ...))
     (begin result1 result2 ...))
    ((cond (test => result))
     (let ((temp test))
       (if temp (result temp))))
    ((cond (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           (result temp)
           (cond clause1 clause2 ...))))
    ((cond (test)) test)
    ((cond (test) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           temp
           (cond clause1 clause2 ...))))
    ((cond (test result1 result2 ...))
     (if test (begin result1 result2 ...)))
    ((cond (test result1 result2 ...)
           clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (cond clause1 clause2 ...)))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{case}

The @func{case} keyword could be defined in terms of @func{let},
@func{cond}, and @func{memv} using @code{syntax-rules} as follows:

@example
(define-syntax case
  (syntax-rules (else)
    ((case expr0
       ((key ...) res1 res2 ...)
       ...
       (else else-res1 else-res2 ...))
     (let ((tmp expr0))
       (cond
         ((memv tmp '(key ...)) res1 res2 ...)
         ...
         (else else-res1 else-res2 ...))))
    ((case expr0
       ((keya ...) res1a res2a ...)
       ((keyb ...) res1b res2b ...)
       ...)
     (let ((tmp expr0))
       (cond
         ((memv tmp '(keya ...)) res1a res2a ...)
         ((memv tmp '(keyb ...)) res1b res2b ...)
         ...)))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{let*}

The @func{let*} keyword could be defined in terms of @func{let} using
@func{syntax-rules} as follows:

@example
(define-syntax let*
  (syntax-rules ()
    ((let* () body1 body2 ...)
     (let () body1 body2 ...))
    ((let* ((name1 expr1) (name2 expr2) ...)
       body1 body2 ...)
     (let ((name1 expr1))
       (let* ((name2 expr2) ...)
         body1 body2 ...)))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{letrec}

The @func{letrec} keyword could be defined approximately in terms of
@func{let} and @func{set!} using @func{syntax-rules}, using a helper to
generate the temporary variables needed to hold the values before the
assignments are made, as follows:

@example
(define-syntax letrec
  (syntax-rules ()
    ((letrec () body1 body2 ...)
     (let () body1 body2 ...))
    ((letrec ((var init) ...) body1 body2 ...)
     (letrec-helper
       (var ...)
       ()
       ((var init) ...)
       body1 body2 ...))))

(define-syntax letrec-helper
  (syntax-rules ()
    ((letrec-helper
       ()
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (let ((var <undefined>) ...)
       (let ((temp init) ...)
         (set! var temp)
         ...)
       (let () body1 body2 ...)))
    ((letrec-helper
       (x y ...)
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (letrec-helper
       (y ...)
       (newtemp temp ...)
       ((var init) ...)
       body1 body2 ...))))
@end example

The syntax @code{<undefined>} represents an expression that returns
something that, when stored in a location, causes an exception with
condition type @code{&assertion} to be raised if an attempt to read from
or write to the location occurs before the assignments generated by the
@func{letrec} transformation take place.  (No such expression is defined
in Scheme.)

@c ------------------------------------------------------------

@subsubheading @func{letrec*}

The @func{letrec*} keyword could be defined approximately in terms of
@func{let} and @func{set!} using @func{syntax-rules} as follows:

@example
(define-syntax letrec*
  (syntax-rules ()
    ((letrec* ((var1 init1) ...) body1 body2 ...)
     (let ((var1 <undefined>) ...)
       (set! var1 init1)
       ...
       (let () body1 body2 ...)))))
@end example

The syntax @code{<undefined>} is as in the definition of @func{letrec}
above.

@c ------------------------------------------------------------

@subsubheading @func{let-values}

The following definition of @func{let-values} using @func{syntax-rules}
employs a pair of helpers to create temporary names for the formals.

@example
(define-syntax let-values
  (syntax-rules ()
    ((let-values (binding ...) body1 body2 ...)
     (let-values-helper1
       ()
       (binding ...)
       body1 body2 ...))))

(define-syntax let-values-helper1
  ;; map over the bindings
  (syntax-rules ()
    ((let-values
       ((id temp) ...)
       ()
       body1 body2 ...)
     (let ((id temp) ...) body1 body2 ...))
    ((let-values
       assocs
       ((formals1 expr1) (formals2 expr2) ...)
       body1 body2 ...)
     (let-values-helper2
       formals1
       ()
       expr1
       assocs
       ((formals2 expr2) ...)
       body1 body2 ...))))

(define-syntax let-values-helper2
  ;; create temporaries for the formals
  (syntax-rules ()
    ((let-values-helper2
       ()
       temp-formals
       expr1
       assocs
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda temp-formals
         (let-values-helper1
           assocs
           bindings
           body1 body2 ...))))
    ((let-values-helper2
       (first . rest)
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (let-values-helper2
       rest
       (temp ... newtemp)
       expr1
       (assoc ... (first newtemp))
       bindings
       body1 body2 ...))
    ((let-values-helper2
       rest-formal
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda (temp ... . newtemp)
         (let-values-helper1
           (assoc ... (rest-formal newtemp))
           bindings
           body1 body2 ...))))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{let*-values}

The following macro defines @func{let*-values} in terms of @func{let}
and @func{let-values} using @func{syntax-rules}:

@example
(define-syntax let*-values
  (syntax-rules ()
    ((let*-values () body1 body2 ...)
     (let () body1 body2 ...))
    ((let*-values (binding1 binding2 ...)
       body1 body2 ...)
     (let-values (binding1)
       (let*-values (binding2 ...)
         body1 body2 ...)))))
@end example


@c ------------------------------------------------------------

@subsubheading @func{let}

The @func{let} keyword could be defined in terms of @func{lambda} and
@func{letrec} using @func{syntax-rules} as follows:

@example
(define-syntax @func{let}
  (syntax-rules ()
    ((let ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
      val ...))
    ((let tag ((name val) ...) body1 body2 ...)
     ((letrec ((tag (lambda (name ...)
                      body1 body2 ...)))
        tag)
      val ...))))
@end example


@c ------------------------------------------------------------

@c page
@node repository
@appendix Additional material


@ignore
In the original document this appendix is the file "repository.tex".
@end ignore


This report itself, as well as more material related to this report such
as reference implementations of some parts of Scheme and archives of
mailing lists discussing this report is at:

@center @url{http://www.r6rs.org/}

The Schemers web site at:

@center @url{http://www.schemers.org/}

@noindent
as well as the ReadScheme site at:

@center @url{http://library.readscheme.org/}

@noindent
contain extensive Scheme bibliographies, as well as papers, programs,
implementations, and other material related to Scheme.


@c ------------------------------------------------------------

@c page
@node example
@appendix Example


@ignore
In the original document this appendix is the file "example.tex".
@end ignore


This section describes an example consisting of the
@library{runge-kutta} library, which provides an @func{integrate-system}
procedure that integrates the system

@example
y_k^\prime = f_k(y_1, y_2, ..., y_n)   k = 1, ..., n
@end example

@noindent
of differential equations with the method of Runge--Kutta.

As the @library{runge-kutta} library makes use of the @rsixlibrary{base}
library, its skeleton is as follows:

@example
#!r6rs
(library (runge-kutta)
  (export integrate-system
          head tail)
  (import (rnrs base))
  @meta{library body})
@end example

The procedure definitions described below go in the place of
@meta{library body}.

The parameter @code{system-derivative} is a function that takes a system
state (a vector of values for the state variables @code{y_1, ..., y_n})
and produces a system derivative (the values @code{y_1^\prime, ...,
y_n^\prime}).  The parameter @code{initial-state} provides an initial
system state, and @code{h} is an initial guess for the length of the
integration step.

The value returned by @func{integrate-system} is an infinite stream of
system states.

@example
(define integrate-system
  (lambda (system-derivative initial-state h)
    (let ((next (runge-kutta-4 system-derivative h)))
      (letrec ((states
                (cons initial-state
                      (lambda ()
                        (map-streams next states)))))
        states))))
@end example

The @func{runge-kutta-4} procedure takes a function, @func{f}, that
produces a system derivative from a system state.  The
@func{runge-kutta-4} procedure produces a function that takes a system
state and produces a new system state.

@example
(define runge-kutta-4
  (lambda (f h)
    (let ((*h (scale-vector h))
          (*2 (scale-vector 2))
          (*1/2 (scale-vector (/ 1 2)))
          (*1/6 (scale-vector (/ 1 6))))
      (lambda (y)
        ;; y is a system state
        (let* ((k0 (*h (f y)))
               (k1 (*h (f (add-vectors y (*1/2 k0)))))
               (k2 (*h (f (add-vectors y (*1/2 k1)))))
               (k3 (*h (f (add-vectors y k2)))))
          (add-vectors y
            (*1/6 (add-vectors k0
                               (*2 k1)
                               (*2 k2)
                               k3))))))))


(define elementwise
  (lambda (f)
    (lambda vectors
      (generate-vector
        (vector-length (car vectors))
        (lambda (i)
          (apply f
                 (map (lambda (v) (vector-ref  v i))
                      vectors)))))))


(define generate-vector
  (lambda (size proc)
    (let ((ans (make-vector size)))
      (letrec ((loop
                (lambda (i)
                  (cond ((= i size) ans)
                        (else
                         (vector-set! ans i (proc i))
                         (loop (+ i 1)))))))
        (loop 0)))))

(define add-vectors (elementwise +))

(define scale-vector
  (lambda (s)
    (elementwise (lambda (x) (* x s)))))
@end example

The @func{map-streams} procedure is analogous to @func{map}: it applies
its first argument (a procedure) to all the elements of its second
argument (a stream).

@example
(define map-streams
  (lambda (f s)
    (cons (f (head s))
          (lambda () (map-streams f (tail s))))))
@end example

Infinite streams are implemented as pairs whose car holds the first
element of the stream and whose cdr holds a procedure that delivers the
rest of the stream.

@example
(define head car)
(define tail
  (lambda (stream) ((cdr stream))))
@end example

The following program illustrates the use of @func{integrate-system} in
integrating the system:

@example
C dv_C/dt = -i_L - v_C/R
L di_L/dt = v_C
@end example

@noindent
which models a damped oscillator.

@example
#!r6rs
(import (rnrs base)
        (rnrs io simple)
        (runge-kutta))

(define damped-oscillator
  (lambda (R L C)
    (lambda (state)
      (let ((Vc (vector-ref state 0))
            (Il (vector-ref state 1)))
        (vector (- 0 (+ (/ Vc (* R C)) (/ Il C)))
                (/ Vc L))))))

(define the-states
  (integrate-system
     (damped-oscillator 10000 1000 .001)
     '#(1 0)
     .01))

(letrec ((loop (lambda (s)
                 (newline)
                 (write (head s))
                 (loop (tail s)))))
  (loop the-states))

(close-output-port (current-output-port))
@end example

This prints output like the following:

@example
#(1 0)
#(0.99895054 9.994835e-6)
#(0.99780226 1.9978681e-5)
#(0.9965554 2.9950552e-5)
#(0.9952102 3.990946e-5)
#(0.99376684 4.985443e-5)
#(0.99222565 5.9784474e-5)
#(0.9905868 6.969862e-5)
#(0.9888506 7.9595884e-5)
#(0.9870173 8.94753e-5)
@end example


@c ------------------------------------------------------------

@c page
@node changes
@appendix Language changes


This chapter describes most of the changes that have been made to Scheme
since the ``Revised^5 Report'' was published:

@itemize
@item 
Scheme source code now uses the Unicode character set.  Specifically,
the character set that can be used for identifiers has been greatly
expanded.

@item 
Identifiers can now start with the characters @code{->}.

@item 
Identifiers and symbol literals are now case--sensitive.

@item 
Identifiers and representations of characters, booleans, number objects,
and @code{.} must be explicitly delimited.

@item 
@code{#} is now a delimiter.

@item 
Bytevector literal syntax has been added.

@item 
Matched square brackets can be used synonymously with parentheses.

@item 
The read--syntax abbreviations @code{#'} (for @func{syntax}),
@code{#\backquote} (for @func{quasisyntax}), @code{#}, (for
@func{unsyntax}), and @code{#,@@} (for @func{unsyntax-splicing}) have
been added.

@item 
@code{#} can no longer be used in place of digits in number
representations.

@item 
The external representation of number objects can now include a mantissa
width.

@item 
Literals for NaNs and infinities were added.

@item 
String and character literals can now use a variety of escape sequences.

@item 
Block and datum comments have been added.

@item 
The @code{#!r6rs} comment for marking report--compliant lexical syntax
has been added.

@item 
Characters are now specified to correspond to Unicode scalar values.

@item 
Many of the procedures and syntactic forms of the language are now part
of the @rsixlibrary{base} library.  Some procedures and syntactic forms
have been moved to other libraries.

@multitable {@code{scheme-report-environment}} @tab {@rsixlibrary{mutable-strings}}
@headitem Identifier @tab moved to
@item @code{assoc} @tab @rsixlibrary{lists}
@item @code{assv} @tab @rsixlibrary{lists}
@item @code{assq} @tab @rsixlibrary{lists}
@item @code{call-with-input-file} @tab @rsixlibrary{io simple}
@item @code{call-with-output-file} @tab @rsixlibrary{io simple}
@item @code{char-upcase} @tab @rsixlibrary{unicode}
@item @code{char-downcase} @tab @rsixlibrary{unicode}
@item @code{char-ci=?} @tab @rsixlibrary{unicode}
@item @code{char-ci<?} @tab @rsixlibrary{unicode}
@item @code{char-ci>?} @tab @rsixlibrary{unicode}
@item @code{char-ci<=?} @tab @rsixlibrary{unicode}
@item @code{char-ci>=?} @tab @rsixlibrary{unicode}
@item @code{char-alphabetic?} @tab @rsixlibrary{unicode}
@item @code{char-numeric?} @tab @rsixlibrary{unicode}
@item @code{char-whitespace?} @tab @rsixlibrary{unicode}
@item @code{char-upper-case?} @tab @rsixlibrary{unicode}
@item @code{char-lower-case?} @tab @rsixlibrary{unicode}
@item @code{close-input-port} @tab @rsixlibrary{io simple}
@item @code{close-output-port} @tab @rsixlibrary{io simple}
@item @code{current-input-port} @tab @rsixlibrary{io simple}
@item @code{current-output-port} @tab @rsixlibrary{io simple}
@item @code{display} @tab @rsixlibrary{io simple}
@item @code{do} @tab @rsixlibrary{control}
@item @code{eof-object?} @tab @rsixlibrary{io simple}
@item @code{eval} @tab @rsixlibrary{eval}
@item @code{delay} @tab @rsixlibrary{r5rs}
@item @code{exact->inexact} @tab @rsixlibrary{r5rs}
@item @code{force} @tab @rsixlibrary{r5rs}
@item @code{inexact->exact} @tab @rsixlibrary{r5rs}
@item @code{member} @tab @rsixlibrary{lists}
@item @code{memv} @tab @rsixlibrary{lists}
@item @code{memq} @tab @rsixlibrary{lists}
@item @code{modulo} @tab @rsixlibrary{r5rs}
@item @code{newline} @tab @rsixlibrary{io simple}
@item @code{null-environment} @tab @rsixlibrary{r5rs}
@item @code{open-input-file} @tab @rsixlibrary{io simple}
@item @code{open-output-file} @tab @rsixlibrary{io simple}
@item @code{peek-char} @tab @rsixlibrary{io simple}
@item @code{quotient} @tab @rsixlibrary{r5rs}
@item @code{read} @tab @rsixlibrary{io simple}
@item @code{read-char} @tab @rsixlibrary{io simple}
@item @code{remainder} @tab @rsixlibrary{r5rs}
@item @code{scheme-report-environment} @tab @rsixlibrary{r5rs}
@item @code{set-car!} @tab @rsixlibrary{mutable-pairs}
@item @code{set-cdr!} @tab @rsixlibrary{mutable-pairs}
@item @code{string-ci=?} @tab @rsixlibrary{unicode}
@item @code{string-ci<?} @tab @rsixlibrary{unicode}
@item @code{string-ci>?} @tab @rsixlibrary{unicode}
@item @code{string-ci<=?} @tab @rsixlibrary{unicode}
@item @code{string-ci>=?} @tab @rsixlibrary{unicode}
@item @code{string-set!} @tab @rsixlibrary{mutable-strings}
@item @code{string-fill!} @tab @rsixlibrary{mutable-strings}
@item @code{with-input-from-file} @tab @rsixlibrary{io simple}
@item @code{with-output-to-file} @tab @rsixlibrary{io simple}
@item @code{write} @tab @rsixlibrary{io simple}
@item @code{write-char} @tab @rsixlibrary{io simple}
@end multitable

@item 
The base language has the following new procedures and syntactic forms:

@example
letrec*                 let-values              let*-values
real-valued?            rational-valued?        integer-valued?
exact                   inexact                 finite?
infinite?               nan?                    div
mod                     div-and-mod             div0
mod0                    div0-and-mod0           exact-integer-sqrt
boolean=?               symbol=?                string-for-each
vector-map              vector-for-each         error
assertion-violation     assert                  call/cc
identifier-syntax
@end example

@item 
The following procedures have been removed: @func{char-ready?},
@func{transcript-on}, @func{transcript-off}, @func{load}.

@item 
The case--insensitive string comparisons:

@example
string-ci=?
string-ci<?             string-ci>?
string-ci<=?            string-ci>=?
@end example

@noindent
operate on the case--folded versions of the strings rather than as the
simple lexicographic ordering induced by the corresponding character
comparison procedures.

@item 
Libraries have been added to the language.

@item 
A number of standard libraries are described in a separate report.

@item 
Many situations that ``were an error'' now have defined or constrained
behavior.  In particular, many are now specified in terms of the
exception system.

@item 
The full numerical tower is now required.

@item 
The semantics for the transcendental functions has been specified more
fully.

@item 
The semantics of @func{expt} for zero bases has been refined.

@item 
In @func{syntax-rules} forms, a @code{_} may be used in place of the
keyword.

@item 
The @func{let-syntax} and @func{letrec-syntax} no longer introduce a new
environment for their bodies.

@item 
For implementations that support NaNs or infinities, many arithmetic
operations have been specified on these values consistently with @ieee{}
754.

@item 
For implementations that support a distinct @code{-0.0}, the semantics
of many arithmetic operations with regard to @code{-0.0} has been
specified consistently with @ieee{} 754.

@item 
Scheme's real number objects now have an exact zero as their imaginary
part.

@item 
The specification of @func{quasiquote} has been extended.  Nested
quasiquotations work correctly now, and @func{unquote} and
@func{unquote-splicing} have been extended to several operands.

@item 
Procedures now may or may not refer to locations.  Consequently,
@func{eqv?} is now unspecified in a few cases where it was specified
before.

@item 
The mutability of the values of @func{quasiquote} structures has been
specified to some degree.

@item 
The dynamic environment of the @var{before} and @var{after} procedures
of @func{dynamic-wind} is now specified.

@item 
Various expressions that have only side effects are now allowed to
return an arbitrary number of values.

@item 
The order and semantics for macro expansion has been more fully
specified.

@item 
Internal definitions are now defined in terms of @func{letrec*}.

@item 
The old notion of program structure and Scheme's top--level environment
has been replaced by top--level programs and libraries.

@item 
The denotational semantics has been replaced by an operational semantics
based on an earlier semantics for the language of the ``Revised^5
Report''.
@end itemize


@c ------------------------------------------------------------

@c page
@node references
@appendix Bibliography and references


@center @strong{OMITTED (sorry but there are so many of them)}


@c ------------------------------------------------------------

@c page
@node concept index
@appendix An entry for each concept
     
@printindex cp
     
@node function index
@appendix An entry for each function. 

@printindex fn

@node variable index
@appendix An entry for each variable. 

@printindex vr

@node type index
@appendix An entry for each type. 

@printindex tp

@contents
@bye

@c end of file
