\input texinfo.tex
@c %**start of header
@setfilename ikarus.info
@settitle The Other Ikarus Scheme User's Guide
@c %**end of header

@ignore

List of things to do
====================

* Write the "contrib gl" node.
* Write documentation for "contrib number theory" node.

* Document the 'PRINT-UNICODE' parameter in the node "ikarus printing".

* Document SRFI-14, char-set

* Document SRFI-67, compare. (Are you sure that you want to reformat
  that monster?)

* Document SRFI-?, shared.

* Document the internal select-base event loop from
  "scheme/ikarus.io.ss".

* Document loading files with LOAD and importing libraries from loaded
  files.

* Understand if SYMBOL-BOUND? does something useful or not.

@end ignore


@c page
@c ------------------------------------------------------------
@c Macros.
@c ------------------------------------------------------------

@macro version{}
0.0.3+ (revision 1661)
@end macro

@macro texiversion{}
2008-12-01-17-00-51
@end macro

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@macro fdl{}
@acronym{FDL}
@end macro


@c page
@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@macro unstable{REVISION}
@quotation
@strong{Undocumented feature:} this feature is still undocumented in
Ikarus revision \REVISION\, so it may change in the future.
@end quotation
@end macro



@c page
@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rnrs{VERSION}
@acronym{R\VERSION\RS}
@end macro

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro



@c page
@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro utf{}
@acronym{UTF}
@end macro


@c page
@c ------------------------------------------------------------
@c Software acronyms.
@c ------------------------------------------------------------

@macro gmp{}
@acronym{GMP}
@end macro

@macro gcc{}
@acronym{GCC}
@end macro


@c page
@c ------------------------------------------------------------
@c Network related acronyms.
@c ------------------------------------------------------------

@macro http{}
@acronym{HTTP}
@end macro

@macro ftp{}
@acronym{FTP}
@end macro

@macro tcp{}
@acronym{TCP}
@end macro

@macro udp{}
@acronym{UDP}
@end macro

@macro smtp{}
@acronym{SMTP}
@end macro


@c page
@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro

@macro null{}
@code{()}
@end macro

@macro true{}
@code{#t}
@end macro

@macro false{}
@code{#f}
@end macro

@macro keyword{NAME}
@code{#:\NAME\}
@end macro


@c page
@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro


@c page
@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro



@c page
@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro cite{NAME}
[@sc{\NAME\}]
@end macro

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@c ------------------------------------------------------------

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      The Other Ikarus Scheme User's Guide

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Ikarus

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ikarus

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2007, 2008


@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, an
@rnrs{6} compliant implementation of the Scheme programming language.
The package is distributed under the terms of the @gnu{} General Public
License (@gpl{}) and can be downloaded from:

@center @url{http://www.cs.indiana.edu/~aghuloum/ikarus/}

@noindent
or:

@center @url{https://launchpad.net/ikarus}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Abdulaziz Ghuloum.

@quotation
This program is free software: you can redistribute it and/or modify it
under the terms of the @gnu{} General Public License version 3 as
published by the Free Software Foundation.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the @gnu{} General Public License
along with this program.  If not, see
@url{http://www.gnu.org/licenses/}.
@end quotation

This document is version @texiversion{} of an unofficial assemblage of
several documents reformatted in Texinfo; the reformatting author and
maintainer is @value{AUTHOR} @value{AUTHOR_EMAIL}.  See the appendix
``Credits'' for the list of original documents and their authors.
@end copying


@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@subtitle Texinfo reformating revision @version{}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* ikarus: (ikarus).             Ikarus Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore


@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* overview::                    Overview of the package.
* invoking::                    Invoking Ikarus.
* script::                      Using @command{scheme-script}.
* crash::                       @rnrs{6} crash course for
                                @rnrs{5} aware ones.
* lang::                        The Scheme language.
* baselib::                     Base library.
* stdlib::                      Standard libraries.
* ikaruslib::                   Ikarus libraries.

Appendices

* contrib libraries::           Contributed libraries.
* devel::                       Accessing development revisions.
* missing::                     Missing Features.
* credits::                     Credits for this document.
* package license::             GNU General Public License.
* references::                  Bibliography and references.

Indexes

* examples::                    Scheme programming examples.
* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

External documents

* rfive: (r5rs).                Revised^5 Report on the algorithmic
                                language Scheme
* rsix: (r6rs).                 Revised^6 Report on the algorithmic
                                language Scheme
* libffi: (libffi).             Libffi documentation.

@detailmenu
 --- The Detailed Node Listing ---

Overview of the package

* overview copying::            Copying this document.
* overview tech::               Technology overview.
* overview system::             System requirements.
* overview install::            Installation and uninstallation.

Installation and uninstallation

* overview install details::    Installation details.

@rnrs{6} crash course for @rnrs{5} aware ones

* crash simple script::         Writing a simple script.
* crash simple libs::           Writing a simple libraries.
* crash record::                @rnrs{6} record types.
* crash exceptions::            Exception handling.

@rnrs{6} record types

* crash record define::                 Defining new record types.
* crash record extend::                 Extending existing record types.
* crash record construct::              Specifying custom constructors.
* crash record construct derived::      Custom constructors for derived
                                        record types.

The Scheme language

* lang overview::               Overview of Scheme.
* lang requirements::           Requirement levels.
* lang numbers::                Numbers.
* lang lex::                    Lexical syntax and datum syntax.
* lang basic::                  Semantic concepts.
* lang entry::                  Entry format.
* lang library::                Libraries.
* lang programs::               Top-level programs.
* lang syntax::                 Primitive syntax.
* lang expansion::              Expansion process.
* lang derived::                Sample definitions for derived forms.

Overview of Scheme

* lang overview basic types::        Basic types.
* lang overview expressions::        Expressions.
* lang overview variables::          Variables and binding.
* lang overview definitions::        Definitions.
* lang overview forms::              Forms.
* lang overview procedures::         Procedures.
* lang overview syntax::             Procedure calls and syntactic keywords.
* lang overview assignment::         Assignment.
* lang overview macros::             Derived forms and macros.
* lang overview data::               Syntactic data and datum values.
* lang overview continuations::      Continuations.
* lang overview libraries::          Libraries.
* lang overview programs::           Top--level programs.

Numbers

* lang numbers tower::          Numerical tower.
* lang numbers exactness::      Exactness.
* lang numbers fix flo::        Fixnums and flonums.
* lang numbers requirements::   Implementation requirements.
* lang numbers inf nan::        Infinities and NaNs.
* lang numbers minus zero::     Distinguished @code{-0.0}.

Lexical syntax and datum syntax

* lang lex notation::           Notation.
* lang lex syntax::             Lexical syntax.
* lang lex datum::              Datum syntax.

Lexical syntax

* lang lex syntax formal account::           Formal account.
* lang lex syntax line endings::             Line endings.
* lang lex syntax whitespace and comments::  Whitespace and comments.
* lang lex syntax identifiers::              Identifiers.
* lang lex syntax booleans::                 Booleans.
* lang lex syntax characters::               Characters.
* lang lex syntax strings::                  Strings.
* lang lex syntax numbers::                  Numbers.

Datum syntax

* lang lex datum formal account::       Formal account.
* lang lex datum pairs and lists::      Pairs and lists.
* lang lex datum vectors::              Vectors.
* lang lex datum bytevectors::          Bytevectors.
* lang lex datum abbreviations::        Abbreviations.

Semantic concepts

* lang basic programs and libraries::        Programs and libraries.
* lang basic variables keywords regions::    Variables, keywords,
                                             and regions.
* lang basic exceptions::                    Exceptional situations.
* lang basic argument checking::             Argument checking.
* lang basic syntax violations::             Syntax violations.
* lang basic safety::                        Safety.
* lang basic boolean values::                Boolean values.
* lang basic multiple return values::        Multiple return values.
* lang basic unspecified behavior::          Unspecified behavior.
* lang basic storage model::                 Storage model.
* lang basic proper tail recursion::         Proper tail recursion.
* lang basic dynamic extent::                Dynamic extent and the
                                             dynamic environment.

Entry format

* lang entry syntax::                Syntax entries.
* lang entry procedure::             Procedure entries.
* lang entry implementation resp::   Implementation responsibilities.
* lang entry other kinds::           Other kinds of entries.
* lang entry equivalent::            Equivalent entries.
* lang entry evaluation examples::   Evaluation examples.
* lang entry naming conventions::    Naming conventions.

Libraries

* lang library form::           Library form.
* lang library import export::  Import and export levels.
* lang library files::          Library files
* lang library path::           Library search path.
* lang library names::          Mapping library names to file names.
* lang library examples::       Examples.

Top--level programs

* lang programs syntax::        Top-level program syntax.
* lang programs semantics::     Top-level program semantics.

Primitive syntax

* lang syntax primitive::       Primitive expression types.
* lang syntax macros::          Macros.

Base library

* baselib types::               Base types.
* baselib definitions::         Definitions.
* baselib bodies::              Bodies.
* baselib expressions::         Expressions.
* baselib predicates::          Equivalence and procedure predicates.
* baselib math::                Mathematics.
* baselib booleans::            Booleans.
* baselib lists::               Pairs and lists.
* baselib symbols::             Symbols.
* baselib characters::          Characters.
* baselib strings::             Strings.
* baselib vectors::             Vectors.
* baselib errors::              Errors and violations.
* baselib control::             Control features.
* baselib iteration::           Iteration.
* baselib quasiquotation::      Quasiquotation.
* baselib syntax binding::      Binding constructs for syntactic keywords.
* baselib transformers::        Macro transformers.
* baselib tail call::           Tail calls and tail contexts.

Definitions

* baselib definitions variables::  Variables definitions.
* baselib definitions syntax::     Syntax definitions.

Expressions

* baselib expressions quotation::       Quotation.
* baselib expressions procedures::      Procedures.
* baselib expressions conditionals::    Conditionals.
* baselib expressions assignments::     Assignments.
* baselib expressions derived cond::    Derived conditionals.
* baselib expressions binding::         Binding constructs.
* baselib expressions sequencing::      Sequencing.

Mathematics

* baselib math exactness::      Propagation of exactness and inexactness.
* baselib math infinities::     Representability of infinities and NaNs.
* baselib math semantics::      Semantics of common operations.
* baselib math ops::            Numerical operations.
* baselib math string::         Numerical input and output.

Semantics of common operations

* baselib math semantics integer::      Integer division.
* baselib math semantics trascend::     Transcendental functions.

Numerical operations

* baselib math ops type pred::          Numerical type predicates.
* baselib math ops exactness::          Generic conversion.
* baselib math ops value pred::         Value predicates.
* baselib math ops comparison::         Comparison.
* baselib math ops arithmetic::         Arithmetic operations.
* baselib math ops part::               Part separation.
* baselib math ops trascend::           Trascendental functions.
* baselib math ops exponentiation::     Exponentiation functions.
* baselib math ops complex::            Complex numbers functions.

Standard libraries

* stdlib unicode::              Unicode.
* stdlib bytevector::           Bytevectors.
* stdlib list::                 List utilities.
* stdlib sorting::              Sorting.
* stdlib control::              Control structures.
* stdlib records::              Records.
* stdlib exceptions::           Exceptions and conditions.
* stdlib io::                   Input/output.
* stdlib files::                File system.
* stdlib programlib::           Command line access and exit values.
* stdlib arithmetics::          Arithmetics.
* stdlib syntax-case::          Syntax-case.
* stdlib hashtable::            Hashtables.
* stdlib enum::                 Enumerations.
* stdlib complib::              Composite library.
* stdlib eval::                 Evaluation.
* stdlib mutable pairs::        Mutable pairs.
* stdlib mutable strings::      Mutable strings.
* stdlib rfive compat::         @rnrs{5} compatibility.

Unicode

* stdlib unicode characters::   Characters.
* stdlib unicode strings::      Strings.

Bytevectors

* stdlib bytevector endianness::        Endianness.
* stdlib bytevector general::           General operations.
* stdlib bytevector bytes and octets::  Operations on bytes and octets.
* stdlib bytevector integers::          Operations on integers of
                                        arbitrary size.
* stdlib bytevector integers 16::       Operations on 16-bit integers.
* stdlib bytevector integers 32::       Operations on 32-bit integers.
* stdlib bytevector integers 64::       Operations on 64-bit integers.
* stdlib bytevector flonum::            Operations on @ieee{} 754
                                        representations.
* stdlib bytevector strings::           Operations on strings.

Records

* stdlib records intro::                Introduction.
* stdlib records mutability::           Mutability and equivalence
                                        of records.
* stdlib records syntactic layer::      Syntactic layer.
* stdlib records procedural layer::     Procedural layer.
* stdlib records inspection::           Inspection.

Exceptions and conditions

* stdlib exceptions exceptions::        Exceptions.
* stdlib exceptions conditions::        Conditions.

Conditions

* stdlib exceptions conditions objects::        Condition objects.
* stdlib exceptions conditions types::          Standard condition types.

Input/output

* stdlib io conditions::        Condition types.
* stdlib io port::              Port input/output.
* stdlib io simple::            Simple input/output.

Port input/output

* stdlib io port file names::           File names.
* stdlib io port file options::         File options.
* stdlib io port buffer modes::         Buffer modes.
* stdlib io port transcoders::          Transcoders.
* stdlib io port eof object::           End of file object.
* stdlib io port io ports::             Input and output ports.
* stdlib io port input ports::          Input ports.
* stdlib io port binary input::         Binary input.
* stdlib io port textual input::        Textual input.
* stdlib io port output ports::         Output ports.
* stdlib io port binary output::        Binary output.
* stdlib io port textual output::       Textual output.
* stdlib io port input output ports::   Input/output ports.

Arithmetics

* stdlib arithmetics bitwise::          Bitwise operations.
* stdlib arithmetics fixnum::           Fixnums.
* stdlib arithmetics flonum::           Flonums.
* stdlib arithmetics exact bitwise::    Exact bitwise arithmetic.

Syntax--case

* stdlib syntax-case hygiene::          Hygiene.
* stdlib syntax-case objects::          Syntax objects.
* stdlib syntax-case transformers::     Transformers.
* stdlib syntax-case parsing::          Parsing input and producing
                                        output.
* stdlib syntax-case identifier::       Identifier predicates.
* stdlib syntax-case conversion::       Syntax-object and datum
                                        conversions.
* stdlib syntax-case temporaries::      Generating lists of temporaries.
* stdlib syntax-case derived::          Derived forms and procedures.
* stdlib syntax-case violations::       Syntax violations.

Examples

* stdlib syntax-case define-macro::     Common Lisp style macros.

Hashtables

* stdlib hashtable constructors::       Constructors.
* stdlib hashtable procedures::         Procedures.
* stdlib hashtable inspection::         Inspection.
* stdlib hashtable hash functions::     Hash functions.

The Ikarus library

* ikaruslib cross::             Writing cross--implementation libraries.
* ikaruslib reader::            Reader.
* ikaruslib cafe::              Cafe.
* ikaruslib environment::       Environments.
* ikaruslib load::              Loading source files.
* ikaruslib import::            Local library imports.
* ikaruslib modules::           Local modules.
* ikaruslib parameters::        Parameters.
* ikaruslib gensym::            Gensyms.
* ikaruslib printing::          Printing.
* ikaruslib tracing::           Tracing.
* ikaruslib timing::            Timing.
* ikaruslib guardians::         Guardians.
* ikaruslib io::                Input/output library.
* ikaruslib posix::             @posix{} functions.
* ikaruslib foreign::           Foreign interface library.
* ikaruslib misc::              Miscellaneous functions.

Local modules

* ikaruslib modules examples::  Usage example for modules.
* ikaruslib modules api::       Modules programming interface.

Usage example for modules

* ikaruslib modules examples anonymous::        Anonymous modules.
* ikaruslib modules examples named::            Named modules.
* ikaruslib modules examples utils::            Utilities examples.

Guardians

* ikaruslib guardians examples::        Usage examples for guardians.
* ikaruslib guardians api::             Guardians programming interface.

Input/output library

* ikaruslib io process::        Spawning processes.
* ikaruslib io socket::         Using network sockets.
* ikaruslib io non-block::      Non--blocking mode for ports.

Using network sockets

* ikaruslib io socket client::  Establishing client network
                                connections.
* ikaruslib io socket server::  Opening server network services.

@posix{} functions

* ikaruslib posix process::     Spawning processes and the like.
* ikaruslib posix waitpid::     Waiting for terminated children.
* ikaruslib posix signal::      Delivering signals to processes.
* ikaruslib posix file::        Interfacing with the file system.
* ikaruslib posix env::         Interfacing with the execution
                                environment.
* ikaruslib posix misc::        Miscellaneous functions.

The @library{ikarus foreign} library

* ikaruslib foreign overview::  Overview of the foreign functions
                                interface.
* ikaruslib foreign memory::    Memory management.
* ikaruslib foreign memops::    Memory operations.
* ikaruslib foreign dl::        Accessing foreign objects from Scheme.
* ikaruslib foreign call out::  Calling out to foreign procedures.
* ikaruslib foreign call back:: Calling back to Scheme.

Memory operations

* ikaruslib foreign memops alloc::      Allocating and freeing memory.
* ikaruslib foreign memops pointer::    Handling pointer values.
* ikaruslib foreign memops poke::       Poking values.
* ikaruslib foreign memops peek::       Peeking values.

Calling out to foreign procedures

* ikaruslib foreign call out api::      Interface to foreign functions.
* ikaruslib foreign call out types::    Type specifiers.
* ikaruslib foreign call out example::  C language call out example.

Contributed libraries

* contrib gl::                  @code{(gl)} and @code{(glut)}.
* contrib number theory::       @code{(math number-theory)}

Scheme programming examples

* examples macros::             Exploring macro mechanisms.

Exploring macro mechanisms

* examples macros phases::      Bits about phases.
* examples macros underscore::  About the underscore.
* examples macros patterns::    About writing patterns.
* examples macros literals::    About literal identifiers.
* examples macros syntax::      Syntax objects and you.

Syntax objects and you

* examples macros syntax not::   What we do not do.

@end detailmenu
@end menu

@end ifnottex


@c page
@node overview
@chapter Overview of the package


@noindent
Ikarus Scheme is an implementation of the Scheme programming language.
The preliminary release of Ikarus implements the majority of the
features found in the current standard, the ``Revised^6 Report on the
algorithmic language Scheme'' including full @rnrs{6} library and script
syntax, syntax--case, unicode strings, bytevectors, user--defined record
types, exception handling, conditions, and enumerations.  More than 94%
of the @rnrs{6} procedures and keywords are currently implemented and
subsequent releases will proceed towards bringing Ikarus to full
@rnrs{6} conformance.

@quotation
The main purpose behind releasing Ikarus early is to give Scheme
programmers the opportunity to experiment with the various new features
that were newly introduced in @rnrs{6}.  The most important of such
features is the ability to structure large programs into libraries;
where each library extends the language through procedural and syntactic
abstractions.

Many useful libraries can be written using the currently supported set
of @rnrs{6} features including text processing tools, symbolic logic
systems, interpreters and compilers, and many mathematical and
scientific packages.  It is the author's hope that this release will
encourage the Scheme community to write and to share their most useful
@rnrs{6} libraries.
@end quotation

@menu
* overview copying::            Copying this document.
* overview tech::               Technology overview.
* overview system::             System requirements.
* overview install::            Installation and uninstallation.
@end menu



@c page
@node overview copying
@section Copying this document

@insertcopying


@c page
@node overview tech
@section Technology overview


@noindent
Ikarus Scheme provides the programmer with many advantages:

@table @strong

@item Optimizing code generator
The compiler's backend employs state of the art technologies in code
generation that produce fast efficient machine code.  When developing
computationally intensive programs, one is not constrained by using a
slow interpreter.

@item Fast incremental compilation
Every library and script is quickly compiled to native machine code.
When developing large software, one is not constrained by how slow the
batch compiler runs.

@item Robust and fine--tuned standard libraries
The standard libraries are written such that they perform as much error
checking as required to provide a safe and fast runtime environment.

@item Multi--generational garbage collector
The BiBOP based garbage collector used in Ikarus allows the runtime
system to expand its memory footprint as needed.  The entire 32-bit
virtual address space could be used and unneeded memory is released back
to the operating system.

@item Supports many operating systems
Ikarus runs on the most popular and widely used operating systems for
servers and personal computers.  The supported systems include Mac OS X,
@gnu{}/Linux, FreeBSD, NetBSD, and Microsoft Windows.
@end table


@c page
@node overview system
@section System requirements


@subsection Hardware


@noindent
Ikarus Scheme runs on the IA-32 (@emph{x86}) architecture supporting
SSE2 extensions.  This includes the Athlon 64, Sempron 64, and Turion 64
processors from AMD and the Pentium 4, Xeon, Celeron, Pentium M, Core,
and Core2 processors from Intel.  The system does not run on Intel
Pentium III or earlier processors.

The Ikarus compiler generates SSE2 instructions to handle Scheme's IEEE
floating point representation (@emph{flonums}) for inexact numbers.


@c ------------------------------------------------------------

@subsection Operating systems


@noindent
Ikarus is tested under the following operating systems:

@itemize
@item
Mac OS X version 10.4 and 10.5.

@item
Linux 2.6.18 (Debian, Fedora, Gentoo, and Ubuntu).

@item
FreeBSD version 6.2.

@item
NetBSD version 3.1.

@item
Microsoft Windows XP (using Cygwin 1.5.24).
@end itemize

@c ------------------------------------------------------------

@subsection Additional software


@table @strong
@item GMP
Ikarus uses the @gnu{} Multiple Precision Arithmetic Library (@gmp{})
for some bignum arithmetic operations.  To build Ikarus from scratch,
@gmp{} version 4.2 or better must be installed along with the required
header files.  Pre--built @gmp{} packages are available for most
operating systems.  Alternatively, @gmp{} can be downloaded from

@center @url{http://gmplib.org/}

@quotation
@emph{Note:} Ikarus runs in 32-bit mode only.  To run it in 64-bit
environments, you will have to obtain the 32-bit version of @gmp{}, or
compile it yourself after adding @code{ABI=32} to its configuration
options.
@end quotation

@item GCC
The @gnu{} C Compiler is required to build the Ikarus executable
(e.g. the garbage collector, loader, and OS--related runtime).  @gcc{}
versions 4.1 and 4.2 were successfully used to build Ikarus.

@item Autoconf and Automake
The @gnu{} Autoconf (version 2.61) and @gnu{} Automake (version 1.10)
tools are required if one wishes to modify the Ikarus source base.  They
are not required to build the official release of Ikarus.

@item XeLaTeX
The XeLaTeX typesetting system is required for building the
documentation.  XeLaTeX (and XeTeX) is an implementation of the LaTeX
(and TeX) typesetting system.  XeLaTeX can be obtained from

@center @url{http://scripts.sil.org/xetex}

@noindent
and is included with TeX--Live@footnote{@url{http://tug.org/texlive/}}
and and Mac--TeX@footnote{@url{http://tug.org/mactex/}} distributions.
@end table


@c page
@node overview install
@section Installation and uninstallation


@cindex Installing Ikarus
@cindex Uninstalling Ikarus
@cindex Disinstalling Ikarus
@cindex Ikarus, installing
@cindex Ikarus, uninstalling
@cindex Ikarus, disinstalling


@noindent
If familiar with installing Unix software on our system, then all we
need to know is that Ikarus uses the standard installation method found
in most other Unix software.  Simply run the following commands from the
shell:

@example
$ tar -zxf ikarus-n.n.n.tar.gz
$ cd ikarus-n.n.n
$ ./configure [--prefix=path] [CFLAGS=-I/dir] [LDFLAGS=-L/dir]
$ make
$ make install
@end example

@noindent
@ref{overview install details} for how to enable the foreign functions
interface.

To uninstall Ikarus, use the following steps:

@example
$ cd path/to/ikarus-n.n.n
$ make uninstall
@end example


@menu
* overview install details::    Installation details.
@end menu



@c page
@node overview install details
@subsection Installation details


@noindent
The rest of this section describes the build process in more details.
It is targeted to users who are unfamiliar with steps mentioned above.

@enumerate
@item
Download the Ikarus source distribution: a @command{gzip}--compressed
@command{tar} file (@file{ikarus-n.n.n.tar.gz} where @code{n.n.n} is a
3--digit number indicating the current revision).  The latest revision
can be downloaded from

@center @url{http://www.cs.indiana.edu/~aghuloum/ikarus/}

@item
Unpack the source distribution package.  From the shell prompt:

@example
$ tar -zxf ikarus-n.n.n.tar.gz
@end example

@noindent
this creates the base directory @file{ikarus-n.n.n}.

@item
Configure the build system by running the @command{configure} script
located in the base directory.  To do this, type the following commands:

@example
$ cd ikarus-n.n.n
$ ./configure
checking build system type... i386-apple-darwin8.10.1
checking host system type... i386-apple-darwin8.10.1
...
configure: creating ./config.status
config.status: creating Makefile
config.status: creating src/Makefile
config.status: creating scheme/Makefile
config.status: creating doc/Makefile
config.status: executing depfiles commands
@end example

This configures the system to be built then installed in the
system--wide location (binaries are installed in @file{/usr/local/bin}).
If we wish to install it in another location (e.g. in our home
directory), we can supply a @option{--prefix} location to the
@command{configure} script as follows:

@example
$ ./configure --prefix=/path/to/installation/location
@end example

The @command{configure} script will fail if it cannot locate the
location where @gmp{} is installed.  If running @command{configure}
fails to locate @gmp{}, we should supply the location in which the
@gmp{} header file, @file{gmp.h}, and the @gmp{} library file,
@file{libgmp.so}, are installed.  This is done by supplying the two
paths in the @env{CFLAGS} and @env{LDFLAGS} arguments:

@example
./configure CFLAGS=-I/path/to/include LDFLAGS=-L/path/to/lib
@end example

Currently (Thu Oct 23, 2008) Ikarus uses Libffi (@ref{ikaruslib foreign
overview} for details) to implement the foreign functions interface.  To
enable it and to let Ikarus find the Libffi headers we have to do:

@example
$ ./configure [other-options] \
      --enable-libffi \
      CFLAGS='-I/usr/local/lib/libffi-3.0.6/include'
@end example

@noindent
assuming that the Libffi headers are under
@file{/usr/local/lib/libffi-3.0.6/include}.

@item
Build the system by running:

@example
$ make
@end example

This performs two tasks: it builds the @command{ikarus} executable from
the C files located in the @command{src} directory; it uses the
@command{ikarus} executable and the pre--built @file{ikarus.boot.orig}
boot file to rebuild the Scheme boot image file @file{ikarus.boot} from
the Scheme sources located in the @file{scheme} directory.

@item
Install Ikarus by typing:

@example
$ make install
@end example

If we are installing Ikarus in a system--wide location, we might need to
have administrator privileges (use the @command{sudo} or @command{su}
commands).

@item
Test that Ikarus runs from the command line.

@example
$ ikarus
Ikarus Scheme version 0.0.3
Copyright (c) 2006-2008 Abdulaziz Ghuloum

>
@end example

If we get the prompt, then Ikarus was successfully installed on our
system.  We may need to update the @env{PATH} variable in our
environment to contain the directory in which the @command{ikarus}
executable was installed.

Do not delete the @file{ikarus-n.n.n} directory from which we
configured, built, and installed Ikarus.  It will be needed if we decide
at a later time to uninstall Ikarus.
@end enumerate


@c page
@node invoking
@chapter Invoking Ikarus


@cindex Command line
@cindex Invoking Ikarus


@noindent
The @command{ikarus} executable recognizes a few command line switches
that influence how Ikarus starts.

@table @code
@item ikarus -h
The presence of the @option{-h} flag causes @command{ikarus} to display
a help message then to exit.  The help message summarizes the command
line switches.  No further action is performed.

@item ikarus -b path/to/boot/file.boot
The @code{-b} flag (which requires an extra argument) directs
@command{ikarus} to use the specified boot file as the initial system
boot file.  The boot file is a binary file that contains all the code
and data of the Scheme system.  In the absence of @option{-b} flag, the
executable will use the default boot file.  Running @code{ikarus -h}
shows the location where the default boot file was installed.

The rest of the command line arguments are recognized by the standard
Scheme run time system.  They are processed after the boot file is
loaded.

@item ikarus --r6rs-script script-file-name [arguments ...]
The @option{--r6rs-script} argument instructs Ikarus that the supplied
file is an @rnrs{6} script.  @ref{crash simple script} for a short
introduction on writing @rnrs{6} scripts.  The script file name and any
additional optional @code{arguments} can be obtained by calling the
@func{command-line} procedure.

@example
$ cat test.ss
(import (rnrs))
(write (command-line))
(newline)

$ ikarus --r6rs-script test.ss hi there
("test.ss" "hi" "there")
@end example

@item ikarus files ... [-- arguments ...]
The lack of an @option{--r6rs-script} argument causes Ikarus to start in
interactive mode.  Each of the @code{files} is first loaded, in the
interaction environment.  The interaction environment initially contains
all the bindings exported from the @library{ikarus} library
(@ref{ikaruslib} for details).

The optional @code{arguments} following the @code{--} marker can be
obtained by calling the @func{command-line} procedure.  In interactive
mode, the first element of the returned list will be the string
@code{*interactive*}, corresponding to the script name in
@rnrs{6}--script mode.

@quotation
@emph{Note:} The interactive mode is intended for quick experimenting
with the built--in features.  It is intended neither for developing
applications nor for writing any substantial piece of code.  The main
reason for this is that the interaction between @rnrs{6} libraries and
the interactive environment is not well understood.  We hope to achieve
better interaction between the two subsystems in the future.
@end quotation
@end table


@c page
@node script
@chapter Using @command{scheme-script}


@noindent
Scheme scripts can be executed using the:

@example
ikarus --r6rs-script script-name
@end example

@noindent
command as described in the previous section.  For convenience, Ikarus
follows the @rnrs{6} recommendations and installs a wrapper program
called @command{scheme-script}.  Typically, a script you write would
start with a @code{#!} line that directs your operating system to the
interpreter used to evaluate the script file.  The following example
shows a very simple script that uses the @command{scheme-script}
command.

@example
#!/usr/bin/env scheme-script

(import (rnrs))
(display "Hello World\n")
@end example

If the above script was placed in a file called @file{hello-world}, then
one can make it executable using the @command{chmod} Unix command.

@example
$ cat hello-world
#!/usr/bin/env scheme-script

(import (rnrs))
(display "Hello World\n")

$ chmod 755 hello-world
$ ./hello-world
Hello World
@end example

@quotation
@emph{Note:} Under Mac OS X, if a script name ends with the
@code{.command} extension, then it can be executed from the Finder by
double--clicking on it.  This brings up a terminal window in which the
script is executed.  The @code{.command} extension can be hidden from
the @emph{Get Info} item from the Finder's File menu.
@end quotation


@c page
@node crash
@chapter @rnrs{6} crash course for @rnrs{5} aware ones


@noindent
The major difference between @rnrs{5} and @rnrs{6} is the way in which
programs are loaded and evaluated.

In @rnrs{5}, Scheme implementations typically start as an interactive
session (often referred to as the @repl{}, or read--eval--print--loop).
Inside the interactive session, the user enters definitions and
expressions one at a time using the keyboard.  Files, which also contain
definitions and expressions, can be loaded and reloaded by calling the
@func{load} procedure.  The environment in which the interactive session
starts often contains implementation--specific bindings that are not
found in @rnrs{5} and users may redefine any of the initial bindings.
The semantics of loading a file depends on the state of the environment
at the time the file contents are evaluated.

@rnrs{6} differs from @rnrs{5} in that it specifies how @emph{whole
programs}, or scripts, are compiled and evaluated.  An @rnrs{6} script
is ``closed'' in the sense that all the identifiers found in the body of
the script must either be defined in the script or imported from a
library.  @rnrs{6} also specifies how @emph{libraries} can be defined
and used.  While files in @rnrs{5} are typically @emph{loaded}
imperatively into the top--level environments, @rnrs{6} libraries are
@emph{imported} declaratively in scripts and in other @rnrs{6}
libraries.


@menu
* crash simple script::         Writing a simple script.
* crash simple libs::           Writing a simple libraries.
* crash record::                @rnrs{6} record types.
* crash exceptions::            Exception handling.
@end menu


@c page
@node crash simple script
@section Writing a simple script


@noindent
An @rnrs{6} script is a set of definitions and expressions preceded by
an @func{import} form.  The @func{import} form specifies the language
(i.e. the variable and keyword bindings) in which the library body is
written.  A very simple example of an @rnrs{6} script is listed below.

@example
#!/usr/bin/env scheme-script
(import (rnrs))
(display "Hello World!\n")
@end example

The first line imports the @library{rnrs} library.  All the bindings
exported from the @library{rnrs} library are made available to be used
within the body of the script.  The exports of the @library{rnrs} library
include variables (e.g. @func{cons}, @func{car}, @func{display}, etc.)
and keywords (e.g.  @func{define}, @func{lambda}, @func{quote}, etc.).
The second line displays the string @code{Hello World!}  followed by a
newline character.

In addition to expressions, such as the call to @func{display} in the
previous example, a script may define some variables.  The script below
defines the variable @code{greeting} and calls the procedure bound to
it.

@example
#!/usr/bin/env scheme-script
(import (rnrs))

(define greeting
  (lambda ()
    (display "Hello World!\n")))

(greeting)
@end example

Additional keywords may be defined within a script.  In the example
below, we define the @code{(do-times n exprs ...)} macro that evaluates
the expressions @code{exprs} @code{n} times.  Running the script
displays @code{Hello World} 3 times.

@example
#!/usr/bin/env scheme-script
(import (rnrs))

(define greeting
  (lambda ()
    (display "Hello World!\n")))

(define-syntax do-times
  (syntax-rules ()
    [(_ n exprs ...)
     (let f ([i n])
       (unless (zero? i)
         exprs ...
         (f (- i 1))))]))

(do-times 3 (greeting))
@end example


@c page
@node crash simple libs
@section Writing simple libraries


@noindent
A script is intended to be a small piece of the program---useful
abstractions belong to libraries.  The @func{do-times} macro that was
defined in the previous section may be useful in places other than
printing greeting messages.  So, we can create a small library,
@code{(iterations)} that contains common iteration forms.

An @rnrs{6} library form is made of four essential parts: (1) the
library name, (2) the set of identifiers that the library exports, (3)
the set of libraries that the library imports, and (4) the body of the
library.

The library name can be any non--empty list of identifiers.
@rnrs{6}--defined libraries includes @code{(rnrs)}, @code{(rnrs
unicode)}, @code{(rnrs bytevectors)}, and so on.

The library exports are a set of identifiers that are made available to
importing libraries.  Every exported identifier must be bound: it may
either be defined in the library or imported using the @func{import}
form.  Library exports include variables, keywords, record names, and
condition names.

Library imports are similar to script imports: they specify the set of
libraries whose exports are made visible within the body of the library.

The body of a library contains definitions (variable, keyword, record,
condition, etc.) followed by an optional set of expressions.  The
expressions are evaluated for side effect when needed.

The @library{iteration} library may be written as follows:

@example
(library (iteration)
  (export do-times)
  (import (rnrs))

  (define-syntax do-times
    (syntax-rules ()
      [(_ n exprs ...)
       (let f ([i n])
         (unless (zero? i)
           exprs ...
           (f (- i 1))))])))
@end example

To use the @library{iteration} library in our script, we add the name of
the library to the script's @func{import} form.  This makes all of
@code{(iteration)}'s exported identifiers, e.g.  @func{do-times},
visible in the body of the script.

@example
#!/usr/bin/env scheme-script
(import (rnrs) (iteration))

(define greeting
  (lambda ()
    (display "Hello World!\n")))

(do-times 3 (greeting))
@end example


@c page
@node crash record
@section @rnrs{6} record types


@noindent
@rnrs{6} provides ways for users to define new types, called record
types.  A record is a fixed--size data structure with a unique type
(called a record type).  A record may have any finite number of fields
that hold arbitrary values.  This section briefly describes what we
expect to be the most commonly used features of the record system.  Full
details are in the @rnrs{6} Standard Libraries document.

@menu
* crash record define::                 Defining new record types.
* crash record extend::                 Extending existing record types.
* crash record construct::              Specifying custom constructors.
* crash record construct derived::      Custom constructors for derived
                                        record types.
@end menu


@c page
@node crash record define
@subsection Defining new record types


@noindent
To define a new record type, use the @func{define-record-type} form.
For example, suppose we want to define a new record type for describing
points, where a point is a data structure that has two fields to hold
the point's @var{x} and @var{y} coordinates.  The following definition
achieves just that:

@example
(define-record-type point
  (fields x y))
@end example

The above use of @code{define-record-type} defines the following
procedures automatically for you:

@itemize
@item
The constructor @func{make-point} that takes two arguments, @var{x} and
@var{y} and returns a new record whose type is point.

@item
The predicate @func{point?} that takes an arbitrary value and returns
@true{} if that value is a point, @false{} otherwise.

@item
The accessors @func{point-x} and @func{point-y} that, given a record of
type point, return the value stored in the @var{x} and @var{y} fields.
@end itemize

Both the @var{x} and @var{y} fields of the @code{point} record type are
@emph{immutable}, meaning that once a record is created with specific
@var{x} and @var{y} values, they cannot be changed later.  If you want
the fields to be @emph{mutable}, then you need to specify that
explicitly as in the following example.

@example
(define-record-type point
  (fields (mutable x) (mutable y)))
@end example

This definition gives us, in addition to the constructor, predicate, and
accessors, two additional procedures:

@itemize
@item
The mutators @func{point-x-set!} and @func{point-y-set!} that, given a
record of type point, and a new value, sets the value stored in the
@var{x} field or @var{y} field to the new value.
@end itemize

@quotation
@emph{Note:} Records in Ikarus have a printable representation in order
to enable debugging programs that use records.  Records are printed in
the @code{#[type-name field-values ...]} notation.  For example,
@code{(write (make-point 1 2))} produces @code{#[point 1 2]}.
@end quotation


@c page
@node crash record extend
@subsection Extending existing record types


@noindent
A record type may be extended by defining new variants of a record with
additional fields.  In our running example, suppose we want to define a
@code{colored-point} record type that, in addition to being a
@code{point}, has an additional field: a @var{color}.  A simple way of
achieving that is by using the following record definition:

@example
(define-record-type cpoint
  (parent point)
  (fields color))
@end example

Here, the definition of @code{cpoint} gives us:

@itemize
@item
A constructor @func{make-cpoint} that takes three arguments (@var{x},
@var{y}, and @var{color} in that order) and returns a @code{cpoint}
record.

@item
A predicate @func{cpoint?} that takes a single argument and determines
whether the argument is a @code{cpoint} record.

@item
An accessor @func{cpoint-color} that returns the value of the
@var{color} field of a @code{cpoint} object.
@end itemize

All procedures that are applicable to records of type @code{point}
(@func{point?}, @func{point-x}, @func{point-y}) are also applicable to
records of type @code{cpoint} since a @code{cpoint} is also a
@code{point}.


@c page
@node crash record construct
@subsection Specifying custom constructors


@noindent
The record type definitions explained so far use the default constructor
that takes as many arguments as there are fields and returns a new
record type with the values of the fields initialized to the arguments'
values.  It is sometimes necessary or convenient to provide a
constructor that performs more than the default constructor.  For
example, we can modify the definition of our @code{point} record so that
the constructor takes either no arguments, in which case it would return
a point located at the origin, or two arguments specifying the @var{x}
and @var{y} coordinates.  We use the @code{protocol} keyword for
specifying such constructor as in the following example:

@example
(define-record-type point
  (fields x y)
  (protocol
    (lambda (new)
      (case-lambda
        [(x y) (new x y)]
        [()    (new 0 0)]))))
@end example

The protocol here is a procedure that takes a constructor procedure
@var{new} (@var{new} takes as many arguments as there are fields) and
returns the desired custom constructor that we want (the actual
constructor will be the value of the @func{case-lambda} expression in
the example above).  Now the constructor @func{make-point} would either
take two arguments which constructs a @code{point} record as before, or
no arguments, in which case @code{(new 0 0)} is called to construct a
point at the origin.

Another reason why one might want to use custom constructors is to
precompute the initial values of some fields based on the values of
other fields.  An example of this case is adding a @var{distance} field
to the record type which is computed as @code{d = sqrt(x^2+y^2)}.  The
protocol in this case may be defined as:

@example
(define-record-type point
  (fields x y distance)
  (protocol
    (lambda (new)
      (lambda (x y)
        (new x y (sqrt (+ (expt x 2) (expt y 2))))))))
@end example

Note that derived record types need not be modified when additional
fields are added to the parent record type.  For example, our
@code{cpoint} record type still works unmodified even after we added the
new @var{distance} field to the parent.  Calling @code{(point-distance
(make-cpoint 3 4 #xFF0000))} returns @code{5.0} as expected.


@c page
@node crash record construct derived
@subsection Custom constructors for derived record types


@noindent
Just like how base record types (e.g. @code{point} in the running
example) may have a custom constructor, derived record types can also
have custom constructors that do other actions.  Suppose that you want
to construct @code{cpoint} records using an optional color that, if not
supplied, defaults to the value 0.  To do so, we supply a
@code{protocol} argument to @func{define-record-type}.  The only
difference here is that the procedure @var{new} is a @emph{curried}
constructor.  It first takes as many arguments as the constructor of the
parent record type, and returns a procedure that takes the initial
values of the new fields.

In our example, the constructor for the @code{point} record type takes
two arguments.  @code{cpoint} extends @code{point} with one new field.
Therefore, @var{new} in the definition below first takes the arguments
for @code{point}'s constructor, then takes the initial color value.  The
definition below shows how the custom constructor may be defined.

@example
(define-record-type cpoint
  (parent point)
  (fields color)
  (protocol
    (lambda (new)
      (case-lambda
        [(x y c) ((new x y) c)]
        [(x y)   ((new x y) 0)]))))
@end example



@c page
@node crash exceptions
@section Exception handling


@noindent
The procedure @func{with-exception-handler} allows the programmer to
specify how to handle exceptional situations.  It takes two procedures
as arguments:

@itemize
@item
An exception handler which is a procedure that takes a single argument:
the object that was raised.

@item
A body thunk which is a procedure with no arguments whose body is
evaluated with the exception handler installed.
@end itemize

In addition to installing exception handlers, @rnrs{6} provides two ways
of raising exceptions: @func{raise} and @func{raise-continuable}.  We
describe the @func{raise-continuable} procedure first since it's the
simpler of the two.  For the code below, assume that @func{print} is
defined as:

@example
(define (print who obj)
  (display who)
  (display ": ")
  (display obj)
  (newline))
@end example

The first example, below, shows how a simple exception handler is
installed.  Here, the exception handler prints the object it receives
and returns the symbol @code{there}.  The call to
@func{raise-continuable} calls the exception handler, passing it the
symbol @code{here}.  When the handler returns, the returned value
becomes the value of the call to @func{raise-continuable}.

@example
(with-exception-handler
  (lambda (obj)                         ;;; prints
    (print "handling" obj)              ;;;   handling: here
    'there)                             ;;;   returned: there
  (lambda ()
    (print "returned" (raise-continuable 'here))))
@end example

Exceptional handlers may nest, and in that case, if an exception is
raised while evaluating an inner handler, the outer handler is called as
the following example illustrates:

@example
(with-exception-handler
  (lambda (obj)                         ;;; prints
    (print "outer" obj)                 ;;;   inner: here
    'outer)                             ;;;   outer: there
  (lambda ()                            ;;;   returned: outer
    (with-exception-handler
      (lambda (obj)
        (print "inner" obj)
        (raise-continuable 'there))
      (lambda ()
        (print "returned" (raise-continuable 'here))))))
@end example

In short, @func{with-exception-handler} binds an exception handler
within the dynamic context of evaluating the thunk, and
@func{raise-continuable} calls it.

The procedure @func{raise} is similar to @func{raise-continuable} except
that if the handler returns, a new exception is raised, calling the next
handler in sequence until the list of handlers is exhausted.

@example
(call/cc                          ;;; prints
  (lambda (escape)                ;;;   inner: here
    (with-exception-handler       ;;;   outer: #[condition ---]
      (lambda (obj)               ;;; returns
        (print "outer" obj)       ;;;   12
        (escape 12))
      (lambda ()
        (with-exception-handler
          (lambda (obj)
            (print "inner" obj)
            'there)
          (lambda ()
            (print "returned" (raise 'here))))))))
@end example

Here, the call to @code{raise} calls the inner exception handler, which
returns, causing @code{raise} to re--raise a non--continuable exception
to the outer exception handler.  The outer exception handler then calls
the escape continuation.

The following procedure provides a useful example of using the exception
handling mechanism.  Consider a simple definition of the procedure
@func{configuration-option} which returns the value associated with a
key where the key/value pairs are stored in an association list in a
configuration file.

@example
(define (configuration-option filename key)
  (cdr (assq key (call-with-input-file filename read))))
@end example

Possible things that may go wrong with calling
@func{configuration-option} include errors opening the file, errors
reading from the file (file may be corrupt), error in @func{assq} since
what's read may not be an association list, and error in @func{cdr}
since the key may not be in the association list.  Handling all error
possibilities is tedious and error prone.  Exceptions provide a clean
way of solving the problem.  Instead of guarding against all possible
errors, we install a handler that suppresses all errors and returns a
default value if things go wrong.  Error handling for
@func{configuration-option} may be added as follows:

@example
(define (configuration-option filename key default)
  (define (getopt)
    (cdr (assq key (call-with-input-file filename read))))
  (call/cc
    (lambda (k)
      (with-exception-handler
        (lambda (_) (k default))
        getopt))))
@end example


@c page
@node lang
@chapter The Scheme language

@c ###########
@lowersections
@c ###########

@menu
* lang overview::               Overview of Scheme.
* lang requirements::           Requirement levels.
* lang numbers::                Numbers.
* lang lex::                    Lexical syntax and datum syntax.
* lang basic::                  Semantic concepts.
* lang entry::                  Entry format.
* lang library::                Libraries.
* lang programs::               Top-level programs.
* lang syntax::                 Primitive syntax.
* lang expansion::              Expansion process.
* lang derived::                Sample definitions for derived forms.
@end menu



@c page
@node lang overview
@chapter Overview of Scheme

@c originally this chapter was the "struct" file.

@menu
* lang overview basic types::        Basic types.
* lang overview expressions::        Expressions.
* lang overview variables::          Variables and binding.
* lang overview definitions::        Definitions.
* lang overview forms::              Forms.
* lang overview procedures::         Procedures.
* lang overview syntax::             Procedure calls and syntactic keywords.
* lang overview assignment::         Assignment.
* lang overview macros::             Derived forms and macros.
* lang overview data::               Syntactic data and datum values.
* lang overview continuations::      Continuations.
* lang overview libraries::          Libraries.
* lang overview programs::           Top--level programs.
@end menu


@noindent
This chapter gives an overview of Scheme's semantics.  The purpose of
this overview is to explain enough about the basic concepts of the
language to facilitate understanding of the subsequent chapters of the
report, which are organized as a reference manual.  Consequently, this
overview is not a complete introduction to the language, nor is it
precise in all respects or normative in any way.

Following Algol, Scheme is a statically scoped programming language.
Each use of a variable is associated with a lexically apparent binding
of that variable.

Scheme has latent as opposed to manifest types @cite{WaiteGoos}.  Types
are associated with objects (also called values) rather than with
variables.  (Some authors refer to languages with latent types as
untyped, weakly typed or dynamically typed languages.)  Other languages
with latent types are Python, Ruby, Smalltalk, and other dialects of
Lisp.  Languages with manifest types (sometimes referred to as strongly
typed or statically typed languages) include Algol 60, C, C#, Java,
Haskell, and ML.

All objects created in the course of a Scheme computation, including
procedures and continuations, have unlimited extent.  No Scheme object
is ever destroyed.  The reason that implementations of Scheme do not
(usually!) run out of storage is that they are permitted to reclaim the
storage occupied by an object if they can prove that the object cannot
possibly matter to any future computation.  Other languages in which
most objects have unlimited extent include C#, Java, Haskell, most Lisp
dialects, ML, Python, Ruby, and Smalltalk.

Implementations of Scheme must be properly tail--recursive.  This allows
the execution of an iterative computation in constant space, even if the
iterative computation is described by a syntactically recursive
procedure.  Thus with a properly tail--recursive implementation,
iteration can be expressed using the ordinary procedure--call mechanics,
so that special iteration constructs are useful only as syntactic sugar.

Scheme was one of the first languages to support procedures as objects
in their own right.  Procedures can be created dynamically, stored in
data structures, returned as results of procedures, and so on.  Other
languages with these properties include Common Lisp, Haskell, ML, Ruby,
and Smalltalk.

One distinguishing feature of Scheme is that continuations, which in
most other languages only operate behind the scenes, also have
``first--class'' status.  First--class continuations are useful for
implementing a wide variety of advanced control constructs, including
non--local exits, backtracking, and coroutines.

In Scheme, the argument expressions of a procedure call are evaluated
before the procedure gains control, whether the procedure needs the
result of the evaluation or not.  C, C#, Common Lisp, Python, Ruby, and
Smalltalk are other languages that always evaluate argument expressions
before invoking a procedure.  This is distinct from the lazy--evaluation
semantics of Haskell, or the call--by--name semantics of Algol 60, where
an argument expression is not evaluated unless its value is needed by
the procedure.

Scheme's model of arithmetic provides a rich set of numerical types and
operations on them.  Furthermore, it distinguishes @emph{exact} and
@emph{inexact} number objects: Essentially, an exact number object
corresponds to a number exactly, and an inexact number object is the
result of a computation that involved rounding or other errors.


@c page
@node lang overview basic types
@section Basic types


@noindent
Scheme programs manipulate @emph{objects}, which are also referred to as
@emph{values}.  Scheme objects are organized into sets of values called
@emph{types}.  This section gives an overview of the fundamentally
important types of the Scheme language.  More types are described in
later chapters.

@quotation
@emph{Note:} As Scheme is latently typed, the use of the term
@emph{type} in this report differs from the use of the term in the
context of other languages, particularly those with manifest typing.
@end quotation

@subsubheading Booleans

@noindent
A boolean is a truth value, and can be either true or false.  In Scheme,
the object for ``false'' is written @false{}.  The object for ``true''
is written @true{}.  In most places where a truth value is expected,
however, any object different from @false{} counts as true.

@subsubheading Numbers

@noindent
Scheme supports a rich variety of numerical data types, including
objects representing integers of arbitrary precision, rational numbers,
complex numbers, and inexact numbers of various kinds.  @ref{lang numbers}
gives an overview of the structure of Scheme's numerical tower.

@subsubheading Characters

@noindent
Scheme characters mostly correspond to textual characters.  More
precisely, they are isomorphic to the @emph{scalar values} of the
Unicode standard.

@subsubheading Strings

@noindent
Strings are finite sequences of characters with fixed length and thus
represent arbitrary Unicode texts.

@subsubheading Symbols

@noindent
A symbol is an object representing a string, the symbol's @emph{name}.
Unlike strings, two symbols whose names are spelled the same way are
never distinguishable.  Symbols are useful for many applications; for
instance, they may be used the way enumerated values are used in other
languages.

@subsubheading Pairs and lists

@noindent
A pair is a data structure with two components.  The most common use of
pairs is to represent (singly linked) lists, where the first component
(the ``car'') represents the first element of the list, and the second
component (the ``cdr'') the rest of the list.  Scheme also has a
distinguished empty list, which is the last cdr in a chain of pairs that
form a list.

@subsubheading Vectors

@noindent
Vectors, like lists, are linear data structures representing finite
sequences of arbitrary objects.  Whereas the elements of a list are
accessed sequentially through the chain of pairs representing it, the
elements of a vector are addressed by integer indices.  Thus, vectors
are more appropriate than lists for random access to elements.

@subsubheading Procedures

@noindent
Procedures are values in Scheme.


@c page
@node lang overview expressions
@section Expressions


@noindent
The most important elements of Scheme code are @emph{expressions}.
Expressions can be @emph{evaluated}, producing a @emph{value}.
(Actually, any number of values; @ref{lang basic multiple return values}.)
The most fundamental expressions are literal expressions:

@example
#t => #t
23 => 23
@end example

This notation means that the expression @true{} evaluates to @true{},
that is, the value for ``true'', and that the expression @code{23}
evaluates to a number object representing the number 23.

Compound expressions are formed by placing parentheses around their
subexpressions.  The first subexpression identifies an operation; the
remaining subexpressions are operands to the operation:

@example
(+ 23 42) => 65
(+ 14 (* 23 42)) => 980
@end example

In the first of these examples, @func{+} is the name of the built--in
operation for addition, and @code{23} and @code{42} are the operands.
The expression @code{(+ 23 42)} reads as ``the sum of 23 and 42''.
Compound expressions can be nested---the second example reads as ``the
sum of 14 and the product of 23 and 42''.

As these examples indicate, compound expressions in Scheme are always
written using the same prefix notation.  As a consequence, the
parentheses are needed to indicate structure.  Consequently,
``superfluous'' parentheses, which are often permissible in mathematical
notation and also in many programming languages, are not allowed in
Scheme.

As in many other languages, whitespace (including line endings) is not
significant when it separates subexpressions of an expression, and can
be used to indicate structure.


@c page
@node lang overview variables
@section Variables and binding


@noindent
Scheme allows identifiers to stand for locations containing values.
These identifiers are called variables.  In many cases, specifically
when the location's value is never modified after its creation, it is
useful to think of the variable as standing for the value directly.

@example
(let ((x 23)
      (y 42))
  (+ x y)) => 65
@end example

In this case, the expression starting with @func{let} is a binding
construct.  The parenthesized structure following the @func{let} lists
variables alongside expressions: the variable @code{x} alongside
@code{23}, and the variable @code{y} alongside @code{42}.  The
@func{let} expression binds @code{x} to 23, and @code{y} to 42.  These
bindings are available in the @emph{body} of the @func{let} expression,
@code{(+ x y)}, and only there.


@c page
@node lang overview definitions
@section Definitions


@noindent
The variables bound by a @func{let} expression are @emph{local}, because
their bindings are visible only in the @func{let}'s body.  Scheme also
allows creating top--level bindings for identifiers as follows:

@example
(define x 23)
(define y 42)
(+ x y) => 65
@end example

@noindent
(These are actually ``top--level'' in the body of a top--level program
or library; @ref{lang library}.)

The first two parenthesized structures are @emph{definitions}; they
create top--level bindings, binding @code{x} to 23 and @code{y} to 42.
Definitions are not expressions, and cannot appear in all places where
an expression can occur.  Moreover, a definition has no value.

Bindings follow the lexical structure of the program: When several
bindings with the same name exist, a variable refers to the binding that
is closest to it, starting with its occurrence in the program and going
from inside to outside, and referring to a top--level binding if no
local binding can be found along the way:

@example
(define x 23)
(define y 42)
(let ((y 43))
  (+ x y)) => 66

(let ((y 43))
  (let ((y 44))
    (+ x y))) => 67
@end example


@c page
@node lang overview forms
@section Forms


@noindent
While definitions are not expressions, compound expressions and
definitions exhibit similar syntactic structure:

@example
(define x 23)
(* x 2)
@end example

While the first line contains a definition, and the second an
expression, this distinction depends on the bindings for @func{let}
and @func{*}.  At the purely syntactical level, both are @emph{forms},
and @emph{form} is the general name for a syntactic part of a Scheme
program.  In particular, @code{23} is a @emph{subform} of the form
@code{(define x 23)}.


@c page
@node lang overview procedures
@section Procedures


@noindent
Definitions can also be used to define procedures:

@example
(define (f x)
  (+ x 42))

(f 23) => 65
@end example

A procedure is, slightly simplified, an abstraction of an expression
over objects.  In the example, the first definition defines a procedure
called @code{f}.  (Note the parentheses around @code{f x}, which
indicate that this is a procedure definition.)  The expression @code{(f
23)} is a procedure call, meaning, roughly, ``evaluate @code{(+ x 42)}
(the body of the procedure) with @code{x} bound to 23''.

As procedures are objects, they can be passed to other procedures:

@example
(define (f x)
  (+ x 42))

(define (g p x)
  (p x))

(g f 23) => 65
@end example

In this example, the body of @code{g} is evaluated with @code{p} bound
to @code{f} and @code{x} bound to 23, which is equivalent to @code{(f
23)}, which evaluates to 65.

In fact, many predefined operations of Scheme are provided not by
syntax, but by variables whose values are procedures.  The @func{+}
operation, for example, which receives special syntactic treatment in
many other languages, is just a regular identifier in Scheme, bound to a
procedure that adds number objects.  The same holds for @func{*} and
many others:

@example
(define (h op x y)
  (op x y))

(h + 23 42) => 65
(h * 23 42) => 966
@end example

Procedure definitions are not the only way to create procedures.  A
@func{lambda} expression creates a new procedure as an object, with no
need to specify a name:

@example
((lambda (x) (+ x 42)) 23) => 65
@end example

The entire expression in this example is a procedure call; @code{(lambda
(x) (+ x 42))}, evaluates to a procedure that takes a single number
object and adds 42 to it.


@c page
@node lang overview syntax
@section Procedure calls and syntactic keywords


@noindent
Whereas @code{(+ 23 42)}, @code{(f 23)}, and @code{((lambda (x) (+ x
42)) 23)} are all examples of procedure calls, @func{lambda} and
@func{let} expressions are not.  This is because @func{let}, even though
it is an identifier, is not a variable, but is instead a @emph{syntactic
keyword}.  A form that has a syntactic keyword as its first
subexpression obeys special rules determined by the keyword.  The
@func{let} identifier in a definition is also a syntactic keyword.
Hence, definitions are also not procedure calls.

The rules for the @func{lambda} keyword specify that the first subform
is a list of parameters, and the remaining subforms are the body of the
procedure.  In @func{let} expressions, the first subform is a list of
binding specifications, and the remaining subforms constitute a body of
expressions.

Procedure calls can generally be distinguished from these @emph{special
forms} by looking for a syntactic keyword in the first position of a
form: if the first position does not contain a syntactic keyword, the
expression is a procedure call.  (So--called @emph{identifier macros}
allow creating other kinds of special forms, but are comparatively
rare.)  The set of syntactic keywords of Scheme is fairly small, which
usually makes this task fairly simple.  It is possible, however, to
create new bindings for syntactic keywords; @ref{lang overview macros} below.


@c page
@node lang overview assignment
@section Assignment


@noindent
Scheme variables bound by definitions or @func{let} or @func{lambda}
expressions are not actually bound directly to the objects specified in
the respective bindings, but to locations containing these objects.  The
contents of these locations can subsequently be modified destructively
via @emph{assignment}:

@example
(let ((x 23))
  (set! x 42)
  x) => 42
@end example

In this case, the body of the @func{let} expression consists of two
expressions which are evaluated sequentially, with the value of the
final expression becoming the value of the entire @func{let} expression.
The expression @code{(set! x 42)} is an assignment, saying ``replace the
object in the location referenced by @code{x} with 42''.  Thus, the
previous value of @code{x}, 23, is replaced by 42.


@c page
@node lang overview macros
@section Derived forms and macros


@noindent
Many of the special forms specified in this report can be translated
into more basic special forms.  For example, a @func{let} expression can
be translated into a procedure call and a @func{lambda} expression.  The
following two expressions are equivalent:

@example
(let ((x 23)
      (y 42))
  (+ x y)) => 65

((lambda (x y) (+ x y)) 23 42)    => 65
@end example

Special forms like @func{let} expressions are called @emph{derived
forms} because their semantics can be derived from that of other kinds
of forms by a syntactic transformation.  Some procedure definitions are
also derived forms.  The following two definitions are equivalent:

@example
(define (f x)
  (+ x 42))

(define f
  (lambda (x)
    (+ x 42)))
@end example

In Scheme, it is possible for a program to create its own derived forms
by binding syntactic keywords to macros:

@example
(define-syntax def
  (syntax-rules ()
    ((def f (p ...) body)
     (define (f p ...)
       body))))

(def f (x)
  (+ x 42))
@end example

The @func{define-syntax} construct specifies that a parenthesized
structure matching the pattern @code{(def f (p ...) body)}, where
@func{f}, @code{p}, and @code{body} are pattern variables, is translated
to @code{(define (f p ...) body)}.  Thus, the @code{def} form appearing
in the example gets translated to:

@example
(define (f x)
  (+ x 42))
@end example

The ability to create new syntactic keywords makes Scheme extremely
flexible and expressive, allowing many of the features built into other
languages to be derived forms in Scheme.


@c page
@node lang overview data
@section Syntactic data and datum values


@noindent
A subset of the Scheme objects is called @emph{datum values}.  These
include booleans, number objects, characters, symbols, and strings as
well as lists and vectors whose elements are data.  Each datum value may
be represented in textual form as a @emph{syntactic datum}, which can be
written out and read back in without loss of information.  A datum value
may be represented by several different syntactic data.  Moreover, each
datum value can be trivially translated to a literal expression in a
program by prepending a @code{'} (single quote) to a corresponding
syntactic datum:

@example
'23 => 23
'@true{} => @true{}
'foo => foo
'(1 2 3) => (1 2 3)
'#(1 2 3) => #(1 2 3)
@end example

The @code{'} shown in the previous examples is not needed for
representations of number objects or booleans.  The syntactic datum
@code{foo} represents a symbol with name ``foo'', and @code{'foo} is a
literal expression with that symbol as its value.  @code{(1 2 3)} is a
syntactic datum that represents a list with elements 1, 2, and 3, and
@code{'(1 2 3)} is a literal expression with this list as its value.
Likewise, @code{#(1 2 3)} is a syntactic datum that represents a vector
with elements 1, 2 and 3, and @code{'#(1 2 3)} is the corresponding
literal.

The syntactic data are a superset of the Scheme forms.  Thus, data can
be used to represent Scheme forms as data objects.  In particular,
symbols can be used to represent identifiers.

@example
'(+ 23 42) => (+ 23 42)
'(define (f x) (+ x 42))    => (define (f x) (+ x 42))
@end example

This facilitates writing programs that operate on Scheme source code, in
particular interpreters and program transformers.


@c page
@node lang overview continuations
@section Continuations


@noindent
Whenever a Scheme expression is evaluated there is a @emph{continuation}
wanting the result of the expression.  The continuation represents an
entire (default) future for the computation.  For example, informally
the continuation of @code{3} in the expression

@example
(+ 1 3)
@end example

@noindent
adds 1 to it.  Normally these ubiquitous continuations are hidden behind
the scenes and programmers do not think much about them.  On rare
occasions, however, a programmer may need to deal with continuations
explicitly.

The @func{call-with-current-continuation} procedure (@ref{baselib control})
allows Scheme programmers to do that by creating a procedure that
reinstates the current continuation.

The @func{call-with-current-continuation} procedure accepts a procedure,
calls it immediately with an argument that is an @emph{escape
procedure}.  This escape procedure can then be called with an argument
that becomes the result of the call to
@func{call-with-current-continuation}.  That is, the escape procedure
abandons its own continuation, and reinstates the continuation of the
call to @func{call-with-current-continuation}.

In the following example, an escape procedure representing the
continuation that adds 1 to its argument is bound to @code{escape}, and
then called with 3 as an argument.  The continuation of the call to
@code{escape} is abandoned, and instead the 3 is passed to the
continuation that adds 1:

@example
(+ 1 (call-with-current-continuation
       (lambda (escape)
         (+ 2 (escape 3)))))    => 4
@end example

An escape procedure has unlimited extent: It can be called after the
continuation it captured has been invoked, and it can be called multiple
times.  This makes @func{call-with-current-continuation} significantly
more powerful than typical non--local control constructs such as
exceptions in other languages.


@c page
@node lang overview libraries
@section Libraries


@noindent
Scheme code can be organized in components called @emph{libraries}.
Each library contains definitions and expressions.  It can import
definitions from other libraries and export definitions to other
libraries.

The following library called @code{(hello)} exports a definition called
@func{hello-world}, and imports the base library (@ref{baselib}) and the
simple I/O library (@ref{stdlib io simple}).  The @func{hello-world}
export is a procedure that displays @code{Hello World} on a separate
line:

@example
(library (hello)
  (export hello-world)
  (import (rnrs base)
          (rnrs io simple))
  (define (hello-world)
    (display "Hello World")
    (newline)))
@end example


@c page
@node lang overview programs
@section Top--level programs


@noindent
A Scheme program is invoked via a @emph{top--level program}.  Like a
library, a top--level program contains imports, definitions and
expressions, and specifies an entry point for execution.  Thus a
top--level program defines, via the transitive closure of the libraries
it imports, a Scheme program.

The following top--level program obtains the first argument from the
command line via the @code{command-line} procedure from the
@rsixlibrary{programs} library (@ref{stdlib programlib}).  It then opens
the file using @func{open-file-input-port} (@ref{stdlib io port input
ports}), yielding a @emph{port}, i.e. a connection to the file as a data
source, and calls the @func{get-bytes-all} procedure to obtain the
contents of the file as binary data.  It then uses @func{put-bytes} to
output the contents of the file to standard output:

@example
#!r6rs
(import (rnrs base)
        (rnrs io ports)
        (rnrs programs))
(let ((p (standard-output-port)))
  (put-bytevector p
                  (call-with-port
                      (open-file-input-port
                        (cadr (command-line)))
                    get-bytevector-all))
  (close-port p))
@end example


@c page
@node lang requirements
@chapter Requirement levels


@noindent
The key words ``must'', ``must not'', ``should'', ``should not'',
``recommended'', ``may'', and ``optional'' in this report are to be
interpreted as described in @acronym{RFC} 2119.  Specifically:

@table @strong
@item must
This word means that a statement is an absolute requirement of the
specification.

@item must not
This phrase means that a statement is an absolute prohibition of the
specification.

@item should
This word, or the adjective ``recommended'', means that valid reasons
may exist in particular circumstances to ignore a statement, but that
the implications must be understood and weighed before choosing a
different course.

@item should not
This phrase, or the phrase ``not recommended'', means that valid reasons
may exist in particular circumstances when the behavior of a statement
is acceptable, but that the implications should be understood and
weighed before choosing the course described by the statement.

@item may
This word, or the adjective ``optional'', means that an item is truly
optional.
@end table

In particular, this report occasionally uses ``should'' to designate
circumstances that are outside the specification of this report, but
cannot be practically detected by an implementation; @ref{lang basic argument
checking}.  In such circumstances, a particular implementation may allow
the programmer to ignore the recommendation of the report and even
exhibit reasonable behavior.  However, as the report does not specify
the behavior, these programs may be unportable, that is, their execution
might produce different results on different implementations.

Moreover, this report occasionally uses the phrase ``not required'' to note the
absence of an absolute requirement.


@c page
@node lang numbers
@chapter Numbers


@menu
* lang numbers tower::          Numerical tower.
* lang numbers exactness::      Exactness.
* lang numbers fix flo::        Fixnums and flonums.
* lang numbers requirements::   Implementation requirements.
* lang numbers inf nan::        Infinities and NaNs.
* lang numbers minus zero::     Distinguished @code{-0.0}.
@end menu


@noindent
This chapter describes Scheme's model for numbers.  It is important to
distinguish between the mathematical numbers, the Scheme objects that
attempt to model them, the machine representations used to implement the
numbers, and notations used to write numbers.

In this report, the term @emph{number} refers to a mathematical number,
and the term @emph{number object} refers to a Scheme object representing
a number.  This report uses the types @emph{complex}, @emph{real},
@emph{rational}, and @emph{integer} to refer to both mathematical
numbers and number objects.  The @emph{fixnum} and @emph{flonum} types
refer to special subsets of the number objects, as determined by common
machine representations, as explained below.



@c page
@node lang numbers tower
@section Numerical tower


@noindent
Numbers may be arranged into a tower of subsets in which each level is a
subset of the level above it:

@example
number
  complex
  real
  rational
  integer
@end example

For example, 5 is an integer.  Therefore 5 is also a rational, a real,
and a complex.  The same is true of the number objects that model 5.

Number objects are organized as a corresponding tower of subtypes
defined by the predicates @code{number?}, @code{complex?}, @code{real?},
@code{rational?}, and @code{ integer?}; @ref{baselib math ops type pred}.
Integer number objects are also called @emph{integer objects}.

There is no simple relationship between the subset that contains a
number and its representation inside a computer.  For example, the
integer 5 may have several representations.  Scheme's numerical
operations treat number objects as abstract data, as independent of
their representation as possible.  Although an implementation of Scheme
may use many different representations for numbers, this should not be
apparent to a casual programmer writing simple programs.



@c page
@node lang numbers exactness
@section Exactness


@noindent
It is useful to distinguish between number objects that are known to
correspond to a number exactly, and those number objects whose
computation involved rounding or other errors.  For example, index
operations into data structures may need to know the index exactly, as
may some operations on polynomial coefficients in a symbolic algebra
system.  On the other hand, the results of measurements are inherently
inexact, and irrational numbers may be approximated by rational and
therefore inexact approximations.  In order to catch uses of numbers
known only inexactly where exact numbers are required, Scheme explicitly
distinguishes @emph{exact} from @emph{inexact} number objects.  This
distinction is orthogonal to the dimension of type.

A number object is exact if it is the value of an exact numerical
literal or was derived from exact number objects using only exact
operations.  Exact number objects correspond to mathematical numbers in
the obvious way.

Conversely, a number object is inexact if it is the value of an inexact
numerical literal, or was derived from inexact number objects, or was
derived using inexact operations.  Thus inexactness is contagious.

Exact arithmetic is reliable in the following sense: If exact number
objects are passed to any of the arithmetic procedures described in
section ``Propagation of exactness and inexactness'', and an exact
number object is returned, then the result is mathematically correct.
This is generally not true of computations involving inexact number
objects because approximate methods such as floating--point arithmetic
may be used, but it is the duty of each implementation to make the
result as close as practical to the mathematically ideal result.


@c page
@node lang numbers fix flo
@section Fixnums and flonums


@noindent
A @emph{fixnum} is an exact integer object that lies within a certain
implementation--dependent subrange of the exact integer objects.
(Library section on ``Fixnums'' describes a library for computing with
fixnums.)  Likewise, every implementation must designate a subset of its
inexact real number objects as @emph{flonums}, and to convert certain
external representations into flonums.  (Library section on ``Flonums''
describes a library for computing with flonums.)  Note that this does
not imply that an implementation must use floating--point
representations.



@c page
@node lang numbers requirements
@section Implementation requirements


@noindent
Implementations of Scheme must support number objects for the entire
tower of subtypes given in section ``Numerical tower''.  Moreover,
implementations must support exact integer objects and exact rational
number objects of practically unlimited size and precision, and to
implement certain procedures (listed in ``Propagation of exactness and
inexactness'') so they always return exact results when given exact
arguments.  (``Practically unlimited'' means that the size and precision
of these numbers should only be limited by the size of the available
memory.)

Implementations may support only a limited range of inexact number
objects of any type, subject to the requirements of this section.  For
example, an implementation may limit the range of the inexact real
number objects (and therefore the range of inexact integer and rational
number objects) to the dynamic range of the flonum format.  Furthermore
the gaps between the inexact integer objects and rationals are likely to
be very large in such an implementation as the limits of this range are
approached.

An implementation may use floating point and other approximate
representation strategies for @emph{inexact} numbers.  This report
recommends, but does not require, that the @acronym{IEEE}
floating--point standards be followed by implementations that use
floating--point representations, and that implementations using other
representations should match or exceed the precision achievable using
these floating--point standards @cite{ieee}.

In particular, implementations that use floating--point representations
must follow these rules: A floating--point result must be represented
with at least as much precision as is used to express any of the inexact
arguments to that operation.  Potentially inexact operations such as
@func{sqrt}, when applied to exact arguments, should produce exact
answers whenever possible (for example the square root of an exact 4
ought to be an exact 2).  However, this is not required.  If, on the
other hand, an exact number object is operated upon so as to produce an
inexact result (as by @func{sqrt}), and if the result is represented in
floating point, then the most precise floating--point format available
must be used; but if the result is represented in some other way then
the representation must have at least as much precision as the most
precise floating--point format available.

It is the programmer's responsibility to avoid using inexact number
objects with magnitude or significand too large to be represented in the
implementation.


@c page
@node lang numbers inf nan
@section Infinities and NaNs


@noindent
Some Scheme implementations, specifically those that follow the
@acronym{IEEE} floating--point standards, distinguish special number
objects called, @emph{negative infinity}, and @emph{NaN}.

Positive infinity is regarded as an inexact real (but not rational)
number object that represents an indeterminate number greater than the
numbers represented by all rational number objects.  Negative infinity
is regarded as an inexact real (but not rational) number object that
represents an indeterminate number less than the numbers represented by
all rational numbers.

A NaN is regarded as an inexact real (but not rational) number object so
indeterminate that it might represent any real number, including
positive or negative infinity, and might even be greater than positive
infinity or less than negative infinity.


@c page
@node lang numbers minus zero
@section Distinguished @code{-0.0}


@noindent
Some Scheme implementations, specifically those that follow the
@acronym{IEEE} floating--point standards, distinguish between number
objects for @code{0.0} and @code{-0.0}, i.e., positive and negative
inexact zero.  This report will sometimes specify the behavior of
certain arithmetic operations on these number objects.  These
specifications are marked with ``if @code{-0.0} is distinguished'' or
``implementations that distinguish @code{-0.0}''.



@c page
@node lang lex
@chapter Lexical syntax and datum syntax


@menu
* lang lex notation::           Notation.
* lang lex syntax::             Lexical syntax.
* lang lex datum::              Datum syntax.
@end menu


@noindent
The syntax of Scheme code is organized in three levels:

@enumerate
@item
the @emph{lexical syntax} that describes how a program text is split
into a sequence of lexemes,

@item
the @emph{datum syntax}, formulated in terms of the lexical syntax, that
structures the lexeme sequence as a sequence of @emph{syntactic data},
where a syntactic datum is a recursively structured entity,

@item
the @emph{program syntax} formulated in terms of the datum syntax,
imposing further structure and assigning meaning to syntactic data.
@end enumerate

Syntactic data (also called @emph{external representations}) double as a
notation for objects, and Scheme's @rsixlibrary{io ports} library
(library section ``Port I/O'') provides the @func{get-datum} and
@func{put-datum} procedures for reading and writing syntactic data,
converting between their textual representation and the corresponding
objects.  Each syntactic datum represents a corresponding @emph{datum
value}.  A syntactic datum can be used in a program to obtain the
corresponding datum value using @code{quote} (@ref{baselib expressions
quotation}).

Scheme source code consists of syntactic data and (non--significant)
comments.  Syntactic data in Scheme source code are called @emph{forms}.
(A form nested inside another form is called a @emph{subform}.)
Consequently, Scheme's syntax has the property that any sequence of
characters that is a form is also a syntactic datum representing some
object.  This can lead to confusion, since it may not be obvious out of
context whether a given sequence of characters is intended to be a
representation of objects or the text of a program.  It is also a source
of power, since it facilitates writing programs such as interpreters or
compilers that treat programs as objects (or vice versa).

A datum value may have several different external representations.  For
example, both @code{#e28.000} and @code{#x1c} are syntactic data
representing the exact integer object 28, and the syntactic data
@code{(8 13)}, @code{( 08 13 )}, @code{(8 . (13 . ()))} all represent a
list containing the exact integer objects 8 and 13.  Syntactic data that
represent equal objects (in the sense of @func{equal?}; @ref{baselib
predicates}) are always equivalent as forms of a program.

Because of the close correspondence between syntactic data and datum
values, this report sometimes uses the term @emph{datum} for either a
syntactic datum or a datum value when the exact meaning is apparent from
the context.

An implementation must not extend the lexical or datum syntax in any
way, with one exception: it need not treat the syntax
@code{#!<identifier>}, for any <identifier> (@ref{lang lex syntax
identifiers}) that is not @code{r6rs}, as a syntax violation, and it may
use specific @code{#!}--prefixed identifiers as flags indicating that
subsequent input contains extensions to the standard lexical or datum
syntax.  The syntax @code{#!r6rs} may be used to signify that the input
afterward is written with the lexical syntax and datum syntax described
by this report.  @code{#!r6rs} is otherwise treated as a comment;
@ref{lang lex syntax whitespace and comments}.


@c page
@node lang lex notation
@section Notation


@noindent
The formal syntax for Scheme is written in an extended @acronym{BNF}.
Non--terminals are written using angle brackets.  Case is insignificant
for non--terminal names.

All spaces in the grammar are for legibility.  @meta{Empty} stands for
the empty string.

The following extensions to @acronym{BNF} are used to make the
description more concise: @arbno{@meta{thing}} means zero or more
occurrences of @meta{thing}, and @atleastone{@meta{thing}} means at
least one @meta{thing}.

Some non-terminal names refer to the Unicode scalar values of the same
name: @meta{character tabulation} (U+0009), @meta{linefeed} (U+000A),
@meta{carriage return} (U+000D), @meta{line tabulation} (U+000B),
@meta{form feed} (U+000C), @meta{space} (U+0020), @meta{next line}
(U+0085), @meta{line separator} (U+2028), and @meta{paragraph separator}
(U+2029).


@c page
@node lang lex syntax
@section Lexical syntax


@menu
* lang lex syntax formal account::           Formal account.
* lang lex syntax line endings::             Line endings.
* lang lex syntax whitespace and comments::  Whitespace and comments.
* lang lex syntax identifiers::              Identifiers.
* lang lex syntax booleans::                 Booleans.
* lang lex syntax characters::               Characters.
* lang lex syntax strings::                  Strings.
* lang lex syntax numbers::                  Numbers.
@end menu


@noindent
The lexical syntax determines how a character sequence is split into a
sequence of lexemes, omitting non--significant portions such as comments
and whitespace.  The character sequence is assumed to be text according
to the Unicode standard @cite{Unicode}.  Some of the lexemes, such as
identifiers, representations of number objects, strings etc., of the
lexical syntax are syntactic data in the datum syntax, and thus
represent objects.  Besides the formal account of the syntax, this
section also describes what datum values are represented by these
syntactic data.

The lexical syntax, in the description of comments, contains a forward
reference to @meta{datum}, which is described as part of the datum
syntax.  Being comments, however, these @meta{datum}s do not play a
significant role in the syntax.

Case is significant except in representations of booleans, number
objects, and in hexadecimal numbers specifying Unicode scalar values.
For example, @code{#x1A} and @code{#X1a} are equivalent.  The identifier
@code{Foo} is, however, distinct from the identifier @code{FOO}.



@c page
@node lang lex syntax formal account
@subsection Formal account


@noindent
@meta{Interlexeme space} may occur on either side of any lexeme, but not
within a lexeme.

@meta{Identifier}s, @code{.}, @meta{number}s, @meta{character}s, and
@meta{boolean}s, must be terminated by a @meta{delimiter} or by the end
of the input.

The following two characters are reserved for future extensions to the
language: @code{@{ @}}

@example
<lexeme> -> <identifier> | <boolean> | <number>
         | <character> | <string>
         | ( | ) | [ | ] | #( | #vu8( | ' | ` | , | ,@@ | .
         | #' | #` | #, | #,@@
<delimiter> -> ( | ) | [ | ] | " | ; | #
         | <whitespace>
<whitespace> -> <character tabulation>
         | <linefeed> | <line tabulation> | <form feed>
         | <carriage return> | <next line>
         | <any character whose category is Zs, Zl, or Zp>
<line ending> -> <linefeed> | <carriage return>
         | <carriage return> <linefeed> | <next line>
         | <carriage return> <next line> | <line separator>
<comment> -> ; <all subsequent characters up to a <line ending>
                or <paragraph separator> >
         | <nested comment>
         | #; <interlexeme space> <datum>
         | #!r6rs
<nested comment> -> #| <comment text>
         <comment cont>* |#
<comment text> -> character sequence not containing #| or |#
<comment cont> -> <nested comment> <comment text>
<atmosphere> -> <whitespace> | <comment>
<interlexeme space> -> <atmosphere>*

<identifier> -> <initial> <subsequent>*
         | <peculiar identifier>
<initial> -> <constituent> | <special initial>
         | <inline hex escape>
<letter> -> a | b | c | ... | z
         | A | B | C | ... | Z
<constituent> -> <letter>
         | <any character whose Unicode scalar value is greater than
             127, and whose category is Lu, Ll, Lt, Lm, Lo, Mn,
             Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co>
<special initial> -> ! | $ | % | & | * | / | : | < | =
         | > | ? | ^ | _ | ~
<subsequent> -> <initial> | <digit>
         | <any character whose category is Nd, Mc, or Me>
         | <special subsequent>
<digit> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9
<hex digit> -> <digit>
         | a | A | b | B | c | C | d | D | e | E | f | F
<special subsequent> -> + | - | . | @@
<inline hex escape> -> \x<hex scalar value>;
<hex scalar value> -> <hex digit>+
<peculiar identifier> -> + | - | ... | -> <subsequent>*
<boolean> -> #t | #T | #f | #F
<character> -> #\<any character>
         | #\<character name>
         | #\x<hex scalar value>
<character name> -> nul | alarm | backspace | tab
         | linefeed | newline | vtab | page | return
         | esc | space | delete
<string> -> " <string element>* "
<string element> -> <any character other than " or \>
         | \a | \b | \t | \n | \v | \f | \r
         | \" | \\
         | \<intraline whitespace>* <line ending>
            <intraline whitespace>*
         | <inline hex escape>
<intraline whitespace> -> <character tabulation>
         | <any character whose category is Zs>
@end example

A @meta{hex scalar value} represents a Unicode scalar value between
@code{0} and @code{#x10FFFF}, excluding the range @code{[#D800,
#xDFFF]}.

The rules for @meta{num R}, @meta{complex R}, @meta{real R}, @meta{ureal
R}, @meta{uinteger R}, and @meta{prefix R} below should be replicated
for R = 2, 8, 10, and 16.  There are no rules for @meta{decimal 2},
@meta{decimal 8}, and @meta{decimal 16}, which means that number
representations containing decimal points or exponents must be in
decimal radix.

@example
<number> -> <num 2> | <num 8>
         | <num 10> | <num 16>
<num R> -> <prefix R> <complex R>
<complex R> -> <real R> | <real R> @@ <real R>
         | <real R> + <ureal R> i | <real R> - <ureal R> i
         | <real R> + <naninf> i | <real R> - <naninf> i
         | <real R> + i | <real R> - i
         | + <ureal R> i | - <ureal R> i
         | + <naninf> i | - <naninf> i
         | + i | - i
<real R> -> <sign> <ureal R>
         | + <naninf> | - <naninf>
<naninf> -> nan.0 | inf.0
<ureal R> -> <uinteger R>
         | <uinteger R> / <uinteger R>
         | <decimal R> <mantissa width>
<decimal 10> -> <uinteger 10> <suffix>
         | . <digit 10>+ <suffix>
         | <digit 10>+ . <digit 10>* <suffix>
         | <digit 10>+ . <suffix>
<uinteger R> -> <digit R>+
<prefix R> -> <radix R> <exactness>
         | <exactness> <radix R>

<suffix> -> <empty>
         | <exponent marker> <sign> <digit 10>+
<exponent marker> -> e | E | s | S | f | F
         | d | D | l | L
<mantissa width> -> <empty>
         | | <digit 10>+
<sign> -> <empty> | + | -
<exactness> -> <empty>
         | #i| #I | #e| #E
<radix 2> -> #b| #B
<radix 8> -> #o| #O
<radix 10> -> <empty> | #d | #D
<radix 16> -> #x| #X
<digit 2> -> 0 | 1
<digit 8> -> 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7
<digit 10> -> <digit>
<digit 16> -> <hex digit>
@end example


@c page
@node lang lex syntax line endings
@subsection Line endings


@noindent
Line endings are significant in Scheme in single--line comments
(@ref{lang lex syntax whitespace and comments}) and within string literals.
In Scheme source code, any of the line endings in @meta{line ending}
marks the end of a line.  Moreover, the two--character line endings
@meta{carriage return} @meta{linefeed} and @meta{carriage return}
@meta{next line} each count as a single line ending.

In a string literal, a @meta{line ending} not preceded by a @code{\}
stands for a linefeed character, which is the standard line--ending
character of Scheme.


@c page
@node lang lex syntax whitespace and comments
@subsection Whitespace and comments


@noindent
@emph{Whitespace} characters are spaces, linefeeds, carriage returns,
character tabulations, form feeds, line tabulations, and any other
character whose category is Zs, Zl, or Zp.  Whitespace is used for
improved readability and as necessary to separate lexemes from each
other.  Whitespace may occur between any two lexemes, but not within a
lexeme.  Whitespace may also occur inside a string, where it is
significant.

The lexical syntax includes several comment forms.  In all cases,
comments are invisible to Scheme, except that they act as delimiters,
so, for example, a comment cannot appear in the middle of an identifier
or representation of a number object.

A semicolon (@code{;}) indicates the start of a line comment.  The
comment continues to the end of the line on which the semicolon appears.

Another way to indicate a comment is to prefix a @meta{datum} (cf.
section ``Formal account'') with @code{#;}, possibly with
@meta{interlexeme space} before the @meta{datum}.  The comment consists
of the comment prefix @code{#;} and the @meta{datum} together.  This
notation is useful for ``commenting out'' sections of code.

Block comments may be indicated with properly nested @code{#|} and
@code{|#} pairs.

@example
#|
   The FACT procedure computes the factorial of a
   non-negative integer.
|#
(define fact
  (lambda (n)
    ;; base case
    (if (= n 0)
        #;(= n 1)
        1       ; identity of *
        (* n (fact (- n 1))))))
@end example

The lexeme @code{#!r6rs}, which signifies that the program text that
follows is written with the lexical and datum syntax described in this
report, is also otherwise treated as a comment.


@c page
@node lang lex syntax identifiers
@subsection Identifiers


@cindex Identifier, definition of
@cindex Definition of identifier


@noindent
Most identifiers allowed by other programming languages are also
acceptable to Scheme.  In general, a sequence of letters, digits, and
``extended alphabetic characters'' is an identifier when it begins with
a character that cannot begin a representation of a number object.  In
addition, @code{+}, @code{-}, and @code{...} are identifiers, as is a
sequence of letters, digits, and extended alphabetic characters that
begins with the two--character sequence @code{->}.  Here are some
examples of identifiers:

@example
lambda         q                soup
list->vector   +                V17a
<=             a34kTMNs         ->-
the-word-recursion-has-many-meanings
@end example

Extended alphabetic characters may be used within identifiers as if they
were letters.  The following are extended alphabetic characters:

@example
! $ % & * + - . / : < = > ? @@ ^ _ ~
@end example

Moreover, all characters whose Unicode scalar values are greater than
127 and whose Unicode category is Lu, Ll, Lt, Lm, Lo, Mn, Mc, Me, Nd,
Nl, No, Pd, Pc, Po, Sc, Sm, Sk, So, or Co can be used within
identifiers.  In addition, any character can be used within an
identifier when specified via an @meta{inline hex escape}.  For example,
the identifier @code{H\x65;llo} is the same as the identifier
@code{Hello}.
@c , and the identifier @code{\x3BB;} is the same as the
@c identifier $\lambda$.

Any identifier may be used as a variable or as a syntactic keyword
(@ref{lang basic variables keywords regions} and @ref{lang syntax macros}) in a
Scheme program.  Any identifier may also be used as a syntactic datum,
in which case it represents a @emph{symbol} (@ref{baselib symbols}).


@c page
@node lang lex syntax booleans
@subsection Booleans


@noindent
The standard boolean objects for true and false have external
representations @true{} and @false{}.


@c page
@node lang lex syntax characters
@subsection Characters


@noindent
Characters are represented using the notation @code{#\<character>} or
@code{#<character name>} or @code{#x<hex scalar value>}.

For example:

@example
#\a             lower case letter a
#\A             upper case letter A
#\(             left parenthesis
#\              space character
#\nul           U+0000
#\alarm         U+0007
#\backspace     U+0008
#\tab           U+0009
#\linefeed      U+000A
#\newline       U+000A
#\vtab          U+000B
#\page          U+000C
#\return        U+000D
#\esc           U+001B
#\space         U+0020 preferred way to write a space
#\delete        U+007F
#\xFF           U+00FF
#\x03BB         U+03BB
#\x00006587     U+6587
#\x0001z        &lexical exception
#\alarmx        &lexical exception
#\alarm x       U+0007 followed by x
#\Alarm         &lexical exception
#\alert         &lexical exception
#\xA            U+000A
#\xFF           U+00FF
#\xff           U+00FF
#\x ff          U+0078 followed by another datum, ff
#\x(ff)         U+0078 followed by another datum, a parenthesized ff
#\(x)           &lexical exception
#\(x            &lexical exception
#\((x)          U+0028 followed by another datum, parenthesized x
#\x00110000     &lexical exception out of range
#\x000000001    U+0001
#\xD800         &lexical exception in excluded range
@end example

(The notation @code{&lexical} means that the line in question is a
lexical syntax violation.)

Case is significant in @code{#\<character>}, and in @code{#\<character
name>}, but not in the @code{<hex scalar value>} of @code{#\x<hex scalar
value>}.  A @meta{character} must be followed by a @meta{delimiter} or
by the end of the input.  This rule resolves various ambiguous cases
involving named characters, requiring, for example, the sequence of
characters @code{#\space} to be interpreted as the space character
rather than as the character @code{#\s} followed by the identifier
@code{pace}.

@quotation
@emph{Note:} The @code{#\newline} notation is retained for backward
compatibility.  Its use is deprecated; @code{#\linefeed} should be used
instead.
@end quotation


@c page
@node lang lex syntax strings
@subsection Strings


@noindent
String are represented by sequences of characters enclosed within
doublequotes (@code{"}).  Within a string literal, various escape
sequences represent characters other than themselves.  Escape sequences
always start with a backslash (@code{\}):

@table @code
@item \a
alarm, U+0007
@item \b
backspace, U+0008
@item \t
character tabulation, U+0009
@item \n
linefeed, U+000A
@item \v
line tabulation, U+000B
@item \f
formfeed, U+000C
@item \r
return, U+000D
@item \"
doublequote, U+0022
@item \
backslash, U+005C
@item \<intraline whitespace><line ending> <intraline whitespace>
nothing
@item \x<hex scalar value>;
specified character (note the terminating semi--colon).
@end table

These escape sequences are case-sensitive, except that the alphabetic
digits of a @meta{hex scalar value} can be uppercase or lowercase.

Any other character in a string after a backslash is a syntax violation.
Except for a line ending, any character outside of an escape sequence
and not a doublequote stands for itself in the string literal.
@c For example the single--character string literal {\tt "$\lambda$"}
@c (doublequote, a lower case lambda, doublequote) represents the same
@c string as {\tt "\{}x03bb;"}.
A line ending that does not follow a backslash stands for a linefeed
character.

Examples:

@example
"abc"           U+0061, U+0062, U+0063
"\x41;bc"       "Abc" ; U+0041, U+0062, U+0063
"\x41; bc"      "A bc"
                U+0041, U+0020, U+0062, U+0063
"\x41bc;"       U+41BC
"\x41"          &lexical exception
"\x;"           &lexical exception
"\x41bx;"       &lexical exception
"\x00000041;"   "A" ; U+0041
"\x0010FFFF;"   U+10FFFF
"\x00110000;"   &lexical exception
                out of range
"\x000000001;"  U+0001
"\xD800;"       &lexical exception
                in excluded range
"A
bc"             U+0041, U+000A, U+0062, U+0063
                if no space occurs after the A
@end example


@c page
@node lang lex syntax numbers
@subsection Numbers


@noindent
The syntax of external representations for number objects is described
formally by the @meta{number} rule in the formal grammar.  Case is not
significant in external representations of number objects.

A representation of a number object may be written in binary, octal,
decimal, or hexadecimal by the use of a radix prefix.  The radix
prefixes are @code{#b} (binary), @code{#o} (octal), @code{#d} (decimal),
and @code{#x} (hexadecimal).  With no radix prefix, a representation of
a number object is assumed to be expressed in decimal.

A representation of a number object may be specified to be either exact
or inexact by a prefix.  The prefixes are @code{#e} for exact, and
@code{#i} for inexact.  An exactness prefix may appear before or after
any radix prefix that is used.  If the representation of a number object
has no exactness prefix, the constant is inexact if it contains a
decimal point, an exponent, or a nonempty mantissa width; otherwise it
is exact.

In systems with inexact number objects of varying precisions, it may be
useful to specify the precision of a constant.  For this purpose,
representations of number objects may be written with an exponent marker
that indicates the desired precision of the inexact representation.  The
letters @code{s}, @code{f}, @code{d}, and @code{l} specify the use of
@emph{short}, @emph{single}, @emph{double}, and @emph{long} precision,
respectively.  (When fewer than four internal inexact representations
exist, the four size specifications are mapped onto those available.
For example, an implementation with two internal representations may map
short and single together and long and double together.)  In addition,
the exponent marker @code{e} specifies the default precision for the
implementation.  The default precision has at least as much precision as
@emph{double}, but implementations may wish to allow this default to be
set by the user.

@example
3.1415926535898F0
       Round to single, perhaps 3.141593
0.6L0
       Extend to long, perhaps .600000000000000
@end example

A representation of a number object with nonempty mantissa width,
@code{x|p}, represents the best binary floating--point approximation of
@emph{x} using a @emph{p}--bit significand.  For example, @code{1.1|53}
is a representation of the best approximation of 1.1 in @acronym{IEEE}
double precision.  If @emph{x} is an external representation of an
inexact real number object that contains no vertical bar, then its
numerical value should be computed as though it had a mantissa width of
53 or more.

Implementations that use binary floating--point representations of real
number objects should represent @code{x|p} using a @emph{p}--bit
significand if practical, or by a greater precision if a @emph{p}--bit
significand is not practical, or by the largest available precision if
@emph{p} or more bits of significand are not practical within the
implementation.

@quotation
@emph{Note} The precision of a significand should not be confused with
the number of bits used to represent the significand.  In the
@acronym{IEEE} floating--point standards, for example, the significand's
most significant bit is implicit in single and double precision but is
explicit in extended precision.  Whether that bit is implicit or
explicit does not affect the mathematical precision.  In implementations
that use binary floating point, the default precision can be calculated
by calling the following procedure:

@example
(define (precision)
  (do ([n 0 (+ n 1)]
       [x 1.0 (/ x 2.0)])
    ((= 1.0 (+ 1.0 x)) n)))
@end example
@end quotation

@quotation
@emph{Note} When the underlying floating--point representation is
@acronym{IEEE} double precision, the @code{|p} suffix should not always
be omitted: Denormalized floating--point numbers have diminished
precision, and therefore their external representations should carry a
@code{|p} suffix with the actual width of the significand.
@end quotation

The literals @code{+inf.0} and @code{-inf.0} represent positive and
negative infinity, respectively.  The @code{+nan.0} literal represents
the NaN that is the result of @code{(/ 0.0 0.0)}, and may represent
other NaNs as well.  The @code{-nan.0} literal also represents a NaN.

If @emph{x} is an external representation of an inexact real number
object and contains no vertical bar and no exponent marker other than
@code{e}, the inexact real number object it represents is a flonum (see
library section ``Flonums'').  Some or all of the other external
representations of inexact real number objects may also represent
flonums, but that is not required by this report.


@c page
@node lang lex datum
@section Datum syntax


@menu
* lang lex datum formal account::       Formal account.
* lang lex datum pairs and lists::      Pairs and lists.
* lang lex datum vectors::              Vectors.
* lang lex datum bytevectors::          Bytevectors.
* lang lex datum abbreviations::        Abbreviations.
@end menu


@noindent
The datum syntax describes the syntax of syntactic data in terms of a
sequence of @meta{lexeme}s, as defined in the lexical syntax.

Syntactic data include the lexeme data described in the previous section
as well as the following constructs for forming compound data:

@itemize
@item
pairs and lists, enclosed by @code{( )} or @code{[ ]};

@item
vectors;

@item
bytevectors.
@end itemize


@c page
@node lang lex datum formal account
@subsection Formal account

@noindent
The following grammar describes the syntax of syntactic data in terms of
various kinds of lexemes defined in the grammar in section ``Lexical
Syntax'':

@example
<datum> -> <lexeme datum>
         | <compound datum>
<lexeme datum> -> <boolean> | <number>
         | <character> | <string> | <symbol>
<symbol> -> <identifier>
<compound datum> -> <list> | <vector> | <bytevector>
<list> -> (<datum>*) | [<datum>*]
         | (<datum>+ . <datum>) | [<datum>+ . <datum>]
         | <abbreviation>
<abbreviation> -> <abbrev prefix> <datum>
<abbrev prefix> -> ' | ` | , | ,@@
         | #' | #` | #, | #,@@
<vector> -> #(<datum>*)
<bytevector> -> #vu8(<u8>*)
<u8> -> <any <number> representing an exact integer in @{0, ..., 255@}>
@end example


@c page
@node lang lex datum pairs and lists
@subsection Pairs and lists


@noindent
List and pair data, representing pairs and lists of values are
represented using parentheses or brackets.  Matching pairs of brackets
that occur in the rules of @meta{list} are equivalent to matching pairs
of parentheses.

The most general notation for Scheme pairs as syntactic data is the
``dotted'' notation @code{(<datum1> . <datum2>)} where @meta{datum1} is
the representation of the value of the car field and @meta{datum2} is
the representation of the value of the cdr field.  For example @code{(4
. 5)} is a pair whose car is 4 and whose cdr is 5.

A more streamlined notation can be used for lists: the elements of the
list are simply enclosed in parentheses and separated by spaces.  The
empty list is represented by @code{( )}.  For example,

@example
(a b c d e)
@end example

@noindent
and:

@example
(a . (b . (c . (d . (e . ())))))
@end example

@noindent
are equivalent notations for a list of symbols.

The general rule is that, if a dot is followed by an open parenthesis,
the dot, open parenthesis, and matching closing parenthesis can be
omitted in the external representation.

The sequence of characters @code{(4 . 5)} is the external representation
of a pair, not an expression that evaluates to a pair.  Similarly, the
sequence of characters @code{(+ 2 6)} is @emph{not} an external
representation of the integer 8, even though it @emph{is} an expression
(in the language of the @rsixlibrary{base} library) evaluating to the
integer 8; rather, it is a syntactic datum representing a three--element
list, the elements of which are the symbol @code{+} and the integers 2
and 6.


@c page
@node lang lex datum vectors
@subsection Vectors


@noindent
Vector data, representing vectors of objects, are represented using the
notation @code{#(<datum> ...)}.  For example, a vector of length 3
containing the number object for zero in element 0, the list @code{(2 2
2 2)} in element 1, and the string @code{"Anna"} in element 2 can be
represented as follows:

@example
#(0 (2 2 2 2) "Anna")
@end example

This is the external representation of a vector, not an expression that
evaluates to a vector.


@c page
@node lang lex datum bytevectors
@subsection Bytevectors


@noindent
Bytevector data, representing bytevectors (@ref{stdlib bytevector}), are
represented using the notation @code{#vu8(<u8> ...)}, where the
@meta{u8}s represent the octets of the bytevector.  For example, a
bytevector of length 3 containing the octets 2, 24, and 123 can be
represented as follows:

@example
#vu8(2 24 123)
@end example

This is the external representation of a bytevector, and also an
expression that evaluates to a bytevector.


@c page
@node lang lex datum abbreviations
@subsection Abbreviations


@example
 '<datum>        `<datum>        ,<datum>
,@@<datum>       #'<datum>       #`<datum>
#,<datum>      #,@@<datum>
@end example

Each of these is an abbreviation:

@table @code
@item '<datum>
for @code{(quote <datum>)},

@item `<datum>
for @code{(quasiquote <datum>)},

@item ,<datum>
for @code{(unquote <datum>)},

@item ,@@<datum>
for @code{(unquote-splicing <datum>)},

@item #'<datum>
for @code{(syntax <datum>)},

@item #`<datum>
for @code{(quasisyntax <datum>)},

@item #,<datum>
for @code{(unsyntax <datum>)}, and

@item #,@@<datum>
for @code{(unsyntax-splicing <datum>)}.
@end table


@c page
@node lang basic
@chapter Semantic concepts

@ignore
In the original document this chapter was the "basic.tex" file.
@end ignore

@menu
* lang basic programs and libraries::        Programs and libraries.
* lang basic variables keywords regions::    Variables, keywords,
                                             and regions.
* lang basic exceptions::                    Exceptional situations.
* lang basic argument checking::             Argument checking.
* lang basic syntax violations::             Syntax violations.
* lang basic safety::                        Safety.
* lang basic boolean values::                Boolean values.
* lang basic multiple return values::        Multiple return values.
* lang basic unspecified behavior::          Unspecified behavior.
* lang basic storage model::                 Storage model.
* lang basic proper tail recursion::         Proper tail recursion.
* lang basic dynamic extent::                Dynamic extent and the
                                             dynamic environment.
@end menu


@c page
@node lang basic programs and libraries
@section Programs and libraries


A Scheme program consists of a @emph{top--level} program together with a
set of @emph{libraries}, each of which defines a part of the program
connected to the others through explicitly specified exports and
imports.

@itemize
@item
A library consists of a set of export and import specifications and a
body, which consists of definitions, and expressions.

@item
A top--level program is similar to a library, but has no export
specifications.
@end itemize

Chapters ``Libraries'' and ``Top--level programs'' describe the syntax
and semantics of libraries and top--level programs, respectively.
Chapter ``Base library'' describes a base library that defines many of
the constructs traditionally associated with Scheme.  A separate report
@cite{R6RS-libraries} describes the various @emph{standard libraries}
provided by a Scheme system.

The division between the base library and the other standard libraries
is based on use, not on construction.  In particular, some facilities
that are typically implemented as ``primitives'' by a compiler or the
run--time system rather than in terms of other standard procedures or
syntactic forms are not part of the base library, but are defined in
separate libraries.  Examples include the fixnums and flonums libraries,
the exceptions and conditions libraries, and the libraries for records.



@c page
@node lang basic variables keywords regions
@section Variables, keywords, and regions


@cindex Keyword, definition of
@cindex Definition of keyword

@cindex Variable, definition of
@cindex Definition of variable

@cindex Environment, definition of
@cindex Definition of environment

@cindex Binding constructs, definition of
@cindex Definition of binding constructs

@cindex Definitions, definition of
@cindex Definition of definitions

@cindex Region, definition of
@cindex Definition of region


Within the body of a library or top--level program, an identifier may
name a kind of syntax, or it may name a location where a value can be
stored.  An identifier that names a kind of syntax is called a
@emph{keyword}, and is said to be @emph{bound} to that kind of syntax
(or, in the case of a syntactic abstraction, a @emph{transformer} that
translates the syntax into more primitive forms).  An identifier that
names a location is called a @emph{variable} and is said to be
@emph{bound} to that location.  At each point within a top--level
program or a library, a specific, fixed set of identifiers is bound.
The set of these identifiers, the set of @emph{visible bindings}, is
known as the @emph{environment} in effect at that point.

Certain forms are used to create syntactic abstractions and to bind
keywords to transformers for those new syntactic abstractions, while
other forms create new locations and bind variables to those locations.
Collectively, these forms are called @emph{binding constructs}.  Some
binding constructs take the form of @emph{definitions}, while others are
expressions.  With the exception of exported library bindings, a binding
created by a definition is visible only within the body in which the
definition appears, e.g. the body of a library, top--level program, or
@func{lambda} expression.  Exported library bindings are also visible
within the bodies of the libraries and top--level programs that import
them.

Expressions that bind variables include the @func{lambda}, @func{let},
@func{let*}, @func{letrec}, @func{letrec*}, @func{let-values}, and
@func{let*-values} forms from the base library.  Of these, @func{lambda}
is the most fundamental.  Variable definitions appearing within the body
of such an expression, or within the bodies of a library or top--level
program, are treated as a set of @func{letrec*} bindings.  In addition,
for library bodies, the variables exported from the library can be
referenced by importing libraries and top--level programs.

Expressions that bind keywords include the @func{let-syntax} and
@func{letrec-syntax} forms.  A @func{define} form is a definition that
creates a variable binding, and a @code{define-syntax} form is a
definition that creates a keyword binding.

Scheme is a statically scoped language with block structure.  To each
place in a top--level program or library body where an identifier is
bound there corresponds a @emph{region} of code within which the binding
is visible.  The region is determined by the particular binding
construct that establishes the binding; if the binding is established by
a @func{lambda} expression, for example, then its region is the entire
@func{lambda} expression.  Every mention of an identifier refers to the
binding of the identifier that establishes the innermost of the regions
containing the use.  If a use of an identifier appears in a place where
none of the surrounding expressions contains a binding for the
identifier, the use may refer to a binding established by a definition
or import at the top of the enclosing library or top--level program.  If
there is no binding for the identifier, it is said to be @emph{unbound}.


@c page
@node lang basic exceptions
@section Exceptional situations


A variety of exceptional situations are distinguished in this report,
among them violations of syntax, violations of a procedure's
specification, violations of implementation restrictions, and
exceptional situations in the environment.  When an exceptional
situation is detected by the implementation, an @emph{exception is
raised}, which means that a special procedure called the @emph{current
exception handler} is called.  A program can also raise an exception,
and override the current exception handler; @ref{stdlib exceptions}.

When an exception is raised, an object is provided that describes the
nature of the exceptional situation.  The report uses the condition
system described in library section ``Conditions'' to describe
exceptional situations, classifying them by condition types.

Some exceptional situations allow continuing the program if the
exception handler takes appropriate action.  The corresponding
exceptions are called @emph{continuable}.  For most of the exceptional
situations described in this report, portable programs cannot rely upon
the exception being continuable at the place where the situation was
detected.  For those exceptions, the exception handler that is invoked
by the exception should not return.  In some cases, however, continuing
is permissible, and the handler may return.  @ref{stdlib exceptions}

Implementations must raise an exception when they are unable to continue
correct execution of a correct program due to some @emph{implementation
restriction}.  For example, an implementation that does not support
infinities must raise an exception with condition type
@code{&implementation-restriction} when it evaluates an expression whose
result would be an infinity.

Some possible implementation restrictions such as the lack of
representations for NaNs and infinities are anticipated by this report,
and implementations typically must raise an exception of the appropriate
condition type if they encounter such a situation.

This report uses the phrase ``an exception is raised'' synonymously with
``an exception must be raised''.  This report uses the phrase ``an
exception with condition type @var{t}'' to indicate that the object
provided with the exception is a condition object of the specified type.
The phrase ``a continuable exception is raised'' indicates an
exceptional situation that permits the exception handler to return.



@c page
@node lang basic argument checking
@section Argument checking


Many procedures specified in this report or as part of a standard
library restrict the arguments they accept.  Typically, a procedure
accepts only specific numbers and types of arguments.  Many syntactic
forms similarly restrict the values to which one or more of their
subforms can evaluate.  These restrictions imply responsibilities for
both the programmer and the implementation.  Specifically, the
programmer is responsible for ensuring that the values indeed adhere to
the restrictions described in the specification.  The implementation
must check that the restrictions in the specification are indeed met, to
the extent that it is reasonable, possible, and necessary to allow the
specified operation to complete successfully.

Note that it is not always possible for an implementation to completely
check the restrictions set forth in a specification.  For example, if an
operation is specified to accept a procedure with specific properties,
checking of these properties is undecidable in general.  Similarly, some
operations accept both lists and procedures that are called by these
operations.  Since lists can be mutated by the procedures through the
@rsixlibrary{mutable-pairs} library, an argument that is a list when the
operation starts may become a non--list during the execution of the
operation.

Also, the procedure might escape to a different continuation, preventing
the operation from performing more checks.  Requiring the operation to
check that the argument is a list after each call to such a procedure
would be impractical.  Furthermore, some operations that accept lists
only need to traverse these lists partially to perform their function;
requiring the implementation to traverse the remainder of the list to
verify that all specified restrictions have been met might violate
reasonable performance assumptions.  For these reasons, the programmer's
obligations may exceed the checking obligations of the implementation.

When an implementation detects a violation of a restriction for an
argument, it must raise an exception with condition type
@code{&assertion} in a way consistent with the safety of execution as
described in section ``Safety''.


@c page
@node lang basic syntax violations
@section Syntax violations


The subforms of a special form usually need to obey certain syntactic
restrictions.  As forms may be subject to macro expansion, which may not
terminate, the question of whether they obey the specified restrictions
is undecidable in general.

When macro expansion terminates, however, implementations must detect
violations of the syntax.  A @emph{syntax violation} is an error with
respect to the syntax of library bodies, top--level bodies, or the
``syntax'' entries in the specification of the base library or the
standard libraries.  Moreover, attempting to assign to an immutable
variable (i.e. the variables exported by a library) is also considered a
syntax violation.

If a top--level or library form in a program is not syntactically
correct, then the implementation must raise an exception with condition
type @code{&syntax}, and execution of that top--level program or library
must not be allowed to begin.


@c page
@node lang basic safety
@section Safety


The standard libraries whose exports are described by this document are
said to be @emph{safe libraries}.  Libraries and top--level programs
that import only from safe libraries are also said to be safe.

As defined by this document, the Scheme programming language is safe in
the following sense: The execution of a safe top--level program cannot
go so badly wrong as to crash or to continue to execute while behaving
in ways that are inconsistent with the semantics described in this
document, unless an exception is raised.

Violations of an implementation restriction must raise an exception with
condition type @code{&implementation-restriction}, as must all
violations and errors that would otherwise threaten system integrity in
ways that might result in execution that is inconsistent with the
semantics described in this document.

The above safety properties are guaranteed only for top--level programs
and libraries that are said to be safe.  In particular, implementations
may provide access to unsafe libraries in ways that cannot guarantee
safety.


@c page
@node lang basic boolean values
@section Boolean values


Although there is a separate boolean type, any Scheme value can be used
as a boolean value for the purpose of a conditional test.  In a
conditional test, all values count as true in such a test except for
@false{}.  This report uses the word ``true'' to refer to any Scheme
value except @false{}, and the word ``false'' to refer to @false{}.



@c page
@node lang basic multiple return values
@section Multiple return values


A Scheme expression can evaluate to an arbitrary finite number of
values.  These values are passed to the expression's continuation.

Not all continuations accept any number of values. For example, a
continuation that accepts the argument to a procedure call is guaranteed
to accept exactly one value.  The effect of passing some other number of
values to such a continuation is unspecified.  The
@func{call-with-values} procedure makes it possible to create
continuations that accept specified numbers of return values.  If the
number of return values passed to a continuation created by a call to
@func{call-with-values} is not accepted by its consumer that was passed
in that call, then an exception is raised.  A more complete description
of the number of values accepted by different continuations and the
consequences of passing an unexpected number of values is given in the
description of the @func{values} procedure.

A number of forms in the base library have sequences of expressions as
subforms that are evaluated sequentially, with the return values of all
but the last expression being discarded.  The continuations discarding
these values accept any number of values.


@c page
@node lang basic unspecified behavior
@section Unspecified behavior


If an expression is said to ``return unspecified values'', then the
expression must evaluate without raising an exception, but the values
returned depend on the implementation; this report explicitly does not
say how many or what values should be returned.  Programmers should not
rely on a specific number of return values or the specific values
themselves.



@c page
@node lang basic storage model
@section Storage model


Variables and objects such as pairs, vectors, bytevectors, strings,
hashtables, and records implicitly refer to locations or sequences of
locations.  A string, for example, contains as many locations as there
are characters in the string.  (These locations need not correspond to a
full machine word.) A new value may be stored into one of these
locations using the @func{string-set!} procedure, but the string
contains the same locations as before.

An object fetched from a location, by a variable reference or by a
procedure such as @func{car}, @func{vector-ref}, or @func{string-ref},
is equivalent in the sense of @func{eqv?} to the object last stored in
the location before the fetch.

Every location is marked to show whether it is in use.  No variable or
object ever refers to a location that is not in use.  Whenever this
report speaks of storage being allocated for a variable or object, what
is meant is that an appropriate number of locations are chosen from the
set of locations that are not in use, and the chosen locations are
marked to indicate that they are now in use before the variable or
object is made to refer to them.

It is desirable for constants (i.e. the values of literal expressions)
to reside in read-only memory.  To express this, it is convenient to
imagine that every object that refers to locations is associated with a
flag telling whether that object is mutable.  Literal constants, the
strings returned by @func{symbol->string}, records with no mutable
fields, and other values explicitly designated as immutable are
immutable objects, while all objects created by the other procedures
listed in this report are mutable.  An attempt to store a new value into
a location referred to by an immutable object should raise an exception
with condition type @code{&assertion}.



@c page
@node lang basic proper tail recursion
@section Proper tail recursion


Implementations of Scheme must be @emph{properly tail--recursive}.
Procedure calls that occur in certain syntactic contexts called
@emph{tail contexts} are @emph{tail calls}.

A Scheme implementation is properly tail--recursive if it supports an
unbounded number of active tail calls.  A call is @emph{active} if the
called procedure may still return.  Note that this includes regular
returns as well as returns through continuations captured earlier by
@func{call-with-current-continuation} that are later invoked.  In the
absence of captured continuations, calls could return at most once and
the active calls would be those that had not yet returned.  A formal
definition of proper tail recursion can be found in Clinger's paper
``Proper tail recursion and and space efficiency''.  The rules for
identifying tail calls in constructs from the @rsixlibrary{base} library
are described in section ``Tail calls and tail contexts''.



@c page
@node lang basic dynamic extent
@section Dynamic extent and the dynamic environment


@cindex Dynamic extent, definition of
@cindex Definition of dynamic extent

@cindex Dynamic environment, definition of
@cindex Definition of dynamic environment


For a procedure call, the time between when it is initiated and when it
returns is called its @emph{dynamic extent}.  In Scheme,
@func{call-with-current-continuation} allows reentering a dynamic extent
after its procedure call has returned.  Thus, the dynamic extent of a
call may not be a single, connected time period.

Some operations described in the report acquire information in addition
to their explicit arguments from the @emph{dynamic environment}.  For
example, @func{call-with-current-continuation} accesses an implicit
context established by @func{dynamic-wind}, and the @func{raise}
procedure accesses the current exception handler.

The operations that modify the dynamic environment do so dynamically,
for the dynamic extent of a call to a procedure like @func{dynamic-wind}
or @func{with-exception-handler}.  When such a call returns, the
previous dynamic environment is restored.  The dynamic environment can
be thought of as part of the dynamic extent of a call.  Consequently, it
is captured by @func{call-with-current-continuation}, and restored by
invoking the escape procedure it creates.



@c page
@node lang entry
@chapter Entry format

@ignore
In the original document, this chapter was the "entry.tex" file.
@end ignore

The chapters that describe bindings in the base library and the standard
libraries are organized into entries.  Each entry describes one language
feature or a group of related features, where a feature is either a
syntactic construct or a built--in procedure.  An entry begins with one
or more header lines of the form

@deffn Category template
@dots{}
@end deffn

The @emph{Category} defines the kind of binding described by the entry,
typically either ``Syntax'' or ``Procedure''.  An entry may specify
various restrictions on subforms or arguments.


@menu
* lang entry syntax::                Syntax entries.
* lang entry procedure::             Procedure entries.
* lang entry implementation resp::   Implementation responsibilities.
* lang entry other kinds::           Other kinds of entries.
* lang entry equivalent::            Equivalent entries.
* lang entry evaluation examples::   Evaluation examples.
* lang entry naming conventions::    Naming conventions.
@end menu


@c page
@node lang entry syntax
@section Syntax entries


If @emph{category} is ``Syntax'', the entry describes a special
syntactic construct, and the template gives the syntax of the forms of
the construct.  The template is written in a notation similar to a
right--hand side of the @acronym{BNF} rules in chapter ``Lexical syntax
and datum syntax'', and describes the set of forms equivalent to the
forms matching the template as syntactic data.  Some ``Syntax'' entries
carry a suffix (@code{expand}), specifying that the syntactic keyword of
the construct is exported with level 1.  Otherwise, the syntactic
keyword is exported with level 0; @ref{lang library import export}.

Components of the form described by a template are designated by
syntactic variables, which are written using angle brackets, for
example, @meta{expression}, @meta{variable}.  Case is insignificant in
syntactic variables.  Syntactic variables stand for other forms, or
sequences of them.  A syntactic variable may refer to a non--terminal in
the grammar for syntactic data, in which case only forms matching that
non--terminal are permissible in that position.  For example,
@meta{identifier} stands for a form which must be an identifier.  Also,
@meta{expression} stands for any form which is a syntactically valid
expression.  Other non--terminals that are used in templates are defined
as part of the specification.

The notation

@example
@hyperi{thing} ...
@end example

@noindent
indicates zero or more occurrences of a @meta{thing}, and

@example
@hyperi{thing} @hyperii{thing} ...
@end example

@noindent
indicates one or more occurrences of a @meta{thing}.

It is the programmer's responsibility to ensure that each component of a
form has the shape specified by a template.  Descriptions of syntax may
express other restrictions on the components of a form.  Typically, such
a restriction is formulated as a phrase of the form ``@meta{x} must be a
@dots{}''.  Again, these specify the programmer's responsibility.  It is
the implementation's responsibility to check that these restrictions are
satisfied, as long as the macro transformers involved in expanding the
form terminate.  If the implementation detects that a component does not
meet the restriction, an exception with condition type @code{&syntax}
is raised.


@c page
@node lang entry procedure
@section Procedure entries


If @emph{Category} is ``Procedure'', then the entry describes a
procedure, and the header line gives a template for a call to the
procedure.  Parameter names in the template are shown like this:
@var{parm}.  Thus the header line:

@deffn Procedure vector-ref @var{vector} @var{k}
@dots{}
@end deffn


@noindent
indicates that the built--in procedure @func{vector-ref} takes two
arguments, a vector @var{vector} and an exact non--negative integer
object @var{k} (see below).  The header lines:

@deffn Procedure make-vector @var{k}
@dots{}
@end deffn

@deffn Procedure make-vector @var{k} @var{fill}
@dots{}
@end deffn

@noindent
indicate that the @func{make-vector} procedure takes either one or two
arguments.  The parameter names are case--insensitive.

As with syntax templates, an ellipsis @dots{} at the end of a header
line, as in:

@deffn Procedure = @vari{z} @varii{z} @variii{z} ...
@dots{}
@end deffn

@noindent
indicates that the procedure takes arbitrarily many arguments of the
same type as specified for the last parameter name.  In this case,
@code{=} accepts two or more arguments that must all be complex number
objects.

A procedure that detects an argument that it is not specified to handle
must raise an exception with condition type @code{&assertion}.  Also,
the argument specifications are exhaustive: if the number of arguments
provided in a procedure call does not match any number of arguments
accepted by the procedure, an exception with condition type
@code{&assertion} must be raised.

For succinctness, the report follows the convention that if a parameter
name is also the name of a type, then the corresponding argument must be
of the named type.  For example, the header line for @func{vector-ref}
given above dictates that the first argument to @func{vector-ref} must
be a vector.  The following naming conventions imply type restrictions:

@table @var
@item obj
any object;

@item z
complex number object;

@item x
real number object;

@item y
real number object;

@item q
rational number object;

@item n
integer object;

@item k
exact non--negative integer object;

@item bool
boolean (@false{} or @true{});

@item octet
exact integer object in @{0, @dots{}, 255@};

@item byte
exact integer object in @{-128, @dots{}, 127@};

@item char
character;

@item pair
pair;

@item vector
vector;

@item string
string;

@item condition
condition;

@item bytevector
bytevector;

@item proc
procedure.
@end table

Other type restrictions are expressed through parameter--naming
conventions that are described in specific chapters.  For example,
library chapter ``Arithmetic'' uses a number of special parameter
variables for the various subsets of the numbers.

With the listed type restrictions, it is the programmer's responsibility
to ensure that the corresponding argument is of the specified type.  It
is the implementation's responsibility to check for that type.

A parameter called @var{list} means that it is the programmer's
responsibility to pass an argument that is a list.  It is the
implementation's responsibility to check that the argument is
appropriately structured for the operation to perform its function, to
the extent that this is possible and reasonable.  The implementation
must at least check that the argument is either an empty list or a pair.

Descriptions of procedures may express other restrictions on the
arguments of a procedure.  Typically, such a restriction is formulated
as a phrase of the form ``@var{x} must be a @dots{}'' (or otherwise
using the word ``must'').


@c page
@node lang entry implementation resp
@section Implementation responsibilities


In addition to the restrictions implied by naming conventions, an entry
may list additional explicit restrictions.  These explicit restrictions
usually describe both the programmer's responsibilities, who must ensure
that the subforms of a form are appropriate, or that an appropriate
argument is passed, and the implementation's responsibilities, which
must check that subform adheres to the specified restrictions (if macro
expansion terminates), or if the argument is appropriate.

A description may explicitly list the implementation's responsibilities
for some arguments or subforms in a paragraph labeled ``Implementation
responsibilities''.  In this case, the responsibilities specified for
these subforms or arguments in the rest of the description are only for
the programmer.  A paragraph describing implementation responsibility
does not affect the implementation's responsibilities for checking
subforms or arguments not mentioned in the paragraph.



@c page
@node lang entry other kinds
@section Other kinds of entries


If @emph{Category} is something other than ``Syntax'' and ``Procedure'',
then the entry describes a non--procedural value, and the
@emph{category} describes the type of that value.  The header line:

@deffn {Condition Type} {&who}
@dots{}
@end deffn

@noindent
indicates that @code{&who} is a condition type.  The header line:

@deffn {Auxiliary Syntax} unquote
@dots{}
@end deffn

@noindent
indicates that @func{unquote} is a syntax binding that may occur only as
part of specific surrounding expressions.  Any use as an independent
syntactic construct or identifier is a syntax violation.  As with
``Syntax'' entries, some ``Auxiliary Syntax'' entries carry a suffix
(@code{expand}), specifying that the syntactic keyword of the construct
is exported with level 1.


@c page
@node lang entry equivalent
@section Equivalent entries


The description of an entry occasionally states that it is @emph{the
same} as another entry.  This means that both entries are equivalent.
Specifically, it means that if both entries have the same name and are
thus exported from different libraries, the entries from both libraries
can be imported under the same name without conflict.


@c page
@node lang entry evaluation examples
@section Evaluation examples


The symbol @code{=>} used in program examples can be read ``evaluates
to''.  For example:

@example
(* 5 8)
=> 40
@end example

@noindent
means that the expression @code{(* 5 8)} evaluates to the object
@code{40}.  Or, more precisely: the expression given by the sequence of
characters @code{(* 5 8)} evaluates, in an environment that imports the
relevant library, to an object that may be represented externally by the
sequence of characters @code{40}.

The @code{=>} symbol is also used when the evaluation of an expression
causes a violation.  For example:

@example
(integer->char #xD800)
=> &assertion exception
@end example

@noindent
means that the evaluation of the expression @code{(integer->char
#xD800)} must raise an exception with condition type @code{&assertion}.

Moreover, the @code{=>} symbol is also used to explicitly say that the
value of an expression in unspecified.  For example:

@example
(eqv? "" "")
=> unspecified
@end example

Mostly, examples merely illustrate the behavior specified in the entry.
In some cases, however, they disambiguate otherwise ambiguous
specifications and are thus normative.  Note that, in some cases,
specifically in the case of inexact number objects, the return value is
only specified conditionally or approximately.  For example:

@example
(atan -inf.0)
=> -1.5707963267948965 ; approximately
@end example


@c page
@node lang entry naming conventions
@section Naming conventions


By convention, the names of procedures that store values into previously
allocated locations usually end in @code{!}.

By convention, @code{->} appears within the names of procedures that
take an object of one type and return an analogous object of another
type.  For example, @func{list->vector} takes a list and returns a
vector whose elements are the same as those of the list.

By convention, the names of predicates (procedures that always return a
boolean value) end in @code{?} when the name contains any letters;
otherwise, the predicate's name does not end with a question mark.

By convention, the components of compound names are separated by
@code{-}.  In particular, prefixes that are actual words or can be
pronounced as though they were actual words are followed by a hyphen,
except when the first character following the hyphen would be something
other than a letter, in which case the hyphen is omitted.  Short,
unpronounceable prefixes (@code{fx} and @code{fl}) are not followed by a
hyphen.

By convention, the names of condition types start with @code{&}.


@c page
@node lang library
@chapter Libraries


@ignore
In the original document this chapter was the "library.tex" file.
@end ignore

Libraries are parts of a program that can be distributed independently.
The library system supports macro definitions within libraries, macro
exports, and distinguishes the phases in which definitions and imports
are needed.  This chapter defines the notation for libraries and a
semantics for library expansion and execution.

@menu
* lang library form::           Library form.
* lang library import export::  Import and export levels.
* lang library files::          Library files
* lang library path::           Library search path.
* lang library names::          Mapping library names to file names.
* lang library examples::       Examples.
@end menu


@c page
@node lang library form
@section Library form


@findex library
@cindex library form, the
@cindex The library form


A library definition must have the following form:

@example
(library @meta{library name}
  (export @meta{export spec} @dots{})
  (import @meta{import spec} @dots{})
  @meta{library body})
@end example

A library declaration contains the following elements:

@itemize
@item
The @meta{library name} specifies the name of the library (possibly with
version).

@item
The @code{export} subform specifies a list of exports, which name a
subset of the bindings defined within or imported into the library.

@item
The @code{import} subform specifies the imported bindings as a list of
import dependencies, where each dependency specifies:

@itemize -
@item
the imported library's name, and, optionally, constraints on its
version,

@item
the relevant levels, e.g. expand or run time,

@item
the subset of the library's exports to make available within the
importing library, and the local names to use within the importing
library for each of the library's exports.
@end itemize

@item
The @meta{library body} is the library body, consisting of a sequence of
definitions followed by a sequence of expressions.  The definitions may
be both for local (unexported) and exported bindings, and the
expressions are initialization expressions to be evaluated for their
effects.
@end itemize

An identifier can be imported with the same local name from two or more
libraries or for two levels from the same library only if the binding
exported by each library is the same (i.e., the binding is defined in
one library, and it arrives through the imports only by exporting and
re--exporting).  Otherwise, no identifier can be imported multiple
times, defined multiple times, or both defined and imported.  No
identifiers are visible within a library except for those explicitly
imported into the library or defined within the library.

A @meta{library name} uniquely identifies a library within an
implementation, and is globally visible in the @code{import} clauses
(see below) of all other libraries within an implementation.  A
@meta{library name} has the following form:

@example
(@hyperi{identifier} @hyperii{identifier} @dots{} @meta{version})
@end example

@noindent
where @meta{version} is empty or has the following form:

@example
(@meta{sub-version} @dots{})
@end example

Each @meta{sub-version} must represent an exact nonnegative integer
object.  An empty @meta{version} is equivalent to @code{()}.

An @meta{export spec} names a set of imported and locally defined
bindings to be exported, possibly with different external names.  An
@meta{export spec} must have one of the following forms:

@example
@meta{identifier}
(rename (@hyperi{identifier} @hyperii{identifier}) @dots{})
@end example

In an @meta{export spec}, an @meta{identifier} names a single binding
defined within or imported into the library, where the external name for
the export is the same as the name of the binding within the library.  A
@func{rename} spec exports the binding named by @hyperi{identifier} in
each @code{(@hyperi{identifier} @hyperii{identifier})} pairing, using
@hyperii{identifier} as the external name.

Each @meta{import spec} specifies a set of bindings to be imported into
the library, the levels at which they are to be available, and the local
names by which they are to be known.  An @meta{import spec} must be one
of the following:

@example
@meta{import set}
(for @meta{import set} @meta{import level} @dots{})
@end example

An @meta{import level} is one of the following:

@example
run
expand
(meta @meta{level})
@end example

@noindent
where @meta{level} represents an exact integer object.

As an @meta{import level}, @code{run} is an abbreviation for @code{(meta
0)}, and @code{expand} is an abbreviation for @code{(meta 1)}.

An @meta{import set} names a set of bindings from another library and
possibly specifies local names for the imported bindings.  It must be
one of the following:

@example
@meta{library reference}
(library @meta{library reference})
(only @meta{import set} @meta{identifier} ...)
(except @meta{import set} @meta{identifier} ...)
(prefix @meta{import set} @meta{identifier})
(rename @meta{import set} (@hyperi{identifier} @hyperii{identifier}) ...)
@end example

A @meta{library reference} identifies a library by its name and
optionally by its version.  It has one of the following forms:

@example
(@hyperi{identifier} @hyperii{identifier} ...)
(@hyperi{identifier} @hyperii{identifier} ... @meta{version reference})
@end example

A @meta{library reference} whose first @meta{identifier} is @code{for},
@code{library}, @code{only}, @code{except}, @code{prefix}, or
@code{rename} is permitted only within a @code{library} @meta{import
set}.  The @meta{import set} @code{(library @meta{library reference})}
is otherwise equivalent to @meta{library reference}.

A @meta{library reference} with no @meta{version reference} (first form
above) is equivalent to a @meta{library reference} with a @meta{version
reference} of @code{()}.

A @meta{version reference} specifies a set of @meta{version}s that it
matches.  The @meta{library reference} identifies all libraries of the
same name and whose version is matched by the @meta{version reference}.
A @meta{version reference} has the following form:

@example
(@hyperi{sub-version reference} ... @hypern{sub-version reference})
(and @meta{version reference} ...)
(or @meta{version reference} @dots{})
(not @meta{version reference})
@end example

A @meta{version reference} of the first form matches a @meta{version}
with at least @var{n} elements, whose @meta{sub-version reference}s
match the corresponding @meta{sub-version}s.  An @code{and}
@hyper{version reference} matches a version if all @meta{version
references} following the @code{and} match it.  Correspondingly, an
@code{or} @meta{version reference} matches a version if one of
@meta{version references} following the @code{or} matches it, and a
@code{not} @meta{version reference} matches a version if the
@meta{version reference} following it does not match it.

A @meta{sub-version reference} has one of the following forms:

@example
@meta{sub-version}
(>= @meta{sub-version})
(<= @meta{sub-version})
(and @meta{sub-version reference} @dots{})
(or @meta{sub-version reference} @dots{})
(not @meta{sub-version reference})
@end example

A @meta{sub-version reference} of the first form matches a
@meta{sub-version} if it is equal to it.  A @code{>=} @meta{sub-version
reference} of the first form matches a sub--version if it is greater or
equal to the @meta{sub-version} following it; analogously for @code{<=}.
An @code{and} @meta{sub-version reference} matches a sub--version if all
of the subsequent @hyper{sub-version reference}s match it.

Correspondingly, an @code{or} @meta{sub-version reference} matches a
sub--version if one of the subsequent @meta{sub-version reference}s
matches it, and a @code{not} @meta{sub-version reference} matches a
sub--version if the subsequent @meta{sub-version reference} does not
match it.

Examples:

@multitable {abcdefghilmnopqrstuvz} {abcdefghi} {match?}
@headitem version reference @tab version @tab match?
@item @code{()} @tab @code{(1)} @tab yes
@item @code{(1)} @tab @code{(1)} @tab yes
@item @code{(1)} @tab @code{(2)} @tab no
@item @code{(2 3)} @tab @code{(2)} @tab no
@item @code{(2 3)} @tab @code{(2 3)} @tab yes
@item @code{(2 3)} @tab @code{(2 3 5)} @tab yes
@item @code{(or (1 (>= 1)) (2))} @tab @code{(2)} @tab yes
@item @code{(or (1 (>= 1)) (2))} @tab @code{(1 1)} @tab yes
@item @code{(or (1 (>= 1)) (2))} @tab @code{(1 0)} @tab no
@item @code{((or 1 2 3))} @tab @code{(1)} @tab yes
@item @code{((or 1 2 3))} @tab @code{(2)} @tab yes
@item @code{((or 1 2 3))} @tab @code{(3)} @tab yes
@item @code{((or 1 2 3))} @tab @code{(4)} @tab no
@end multitable

When more than one library is identified by a library reference, the
choice of libraries is determined in some implementation-dependent
manner.

To avoid problems such as incompatible types and replicated state,
implementations should prohibit the two libraries whose library names
consist of the same sequence of identifiers but whose versions do not
match to co--exist in the same program.

By default, all of an imported library's exported bindings are made
visible within an importing library using the names given to the
bindings by the imported library.  The precise set of bindings to be
imported and the names of those bindings can be adjusted with the
@code{only}, @code{except}, @code{prefix}, and @code{ rename} forms as
described below.

@itemize
@item
An @code{only} form produces a subset of the bindings from another
@meta{import set}, including only the listed @meta{identifier}s.  The
included @meta{identifier}s must be in the original @meta{import set}.

@item
An @code{except} form produces a subset of the bindings from another
@meta{import set}, including all but the listed @meta{identifier}s.  All
of the excluded @meta{identifier}s must be in the original @meta{import
set}.

@item
A @code{prefix} form adds the @meta{identifier} prefix to each name from
another @meta{import set}.

@item
A @code{rename} form:

@example
(rename (@hyperi{identifier} @hyperii{identifier}) @dots{})
@end example

@noindent
removes the bindings for @code{@hyperi{identifier} @dots{}} to form an
intermediate @meta{import set}, then adds the bindings back for the
corresponding @code{@hyperii{identifier} @dots{}} to form the final
@meta{import set}.  Each @hyperi{identifier} must be in the original
@meta{import set}, each @hyperii{identifier} must not be in the
intermediate @meta{import set}, and the @hyperii{identifier}s must be
distinct.
@end itemize

It is a syntax violation if a constraint given above is not met.

The @meta{library body} of a @code{library} form consists of forms that
are classified as @emph{definitions} or @emph{expressions}.  Which forms
belong to which class depends on the imported libraries and the result
of expansion.  Generally, forms that are not definitions are
expressions.

A @meta{library body} is like a @meta{body} except that a @meta{library
body}s need not include any expressions.  It must have the following
form:

@example
@meta{definition} @dots{} @meta{expression} @dots{}
@end example

When @func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms
occur in a top--level body prior to the first expression, they are
spliced into the body.  Some or all of the body, including portions
wrapped in @func{begin}, @func{let-syntax}, or @func{letrec-syntax}
forms, may be specified by a syntactic abstraction.

The transformer expressions and bindings are evaluated and created from
left to right, as described in chapter ``Expansion process''.  The
expressions of variable definitions are evaluated from left to right, as
if in an implicit @func{letrec*}, and the body expressions are also
evaluated from left to right after the expressions of the variable
definitions.  A fresh location is created for each exported variable and
initialized to the value of its local counterpart.  The effect of
returning twice to the continuation of the last body expression is
unspecified.

@quotation
@emph{Note:}
The names @code{library}, @code{export}, @code{import}, @code{for},
@code{run}, @code{expand}, @code{meta}, @code{import}, @code{ export},
@code{only}, @code{except}, @code{prefix}, @code{rename}, @code{and},
@code{or}, @code{not}, @code{>=}, and @code{<=} appearing in the library
syntax are part of the syntax and are not reserved, i.e., the same names
can be used for other purposes within the library or even exported from
or imported into a library with different meanings, without affecting
their use in the @code{library} form.
@end quotation

Bindings defined with a library are not visible in code outside of the
library, unless the bindings are explicitly exported from the library.
An exported macro may, however, @emph{implicitly export} an otherwise
unexported identifier defined within or imported into the library.  That
is, it may insert a reference to that identifier into the output code it
produces.

All explicitly exported variables are immutable in both the exporting
and importing libraries.  It is thus a syntax violation if an explicitly
exported variable appears on the left--hand side of a @func{set!}
expression, either in the exporting or importing libraries.

All implicitly exported variables are also immutable in both the
exporting and importing libraries.  It is thus a syntax violation if a
variable appears on the left-hand side of a @code{set!}  expression in
any code produced by an exported macro outside of the library in which
the variable is defined.  It is also a syntax violation if a reference
to an assigned variable appears in any code produced by an exported
macro outside of the library in which the variable is defined, where an
assigned variable is one that appears on the left--hand side of a
@func{set!} expression in the exporting library.

All other variables defined within a library are mutable.


@c page
@node lang library import export
@section Import and export levels


Expanding a library may require run--time information from another
library.  For example, if a macro transformer calls a procedure from
library @emph{A}, then the library @emph{A} must be instantiated before
expanding any use of the macro in library @emph{B}.  Library @emph{A}
may not be needed when library @emph{B} is eventually run as part of a
program, or it may be needed for run time of library @emph{B}, too.  The
library mechanism distinguishes these times by phases, which are
explained in this section.

Every library can be characterized by expand--time information
(minimally, its imported libraries, a list of the exported keywords, a
list of the exported variables, and code to evaluate the transformer
expressions) and run--time information (minimally, code to evaluate the
variable definition right--hand--side expressions, and code to evaluate
the body expressions).  The expand--time information must be available
to expand references to any exported binding, and the run--time
information must be available to evaluate references to any exported
variable binding.

A @emph{phase} is a time at which the expressions within a library are
evaluated.  Within a library body, top--level expressions and the
right--hand sides of @func{define} forms are evaluated at run time,
i.e. phase @emph{0}, and the right--hand sides of @func{define-syntax}
forms are evaluated at expand time, i.e. phase @emph{1}.  When
@func{define-syntax}, @func{let-syntax}, or @func{letrec-syntax} forms
appear within code evaluated at phase @emph{n}, the right--hand sides
are evaluated at phase @emph{n+1}.

These phases are relative to the phase in which the library itself is
used.  An @emph{instance} of a library corresponds to an evaluation of
its variable definitions and expressions in a particular phase relative
to another library---a process called @emph{instantiation}.  For
example, if a top--level expression in a library @emph{B} refers to a
variable export from another library @emph{A}, then it refers to the
export from an instance of @emph{A} at phase @emph{0} (relative to the
phase of @emph{B}).  But if a phase @emph{1} expression within @emph{B}
refers to the same binding from @emph{A}, then it refers to the export
from an instance of @emph{A} at phase @emph{1} (relative to the phase of
@emph{B}).

A @emph{visit} of a library corresponds to the evaluation of its syntax
definitions in a particular phase relative to another library; a process
called @emph{visiting}.  For example, if a top--level expression in a
library @emph{B} refers to a macro export from another library @emph{A},
then it refers to the export from a visit of @emph{A} at phase @emph{0}
(relative to the phase of @emph{B}), which corresponds to the evaluation
of the macro's transformer expression at phase @emph{1}.

A @emph{level} is a lexical property of an identifier that determines in
which phases it can be referenced.  The level for each identifier bound
by a definition within a library is @emph{0}; that is, the identifier
can be referenced only at phase @emph{0} within the library.  The level
for each imported binding is determined by the enclosing @code{for} form
of the @code{import} in the importing library, in addition to the levels
of the identifier in the exporting library.  Import and export levels
are combined by pairwise addition of all level combinations.  For
example, references to an imported identifier exported for levels
@emph{p_a} and @emph{p_b} and imported for levels @emph{q_a},
@emph{q_b}, and @emph{q_c} are valid at levels @emph{p_a + q_a},
@emph{p_a + q_b}, @emph{p_a + q_c}, @emph{p_b + q_a}, @emph{p_b + q_b},
and @emph{p_b + q_c}.  An @meta{import set} without an enclosing
@code{for} is equivalent to @code{(for @meta{import set} run)}, which is
the same as @code{(for @meta{import set} (meta 0))}.

The export level of an exported binding is @emph{0} for all bindings
that are defined within the exporting library.  The export levels of a
reexported binding, i.e. an export imported from another library, are
the same as the effective import levels of that binding within the
reexporting library.

For the libraries defined in the library report, the export level is
@emph{0} for nearly all bindings.  The exceptions are
@func{syntax-rules}, @func{identifier-syntax}, @code{...}, and @code{_}
from the @rsixlibrary{base} library, which are exported with level
@emph{1}, @func{set!} from the @rsixlibrary{base} library, which is
exported with levels @emph{0} and @emph{1}, and all bindings from the
composite @code{(rnrs (6))} library, which are exported with levels
@emph{0} and @emph{1}.

Macro expansion within a library can introduce a reference to an
identifier that is not explicitly imported into the library.  In that
case, the phase of the reference must match the identifier's level as
shifted by the difference between the phase of the source library (i.e.,
the library that supplied the identifier's lexical context) and the
library that encloses the reference.  For example, suppose that
expanding a library invokes a macro transformer, and the evaluation of
the macro transformer refers to an identifier that is exported from
another library (so the phase @emph{1} instance of the library is used);
suppose further that the value of the binding is a syntax object
representing an identifier with only a level @emph{n} binding; then, the
identifier must be used only at phase @emph{n+1} in the library being
expanded.  This combination of levels and phases is why negative levels
on identifiers can be useful, even though libraries exist only at
non--negative phases.

If any of a library's definitions are referenced at phase @emph{0} in
the expanded form of a program, then an instance of the referenced
library is created for phase @emph{0} before the program's definitions
and expressions are evaluated.  This rule applies transitively: if the
expanded form of one library references at phase @emph{0} an identifier
from another library, then before the referencing library is
instantiated at phase @emph{n}, the referenced library must be
instantiated at phase @emph{n}.  When an identifier is referenced at any
phase @emph{n} greater than @emph{0}, in contrast, then the defining
library is instantiated at phase @emph{n} at some unspecified time
before the reference is evaluated.  Similarly, when a macro keyword is
referenced at phase @emph{n} during the expansion of a library, then the
defining library is visited at phase @emph{n} at some unspecified time
before the reference is evaluated.

An implementation may distinguish instances/visits of a library for
different phases or to use an instance/visit at any phase as an
instance/visit at any other phase.  An implementation may further expand
each @code{library} form with distinct visits of libraries in any phase
and/or instances of libraries in phases above @emph{0}.  An
implementation may create instances/visits of more libraries at more
phases than required to satisfy references.  When an identifier appears
as an expression in a phase that is inconsistent with the identifier's
level, then an implementation may raise an exception either at expand
time or run time, or it may allow the reference.  Thus, a library whose
meaning depends on whether the instances of a library are distinguished
or shared across phases or @code{library} expansions may be unportable.



@c page
@node lang library files
@section Library files


@noindent
The contributed libraries are installed in the system when Ikarus is
installed.  By default, running the @command{configure} script installs
the contributed libraries into the @file{/usr/local/lib/ikarus}
directory.  If a @code{--prefix=DIR} argument was supplied to
@command{configure}, then the libraries are installed in the
@file{DIR/ikarus/lib} directory.

We may install additional libraries into the Ikarus library directory.
Doing so makes them available for @func{import} into other libraries and
script regardless of where the importing code is located or the current
directory in which it is executed.


@c page
@node lang library path
@section Library search path


@cindex @env{IKARUS_LIBRARY_PATH}
@cindex Search path for libraries
@cindex Libraries search path


@noindent
There may be situations in which we may wish to install our own
libraries into a different location.  For example, we may not have
sufficient administrative privileges to write to the system directory,
or we may wish to keep our own libraries separated from the standard
libraries.  Whatever the reason is, we can store our library files in
any location we want and set up the @env{IKARUS_LIBRARY_PATH}
environment variable to point to these locations.  The value of
@env{IKARUS_LIBRARY_PATH} is a colon--separated list of directories in
which Ikarus will search.

For example, suppose our script imports the @code{(streams derived)}
library.  Suppose that Ikarus was installed under @file{/usr/local}, and
that @env{IKARUS_LIBRARY_PATH} is set to:

@example
/home/john/ikarus-libraries:/home/john/srfis
@end example

First, Ikarus will map the library name to the file path
@file{streams/derived.ss}; then it will search in the following
locations, in sequence, until it finds the file it is looking for:

@example
./streams/derived.ss
/home/john/ikarus-libraries/streams/derived.ss
/home/john/srfis/streams/derived.ss
/usr/local/lib/ikarus/streams/derived.ss
@end example

@quotation
@emph{Warning:} The current behavior of Ikarus regarding the
@env{IKARUS_LIBRARY_PATH} is preliminary and is likely to change in
future releases.
@end quotation

The method in which the value of @env{IKARUS_LIBRARY_PATH} is defined is
typically shell dependant.  If we use @gnu{} Bash, we typically set the
values of environment variables in the @file{~/.bash_profile} or
@file{~/.bashrc} file by adding the following lines:

@example
IKARUS_LIBRARY_PATH=/path/to/some/directory:/and/another
export IKARUS_LIBRARY_PATH
@end example


@defun library-path
Return a list of strings representing the search path for libraries.
Example, from a Unix shell prompt:

@example
$ echo '(write (library-path))' | ikarus
...
> ("." "/usr/local/lib/ikarus")

$ echo '(write (library-path))' | \
IKARUS_LIBRARY_PATH=/usr/lib/ikarus ikarus
...
> ("." "/usr/lib/ikarus" "/usr/local/lib/ikarus")
@end example

@noindent
so it is possible to inspect the directories.

@unstable{1661}
@end defun



@c page
@node lang library names
@section Mapping library names to file names


@ignore
Try to use the word 'path' to indicate a list of directories in which to
search for a file, and the word 'pathname' to indicate a specific file
or directory string identifier.
@end ignore


@noindent
The name of an @rnrs{6} library consists of a non--empty list of
identifiers (symbols), followed by an optional version number.  All of
the standard @rnrs{6} libraries are built into Ikarus, thus importing
any one of them does not require any special action other than listing
the library name in the @func{import} part of a library or a script.
The same holds for the @library{ikarus} library.

When importing a user library, Ikarus uses a simple mechanism to map
library names to file names.  A library name is converted to a file
pathname by joining the library identifiers with a pathname separator,
e.g. @code{/}.

@multitable {`(foo bar baz)'} {File name}
@headitem Library Name @tab File name
@item @code{(foo)} @tab @code{foo}
@item @code{(foo bar)} @tab @file{foo/bar}
@item @code{(foo bar baz)} @tab @file{foo/bar/baz}
@end multitable

Having mapped a library name to a file pathname, Ikarus attempts to
locate that file in one of several locations.  The locations attempted
depend on two settings: the search path and the file suffix set (e.g.,
@code{.sls}, @code{.ss}, @code{.scm}, etc.).

First, Ikarus attempts to locate the file in the current working
directory from which Ikarus was invoked.  In the current working
directory, Ikarus enumerates all the file suffixes before searching
other locations.  If the file is not found in the current directory,
Ikarus tries to find it in the Ikarus library directory.  The Ikarus
library directory is determined when Ikarus is installed (based on the
@option{--prefix} argument that was passed to the @command{configure}
script).  If Ikarus fails to locate the library file, it raises an
exception and exits.  @ref{contrib libraries} for more details about the
library locations.

@quotation
@emph{Tip:} Use simple library names for the libraries that you define.
Library names that contain non--printable characters, complex
punctuations, or Unicode may pose a challenge for some operating
systems.  If Ikarus cannot find a library, it will raise an error
listing the locations in which it looked, helping you move the library
file to a place where Ikarus can find it.
@end quotation


@defun library-extensions
Return a list of strings representing the extensions added to a library
name when resolving a library specification.

@unstable{1661}
@end defun



@c page
@node lang library examples
@section Examples


Examples for various @meta{import spec}s and @meta{export spec}s:

@example
(library (stack)
  (export make push! pop! empty!)
  (import (rnrs)
          (rnrs mutable-pairs))

  (define (make)
    (list '()))
  (define (push! s v)
    (set-car! s (cons v (car s))))
  (define (pop! s)
    (let ([v (caar s)])
      (set-car! s (cdar s))
      v))
  (define (empty! s)
    (set-car! s '())))

(library (balloons)
  (export make push pop)
  (import (rnrs))

  (define (make w h)
    (cons w h))
  (define (push b amt)
    (cons (- (car b) amt)
          (+ (cdr b) amt)))
  (define (pop b)
    (display "Boom! ")
    (display (* (car b) (cdr b)))
    (newline)))

(library (party)
  ;; Total exports:
  ;; make, push, push!, make-party, pop!
  (export (rename (balloon:make make)
                  (balloon:push push))
          push!
          make-party
          (rename (party-pop! pop!)))
  (import (rnrs)
          (only (stack) make push! pop!) ; not empty!
          (prefix (balloons) balloon:))

  ;; Creates a party as a stack of balloons,
  ;; starting with two balloons
  (define (make-party)
    (let ([s (make)]) ; from stack
      (push! s (balloon:make 10 10))
      (push! s (balloon:make 12 9))
      s))
  (define (party-pop! p)
    (balloon:pop (pop! p))))


(library (main)
  (export)
  (import (rnrs) (party))

  (define p (make-party))
  (pop! p)        ; displays "Boom! 108"
  (push! p (push (make 5 5) 1))
  (pop! p))       ; displays "Boom! 24"
@end example

Examples for macros and phases:

@example
(library (my-helpers id-stuff)
  (export find-dup)
  (import (rnrs))

  (define (find-dup l)
    (and (pair? l)
         (let loop ((rest (cdr l)))
           (cond
            [(null? rest) (find-dup (cdr l))]
            [(bound-identifier=? (car l) (car rest))
             (car rest)]
            [else (loop (cdr rest))])))))

(library (my-helpers values-stuff)
  (export mvlet)
  (import (rnrs) (for (my-helpers id-stuff) expand))

  (define-syntax mvlet
    (lambda (stx)
      (syntax-case stx ()
        [(_ [(id ...) expr] body0 body ...)
         (not (find-dup (syntax (id ...))))
         (syntax
           (call-with-values
               (lambda () expr)
             (lambda (id ...) body0 body ...)))]))))

(library (let-div)
  (export let-div)
  (import (rnrs)
          (my-helpers values-stuff)
          (rnrs r5rs))

  (define (quotient+remainder n d)
    (let ([q (quotient n d)])
      (values q (- n (* q d)))))
  (define-syntax let-div
    (syntax-rules ()
      [(_ n d (q r) body0 body ...)
       (mvlet [(q r) (quotient+remainder n d)]
         body0 body ...)])))
@end example



@c page
@node lang programs
@chapter Top--level programs


@ignore
In the original document this chapter is the "programs.tex" file.
@end ignore


A ``top--level program'' specifies an entry point for defining and
running a Scheme program.  A top--level program specifies a set of
libraries to import and code to run.  Through the imported libraries,
whether directly or through the transitive closure of importing, a
top--level program defines a complete Scheme program.


@menu
* lang programs syntax::        Top-level program syntax.
* lang programs semantics::     Top-level program semantics.
@end menu


@c page
@node lang programs syntax
@section Top--level program syntax


A top--level program is a delimited piece of text, typically a file,
that has the following form:

@example
@meta{import form} @hyper{top-level body}
@end example

An @meta{import form} has the following form:

@example
(import @meta{import spec} @dots{})
@end example

A @meta{top-level body} has the following form:

@example
@meta{top-level body form} @dots{}
@end example

A @meta{top-level body form} is either a @hyper{definition} or an
@meta{expression}.

The @meta{import form} is identical to the import clause in libraries,
and specifies a set of libraries to import.  A @meta{top-level body} is
like a @meta{library body}, except that definitions and expressions may
occur in any order.  Thus, the syntax specified by @meta{top-level body
form} refers to the result of macro expansion.

When uses of @func{begin}, @func{let-syntax}, or @func{letrec-syntax}
from the @rsixlibrary{base} library occur in a top--level body prior to
the first expression, they are spliced into the body.  Some or all of
the body, including portions wrapped in @func{begin}, @func{let-syntax},
or @func{letrec-syntax} forms, may be specified by a syntactic
abstraction.

@c ------------------------------------------------------------


@c page
@node lang programs semantics
@section Top--level program semantics


A top--level program is executed by treating the program similarly to a
library, and evaluating its definitions and expressions.  The semantics
of a top--level body may be roughly explained by a simple translation
into a library body: Each @meta{expression} that appears before a
definition in the top-level body is converted into a dummy definition

@example
(define @meta{variable}
  (begin @meta{expression} @meta{unspecified}))
@end example

where @meta{variable} is a fresh identifier and @meta{unspecified} is a
side--effect--free expression returning an unspecified value.  (It is
generally impossible to determine which forms are definitions and
expressions without concurrently expanding the body, so the actual
translation is somewhat more complicated.)

On platforms that support it, a top--level program may access its
command line by calling the @func{command-line} procedure (@ref{stdlib
programlib}).



@c page
@node lang syntax
@chapter Primitive syntax


@ignore
In the original document this chapter is the "syntax.tex" file.
@end ignore

After the @code{import} form within a @code{library} form or a
top--level program, the forms that constitute the body of the library or
the top--level program depend on the libraries that are imported.  In
particular, imported syntactic keywords determine the available
syntactic abstractions and whether each form is a definition or
expression.  A few form types are always available independent of
imported libraries, however, including constant literals, variable
references, procedure calls, and macro uses.

@menu
* lang syntax primitive::       Primitive expression types.
* lang syntax macros::          Macros.
@end menu



@c page
@node lang syntax primitive
@section Primitive expression types


The entries in this section all describe expressions, which may occur in
the place of @meta{expression} syntactic variables.


@subsubheading Constant literals

@deffn Syntax @meta{number}
@deffnx Syntax @meta{boolean}
@deffnx Syntax @meta{character}
@deffnx Syntax @meta{string}
@deffnx Syntax @meta{bytevector}
An expression consisting of a representation of a number object, a
boolean, a character, a string, or a bytevector, evaluates ``to
itself''.

@example
145932          =>  145932
#t              =>  #t
"abc"           =>  "abc"
#vu8(2 24 123)  => #vu8(2 24 123)
@end example

As noted in section ``Storage model'', the value of a literal expression
is immutable.
@end deffn

@c ------------------------------------------------------------

@subsubheading Variable references

@deffn Syntax @meta{variable}
An expression consisting of a variable is a variable reference if it is
not a macro use (see below).  The value of the variable reference is the
value stored in the location to which the variable is bound.  It is a
syntax violation to reference an unbound variable.

The following example examples assumes the base library has been
imported:

@example
(define x 28)
x   =>  28
@end example
@end deffn

@c ------------------------------------------------------------

@subsubheading Procedure calls

@deffn Syntax (@meta{operator} @hyperi{operand} @dots{})
A procedure call consists of expressions for the procedure to be called
and the arguments to be passed to it, with enclosing parentheses.  A
form in an expression context is a procedure call if @meta{operator} is
not an identifier bound as a syntactic keyword.

When a procedure call is evaluated, the operator and operand expressions
are evaluated (in an unspecified order) and the resulting procedure is
passed the resulting arguments.

The following examples assume the @rsixlibrary{base} library has been
imported:

@example
(+ 3 4)                 =>  7
((if #f + *) 3 4)       =>  12
@end example

If the value of @meta{operator} is not a procedure, an exception with
condition type @code{&assertion} is raised.  Also, if @meta{operator}
does not accept as many arguments as there are @meta{operand}s, an
exception with condition type @code{&assertion} is raised.

@quotation
@emph{Note:} In contrast to other dialects of Lisp, the order of
evaluation is unspecified, and the operator expression and the operand
expressions are always evaluated with the same evaluation rules.

Although the order of evaluation is otherwise unspecified, the effect of
any concurrent evaluation of the operator and operand expressions is
constrained to be consistent with some sequential order of evaluation.
The order of evaluation may be chosen differently for each procedure
call.
@end quotation

@quotation
@emph{Note:} In many dialects of Lisp, the form @code{()} is a
legitimate expression.  In Scheme, expressions written as list/pair
forms must have at least one subexpression, so @code{()} is not a
syntactically valid expression.
@end quotation
@end deffn



@c page
@node lang syntax macros
@section Macros


@cindex Transformer, definition of
@cindex Definition of transformer
@cindex Macro transformer, definition of
@cindex Definition of macro transformer


Libraries and top--level programs can define and use new kinds of
derived expressions and definitions called @emph{syntactic abstractions}
or @emph{macros}.  A syntactic abstraction is created by binding a
keyword to a @emph{macro transformer} or, simply, @emph{transformer}.

The transformer determines how a use of the macro (called a @emph{macro
use}) is transcribed into a more primitive form.

Most macro uses have the form:

@example
(@meta{keyword} @meta{datum} @dots{})
@end example

@noindent
where @meta{keyword} is an identifier that uniquely determines the kind
of form.  This identifier is called the @emph{syntactic keyword}, or
simply @emph{keyword}.  The number of @meta{datum}s and the syntax of
each depends on the syntactic abstraction.

Macro uses can also take the form of improper lists, singleton
identifiers, or @func{set!} forms, where the second subform of the
@func{set!} is the keyword:

@example
(@meta{keyword} @meta{datum} @dots{} . @meta{datum})
@meta{keyword}
(set! @meta{keyword} @meta{datum})
@end example

The @func{define-syntax}, @func{let-syntax} and @func{letrec-syntax}
forms create bindings for keywords, associate them with macro
transformers, and control the scope within which they are visible.

The @func{syntax-rules} and @func{identifier-syntax} forms create
transformers via a pattern language.  Moreover, the @func{syntax-case}
form allows creating transformers via arbitrary Scheme code.

Keywords occupy the same name space as variables.  That is, within the
same scope, an identifier can be bound as a variable or keyword, or
neither, but not both, and local bindings of either kind may shadow
other bindings of either kind.

Macros defined using @func{syntax-rules} and @func{identifier-syntax}
are ``hygienic'' and ``referentially transparent'' and thus preserve
Scheme's lexical scoping.

@itemize
@item
If a macro transformer inserts a binding for an identifier (variable or
keyword) not appearing in the macro use, the identifier is in effect
renamed throughout its scope to avoid conflicts with other identifiers.

@item
If a macro transformer inserts a free reference to an identifier, the
reference refers to the binding that was visible where the transformer
was specified, regardless of any local bindings that may surround the
use of the macro.
@end itemize

Macros defined using the @func{syntax-case} facility are also hygienic
unless @func{datum->syntax} is used.



@c page
@node lang expansion
@chapter Expansion process


@ignore
In the original document this chapter is the file "expansion.tex".
@end ignore


Macro uses are expanded into @emph{core forms} at the start of
evaluation (before compilation or interpretation) by a syntax
@emph{expander}.  The set of core forms is implementation--dependent, as
is the representation of these forms in the expander's output.  If the
expander encounters a syntactic abstraction, it invokes the associated
transformer to expand the syntactic abstraction, then repeats the
expansion process for the form returned by the transformer.  If the
expander encounters a core form, it recursively processes its subforms
that are in expression or definition context, if any, and reconstructs
the form from the expanded subforms.  Information about identifier
bindings is maintained during expansion to enforce lexical scoping for
variables and keywords.

To handle definitions, the expander processes the initial forms in a
@meta{body} or @meta{library body} from left to right.  How the expander
processes each form encountered depends upon the kind of form.

@table @asis
@item macro use
The expander invokes the associated transformer to transform the macro
use, then recursively performs whichever of these actions are
appropriate for the resulting form.

@item @func{define-syntax} form
The expander expands and evaluates the right--hand--side expression and
binds the keyword to the resulting transformer.

@item @func{define} form
The expander records the fact that the defined identifier is a variable
but defers expansion of the right--hand--side expression until after all
of the definitions have been processed.

@item @func{begin} form
The expander splices the subforms into the list of body forms it is
processing.

@item @func{let-syntax} or @func{letrec-syntax} form
The expander splices the inner body forms into the list of (outer) body
forms it is processing, arranging for the keywords bound by the
@func{let-syntax} and @func{letrec-syntax} to be visible only in the
inner body forms.

@item expression, i.e., nondefinition
The expander completes the expansion of the deferred right--hand--side
expressions and the current and remaining expressions in the body, and
then creates the equivalent of a @func{letrec*} form from the defined
variables, expanded right--hand--side expressions, and expanded body
expressions.
@end table

For the right--hand side of the definition of a variable, expansion is
deferred until after all of the definitions have been seen.
Consequently, each keyword and variable reference within the right--hand
side resolves to the local binding, if any.

A definition in the sequence of forms must not define any identifier
whose binding is used to determine the meaning of the undeferred
portions of the definition or any definition that precedes it in the
sequence of forms.  For example, the bodies of the following expressions
violate this restriction.

@example
(let ()
  (define define 17)
  (list define))

(let-syntax ([def0 (syntax-rules ()
                     [(_ x) (define x 0)])])
  (let ([z 3])
    (def0 z)
    (define def0 list)
    (list z)))

(let ()
  (define-syntax foo
    (lambda (e)
      (+ 1 2)))
  (define + 2)
  (foo))%
@end example

The following do not violate the restriction.

@example
(let ([x 5])
  (define lambda list)
  (lambda x x))         =>  (5 5)

(let-syntax ([def0 (syntax-rules ()
                     [(_ x) (define x 0)])])
  (let ([z 3])
    (define def0 list)
    (def0 z)
    (list z)))          =>  (3)

(let ()
  (define-syntax foo
    (lambda (e)
      (let ([+ -]) (+ 1 2))))
  (define + 2)
  (foo))                =>  -1%
@end example

The implementation should treat a violation of the restriction as a
syntax violation.

Note that this algorithm does not directly reprocess any form.  It
requires a single left--to--right pass over the definitions followed by
a single pass (in any order) over the body expressions and deferred
right--hand sides.

Example:

@example
(lambda (x)
  (define-syntax defun
    (syntax-rules ()
      [(_ x a e) (define x (lambda a e))]))
  (defun even? (n) (or (= n 0) (odd? (- n 1))))
  (define-syntax odd?
    (syntax-rules () [(_ n) (not (even? n))]))
  (odd? (if (odd? x) (* x x) x)))
@end example

In the example:

@enumerate
@item
The definition of @func{defun} is encountered first, and the keyword
@func{defun} is associated with the transformer resulting from the
expansion and evaluation of the corresponding right--hand side.

@item
A use of @func{defun} is encountered next and expands into a
@func{define} form.  Expansion of the right--hand side of this
@func{define} form is deferred.

@item
The definition of @func{odd?} is next and results in the association of
the keyword @func{odd?} with the transformer resulting from expanding
and evaluating the corresponding right--hand side.

@item
A use of @func{odd?}  appears next and is expanded; the resulting call
to @func{not} is recognized as an expression because @func{not} is bound
as a variable.

@item
At this point, the expander completes the expansion of the current
expression (the call to @func{not}) and the deferred right--hand side of
the @func{even?}  definition; the uses of @func{odd?} appearing in these
expressions are expanded using the transformer associated with the
keyword @func{odd?}.

@item
The final output is the equivalent of:

@example
(lambda (x)
  (letrec* ([even?
              (lambda (n)
                (or (= n 0)
                    (not (even? (- n 1)))))])
    (not (even? (if (not (even? x)) (* x x) x)))))
@end example

@noindent
although the structure of the output is implementation-dependent.
@end enumerate

Because definitions and expressions can be interleaved in a
@meta{top-level body}, the expander's processing of a @meta{top-level
body} is somewhat more complicated.  It behaves as described above for a
@meta{body} or @meta{library body} with the following exceptions:

@itemize
@item
When the expander finds a nondefinition, it defers its expansion and
continues scanning for definitions.

@item
Once it reaches the end of the set of forms, it processes the deferred
right--hand--side and body expressions, then generates the equivalent of
a @func{letrec*} form from the defined variables, expanded
right--hand--side expressions, and expanded body expressions.

@item
For each body expression @meta{expression} that appears before a
variable definition in the body, a dummy binding is created at the
corresponding place within the set of @func{letrec*} bindings, with a
fresh temporary variable on the left--hand side and the equivalent of:

@example
(begin @meta{expression} @meta{unspecified})
@end example

@noindent
where @meta{unspecified} is a side--effect--free expression returning an
unspecified value, on the right--hand side, so that left--to--right
evaluation order is preserved.  The @func{begin} wrapper allows
@meta{expression} to evaluate to an arbitrary number of values.
@end itemize



@c page
@node lang derived
@chapter Sample definitions for derived forms


@ignore
In the original document this appendix is the file "derived.tex".
@end ignore


This appendix contains sample definitions for some of the keywords
described in this report in terms of simpler forms:


@c ------------------------------------------------------------

@subsubheading @func{cond}

The @func{cond} keyword could be defined in terms of @func{if},
@func{let} and @func{begin} using @func{syntax-rules} as follows:

@example
(define-syntax cond
  (syntax-rules (else =>)
    ((cond (else result1 result2 ...))
     (begin result1 result2 ...))
    ((cond (test => result))
     (let ((temp test))
       (if temp (result temp))))
    ((cond (test => result) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           (result temp)
           (cond clause1 clause2 ...))))
    ((cond (test)) test)
    ((cond (test) clause1 clause2 ...)
     (let ((temp test))
       (if temp
           temp
           (cond clause1 clause2 ...))))
    ((cond (test result1 result2 ...))
     (if test (begin result1 result2 ...)))
    ((cond (test result1 result2 ...)
           clause1 clause2 ...)
     (if test
         (begin result1 result2 ...)
         (cond clause1 clause2 ...)))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{case}

The @func{case} keyword could be defined in terms of @func{let},
@func{cond}, and @func{memv} using @code{syntax-rules} as follows:

@example
(define-syntax case
  (syntax-rules (else)
    ((case expr0
       ((key ...) res1 res2 ...)
       ...
       (else else-res1 else-res2 ...))
     (let ((tmp expr0))
       (cond
         ((memv tmp '(key ...)) res1 res2 ...)
         ...
         (else else-res1 else-res2 ...))))
    ((case expr0
       ((keya ...) res1a res2a ...)
       ((keyb ...) res1b res2b ...)
       ...)
     (let ((tmp expr0))
       (cond
         ((memv tmp '(keya ...)) res1a res2a ...)
         ((memv tmp '(keyb ...)) res1b res2b ...)
         ...)))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{let*}

The @func{let*} keyword could be defined in terms of @func{let} using
@func{syntax-rules} as follows:

@example
(define-syntax let*
  (syntax-rules ()
    ((let* () body1 body2 ...)
     (let () body1 body2 ...))
    ((let* ((name1 expr1) (name2 expr2) ...)
       body1 body2 ...)
     (let ((name1 expr1))
       (let* ((name2 expr2) ...)
         body1 body2 ...)))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{letrec}

The @func{letrec} keyword could be defined approximately in terms of
@func{let} and @func{set!} using @func{syntax-rules}, using a helper to
generate the temporary variables needed to hold the values before the
assignments are made, as follows:

@example
(define-syntax letrec
  (syntax-rules ()
    ((letrec () body1 body2 ...)
     (let () body1 body2 ...))
    ((letrec ((var init) ...) body1 body2 ...)
     (letrec-helper
       (var ...)
       ()
       ((var init) ...)
       body1 body2 ...))))

(define-syntax letrec-helper
  (syntax-rules ()
    ((letrec-helper
       ()
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (let ((var <undefined>) ...)
       (let ((temp init) ...)
         (set! var temp)
         ...)
       (let () body1 body2 ...)))
    ((letrec-helper
       (x y ...)
       (temp ...)
       ((var init) ...)
       body1 body2 ...)
     (letrec-helper
       (y ...)
       (newtemp temp ...)
       ((var init) ...)
       body1 body2 ...))))
@end example

The syntax @code{<undefined>} represents an expression that returns
something that, when stored in a location, causes an exception with
condition type @code{&assertion} to be raised if an attempt to read from
or write to the location occurs before the assignments generated by the
@func{letrec} transformation take place.  (No such expression is defined
in Scheme.)

@c ------------------------------------------------------------

@subsubheading @func{letrec*}

The @func{letrec*} keyword could be defined approximately in terms of
@func{let} and @func{set!} using @func{syntax-rules} as follows:

@example
(define-syntax letrec*
  (syntax-rules ()
    ((letrec* ((var1 init1) ...) body1 body2 ...)
     (let ((var1 <undefined>) ...)
       (set! var1 init1)
       ...
       (let () body1 body2 ...)))))
@end example

The syntax @code{<undefined>} is as in the definition of @func{letrec}
above.

@c ------------------------------------------------------------

@subsubheading @func{let-values}

The following definition of @func{let-values} using @func{syntax-rules}
employs a pair of helpers to create temporary names for the formals.

@example
(define-syntax let-values
  (syntax-rules ()
    ((let-values (binding ...) body1 body2 ...)
     (let-values-helper1
       ()
       (binding ...)
       body1 body2 ...))))

(define-syntax let-values-helper1
  ;; map over the bindings
  (syntax-rules ()
    ((let-values
       ((id temp) ...)
       ()
       body1 body2 ...)
     (let ((id temp) ...) body1 body2 ...))
    ((let-values
       assocs
       ((formals1 expr1) (formals2 expr2) ...)
       body1 body2 ...)
     (let-values-helper2
       formals1
       ()
       expr1
       assocs
       ((formals2 expr2) ...)
       body1 body2 ...))))

(define-syntax let-values-helper2
  ;; create temporaries for the formals
  (syntax-rules ()
    ((let-values-helper2
       ()
       temp-formals
       expr1
       assocs
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda temp-formals
         (let-values-helper1
           assocs
           bindings
           body1 body2 ...))))
    ((let-values-helper2
       (first . rest)
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (let-values-helper2
       rest
       (temp ... newtemp)
       expr1
       (assoc ... (first newtemp))
       bindings
       body1 body2 ...))
    ((let-values-helper2
       rest-formal
       (temp ...)
       expr1
       (assoc ...)
       bindings
       body1 body2 ...)
     (call-with-values
       (lambda () expr1)
       (lambda (temp ... . newtemp)
         (let-values-helper1
           (assoc ... (rest-formal newtemp))
           bindings
           body1 body2 ...))))))
@end example

@c ------------------------------------------------------------

@subsubheading @func{let*-values}

The following macro defines @func{let*-values} in terms of @func{let}
and @func{let-values} using @func{syntax-rules}:

@example
(define-syntax let*-values
  (syntax-rules ()
    ((let*-values () body1 body2 ...)
     (let () body1 body2 ...))
    ((let*-values (binding1 binding2 ...)
       body1 body2 ...)
     (let-values (binding1)
       (let*-values (binding2 ...)
         body1 body2 ...)))))
@end example


@c ------------------------------------------------------------

@subsubheading @func{let}

The @func{let} keyword could be defined in terms of @func{lambda} and
@func{letrec} using @func{syntax-rules} as follows:

@example
(define-syntax @func{let}
  (syntax-rules ()
    ((let ((name val) ...) body1 body2 ...)
     ((lambda (name ...) body1 body2 ...)
      val ...))
    ((let tag ((name val) ...) body1 body2 ...)
     ((letrec ((tag (lambda (name ...)
                      body1 body2 ...)))
        tag)
      val ...))))
@end example


@c page
@c ------------------------------------------------------------
@c End of lowered sections from the R6RS document.
@c ------------------------------------------------------------

@raisesections


@c page
@node baselib
@chapter Base library


@ignore
In the original document this chapter is the "base.tex" file.
@end ignore

This chapter describes Scheme's @rsixlibrary{base} library, which
exports many of the procedure and syntax bindings that are traditionally
associated with Scheme.


@menu
* baselib types::               Base types.
* baselib definitions::         Definitions.
* baselib bodies::              Bodies.
* baselib expressions::         Expressions.
* baselib predicates::          Equivalence and procedure predicates.
* baselib math::                Mathematics.
* baselib booleans::            Booleans.
* baselib lists::               Pairs and lists.
* baselib symbols::             Symbols.
* baselib characters::          Characters.
* baselib strings::             Strings.
* baselib vectors::             Vectors.
* baselib errors::              Errors and violations.
* baselib control::             Control features.
* baselib iteration::           Iteration.
* baselib quasiquotation::      Quasiquotation.
* baselib syntax binding::      Binding constructs for syntactic keywords.
* baselib transformers::        Macro transformers.
* baselib tail call::           Tail calls and tail contexts.
@end menu


@c page
@node baselib types
@section Base types


No object satisfies more than one of the following predicates:

@example
boolean?          pair?
symbol?           number?
char?             string?
vector?           procedure?
null?
@end example

These predicates define the base types @emph{boolean}, @emph{pair},
@emph{symbol}, @emph{number}, @emph{char} (or @emph{character}),
@emph{string}, @emph{vector}, and @emph{procedure}.  Moreover, the empty
list is a special object of its own type.

Note that, although there is a separate boolean type, any Scheme value
can be used as a boolean value for the purpose of a conditional test.


@c page
@node baselib definitions
@section Definitions


Definitions may appear within a @meta{top-level body}, at the top of a
@meta{library body}, or at the top of a @meta{body}.

A @meta{definition} may be a variable definition or keyword definition.
Macro uses that expand into definitions or groups of definitions
(packaged in a @func{begin}, @func{let-syntax}, or @func{letrec-syntax}
form) may also appear wherever other definitions may appear.


@menu
* baselib definitions variables::  Variables definitions.
* baselib definitions syntax::     Syntax definitions.
@end menu


@c page
@node baselib definitions variables
@subsection Variables definitions


The @func{define} form described in this section is a @meta{definition}
used to create variable bindings and may appear anywhere other
definitions may appear.


@deffn Syntax define @meta{variable} @hyper{expression}
@deffnx Syntax define @meta{variable}
@deffnx Syntax define @meta{variable} @hyper{formals}) @hyper{body}
@deffnx Syntax define (@meta{variable} . @hyper{formal}) @hyper{body})
The first from of @func{define} binds @meta{variable} to a new location
before assigning the value of @meta{expression} to it.

@example
(define add3
  (lambda (x) (+ x 3)))
(add3 3)                            =>  6
(define first car)
(first '(1 2))                      =>  1
@end example

The continuation of @meta{expression} should not be invoked more than
once.

@strong{Implementation responsibilities:} Implementations should detect
that the continuation of @meta{expression} is invoked more than once.
If the implementation detects this, it must raise an exception with
condition type @code{&assertion}.

The second form of @func{define} is equivalent to:

@example
(define @meta{variable} @hyper{unspecified})
@end example

@noindent
where @meta{unspecified} is a side--effect--free expression returning an
unspecified value.

In the third form of @func{define}, @meta{formals} must be either a
sequence of zero or more variables, or a sequence of one or more
variables followed by a dot @code{.} and another variable (as in a
lambda expression).  This form is equivalent to:

@example
(define @meta{variable}
  (lambda (@meta{formals}) @hyper{body}))
@end example

In the fourth form of @func{define}, @meta{formal} must be a single
variable.  This form is equivalent to:

@example
(define @meta{variable}
  (lambda @meta{formal} @hyper{body}))
@end example
@end deffn



@c page
@node baselib definitions syntax
@subsection Syntax definitions


The @code{define-syntax} form described in this section is a
@meta{definition} used to create keyword bindings and may appear
anywhere other definitions may appear.


@deffn Syntax define-syntax @meta{keyword} @hyper{expression}
Binds @meta{keyword} to the value of @meta{expression}, which must
evaluate, at macro--expansion time, to a transformer.  Macro
transformers can be created using the @func{syntax-rules} and
@func{identifier-syntax} forms.

Keyword bindings established by @func{define-syntax} are visible
throughout the body in which they appear, except where shadowed by other
bindings, and nowhere else, just like variable bindings established by
@func{define}.  All bindings established by a set of definitions,
whether keyword or variable definitions, are visible within the
definitions themselves.

@strong{Implementation responsibilities:} The implementation should
detect if the value of @meta{expression} cannot possibly be a
transformer.

Example:

@example
(let ()
  (define even?
    (lambda (x)
      (or (= x 0) (odd? (- x 1)))))
  (define-syntax odd?
    (syntax-rules ()
      ((odd?  x) (not (even? x)))))
  (even? 10))
=> #t
@end example

An implication of the left--to--right processing order is that one
definition can affect whether a subsequent form is also a definition.

Example:

@example
(let ()
  (define-syntax bind-to-zero
    (syntax-rules ()
      ((bind-to-zero id) (define id 0))))
  (bind-to-zero x)
  x)
=> 0
@end example

The behavior is unaffected by any binding for @func{bind-to-zero} that
might appear outside of the @func{let} expression.
@end deffn



@c page
@node baselib bodies
@section Bodies


The @meta{body} of a @func{lambda}, @func{let}, @func{let*},
@func{let-values}, @func{let*-values}, @func{letrec}, or @func{letrec*}
expression, or that of a definition with a body consists of zero or more
definitions followed by one or more expressions.

@example
@meta{definition} @dots{} @hyperi{expression} @hyperii{expression} @dots{}
@end example

Each identifier defined by a definition is local to the @meta{body}.
That is, the identifier is bound, and the region of the binding is the
entire @meta{body}.

Example:

@example
(let ((x 5))
  (define foo (lambda (y) (bar x y)))
  (define bar (lambda (a b) (+ (* a b) a)))
  (foo (+ x 3)))
=>  45
@end example

When @func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms
occur in a body prior to the first expression, they are spliced into the
body.  Some or all of the body, including portions wrapped in
@func{begin}, @func{let-syntax}, or @func{letrec-syntax} forms, may be
specified by a macro use.

An expanded @meta{body} containing variable definitions can always be
converted into an equivalent @func{letrec*} expression.  For example,
the @func{let} expression in the above example is equivalent to

@example
(let ((x 5))
  (letrec* ((foo (lambda (y) (bar x y)))
            (bar (lambda (a b) (+ (* a b) a))))
    (foo (+ x 3))))
@end example



@c page
@node baselib expressions
@section Expressions


The entries in this section describe the expressions of the
@rsixlibrary{base} library, which may occur in the position of the
@meta{expression} syntactic variable in addition to the primitive
expression types.


@menu
* baselib expressions quotation::       Quotation.
* baselib expressions procedures::      Procedures.
* baselib expressions conditionals::    Conditionals.
* baselib expressions assignments::     Assignments.
* baselib expressions derived cond::    Derived conditionals.
* baselib expressions binding::         Binding constructs.
* baselib expressions sequencing::      Sequencing.
@end menu



@c page
@node baselib expressions quotation
@subsection Quotation


@deffn Syntax quote @meta{datum}
@meta{Datum} should be a syntactic datum.  @code{(quote @meta{datum})}
evaluates to the datum value represented by @meta{datum}.  This notation
is used to include constants.

@example
(quote a)               =>  a
(quote #(a b c))        =>  #(a b c)
(quote (+ 1 2))         =>  (+ 1 2)
@end example

@code{(quote @meta{datum})} may be abbreviated as @code{'@meta{datum}}:

@example
'"abc"               =>  "abc"
'145932              =>  145932
'a                   =>  a
'#(a b c)            =>  #(a b c)
'()                  =>  ()
'(+ 1 2)             =>  (+ 1 2)
'(quote a)           =>  (quote a)
''a                  =>  (quote a)
@end example

Constants are immutable.

@quotation
@emph{Note:} Different constants that are the value of a @func{quote}
expression may share the same locations.
@end quotation
@end deffn



@c page
@node baselib expressions procedures
@subsection Procedures


@deffn Syntax lambda @meta{formals} @hyper{body}
@meta{formals} must be a formal parameter list as described below, and
@meta{body} must be as described in @ref{baselib bodies}.

A @func{lambda} evaluates to a procedure.  The environment in effect
when the @func{lambda} is evaluated is remembered as part of the
procedure.  When the procedure is later called with some arguments, the
environment in which the @func{lambda} was evaluated is extended by
binding the variables in the parameter list to fresh locations, and the
resulting argument values are stored in those locations.  Then, the
expressions in the body of the @func{lambda} (which may contain
definitions and thus represent a @func{letrec*} form) are evaluated
sequentially in the extended environment.  The results of the last
expression in the body are returned as the results of the procedure
call.

@example
(lambda (x) (+ x x))      =>  a procedure
((lambda (x) (+ x x)) 4)  =>  8

((lambda (x)
   (define (p y)
     (+ y 1))
   (+ (p x) x))
 5) => 11

(define reverse-subtract
  (lambda (x y) (- y x)))
(reverse-subtract 7 10)         =>  3

(define add4
  (let ((x 4))
    (lambda (y) (+ x y))))
(add4 6)                        =>  10
@end example

@meta{formals} must have one of the following forms:

@table @code
@item (@hyperi{variable} @dots{})
The procedure takes a fixed number of arguments; when the procedure is
called, the arguments are stored in the bindings of the corresponding
variables.

@item @meta{variable}
The procedure takes any number of arguments; when the procedure is
called, the sequence of arguments is converted into a newly allocated
list, and the list is stored in the binding of the @meta{variable}.

@item (@hyperi{variable} @dots{} @meta{variableN} . @meta{variableN+1})
If a period @code{.} precedes the last variable, then the procedure
takes @var{n} or more arguments, where @var{n} is the number of
parameters before the period (there must be at least one).  The value
stored in the binding of the last variable is a newly allocated list of
the arguments left over after all the other arguments have been matched
up against the other parameters.

@example
((lambda x x) 3 4 5 6)          =>  (3 4 5 6)
((lambda (x y . z) z)
 3 4 5 6)                       =>  (5 6)
@end example
@end table

Any @meta{variable} must not appear more than once in @meta{formals}.
@end deffn



@c page
@node baselib expressions conditionals
@subsection Conditionals


@deffn Syntax if @meta{test} @meta{consequent} @meta{alternate}
@deffnx Syntax if @meta{test} @meta{consequent}
@meta{test}, @meta{consequent}, and @meta{alternate} must be
expressions.

An @func{if} expression is evaluated as follows: first, @meta{test} is
evaluated.  If it yields a true value, then @meta{consequent} is
evaluated and its values are returned.  Otherwise @meta{alternate} is
evaluated and its values are returned.  If @meta{test} yields @false{}
and no @meta{alternate} is specified, then the result of the expression
is unspecified.

@example
(if (> 3 2) 'yes 'no)           => yes
(if (> 2 3) 'yes 'no)           => no
(if (> 3 2)
    (- 3 2)
    (+ 3 2))                    => 1
(if #f #f)                      => unspecified
@end example

The @meta{consequent} and @meta{alternate} expressions are in tail
context if the @func{if} expression itself is.
@end deffn



@c page
@node baselib expressions assignments
@subsection Assignments


@deffn Syntax set! @meta{variable} @meta{expression}
@meta{expression} is evaluated, and the resulting value is stored in the
location to which @meta{variable} is bound.  @meta{variable} must be
bound either in some region expression or at the top level.  The result
of the @func{set!} expression is unspecified.

@example
(let ((x 2))
  (+ x 1)
  (set! x 4)
  (+ x 1)) =>  5
@end example

It is a syntax violation if @meta{variable} refers to an immutable
binding.

@quotation
@emph{Note:} The identifier @func{set!} is exported with level @emph{1}
as well.
@end quotation
@end deffn



@c page
@node baselib expressions derived cond
@subsection Derived conditionals


@deffn Syntax cond @hyperi{cond clause} @hyperii{cond clause} @dots{}
@deffnx {Auxiliary Syntax} {=>}
@deffnx {Auxiliary Syntax} else
Each @meta{cond clause} must be of the form:

@example
(@meta{test} @hyperi{expression} @dots{})
@end example

@noindent
where @meta{test} is an expression.  Alternatively, a @meta{cond clause}
may be of the form:

@example
(@meta{test} => @meta{expression})
@end example

The last @meta{cond clause} may be an ``@code{else} clause'', which has
the form:

@example
(else @hyperi{expression} @hyperii{expression} @dots{})
@end example

A @func{cond} expression is evaluated by evaluating the @meta{test}
expressions of successive @meta{cond clause}s in order until one of them
evaluates to a true value.  When a @meta{test} evaluates to a true
value, then the remaining @meta{expression}s in its @meta{cond clause}
are evaluated in order, and the results of the last @meta{expression} in
the @meta{cond clause} are returned as the results of the entire
@func{cond} expression.

If the selected @meta{cond clause} contains only the @meta{test} and no
@meta{expression}s, then the value of the @meta{test} is returned as the
result.  If the selected @meta{cond clause} uses the @code{=>} alternate
form, then the @meta{expression} is evaluated.  Its value must be a
procedure.  This procedure should accept one argument; it is called on
the value of the @meta{test} and the values returned by this procedure
are returned by the @func{cond} expression.

If all @meta{test}s evaluate to @false{}, and there is no @code{else}
clause, then the conditional expression returns unspecified values; if
there is an @code{else} clause, then its @meta{expression}s are
evaluated, and the values of the last one are returned.

@example
(cond ((> 3 2) 'greater)
      ((< 3 2) 'less))          => greater

(cond ((> 3 3) 'greater)
      ((< 3 3) 'less)
      (else 'equal))            => equal

(cond ('(1 2 3) => cadr)
      (else #f))                => 2
@end example

For a @meta{cond clause} of one of the following forms:

@example
(@meta{test} @hyperi{expression} @dots{})
(else @hyperi{expression} @hyperii{expression} @dots{})
@end example

@noindent
the last @meta{expression} is in tail context if the @func{cond} form
itself is.  For a @meta{cond clause} of the form:

@example
(@meta{test} => @meta{expression})
@end example

@noindent
the (implied) call to the procedure that results from the evaluation of
@meta{expression} is in a tail context if the @func{cond} form itself
is.
@end deffn


@deffn Syntax case @meta{key} @hyperi{case clause} @hyperii{case clause} @dots{}
@meta{key} must be an expression.  Each @meta{case clause} must have one
of the following forms:

@example
((@hyperi{datum} @dots{}) @hyperi{expression} @hyperii{expression} @dots{})
(else @hyperi{expression} @hyperii{expression} @dots{})
@end example

The second form, which specifies an ``@code{else} clause'', may only
appear as the last @meta{case clause}.  Each @meta{datum} is an external
representation of some object.  The data represented by the
@meta{datum}s need not be distinct.

A @func{case} expression is evaluated as follows.

@enumerate
@item
@meta{key} is evaluated and its result is compared using @func{eqv?}
against the data represented by the @meta{datum}s of each @meta{case
clause} in turn, proceeding in order from left to right through the set
of clauses.

@item
If the result of evaluating @meta{key} is equivalent to a datum of a
@meta{case clause}, the corresponding @meta{expression}s are evaluated
from left to right and the results of the last expression in the
@meta{case clause} are returned as the results of the @func{case}
expression.  Otherwise, the comparison process continues.

@item
If the result of evaluating @meta{key} is different from every datum in
each set, then if there is an @code{else} clause its expressions are
evaluated and the results of the last are the results of the @func{case}
expression; otherwise the @func{case} expression returns unspecified
values.
@end enumerate

@example
(case (* 2 3)
  ((2 3 5 7) 'prime)
  ((1 4 6 8 9) 'composite))     => composite
(case (car '(c d))
  ((a) 'a)
  ((b) 'b))                     => unspecified
(case (car '(c d))
  ((a e i o u) 'vowel)
  ((w y) 'semivowel)
  (else 'consonant))            => consonant
@end example

The last @meta{expression} of a @meta{case clause} is in tail context if
the @func{case} expression itself is.
@end deffn


@deffn Syntax and @hyperi{test} @dots{}
The @meta{test}s must be expressions.

If there are no @meta{test}s, @true{} is returned.  Otherwise, the
@meta{test} expressions are evaluated from left to right until a
@meta{test} returns @false{} or the last @meta{test} is reached.  In the
former case, the @func{and} expression returns @false{} without
evaluating the remaining expressions.  In the latter case, the last
expression is evaluated and its values are returned.

@example
(and (= 2 2) (> 2 1))           =>  #t
(and (= 2 2) (< 2 1))           =>  #f
(and 1 2 'c '(f g))             =>  (f g)
(and)                           =>  #t
@end example

The @func{and} keyword could be defined in terms of @func{if} using
@func{syntax-rules} as follows:

@example
(define-syntax and
  (syntax-rules ()
    ((and) #t)
    ((and test) test)
    ((and test1 test2 ...)
     (if test1 (and test2 ...) #t))))
@end example

The last @meta{test} expression is in tail context if the @func{and}
expression itself is.
@end deffn


@deffn Syntax or @hyperi{test} @dots{}
The @meta{test}s must be expressions.

If there are no @meta{test}s, @false{} is returned.  Otherwise, the
@meta{test} expressions are evaluated from left to right until a
@meta{test} returns a true value @var{val} or the last @meta{test} is
reached.  In the former case, the @func{or} expression returns @var{val}
without evaluating the remaining expressions.  In the latter case, the
last expression is evaluated and its values are returned.

@example
(or (= 2 2) (> 2 1))            => #t
(or (= 2 2) (< 2 1))            => #t
(or #f #f #f)                   => #f
(or '(b c) (/ 3 0))             => (b c)
@end example

The @func{or} keyword could be defined in terms of @func{if} using
@func{syntax-rules} as follows:

@example
(define-syntax or
  (syntax-rules ()
    ((or) #f)
    ((or test) test)
    ((or test1 test2 ...)
     (let ((x test1))
       (if x x (or test2 ...))))))
@end example

The last @meta{test} expression is in tail context if the @func{or}
expression itself is.
@end deffn



@c page
@node baselib expressions binding
@subsection Binding constructs


The binding constructs described in this section create local bindings
for variables that are visible only in a delimited region.  The syntax
of the constructs @func{let}, @func{let*}, @func{letrec}, and
@func{letrec*} is identical, but they differ in the regions they
establish for their variable bindings and in the order in which the
values for the bindings are computed.

@itemize
@item
In a @func{let} expression, the initial values are computed before any
of the variables become bound; in a @func{let*} expression, the bindings
and evaluations are performed sequentially.

@item
In a @func{letrec} or @func{letrec*} expression, all the bindings are in
effect while their initial values are being computed, thus allowing
mutually recursive definitions.

@item
In a @func{letrec} expression, the initial values are computed before
being assigned to the variables; in a @func{letrec*}, the evaluations
and assignments are performed sequentially.
@end itemize

In addition, the binding constructs @func{let-values} and
@func{let*-values} generalize @func{let} and @func{let*} to allow
multiple variables to be bound to the results of expressions that
evaluate to multiple values.  They are analogous to @func{let} and
@func{let*} in the way they establish regions: in a @func{let-values}
expression, the initial values are computed before any of the variables
become bound; in a @func{let*-values} expression, the bindings are
performed sequentially.

@deffn Syntax let @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{baselib bodies}.  Any variable must not appear more than once in
the @meta{variable}s.

The @meta{init}s are evaluated in the current environment (in some
unspecified order), the @meta{variable}s are bound to fresh locations
holding the results, the @meta{body} is evaluated in the extended
environment, and the values of the last expression of @meta{body} are
returned.  Each binding of a @meta{variable} has @meta{body} as its
region.

@example
(let ((x 2) (y 3))
  (* x y))                      => 6

(let ((x 2) (y 3))
  (let ((x 7)
        (z (+ x y)))
    (* z x)))                   => 35
@end example

See also named @func{let}.
@end deffn


@deffn Syntax {let*} @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{baselib bodies}.

The @func{let*} form is similar to @func{let}, but the @meta{init}s are
evaluated and bindings created sequentially from left to right, with the
region of each binding including the bindings to its right as well as
@meta{body}.  Thus the second @meta{init} is evaluated in an environment
in which the first binding is visible and initialized, and so on.

@example
(let ((x 2) (y 3))
  (let* ((x 7)
         (z (+ x y)))
    (* z x)))             => 70
@end example

@quotation
@emph{Note:} While the variables bound by a @func{let} expression must
be distinct, the variables bound by a @func{let*} expression need not be
distinct.
@end quotation
@end deffn


@deffn Syntax letrec @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{baselib bodies}.  Any variable must not appear more than once in
the @meta{variable}s.

The @meta{variable}s are bound to fresh locations, the @meta{init}s are
evaluated in the resulting environment (in some unspecified order), each
@meta{variable} is assigned to the result of the corresponding
@meta{init}, the @meta{body} is evaluated in the resulting environment,
and the values of the last expression in @meta{body} are returned.  Each
binding of a @meta{variable} has the entire @func{letrec} expression as
its region, making it possible to define mutually recursive procedures.

@example
(letrec ((even?
          (lambda (n)
            (if (zero? n)
                \schtrue
                (odd? (- n 1)))))
         (odd?
          (lambda (n)
            (if (zero? n)
                \schfalse
                (even? (- n 1))))))
  (even? 88))
=> #t
@end example

It should be possible to evaluate each @meta{init} without assigning or
referring to the value of any @meta{variable}.  In the most common uses
of @func{letrec}, all the @meta{init}s are @func{lambda}s and the
restriction is satisfied automatically.  Another restriction is that the
continuation of each @meta{init} should not be invoked more than once.

@strong{Implementation responsibilities:} Implementations must detect
references to a @meta{variable} during the evaluation of the @meta{init}
expressions (using one particular evaluation order and order of
evaluating the @meta{init} expressions).  If an implementation detects
such a violation of the restriction, it must raise an exception with
condition type @code{&assertion}.  Implementations may or may not detect
that the continuation of each @meta{init} is invoked more than once.
However, if the implementation detects this, it must raise an exception
with condition type @code{&assertion}.
@end deffn

@deffn Syntax {letrec*} @meta{bindings} @meta{body}
@meta{bindings} must have the form:

@example
((@hyperi{variable} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{baselib bodies}.  Any variable must not appear more than once in
the @meta{variable}s.

The @meta{variable}s are bound to fresh locations, each @meta{variable}
is assigned in left--to--right order to the result of evaluating the
corresponding @meta{init}, the @meta{body} is evaluated in the resulting
environment, and the values of the last expression in @meta{body} are
returned.  Despite the left--to--right evaluation and assignment order,
each binding of a @meta{variable} has the entire @func{letrec*}
expression as its region, making it possible to define mutually
recursive procedures.

@example
(letrec* ((p
           (lambda (x)
             (+ 1 (q (- x 1)))))
          (q
           (lambda (y)
             (if (zero? y)
                 0
                 (+ 1 (p (- y 1))))))
          (x (p 5))
          (y x))
  y)
=>  5
@end example

It must be possible to evaluate each @meta{init} without assigning or
referring to the value of the corresponding @meta{variable} or the
@meta{variable} of any of the bindings that follow it in
@meta{bindings}.  Another restriction is that the continuation of each
@meta{init} should not be invoked more than once.

@strong{Implementation responsibilities:} Implementations must, during
the evaluation of an @meta{init} expression, detect references to the
value of the corresponding @meta{variable} or the @meta{variable} of any
of the bindings that follow it in @meta{bindings}.  If an implementation
detects such a violation of the restriction, it must raise an exception
with condition type @code{&assertion}.  Implementations may or may not
detect that the continuation of each @meta{init} is invoked more than
once.  However, if the implementation detects this, it must raise an
exception with condition type @code{&assertion}.
@end deffn


@deffn Syntax let-values @meta{mv-bindings} @meta{body}
@meta{mv-bindings} must have the form:

@example
((@hyperi{formals} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{baselib bodies}.  Any variable must not appear more than once in
the set of @meta{formals}.

The @meta{init}s are evaluated in the current environment (in some
unspecified order), and the variables occurring in the @meta{formals}
are bound to fresh locations containing the values returned by the
@meta{init}s, where the @meta{formals} are matched to the return values
in the same way that the @meta{formals} in a @func{lambda} are matched
to the arguments in a procedure call.  Then, the @meta{body} is
evaluated in the extended environment, and the values of the last
expression of @meta{body} are returned.  Each binding of a variable has
@meta{body} as its region.  If the @meta{formals} do not match, an
exception with condition type @code{&assertion} is raised.

@example
(let-values (((a b) (values 1 2))
             ((c d) (values 3 4)))
  (list a b c d))
=> (1 2 3 4)

(let-values (((a b . c) (values 1 2 3 4)))
  (list a b c))
=> (1 2 (3 4))

(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let-values (((a b) (values x y))
               ((x y) (values a b)))
    (list a b x y)))
=> (x y a b)
@end example
@end deffn


@deffn Syntax {let*-values} @meta{mv-bindings} @meta{body}
@meta{mv-bindings} must have the form:

@example
((@hyperi{formals} @metai{init}) @dots{})
@end example

@noindent
where each @meta{init} is an expression, and @meta{body} is as described
in @ref{baselib bodies}.  In each @meta{formals}, any variable must not
appear more than once.

The @func{let*-values} form is similar to @func{let-values}, but the
@meta{init}s are evaluated and bindings created sequentially from left
to right, with the region including the bindings to its right as well as
@meta{body}.  Thus the second @meta{init} is evaluated in an environment
in which the bindings of the first @meta{formals} is visible and
initialized, and so on.

@example
(let ((a 'a) (b 'b) (x 'x) (y 'y))
  (let*-values (((a b) (values x y))
                ((x y) (values a b)))
    (list a b x y)))
=> (x y x y)
@end example

@quotation
@emph{Note:} While all of the variables bound by a @func{let-values}
expression must be distinct, the variables bound by different
@meta{formals} of a @func{let*-values} expression need not be distinct.
@end quotation
@end deffn



@c page
@node baselib expressions sequencing
@subsection Sequencing


@deffn Syntax begin @meta{form} @dots{}
@deffnx Syntax begin @meta{expression} @meta{expression} @dots{}
The @meta{begin} keyword has two different roles, depending on its
context:

@itemize
@item
It may appear as a form in a @meta{body}, @meta{library body}, or
@meta{top-level body}, or directly nested in a @func{begin} form that
appears in a body.  In this case, the @func{begin} form must have the
shape specified in the first header line.  This use of @func{begin} acts
as a @emph{splicing} form: the forms inside the @meta{body} are spliced
into the surrounding body, as if the @func{begin} wrapper were not
actually present.

A @func{begin} form in a @meta{body} or @meta{library body} must be
non--empty if it appears after the first @meta{expression} within the
body.

@item
It may appear as an ordinary expression and must have the shape
specified in the second header line.  In this case, the
@meta{expression}s are evaluated sequentially from left to right, and
the values of the last @meta{expression} are returned.  This expression
type is used to sequence side effects such as assignments or input and
output.
@end itemize

@example
(define x 0)

(begin (set! x 5)
       (+ x 1))
=>  6

(begin (display "4 plus 1 equals ")
       (display (+ 4 1)))
=>  unspecified and prints 4 plus 1 equals 5
@end example
@end deffn



@c page
@node baselib predicates
@section Equivalence and procedure predicates


A @emph{predicate} is a procedure that always returns a boolean value
(@true{} or @false{}).  An @emph{equivalence predicate} is the
computational analogue of a mathematical equivalence relation (it is
symmetric, reflexive, and transitive).  Of the equivalence predicates
described in this section, @func{eq?} is the finest or most
discriminating, and @func{equal?} is the coarsest.  The @func{eqv?}
predicate is slightly less discriminating than @func{eq?}.


@deffn Procedure {eqv?} @vari{obj} @varii{obj}
The @func{eqv?} procedure defines a useful equivalence relation on
objects.  Briefly, it returns @true{} if @vari{obj} and @varii{obj}
should normally be regarded as the same object and @false{} otherwise.
This relation is left slightly open to interpretation, but the following
partial specification of @func{eqv?} must hold for all implementations.

The @func{eqv?} procedure returns @true{} if one of the following holds:

@itemize
@item
@vari{obj} and @varii{obj} are both booleans and are the same according
to the @func{boolean=?} procedure.

@item
@vari{obj} and @varii{obj} are both symbols and are the same according
to the @func{symbol=?} procedure.

@item
@vari{obj} and @varii{obj} are both exact number objects and are
numerically equal (see @code{=}).

@item
@vari{obj} and @varii{obj} are both inexact number objects, are
numerically equal (see @code{=}), and yield the same results (in the
sense of @func{eqv?}) when passed as arguments to any other procedure
that can be defined as a finite composition of Scheme's standard
arithmetic procedures.

@item
@vari{obj} and @varii{obj} are both characters and are the same
character according to the @code{char=?} procedure.

@item
Both @vari{obj} and @varii{obj} are the empty list.

@item
@vari{obj} and @varii{obj} are objects such as pairs, vectors,
bytevectors (library chapter ``Bytevectors''), strings, hashtables,
records (library chapter ``Records''), ports (library section ``Port
I/O''), or hashtables (library chapter ``Hash tables'') that refer to
the same locations in the store.

@item
@vari{obj} and @varii{obj} are record--type descriptors that are
specified to be @func{eqv?} in library section ``Procedural layer''.
@end itemize

The @func{eqv?} procedure returns @false{} if one of the following
holds:

@itemize
@item
@vari{obj} and @varii{obj} are of different types.

@item
@vari{obj} and @varii{obj} are booleans for which the @func{boolean=?}
procedure returns @false{}.

@item
@vari{Obj} and @varii{obj} are symbols for which the @func{symbol=?}
procedure returns @false{}.

@item
One of @vari{obj} and @varii{obj} is an exact number object but the
other is an inexact number object.

@item
@vari{obj} and @varii{obj} are rational number objects for which the
@code{=} procedure returns @false{}.

@item
@vari{Obj} and @varii{obj} yield different results (in the sense of
@func{eqv?}) when passed as arguments to any other procedure that can be
defined as a finite composition of Scheme's standard arithmetic
procedures.

@item
@vari{obj} and @varii{obj} are characters for which the @func{char=?}
procedure returns @false{}.

@item
One of @vari{obj} and @varii{obj} is the empty list, but the other is
not.

@item
@vari{obj} and @varii{obj} are objects such as pairs, vectors,
bytevectors (library chapter ``Bytevectors''), strings, records (library
chapter ``Records''), ports (library section ``Port I/O''), or
hashtables (library chapter ``Hashtables'') that refer to distinct
locations.

@item
@vari{obj} and @varii{obj} are pairs, vectors, strings, or records, or
hashtables, where the applying the same accessor (i.e. @func{car},
@func{cdr}, @func{vector-ref}, @func{string-ref}, or record accessors)
to both yields results for which @func{eqv?} returns @false{}.

@item
@vari{obj} and @varii{obj} are procedures that would behave differently
(return different values or have different side effects) for some
arguments.
@end itemize

@quotation
@emph{Note:} The @func{eqv?} procedure returning @true{} when @vari{obj}
and @varii{obj} are number objects does not imply that @code{=} would
also return @true{} when called with @vari{obj} and @varii{obj} as
arguments.
@end quotation

@example
(eqv? 'a 'a)                     =>  #t
(eqv? 'a 'b)                     =>  #f
(eqv? 2 2)                       =>  #t
(eqv? '() '())                   =>  #t
(eqv? 100000000 100000000)       =>  #t
(eqv? (cons 1 2) (cons 1 2))     =>  #f
(eqv? (lambda () 1)
      (lambda () 2))             =>  #f
(eqv? #f 'nil)                   =>  #f
@end example

The following examples illustrate cases in which the above rules do not
fully specify the behavior of @func{eqv?}.  All that can be said about
such cases is that the value returned by @func{eqv?} must be a boolean.

@example
(let ((p (lambda (x) x)))
  (eqv? p p))                   => unspecified

(eqv? "" "")                    => unspecified

(eqv? '#() '#())                => unspecified

(eqv? (lambda (x) x)
      (lambda (x) x))           => unspecified

(eqv? (lambda (x) x)
      (lambda (y) y))           => unspecified

(eqv? +nan.0 +nan.0)            => unspecified
@end example

The next set of examples shows the use of @func{eqv?} with procedures
that have local state.  Calls to @func{gen-counter} must return a
distinct procedure every time, since each procedure has its own internal
counter.  Calls to @func{gen-loser} return procedures that behave
equivalently when called.  However, @func{eqv?} may not detect this
equivalence.

@example
(define gen-counter
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) n))))
(let ((g (gen-counter)))
  (eqv? g g))           =>  unspecified
(eqv? (gen-counter) (gen-counter))
                        =>  #f
(define gen-loser
  (lambda ()
    (let ((n 0))
      (lambda () (set! n (+ n 1)) 27))))
(let ((g (gen-loser)))
  (eqv? g g))           =>  unspecified
(eqv? (gen-loser) (gen-loser))
                        =>  unspecified

(letrec ((f (lambda () (if (eqv? f g) 'both 'f)))
         (g (lambda () (if (eqv? f g) 'both 'g))))
  (eqv? f g)) => unspecified

(letrec ((f (lambda () (if (eqv? f g) 'f 'both)))
         (g (lambda () (if (eqv? f g) 'g 'both))))
  (eqv? f g)) => #f
@end example

Implementations may share structure between constants where appropriate.
Furthermore, a constant may be copied at any time by the implementation
so as to exist simultaneously in different sets of locations.  Thus the
value of @func{eqv?} on constants is sometimes
implementation--dependent.

@example
(eqv? '(a) '(a))                 => unspecified
(eqv? "a" "a")                   => unspecified
(eqv? '(b) (cdr '(a b)))         => unspecified
(let ((x '(a)))
  (eqv? x x))                    => #t
@end example
@end deffn


@deffn Procedure eq? @vari{obj} @varii{obj}
The @func{eq?} predicate is similar to @func{eqv?} except that in some
cases it is capable of discerning distinctions finer than those
detectable by @func{eqv?}.

The @func{eq?} and @func{eqv?} predicates are guaranteed to have the
same behavior on symbols, booleans, the empty list, pairs, procedures,
non--empty strings, bytevectors, vectors, and records.  The behavior of
@func{eq?} on number objects and characters is
implementation--dependent, but it always returns either @true{} or
@false{}, and returns @true{} only when @func{eqv?} would also return
@true{}.  The @func{eq?} predicate may also behave differently from
@func{eqv?} on empty vectors, empty bytevectors, and empty strings.

@example
(eq? 'a 'a)                     => #t
(eq? '(a) '(a))                 => unspecified
(eq? (list 'a) (list 'a))       => #f
(eq? "a" "a")                   => unspecified
(eq? "" "")                     => unspecified
(eq? '() '())                   => #t
(eq? 2 2)                       => unspecified
(eq? #\A #\A)                   => unspecified
(eq? car car)                   => #t
(let ((n (+ 2 3)))
  (eq? n n))                    => unspecified
(let ((x '(a)))
  (eq? x x))                    => #t
(let ((x '#()))
  (eq? x x))                    => unspecified
(let ((p (lambda (x) x)))
  (eq? p p))                    => unspecified
@end example
@end deffn


@deffn Procedure {equal?} @vari{obj} @varii{obj}
The @func{equal?}  predicate returns @true{} if and only if the
(possibly infinite) unfoldings of its arguments into regular trees are
equal as ordered trees.

The @func{equal?} predicate treats pairs and vectors as nodes with
outgoing edges, uses @func{string=?} to compare strings, uses
@func{bytevector=?} to compare bytevectors (@ref{stdlib bytevector}),
and uses @func{eqv?} to compare other nodes.

@example
(equal? 'a 'a)                  =>  #t

(equal? '(a) '(a))              =>  #t

(equal? '(a (b) c)
        '(a (b) c))             =>  #t

(equal? "abc" "abc")            =>  #t

(equal? 2 2)                    =>  #t

(equal? (make-vector 5 'a)
        (make-vector 5 'a))     =>  #t

(equal? '#vu8(1 2 3 4 5)
        (u8-list->bytevector
         '(1 2 3 4 5))          =>  #t

(equal? (lambda (x) x)
        (lambda (y) y))         =>  unspecified

(let* ((x (list 'a))
       (y (list 'a))
       (z (list x y)))
  (list (equal? z (list y x))
        (equal? z (list x x)))) =>  (#t #t)
@end example

@quotation
@emph{Note:} The @func{equal?} procedure must always terminate, even if
its arguments contain cycles.
@end quotation
@end deffn


@c ------------------------------------------------------------

@subsubheading Procedure predicate


@deffn Procedure {procedure?} @var{obj}
Return @true{} if @var{obj} is a procedure, otherwise return @false{}.

@example
(procedure? car)                        => #t
(procedure? 'car)                       => #f
(procedure? (lambda (x) (* x x)))       => #t
(procedure? '(lambda (x) (* x x)))      => #f
@end example
@end deffn



@c page
@node baselib math
@section Mathematics


The procedures described here implement arithmetic that is generic over
the numerical tower.  The generic procedures described in this section
accept both exact and inexact number objects as arguments, performing
coercions and selecting the appropriate operations as determined by the
numeric subtypes of their arguments.


@menu
* baselib math exactness::      Propagation of exactness and inexactness.
* baselib math infinities::     Representability of infinities and NaNs.
* baselib math semantics::      Semantics of common operations.
* baselib math ops::            Numerical operations.
* baselib math string::         Numerical input and output.
@end menu


@c page
@node baselib math exactness
@subsection Propagation of exactness and inexactness


The procedures listed below must return the mathematically correct exact
result provided all their arguments are exact:

@example
+            -            *
max          min          abs
numerator    denominator  gcd
lcm          floor        ceiling
truncate     round        rationalize
real-part    imag-part    make-rectangular
@end example

The procedures listed below must return the correct exact result
provided all their arguments are exact, and no divisors are zero:

@example
/
div          mod           div-and-mod
div0         mod0          div0-and-mod0
@end example

Moreover, the procedure @func{expt} must return the correct exact result
provided its first argument is an exact real number object and its
second argument is an exact integer object.

The general rule is that the generic operations return the correct exact
result when all of their arguments are exact and the result is
mathematically well--defined, but return an inexact result when any
argument is inexact.  Exceptions to this rule include:

@example
sqrt            exp             log
sin             cos             tan
asin            acos            atan
expt            make-polar      magnitude
angle
@end example

@noindent
which may (but are not required to) return inexact results even when
given exact arguments, as indicated in the specification of these
procedures.

One general exception to the rule above is that an implementation may
return an exact result despite inexact arguments if that exact result
would be the correct result for all possible substitutions of exact
arguments for the inexact ones.  An example is @code{(* 1.0 0)} which
may return either @code{0} (exact) or @code{0.0} (inexact).



@c page
@node baselib math infinities
@subsection Representability of infinities and NaNs


The specification of the numerical operations is written as though
infinities and NaNs are representable, and specifies many operations
with respect to these number objects in ways that are consistent with
the @ieee{} 754 standard for binary floating--point arithmetic.

An implementation of Scheme may or may not represent infinities and
NaNs; however, an implementation must raise a continuable exception with
condition type @code{&no-infinities} or @code{&no-nans} (respectively;
@ref{stdlib arithmetics flonum}) whenever it is unable to represent an
infinity or NaN as specified.  In this case, the continuation of the
exception handler is the continuation that otherwise would have received
the infinity or NaN value.  This requirement also applies to conversions
between number objects and external representations, including the
reading of program source code.



@c page
@node baselib math semantics
@subsection Semantics of common operations


Some operations are the semantic basis for several arithmetic
procedures.  The behavior of these operations is described in this
section for later reference.


@menu
* baselib math semantics integer::      Integer division.
* baselib math semantics trascend::     Transcendental functions.
@end menu


@c page
@node baselib math semantics integer
@subsubsection Integer division


Scheme's operations for performing integer division rely on mathematical
operations @emph{div}, @emph{mod}, @emph{div_0}, and @emph{mod_0}, that
are defined as follows:

@itemize
@item
@emph{div}, @emph{mod}, @emph{div_0}, and @emph{mod_0} each accept two
real numbers @emph{x_1} and @emph{x_2} as operands, where @emph{x_2}
must be nonzero.

@item
@emph{div} returns an integer, and @emph{mod} returns a real.  Their
results are specified by:

@example
x_1 div x_2 = n_d
x_1 mod x_2 = x_m
@end example

@noindent
where:

@example
x_1 = n_d * x_2 + x_m
0  <= x_m < |x_2|
@end example

Examples:

@example
 123 div  10 =  12
 123 mod  10 =   3
 123 div -10 = -12
 123 mod -10 =   3
-123 div  10 = -13
-123 mod  10 =   7
-123 div -10 =  13
-123 mod -10 =   7
@end example

@item
@emph{div_0} and @emph{mod_0} are like @emph{div} and @emph{mod}, except
the result of @emph{mod_0} lies within a half--open interval centered on
zero.  The results are specified by:

@example
x_1 div_0 x_2 = n_d
x_1 mod_0 x_2 = x_m
@end example

@noindent
where:

@example
x_1 = n_d * x_2 + x_m
-|x_2/2| <= x_m < |x_2/2|
@end example

Examples:

@example
 123 div_0  10 =  12
 123 mod_0  10 =   3
 123 div_0 -10 = -12
 123 mod_0 -10 =   3
-123 div_0  10 = -12
-123 mod_0  10 =  -3
-123 div_0 -10 =  12
-123 mod_0 -10 =  -3
@end example
@end itemize



@c page
@node baselib math semantics trascend
@subsubsection Transcendental functions


In general, the transcendental functions @emph{log}, @emph{sin^(-1)}
(arcsine), @emph{cos^(-1)} (arccosine), and @emph{tan^(-1)} are multiply
defined.  The value of @code{log z} is defined to be the one whose
imaginary part lies in the range from @code{-pi} (inclusive if
@code{-0.0} is distinguished, exclusive otherwise) to @code{pi}
(inclusive).  @code{log 0} is undefined.

The value of @code{log z} for non--real @var{z} is defined in terms of
log on real numbers as:

@example
log z = log |z| + (angle z) i
@end example

@noindent
where @code{angle z} is the angle of @code{z = a * e^(i * b)} specified
as:

@example
angle z = b + 2 pi n
@end example

with @code{-pi <= angle z <= \pi} and @code{angle z = b + 2 pi n} for
some integer @var{n}.

With the one--argument version of @emph{log} defined this way, the
values of the two--argument--version of @emph{log}, @code{sin^(-1) z},
@code{cos^(-1) z}, @code{tan^(-1) z}, and the two--argument version
of @code{tan^(-1)} are according to the following formulae:

@example
log_b z = (log z)/(log b)
sin^(-1) z = -i log (i z + sqrt(1 - z^2))
cos^(-1) z = pi/2 - sin^(-1) z
tan^(-1) z = (log (1 + i z) - log (1 - i z)) / (2 i)
tan^(-1) x y = angle(x + yi)
@end example

The range of @code{tan^(-1) x y} is as in the following table.  The
asterisk (*) indicates that the entry applies to implementations that
distinguish minus zero.

@multitable {*} {@emph{y} condition} {@emph{x} condition} {range of result @emph{r}}
@headitem @tab @emph{y} condition @tab @emph{x} condition @tab range of result @emph{r}
@item @tab y = 0.0 @tab x > 0.0 @tab 0.0
@item * @tab y = +0.0  @tab x > 0.0 @tab +0.0
@item * @tab y = -0.0 @tab x > 0.0 @tab -0.0
@item @tab y > 0.0 @tab x > 0.0 @tab 0.0 < r < pi/2
@item @tab y > 0.0 @tab x = 0.0 @tab pi/2
@item @tab y > 0.0 @tab x < 0.0 @tab pi/2 < r < pi
@item @tab y = 0.0 @tab x < 0 @tab pi
@item * @tab y = +0.0 @tab x < 0.0 @tab pi
@item * @tab y = -0.0 @tab x < 0.0 @tab -pi
@item @tab y < 0.0 @tab x < 0.0 @tab -pi< r < -pi/2
@item @tab y < 0.0 @tab x = 0.0 @tab -pi/2
@item @tab y < 0.0 @tab x > 0.0 @tab -pi/2 < r < 0.0
@item @tab y = 0.0 @tab x = 0.0 @tab undefined
@item * @tab y = +0.0 @tab x = +0.0 @tab +0.0
@item * @tab y = -0.0 @tab x = +0.0 @tab -0.0
@item * @tab y = +0.0 @tab x = -0.0 @tab pi
@item * @tab y = -0.0 @tab x = -0.0 @tab -pi
@item * @tab y = +0.0 @tab x = 0 @tab pi/2
@item * @tab y = -0.0 @tab x = 0 @tab -pi/2
@end multitable



@c page
@node baselib math ops
@subsection Numerical operations


@menu
* baselib math ops type pred::          Numerical type predicates.
* baselib math ops exactness::          Generic conversion.
* baselib math ops value pred::         Value predicates.
* baselib math ops comparison::         Comparison.
* baselib math ops arithmetic::         Arithmetic operations.
* baselib math ops part::               Part separation.
* baselib math ops trascend::           Trascendental functions.
* baselib math ops exponentiation::     Exponentiation functions.
* baselib math ops complex::            Complex numbers functions.
@end menu


@c page
@node baselib math ops type pred
@subsubsection Numerical type predicates


@deffn Procedure {number?} @var{obj}
@deffnx Procedure {complex?} @var{obj}
@deffnx Procedure {real?} @var{obj}
@deffnx Procedure {rational?} @var{obj}
@deffnx Procedure {integer?} @var{obj}
These numerical type predicates can be applied to any kind of argument.
They return @true{} if the object is a number object of the named type,
and @false{} otherwise.  In general, if a type predicate is true of a
number object then all higher type predicates are also true of that
number object.  Consequently, if a type predicate is false of a number
object, then all lower type predicates are also false of that number
object.

If @var{z} is a complex number object, then @code{(real? @var{z})} is
true if and only if @code{(zero? (imag-part @var{z}))} and @code{(exact?
(imag-part @var{z}))} are both true.

If @var{x} is a real number object, then @code{(rational? @var{x})} is
true if and only if there exist exact integer objects @vari{k} and
@varii{k} such that @code{(= @var{x} (/ @vari{k} @varii{k}))} and
@code{(= (numerator @var{x}) @vari{k})} and @code{(= (denominator
@var{x}) @varii{k})} are all true.  Thus infinities and NaNs are not
rational number objects.

If @var{q} is a rational number objects, then @code{(integer? @var{q})}
is true if and only if @code{(= (denominator @var{q}) 1)} is true.  If
@var{q} is not a rational number object, then @code{(integer? @var{q})}
is @false{}.

@example
(complex? 3+4i)                        => #t
(complex? 3)                           => #t
(real? 3)                              => #t
(real? -2.5+0.0i)                      => #f
(real? -2.5+0i)                        => #t
(real? -2.5)                           => #t
(real? #e1e10)                         => #t
(rational? 6/10)                       => #t
(rational? 6/3)                        => #t
(rational? 2)                          => #t
(integer? 3+0i)                        => #t
(integer? 3.0)                         => #t
(integer? 8/4)                         => #t

(number? +nan.0)                       => #t
(complex? +nan.0)                      => #t
(real? +nan.0)                         => #t
(rational? +nan.0)                     => #f
(complex? +inf.0)                      => #t
(real? -inf.0)                         => #t
(rational? -inf.0)                     => #f
(integer? -inf.0)                      => #f
@end example

@quotation
@emph{Note:} Except for @func{number?}, the behavior of these type
predicates on inexact number objects is unreliable, because any
inaccuracy may affect the result.
@end quotation
@end deffn


@deffn Procedure {real-valued?} @var{obj}
@deffnx Procedure {rational-valued?} @var{obj}
@deffnx Procedure {integer-valued?} @var{obj}
These numerical type predicates can be applied to any kind of argument.
The @func{real-valued?} procedure returns @true{} if the object is a
number object and is equal in the sense of @code{=} to some real number
object, or if the object is a NaN, or a complex number object whose real
part is a NaN and whose imaginary part is zero in the sense of
@func{zero?}.  The @func{rational-valued?} and @func{integer-valued?}
procedures return @true{} if the object is a number object and is equal
in the sense of @code{=} to some object of the named type, and otherwise
they return @false{}.

@example
(real-valued? +nan.0)                  => #t
(real-valued? +nan.0+0i)               => #t
(real-valued? -inf.0)                  => #t
(real-valued? 3)                       => #t
(real-valued? -2.5+0.0i)               => #t
(real-valued? -2.5+0i)                 => #t
(real-valued? -2.5)                    => #t
(real-valued? #e1e10)                  => #t

(rational-valued? +nan.0)              => #f
(rational-valued? -inf.0)              => #f
(rational-valued? 6/10)                => #t
(rational-valued? 6/10+0.0i)           => #t
(rational-valued? 6/10+0i)             => #t
(rational-valued? 6/3)                 => #t

(integer-valued? 3+0i)                 => #t
(integer-valued? 3+0.0i)               => #t
(integer-valued? 3.0)                  => #t
(integer-valued? 3.0+0.0i)             => #t
(integer-valued? 8/4)                  => #t
@end example

@quotation
@emph{Note:} These procedures test whether a given number object can be
coerced to the specified type without loss of numerical accuracy.
Specifically, the behavior of these predicates differs from the behavior
of @func{real?}, @func{rational?}, and @func{integer?} on complex number
objects whose imaginary part is inexact zero.
@end quotation

@quotation
@emph{Note:} The behavior of these type predicates on inexact number
objects is unreliable, because any inaccuracy may affect the result.
@end quotation
@end deffn


@deffn Procedure {exact?} @var{z}
@deffnx Procedure {inexact?} @var{z}
These numerical predicates provide tests for the exactness of a
quantity.  For any number object, precisely one of these predicates is
true.

@example
(exact? 5)                   => #t
(inexact? +inf.0)            => #t
@end example
@end deffn



@c page
@node baselib math ops exactness
@subsubsection Exactness conversion


These procedures implement the natural one--to-one correspondence
between exact and inexact integer objects throughout an
implementation--dependent range.  The @func{inexact} and @func{exact}
procedures are idempotent.


@deffn Procedure inexact @var{z}
The @func{inexact} procedure returns an inexact representation of
@var{z}.  If inexact number objects of the appropriate type have bounded
precision, then the value returned is an inexact number object that is
nearest to the argument.  If an exact argument has no reasonably close
inexact equivalent, an exception with condition type
@code{&implementation-violation} may be raised.

@quotation
@emph{Note:} For a real number object whose magnitude is finite but so
large that it has no reasonable finite approximation as an inexact
number, a reasonably close inexact equivalent may be @code{+inf.0} or
@code{-inf.0}.  Similarly, the inexact representation of a complex
number object whose components are finite may have infinite components.
@end quotation
@end deffn


@deffn Procedure exact @var{z}
The @func{exact} procedure returns an exact representation of @var{z}.
The value returned is the exact number object that is numerically
closest to the argument; in most cases, the result of this procedure
should be numerically equal to its argument.  If an inexact argument has
no reasonably close exact equivalent, an exception with condition type
@code{&implementation-violation} may be raised.
@end deffn



@c page
@node baselib math ops value pred
@subsubsection Value predicates


@deffn Procedure = @vari{z} @varii{z} @variii{z} @dots{}
@deffnx Procedure < @vari{x} @varii{x} @variii{x} @dots{}
@deffnx Procedure > @vari{x} @varii{x} @variii{x} @dots{}
@deffnx Procedure <= @vari{x} @varii{x} @variii{x} @dots{}
@deffnx Procedure >= @vari{x} @varii{x} @variii{x} @dots{}
These procedures return @true{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, and @false{} otherwise.

Examples:

@example
(= +inf.0 +inf.0)               => #t
(= -inf.0 +inf.0)               => #f
(= -inf.0 -inf.0)               => #t
@end example

@noindent
for any real number object @var{x} that is neither infinite nor NaN:

@example
(< -inf.0 @var{x} +inf.0)       => #t
(> +inf.0 @var{x} -inf.0)       => #t
@end example

@noindent
for any number object @var{z}:

@example
(= +nan.0 @var{z})              => #f
@end example

For any real number object @var{x}:

@example
(< +nan.0 @var{x})              => #f
(> +nan.0 @var{x})              => #f
@end example

These predicates must be transitive.

@quotation
@emph{Note:} The traditional implementations of these predicates in
Lisp--like languages are not transitive.
@end quotation

@quotation
@emph{Note:} While it is possible to compare inexact number objects
using these predicates, the results may be unreliable because a small
inaccuracy may affect the result; this is especially true of @code{=}
and @func{zero?}  (below).

When in doubt, consult a numerical analyst.
@end quotation
@end deffn


@deffn Procedure {zero?} @var{z}
@deffnx Procedure {positive?} @var{x}
@deffnx Procedure {negative?} @var{x}
@deffnx Procedure {odd?} @var{n}
@deffnx Procedure {even?} @var{n}
@deffnx Procedure {finite?} @var{x}
@deffnx Procedure {infinite?} @var{x}
@deffnx Procedure {nan?} @var{x}
These numerical predicates test a number object for a particular
property, returning @true{} or @false{}.

@table @func
@item zero?
Tests if the number object is @code{=} to zero.

@item positive?
Tests whether it is greater than zero.

@item negative?
Tests whether it is less than zero.

@item odd?
Tests whether it is odd.

@item even?
Tests whether it is even.

@item finite?
Tests whether it is not an infinity and not a NaN.

@item infinite?
Tests whether it is an infinity.

@item nan?
Tests whether it is a NaN.
@end table

@example
(zero? +0.0)                  => #t
(zero? -0.0)                  => #t
(zero? +nan.0)                => #f
(positive? +inf.0)            => #t
(negative? -inf.0)            => #t
(positive? +nan.0)            => #f
(negative? +nan.0)            => #f
(finite? +inf.0)              => #f
(finite? 5)                   => #t
(finite? 5.0)                 => #t
(infinite? 5.0)               => #f
(infinite? +inf.0)            => #t
@end example

@quotation
@emph{Note:} As with the predicates above, the results may be unreliable
because a small inaccuracy may affect the result.
@end quotation
@end deffn



@c page
@node baselib math ops comparison
@subsubsection Comparison


@deffn Procedure max @vari{x} @varii{x} @dots{}
@deffnx Procedure min @vari{x} @varii{x} @dots{}
These procedures return the maximum or minimum of their arguments.

@example
(max 3 4)                       =>  4
(max 3.9 4)                     =>  4.0
@end example

For any real number object @var{x} that is not a NaN:

@example
(max +inf.0 @var{x})            =>  +inf.0
(min -inf.0 @var{x})            =>  -inf.0
@end example

@quotation
@emph{Note:} If any argument is inexact, then the result is also inexact
(unless the procedure can prove that the inaccuracy is not large enough
to affect the result, which is possible only in unusual
implementations).  If @func{min} or @func{max} is used to compare number
objects of mixed exactness, and the numerical value of the result cannot
be represented as an inexact number object without loss of accuracy,
then the procedure may raise an exception with condition type
@code{&implementation-restriction}.
@end quotation
@end deffn



@c page
@node baselib math ops arithmetic
@subsubsection Arithmetic operations


@deffn Procedure + @vari{z} @dots{}
@deffnx Procedure * @vari{z} @dots{}
These procedures return the sum or product of their arguments.

@example
(+ 3 4)                                =>  7
(+ 3)                                  =>  3
(+)                                    =>  0
(+ +inf.0 +inf.0)                      =>  +inf.0
(+ +inf.0 -inf.0)                      =>  +nan.0

(* 4)                                  =>  4
(*)                                    =>  1
(* 5 +inf.0)                           =>  +inf.0
(* -5 +inf.0)                          =>  -inf.0
(* +inf.0 +inf.0)                      =>  +inf.0
(* +inf.0 -inf.0)                      =>  -inf.0
(* 0 +inf.0)                           =>  0 or +nan.0
(* 0 +nan.0)                           =>  0 or +nan.0
(* 1.0 0)                              =>  0 or 0.0
@end example

For any real number object @var{x} that is neither infinite nor NaN:

@example
(+ +inf.0 @var{x})                           =>  +inf.0
(+ -inf.0 @var{x})                           =>  -inf.0
@end example

For any real number object @var{x}:

@example
(+ +nan.0 @var{x})                           =>  +nan.0
@end example

For any real number object @var{x} that is not an exact 0:

@example
(* +nan.0 @var{x})                           =>  +nan.0
@end example

If any of these procedures are applied to mixed non--rational real and
non--real complex arguments, they either raise an exception with
condition type @code{&implementation-restriction} or return an
unspecified number object.

Implementations that distinguish @code{-0.0} should adopt behavior
consistent with the following examples:

@example
(+  0.0 -0.0)  =>  0.0
(+ -0.0  0.0)  =>  0.0
(+  0.0  0.0)  =>  0.0
(+ -0.0 -0.0)  => -0.0
@end example
@end deffn


@deffn Procedure - @var{z}
@deffnx Procedure - @vari{z} @varii{z} @variii{z} @dots{}
With two or more arguments, this procedures returns the difference of
its arguments, associating to the left.  With one argument, however, it
returns the additive inverse of its argument.

@example
(- 3 4)                                =>  -1
(- 3 4 5)                              =>  -6
(- 3)                                  =>  -3
(- +inf.0 +inf.0)                      =>  +nan.0
@end example

If this procedure is applied to mixed non--rational real and non--real
complex arguments, it either raises an exception with condition type
@code{&implementation-restriction} or returns an unspecified number
object.

Implementations that distinguish @code{-0.0} should adopt behavior
consistent with the following examples:

@example
(-  0.0)       => -0.0
(- -0.0)       =>  0.0
(-  0.0 -0.0)  =>  0.0
(- -0.0  0.0)  => -0.0
(-  0.0  0.0)  =>  0.0
(- -0.0 -0.0)  =>  0.0
@end example
@end deffn


@deffn Procedure / @var{z}
@deffnx Procedure / @vari{z} @varii{z} @variii{z} @dots{}
If all of the arguments are exact, then the divisors must all be
nonzero.  With two or more arguments, this procedure returns the
quotient of its arguments, associating to the left.  With one argument,
however, it returns the multiplicative inverse of its argument.

@example
(/ 3 4 5)                              =>  3/20
(/ 3)                                  =>  1/3
(/ 0.0)                                =>  +inf.0
(/ 1.0 0)                              =>  +inf.0
(/ -1 0.0)                             =>  -inf.0
(/ +inf.0)                             =>  0.0
(/ 0 0)                                =>  exception &assertion
(/ 3 0)                                =>  exception &assertion
(/ 0 3.5)                              =>  0.0
(/ 0 0.0)                              =>  +nan.0
(/ 0.0 0)                              =>  +nan.0
(/ 0.0 0.0)                            =>  +nan.0
@end example

If this procedure is applied to mixed non--rational real and non--real
complex arguments, it either raises an exception with condition type
@code{&implementation-restriction} or returns an unspecified number
object.
@end deffn


@deffn Procedure abs @var{x}
Returns the absolute value of its argument.

@example
(abs -7)                               =>  7
(abs -inf.0)                           =>  +inf.0
@end example
@end deffn


@deffn Procedure div-and-mod @vari{x} @varii{x}
@deffnx Procedure div @vari{x} @varii{x}
@deffnx Procedure mod @vari{x} @varii{x}
@deffnx Procedure div0-and-mod0 @vari{x} @varii{x}
@deffnx Procedure div0 @vari{x} @varii{x}
@deffnx Procedure mod0 @vari{x} @varii{x}
These procedures implement number--theoretic integer division and return
the results of the corresponding mathematical operations specified in
@ref{baselib math semantics integer}.  If @vari{x} and @varii{x} are exact,
@varii{x} must be nonzero. In the cases where the mathematical
requirements in @ref{baselib math semantics integer} cannot be satisfied by
any number object, either an exception is raised with condition type
@code{&implementation-restriction}, or unspecified number objects (one
for for @func{div}, @func{mod}, @func{div0} and @func{mod0}, two for
@func{div-and-mod} and @func{div0-and-mod0}) are returned.

@example
(div @vari{x} @varii{x})                => @vari{x} div @varii{x}
(mod @vari{x} @varii{x})                => @vari{x} mod @varii{x}

(div-and-mod @vari{x} @varii{x})
=> @vari{x} div @varii{x}, @vari{x} mod @varii{x} ;; two return values

(div0 @vari{x} @varii{x})               => @vari{x} div_0 @varii{x}
(mod0 @vari{x} @varii{x})               => @vari{x} mod_0 @varii{x}

(div0-and-mod0 @vari{x} @varii{x})
=> @vari{x} div_0 @varii{x}, @vari{x} mod_0 @varii{x} ;; two return values
@end example
@end deffn


@deffn Procedure gcd @vari{n} @dots{}
@deffnx Procedure lcm @vari{n} @dots{}
These procedures return the greatest common divisor or least common
multiple of their arguments.  The result is always non--negative.

@example
(gcd 32 -36)                           =>  4
(gcd)                                  =>  0
(lcm 32 -36)                           =>  288
(lcm 32.0 -36)                         =>  288.0
(lcm)                                  =>  1
@end example
@end deffn


@c page
@node baselib math ops part
@subsubsection Part separation


@deffn Procedure numerator @var{q}
@deffnx Procedure denominator @var{q}
These procedures return the numerator or denominator of their argument;
the result is computed as if the argument was represented as a fraction
in lowest terms.  The denominator is always positive.  The denominator
of @code{0} is defined to be @code{1}.

@example
(numerator   (/ 6 4))                  =>  3
(denominator (/ 6 4))                  =>  2
(denominator (inexact (/ 6 4)))        =>  2.0
@end example
@end deffn


@deffn Procedure floor @var{x}
@deffnx Procedure ceiling @var{x}
@deffnx Procedure truncate @var{x}
@deffnx Procedure round @var{x}
These procedures return inexact integer objects for inexact arguments
that are not infinities or NaNs, and exact integer objects for exact
rational arguments.

@table @func
@item floor
Returns the largest integer object not larger than @var{x}.

@item ceiling
Returns the smallest integer object not smaller than @var{x}.

@item truncate
Returns the integer object closest to @var{x} whose absolute value is
not larger than the absolute value of @var{x}.

@item round
Returns the closest integer object to @var{x}, rounding to even when
@var{x} represents a number halfway between two integers.
@end table

If the argument to one of these procedures is inexact, then the result
is also inexact.  If an exact value is needed, the result should be
passed to the @func{exact} procedure.

Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN.

@example
(floor -4.3)                           =>  -5.0
(ceiling -4.3)                         =>  -4.0
(truncate -4.3)                        =>  -4.0
(round -4.3)                           =>  -4.0

(floor 3.5)                            =>  3.0
(ceiling 3.5)                          =>  4.0
(truncate 3.5)                         =>  3.0
(round 3.5)                            =>  4.0

(round 7/2)                            =>  4
(round 7)                              =>  7

(floor +inf.0)                         =>  +inf.0
(ceiling -inf.0)                       =>  -inf.0
(round +nan.0)                         =>  +nan.0
@end example
@end deffn


@deffn Procedure rationalize @vari{x} @varii{x}
The @func{rationalize} procedure returns a number object representing
the @emph{simplest} rational number differing from @vari{x} by no more
than @varii{x}.

A rational number @emph{r_1} is @emph{simpler} than another rational
number @emph{r_2} if @code{r_1 = p_1/q_1} and @code{r_2 = p_2/q_2} (in
lowest terms) and @code{|p_1| <= |p_2|} and @code{|q_1| <= |q_2|}.  Thus
@code{3/5} is simpler than @code{4/7}.

Although not all rationals are comparable in this ordering (consider
@code{2/7} and @code{3/5}) any interval contains a rational number that
is simpler than every other rational number in that interval (the
simpler @code{2/5} lies between @code{2/7} and @code{3/5}).

Note that @code{0 = 0/1} is the simplest rational of all.

@example
(rationalize (exact .3) 1/10)          => 1/3
(rationalize .3 1/10)                  => #i1/3  ; approximately

(rationalize +inf.0 3)                 =>  +inf.0
(rationalize +inf.0 +inf.0)            =>  +nan.0
(rationalize 3 +inf.0)                 =>  0.0
@end example

The first two examples hold only in implementations whose inexact real
number objects have sufficient precision.
@end deffn


@c page
@node baselib math ops trascend
@subsubsection Trascendental functions


@deffn Procedure exp @var{z}
@deffnx Procedure log @var{z}
@deffnx Procedure log @vari{z} @varii{z}
@deffnx Procedure sin @var{z}
@deffnx Procedure cos @var{z}
@deffnx Procedure tan @var{z}
@deffnx Procedure asin @var{z}
@deffnx Procedure acos @var{z}
@deffnx Procedure atan @var{z}
@deffnx Procedure atan @vari{x} @varii{x}
These procedures compute the usual transcendental functions.

The @func{exp} procedure computes the base--@var{e} exponential of
@var{z}.

The @func{log} procedure with a single argument computes the natural
logarithm of @var{z} (@strong{not} the base--10 logarithm); @code{(log
@vari{z} @varii{z})} computes the base--@varii{z} logarithm of @vari{z}.

The @func{asin}, @func{acos}, and @func{atan} procedures compute
arcsine, arccosine, and arctangent, respectively.  The two--argument
variant of @func{atan} computes:

@example
(angle (make-rectangular @varii{x} @vari{x}))
@end example

These procedures may return inexact results even when given exact
arguments.

@example
(exp +inf.0)    => +inf.0
(exp -inf.0)    => 0.0
(log +inf.0)    => +inf.0
(log 0.0)       => -inf.0
(log 0)         => exception &assertion
(log -inf.0)    => +inf.0+3.141592653589793i    ; approximately
(atan -inf.0)   => -1.5707963267948965          ; approximately
(atan +inf.0)   => 1.5707963267948965           ; approximately
(log -1.0+0.0i) => 0.0+3.141592653589793i       ; approximately
(log -1.0-0.0i) => 0.0-3.141592653589793i       ; approximately
                                                ; if -0.0 is distinguished
@end example
@end deffn



@c page
@node baselib math ops exponentiation
@subsubsection Exponentiation functions


@deffn Procedure sqrt @var{z}
Return the principal square root of @var{z}.  For rational @var{z}, the
result has either positive real part, or zero real part and
non--negative imaginary part.  With @emph{log} defined as in @ref{baselib
math semantics trascend}, the value of @code{(sqrt @var{z})} could be
expressed as:

@example
e^((log z)/2)
@end example

The @func{sqrt} procedure may return an inexact result even when given
an exact argument.

@example
(sqrt -5)                   =>  0.0+2.23606797749979i ; approximately
(sqrt +inf.0)               =>  +inf.0
(sqrt -inf.0)               =>  +inf.0i
@end example
@end deffn


@deffn Procedure exact-integer-sqrt @var{k}
The @func{exact-integer-sqrt} procedure returns two non--negative exact
integer objects @emph{s} and @emph{r} where @code{@var{k} = s^2 + r} and
@code{@var{k} < (s+1)^2}.

@example
(exact-integer-sqrt 4)  => 2 0 ; two return values
(exact-integer-sqrt 5)  => 2 1 ; two return values
@end example
@end deffn


@deffn Procedure expt @vari{z} @varii{z}
Return @vari{z} raised to the power @varii{z}.  For non--zero @vari{z},
this is @code{e^(z_2 log z_1)}.  @code{0.0^z} is @code{1.0} if
@code{@var{z} = 0.0}, and @code{0.0} if @code{(real-part @var{z})} is
positive.  For other cases in which the first argument is zero, either
an exception is raised with condition type
@code{&implementation-restriction}, or an unspecified number object is
returned.

For an exact real number object @vari{z} and an exact integer object
@varii{z}, @code{(expt @vari{z} @varii{z})} must return an exact result.
For all other values of @vari{z} and @varii{z}, @code{(expt @vari{z}
@varii{z})} may return an inexact result, even when both @vari{z} and
@varii{z} are exact.

@example
(expt 5 3)                  =>  125
(expt 5 -3)                 =>  1/125
(expt 5 0)                  =>  1
(expt 0 5)                  =>  0
(expt 0 5+.0000312i)        =>  0.0
(expt 0 -5)                 =>  unspecified
(expt 0 -5+.0000312i)       =>  unspecified
(expt 0 0)                  =>  1
(expt 0.0 0.0)              =>  1.0
@end example
@end deffn



@c page
@node baselib math ops complex
@subsubsection Complex numbers functions


@deffn Procedure make-rectangular @vari{x} @varii{x}
@deffnx Procedure make-polar @variii{x} @variv{x}
@deffnx Procedure real-part @var{z}
@deffnx Procedure imag-part @var{z}
@deffnx Procedure magnitude @var{z}
@deffnx Procedure angle @var{z}
Suppose @emph{a_1}, @emph{a_2}, @emph{a_3}, and @emph{a_4} are real
numbers, and @emph{c} is a complex number such that the following holds:

@example
c = a_1 + a_2 i = a_3 e^(i a_4)
@end example

Then, if @vari{x}, @varii{x}, @variii{x}, and @variv{x} are number
objects representing @emph{a_1}, @emph{a_2}, @emph{a_3}, and @emph{a_4},
respectively, @code{(make-rectangular @vari{x} @varii{x})} returns
@emph{c}, and @code{(make-polar @variii{x} @variv{x})} returns @emph{c}.

@example
(make-rectangular 1.1 2.2)    => 1.1+2.2i ; approximately
(make-polar 1.1 2.2)          => 1.1@@2.2 ; approximately
@end example

Conversely, if @code{-pi <= a_4 <= pi}, and if @emph{z} is a number
object representing @emph{c}, then @code{(real-part @var{z})} returns
@emph{a_1}, @code{(imag-part @var{z})} returns @emph{a_2},
@code{(magnitude @var{z})} returns @emph{a_3}, and @code{(angle
@var{z})} returns @emph{a_4}.

@example
(real-part 1.1+2.2i)              => 1.1  ; approximately
(imag-part 1.1+2.2i)              => 2.2  ; approximately
(magnitude 1.1@@2.2)              => 1.1  ; approximately
(angle     1.1@@2.2)              => 2.2  ; approximately

(angle -1.0)            => 3.141592653589793 ; approximately
(angle -1.0+0.0i)       => 3.141592653589793 ; approximately
(angle -1.0-0.0i)       => -3.141592653589793
                        ; approximately if -0.0 is distinguished
(angle +inf.0)          => 0.0
(angle -inf.0)          => 3.141592653589793 ; approximately
@end example

Moreover, suppose @vari{x}, @varii{x} are such that either @vari{x} or
@varii{x} is an infinity, then

@example
(make-rectangular @vari{x} @varii{x})   => @var{z}
(magnitude @var{z})                     => +inf.0
@end example

The @func{make-polar}, @func{magnitude}, and @func{angle} procedures may
return inexact results even when given exact arguments.

@example
(angle -1)              => 3.141592653589793 ; approximately
@end example
@end deffn



@c page
@node baselib math string
@subsection Numerical Input and Output


@deffn Procedure {number->string} @var{z}
@deffnx Procedure {number->string} @var{z} @var{radix}
@deffnx Procedure {number->string} @var{z} @var{radix} @var{precision}
The @func{number->string} procedure takes a number object and a radix
and returns as a string an external representation of the given number
object in the given radix such that:

@example
(let ((number   @var{z})
      (radix    @var{radix}))
  (eqv?
    (string->number (number->string number radix) radix)
    number))
@end example

@noindent
is true.  If no possible result makes this expression true, an exception
with condition type @code{&implementation-restriction} is raised.

@var{radix} must be an exact integer object, either @code{2}, @code{8},
@code{10}, or @code{16}.  If omitted, @var{radix} defaults to @code{10}.
If a @var{precision} is specified, then @var{z} must be an inexact
complex number object, @var{precision} must be an exact positive integer
object, and @var{radix} must be @code{10}.

@quotation
@emph{Note:} The error case can occur only when @var{z} is not a complex
number object or is a complex number object with a non--rational real or
imaginary part.
@end quotation

If a @var{precision} is specified, then the representations of the
inexact real components of the result, unless they are infinite or NaN,
specify an explicit @meta{mantissa width} @var{p}, and @var{p} is the
least @emph{@var{p} >= @var{precision}} for which the above expression
is true.

If @var{z} is inexact, the radix is @code{10}, and the above expression
and condition can be satisfied by a result that contains a decimal
point, then the result contains a decimal point and is expressed using
the minimum number of digits (exclusive of exponent, trailing zeroes,
and mantissa width) needed to make the above expression and condition
true; otherwise the format of the result is unspecified.

The result returned by @func{number->string} never contains an explicit
radix prefix.
@end deffn


@deffn Procedure {string->number} @var{string}
@deffnx Procedure {string->number} @var{string} @var{radix}
Return a number object with maximally precise representation expressed
by the given @var{string}.

@var{radix} must be an exact integer object, either @code{2}, @code{8},
@code{10}, or @code{16}.  If supplied, @var{radix} is a default radix
that may be overridden by an explicit radix prefix in @var{string}
(e.g. @code{#o177}).  If @var{radix} is not supplied, then the default
radix is @code{10}.

If @var{string} is not a syntactically valid notation for a number
object or a notation for a rational number object with a zero
denominator, then @func{string->number} returns @false{}.

@example
(string->number "100")                 => 100
(string->number "100" 16)              => 256
(string->number "1e2")                 => 100.0
(string->number "0/0")                 => #f
(string->number "+inf.0")              => +inf.0
(string->number "-inf.0")              => -inf.0
(string->number "+nan.0")              => +nan.0
@end example

@quotation
@emph{Note:} The @func{string->number} procedure always returns a number
object or @false{}; it never raises an exception.
@end quotation
@end deffn



@c page
@node baselib booleans
@section Booleans


The standard boolean objects for true and false have external
representations @true{} and @false{}.  However, of all objects, only
@false{} counts as false in conditional expressions.

@quotation
@emph{Note:} Programmers accustomed to other dialects of Lisp should be
aware that Scheme distinguishes both @false{} and the empty list from
each other and from the symbol @code{nil}.
@end quotation


@deffn Procedure not @var{obj}
Return @true{} if @var{obj} is @false{}, or @false{} otherwise.

@example
(not #t)         => #f
(not 3)          => #f
(not (list 3))   => #f
(not #f)         => #t
(not '())        => #f
(not (list))     => #f
(not 'nil)       => #f
@end example
@end deffn


@deffn Procedure {boolean?} @var{obj}
Return @true{} if @var{obj} is either @true{} or @false{}, or @false{}
otherwise.

@example
(boolean? #f)   => #t
(boolean? 0)    => #f
(boolean? '())  => #f
@end example
@end deffn


@deffn Procedure {boolean=?} @vari{bool} @varii{bool} @variii{bool} @dots{}
Return @true{} if the booleans are the same.
@end deffn



@c page
@node baselib lists
@section Pairs and lists


A @emph{pair} is a compound structure with two fields called the car and
cdr fields (for historical reasons).  Pairs are created by the procedure
@func{cons}.  The car and cdr fields are accessed by the procedures
@func{car} and @func{cdr}.

Pairs are used primarily to represent lists.  A list can be defined
recursively as either the empty list or a pair whose cdr is a list.
More precisely, the set of lists is defined as the smallest set @var{X}
such that:

@itemize
@item
The empty list is in @var{X}.

@item
If @var{list} is in @var{X}, then any pair whose cdr field contains
@var{list} is also in @var{X}.
@end itemize

The objects in the car fields of successive pairs of a list are the
elements of the list.  For example, a two--element list is a pair whose
car is the first element and whose cdr is a pair whose car is the second
element and whose cdr is the empty list.  The length of a list is the
number of elements, which is the same as the number of pairs.

The empty list is a special object of its own type.  It is not a pair.
It has no elements and its length is zero.

@quotation
@emph{Note:} The above definitions imply that all lists have finite
length and are terminated by the empty list.
@end quotation

A chain of pairs not ending in the empty list is called an
@emph{improper list}.  Note that an improper list is not a list.  The
list and dotted notations can be combined to represent improper lists:

@example
(a b c . d)
@end example

@noindent
is equivalent to

@example
(a . (b . (c . d)))
@end example

Whether a given pair is a list depends upon what is stored in the cdr
field.


@deffn Procedure {pair?} @var{obj}
Return @true{} if @var{obj} is a pair, @false{} otherwise.

@example
(pair? '(a . b))        => #t
(pair? '(a b c))        => #t
(pair? '())             => #f
(pair? '#(a b))         => #f
@end example
@end deffn


@deffn Procedure cons @vari{obj} @varii{obj}
Return a newly allocated pair whose car is @vari{obj} and whose cdr is
@varii{obj}.  The pair is guaranteed to be different (in the sense of
@func{eqv?}) from every existing object.

@example
(cons 'a '())           =>  (a)
(cons '(a) '(b c d))    =>  ((a) b c d)
(cons "a" '(b c))       =>  ("a" b c)
(cons 'a 3)             =>  (a . 3)
(cons '(a b) 'c)        =>  ((a b) . c)
@end example
@end deffn


@deffn Procedure car @var{pair}
Return the contents of the car field of @var{pair}.

@example
(car '(a b c))          => a
(car '((a) b c d))      => (a)
(car '(1 . 2))          => 1
(car '())               => exception &assertion
@end example
@end deffn


@deffn Procedure cdr @var{pair}
Return the contents of the cdr field of @var{pair}.

@example
(cdr '((a) b c d))      => (b c d)
(cdr '(1 . 2))          => 2
(cdr '())               => exception &assertion
@end example
@end deffn


@deffn Procedure caar @var{pair}
@deffnx Procedure cadr @var{pair}
@deffnx Procedure ...
@deffnx Procedure cdddar @var{pair}
@deffnx Procedure cddddr @var{pair}
These procedures are compositions of @func{car} and @func{cdr}, where
for example @func{caddr} could be defined by

@example
(define caddr (lambda (x) (car (cdr (cdr x)))))
@end example

Arbitrary compositions, up to four deep, are provided.  There are
twenty--eight of these procedures in all.
@end deffn


@deffn Procedure {null?} @var{obj}
Return @true{} if @var{obj} is the empty list, @false{} otherwise.
@end deffn


@deffn Procedure {list?} @var{obj}
Return @true{} if @var{obj} is a list, @false{} otherwise.  By
definition, all lists are chains of pairs that have finite length and
are terminated by the empty list.

@example
(list? '(a b c))     => #t
(list? '())          => #t
(list? '(a . b))     => #f
@end example
@end deffn


@deffn Procedure list @var{obj} @dots{}
Return a newly allocated list of its arguments.

@example
(list 'a (+ 3 4) 'c)    => (a 7 c)
(list)                  => ()
@end example
@end deffn


@deffn Procedure length @var{list}
Return the length of @var{list}.

@example
(length '(a b c))               =>  3
(length '(a (b) (c d e)))       =>  3
(length '())                    =>  0
@end example
@end deffn


@deffn Procedure append
@deffnx Procedure append @var{list} @dots{} @var{obj}
Return a possibly improper list consisting of the elements of the first
@var{list} followed by the elements of the other @var{list}s, with
@var{obj} as the cdr of the final pair.  An improper list results if
@var{obj} is not a list.

@example
(append '(x) '(y))              =>  (x y)
(append '(a) '(b c d))          =>  (a b c d)
(append '(a (b)) '((c)))        =>  (a (b) (c))
(append '(a b) '(c . d))        =>  (a b c . d)
(append '() 'a)                 =>  a
@end example

If @func{append} constructs a non--empty chain of pairs, it is always
newly allocated.  If no pairs are allocated, @var{obj} is returned.
@end deffn


@deffn Procedure reverse @var{list}
Return a newly allocated list consisting of the elements of @var{list}
in reverse order.

@example
(reverse '(a b c))              => (c b a)
(reverse '(a (b c) d (e (f))))  => ((e (f)) d (b c) a)
@end example
@end deffn


@deffn Procedure list-tail @var{list} @var{k}
@var{list} should be a list of size at least @var{k}.  Return the
subchain of pairs of @var{list} obtained by omitting the first @var{k}
elements.

@example
(list-tail '(a b c d) 2)        =>  (c d)
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs whose length is at least @var{k}.
It should not check that it is a chain of pairs beyond this length.
@end deffn


@deffn Procedure list-ref @var{list} @var{k}
@var{list} must be a list whose length is at least @emph{@var{k} + 1}.
The @func{list-tail} procedure returns the @var{k}th element of
@var{list}.

@example
(list-ref '(a b c d) 2)         => c
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs whose length is at least
@emph{@var{k} + 1}.  It should not check that it is a list of pairs
beyond this length.
@end deffn


@deffn Procedure map @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s should all have the same length.  @var{proc} should
accept as many arguments as there are @var{list}s and return a single
value.  @var{proc} should not mutate any of the @var{list}s.

The @func{map} procedure applies @var{proc} element--wise to the
elements of the @var{list}s and returns a list of the results, in order.
@var{proc} is always called in the same dynamic environment as
@func{map} itself.  The order in which @var{proc} is applied to the
elements of the @var{list}s is unspecified.  If multiple returns occur
from @func{map}, the values returned by earlier returns are not mutated.

@example
(map cadr '((a b) (d e) (g h)))         =>  (b e h)

(map (lambda (n) (expt n n))
     '(1 2 3 4 5))                      =>  (1 4 27 256 3125)

(map + '(1 2 3) '(4 5 6))               =>  (5 7 9)

(let ((count 0))
  (map (lambda (ignored)
         (set! count (+ count 1))
         count)
       '(a b)))                         =>  (1 2) or (2 1)
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{proc} to the extent performed by
applying it as described.  An implementation may check whether
@var{proc} is an appropriate argument before applying it.
@end deffn


@deffn Procedure for-each @var{proc} @vari{list} @varii{list} @dots{}
The @var{list}s should all have the same length.  @var{proc} should
accept as many arguments as there are @var{list}s.  @var{proc} should
not mutate any of the @var{list}s.

The @func{for-each} procedure applies @var{proc} element--wise to the
elements of the @var{list}s for its side effects, in order from the
first elements to the last.  @var{proc} is always called in the same
dynamic environment as @func{for-each} itself.  The return values of
@func{for-each} are unspecified.

@example
(let ((v (make-vector 5)))
  (for-each (lambda (i)
              (vector-set! v i (* i i)))
            '(0 1 2 3 4))
  v)
=>  #(0 1 4 9 16)

(for-each (lambda (x) x) '(1 2 3 4))
=> unspecified

(for-each even? '())
=> unspecified
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{proc} to the extent performed by
applying it as described.  An implementation may check whether
@var{proc} is an appropriate argument before applying it.

@quotation
@emph{Note:} Implementations of @code{for-each} may or may not
tail--call @var{proc} on the last elements.
@end quotation
@end deffn



@c page
@node baselib symbols
@section Symbols


Symbols are objects whose usefulness rests on the fact that two symbols
are identical (in the sense of @func{eq?}, @func{eqv?} and
@func{equal?}) if and only if their names are spelled the same way.  A
symbol literal is formed using @func{quote}.


@deffn Procedure {symbol?} @var{obj}
Return @true{} if @var{obj} is a symbol, @false{} otherwise.

@example
(symbol? 'foo)          => #t
(symbol? (car '(a b)))  => #t
(symbol? "bar")         => #f
(symbol? 'nil)          => #t
(symbol? '())           => #f
(symbol? #f)            => #f
@end example
@end deffn


@deffn Procedure {symbol->string} @var{symbol}
Return the name of @var{symbol} as an immutable string.

@example
(symbol->string 'flying-fish)                   =>  "flying-fish"
(symbol->string 'Martin)                        =>  "Martin"
(symbol->string (string->symbol "Malvina"))     =>  "Malvina"
@end example
@end deffn


@deffn Procedure {symbol=?} @vari{symbol} @varii{symbol} @variii{symbol} @dots{}
Return @true{} if the symbols are the same, i.e., if their names are
spelled the same.
@end deffn


@deffn Procedure {string->symbol} @var{string}
Return the symbol whose name is @var{string}.

@example
(eq? 'mISSISSIppi 'mississippi)
=> #f

(string->symbol "mISSISSIppi")
=> the symbol with name "mISSISSIppi"

(eq? 'bitBlt (string->symbol "bitBlt"))
=> #t

(eq? 'JollyWog (string->symbol (symbol->string 'JollyWog)))
=> #t

(string=? "K. Harper, M.D."
          (symbol->string (string->symbol "K. Harper, M.D.")))
=> #t
@end example
@end deffn



@c page
@node baselib characters
@section Characters


@emph{Characters} are objects that represent Unicode scalar values.

@quotation
Unicode defines a standard mapping between sequences of @emph{Unicode
scalar values} (integers in the range @code{0} to @code{#x10FFFF},
excluding the range @code{#xD800} to @code{#xDFFF}) in the latest
version of the standard and human--readable ``characters''.

More precisely, Unicode distinguishes between glyphs, which are printed
for humans to read, and characters, which are abstract entities that map
to glyphs (sometimes in a way that's sensitive to surrounding
characters).  Furthermore, different sequences of scalar values
sometimes correspond to the same character.  The relationships among
scalar, characters, and glyphs are subtle and complex.

Despite this complexity, most things that a literate human would call a
``character'' can be represented by a single Unicode scalar value
(although several sequences of Unicode scalar values may represent that
same character).  For example, Roman letters, Cyrillic letters, Hebrew
consonants, and most Chinese characters fall into this category.

Unicode scalar values exclude the range @code{#xD800} to @code{#xDFFF},
which are part of the range of Unicode @emph{code points}.  However, the
Unicode code points in this range, the so--called @emph{surrogates}, are
an artifact of the @utf{}--16 encoding, and can only appear in specific
Unicode encodings, and even then only in pairs that encode scalar
values.  Consequently, all characters represent code points, but the
surrogate code points do not have representations as characters.
@end quotation


@deffn Procedure {char?} @var{obj}
Return @true{} if @var{obj} is a character, @false{} otherwise.
@end deffn


@deffn Procedure {char->integer} @var{char}
@deffnx Procedure {integer->char} @var{sv}
@var{sv} must be a Unicode scalar value, i.e., a non--negative exact
integer object in @code{[0, #xD7FF] union [#xE000, #x10FFFF]}.

Given a character, @func{char->integer} returns its Unicode scalar value
as an exact integer object.  For a Unicode scalar value @var{sv},
@func{integer->char} returns its associated character.

@example
(integer->char 32) =>                   #\space
(char->integer (integer->char 5000))    => 5000
(integer->char #\xD800)                 => exception &assertion
@end example
@end deffn


@deffn Procedure {char=?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char<?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char>?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char<=?} @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure {char>=?} @vari{char} @varii{char} @variii{char} @dots{}
These procedures impose a total ordering on the set of characters
according to their Unicode scalar values.

@example
@c (char<? #\z #\\ss)      => #t
(char<? #\z #\Z)        => #f
@end example
@end deffn



@c page
@node baselib strings
@section Strings


Strings are sequences of characters.  The @emph{length} of a string is
the number of characters that it contains.  This number is fixed when
the string is created.  The @emph{valid indices} of a string are the
integers less than the length of the string.  The first character of a
string has index 0, the second has index 1, and so on.


@deffn Procedure {string?} @var{obj}
Return @true{} if @var{obj} is a string, @false{} otherwise.
@end deffn


@deffn Procedure make-string @var{k}
@deffnx Procedure make-string @var{k} @var{char}
Return a newly allocated string of length @var{k}.  If @var{char} is
given, then all elements of the string are initialized to @var{char},
otherwise the contents of the @var{string} are unspecified.
@end deffn


@deffn Procedure string @var{char} @dots{}
Return a newly allocated string composed of the arguments.
@end deffn


@deffn Procedure string-length @var{string}
Return the number of characters in the given @var{string} as an exact
integer object.
@end deffn


@deffn Procedure string-ref @var{string} @var{k}
@var{k} must be a valid index of @var{string}.  The @func{string-ref}
procedure returns character @var{k} of @var{string} using zero--origin
indexing.

@quotation
@emph{Note:} Implementors should make @func{string-ref} run in constant
time.
@end quotation
@end deffn


@deffn Procedure {string=?} @vari{string} @varii{string} @variii{string} @dots{}
Return @true{} if the strings are the same length and contain the same
characters in the same positions.  Otherwise, the @func{string=?}
procedure returns @false{}.

@example
(string=? "Strause" "Strasse")    => #f
@end example
@end deffn


@deffn Procedure {string<?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string>?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string<=?} @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure {string>=?} @vari{string} @varii{string} @variii{string} @dots{}
These procedures are the lexicographic extensions to strings of the
corresponding orderings on characters.  For example, @func{string<?} is
the lexicographic ordering on strings induced by the ordering
@func{char<?} on characters.  If two strings differ in length but are
the same up to the length of the shorter string, the shorter string is
considered to be lexicographically less than the longer string.

@example
(string<? "z" "a")      => #t
(string<? "z" "zz")     => #t
(string<? "z" "Z")      => #f
@end example
@end deffn


@deffn Procedure substring @var{string} @var{start} @var{end}
@var{string} must be a string, and @var{start} and @var{end} must be
exact integer objects satisfying:

@example
0 <= @var{start} <= @var{end} <= (string-length @var{string})
@end example

The @func{substring} procedure returns a newly allocated string formed
from the characters of @var{string} beginning with index @var{start}
(inclusive) and ending with index @var{end} (exclusive).
@end deffn


@deffn Procedure string-append @var{string} @dots{}
Return a newly allocated string whose characters form the concatenation
of the given strings.
@end deffn


@deffn Procedure string->list @var{string}
@deffnx Procedure list->string @var{list}
@var{list} must be a list of characters.

The @func{string->list} procedure returns a newly allocated list of the
characters that make up the given string.

The @func{list->string} procedure returns a newly allocated string
formed from the characters in @var{list}.

The @func{string->list} and @func{list->string} procedures are inverses
so far as @func{equal?} is concerned.
@end deffn


@deffn Procedure string-for-each @var{proc} @vari{string} @varii{string} @dots{}
The @var{string}s must all have the same length.  @var{proc} should
accept as many arguments as there are @var{string}s.

The @func{string-for-each} procedure applies @var{proc} element--wise to
the characters of the @var{string}s for its side effects, in order from
the first characters to the last.  @var{proc} is always called in the
same dynamic environment as @func{string-for-each} itself.  The return
values of @func{string-for-each} are unspecified.

Analogous to @func{for-each}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure string-copy @var{string}
Returns a newly allocated copy of the given @var{string}.
@end deffn



@c page
@node baselib vectors
@section Vectors


Vectors are heterogeneous structures whose elements are indexed by
integers.  A vector typically occupies less space than a list of the
same length, and the average time needed to access a randomly chosen
element is typically less for the vector than for the list.

The @emph{length} of a vector is the number of elements that it
contains.  This number is a non--negative integer that is fixed when the
vector is created.  The @emph{valid indices} of a vector are the exact
non--negative integer objects less than the length of the vector.  The
first element in a vector is indexed by zero, and the last element is
indexed by one less than the length of the vector.

Like list constants, vector constants must be quoted:

@example
'#(0 (2 2 2 2) "Anna")     =>  #(0 (2 2 2 2) "Anna")
@end example


@deffn Procedure vector? @var{obj}
Return @true{} if @var{obj} is a vector, @false{} otherwise.
@end deffn


@deffn Procedure make-vector @var{k}
@deffnx Procedure make-vector @var{k} @var{fill}
Return a newly allocated vector of @var{k} elements.  If a second
argument is given, then each element is initialized to @var{fill}.
Otherwise the initial contents of each element is unspecified.
@end deffn


@deffn Procedure vector @var{obj} @dots{}
Return a newly allocated vector whose elements contain the given
arguments.  Analogous to @code{list}.

@example
(vector 'a 'b 'c)               =>  #(a b c)
@end example
@end deffn


@deffn Procedure vector-length @var{vector}
Return the number of elements in @var{vector} as an exact integer
object.
@end deffn


@deffn Procedure vector-ref @var{vector} @var{k}
@var{k} must be a valid index of @var{vector}.  The @func{vector-ref}
procedure returns the contents of element @var{k} of @var{vector}.

@example
(vector-ref '#(1 1 2 3 5 8 13 21) 5)     =>  8
@end example
@end deffn


@deffn Procedure vector-set! @var{vector} @var{k} @var{obj}
@var{k} must be a valid index of @var{vector}.  The @func{vector-set!}
procedure stores @var{obj} in element @var{k} of @var{vector}, and
returns unspecified.

Passing an immutable vector to @func{vector-set!} should cause an
exception with condition type @code{&assertion} to be raised.

@example
(let ((vec (vector 0 '(2 2 2 2) "Anna")))
  (vector-set! vec 1 '("Sue" "Sue"))
  vec)
=>  #(0 ("Sue" "Sue") "Anna")

(vector-set! '#(0 1 2) 1 "doe")
=>  unspecified
    ;; constant vector
    ;; should raise exception &assertion
@end example
@end deffn


@deffn Procedure vector->list @var{vector}
@deffnx Procedure list->vector @var{list}
The @func{vector->list} procedure returns a newly allocated list of the
objects contained in the elements of @var{vector}.

The @func{list->vector} procedure returns a newly created vector
initialized to the elements of the list @var{list}.

@example
(vector->list '#(dah dah didah))        =>  (dah dah didah)
(list->vector '(dididit dah))           =>  #(dididit dah)
@end example
@end deffn


@deffn Procedure {vector-fill!} @var{vector fill}
Store @var{fill} in every element of @var{vector} and returns
unspecified.
@end deffn


@deffn Procedure vector-map @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} should
accept as many arguments as there are @var{vector}s and return a single
value.

The @func{vector-map} procedure applies @var{proc} element--wise to the
elements of the @var{vector}s and returns a vector of the results, in
order.  @var{proc} is always called in the same dynamic environment as
@func{vector-map} itself.  The order in which @var{proc} is applied to
the elements of the @var{vector}s is unspecified.  If multiple returns
occur from @func{vector-map}, the return values returned by earlier
returns are not mutated.

Analogous to @func{map}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure vector-for-each @var{proc} @vari{vector} @varii{vector} @dots{}
The @var{vector}s must all have the same length.  @var{proc} should
accept as many arguments as there are @var{vector}s.  The
@code{vector-for-each} procedure applies @var{proc} element--wise to the
elements of the @var{vector}s for its side effects, in order from the
first elements to the last.  @var{proc} is always called in the same
dynamic environment as @func{vector-for-each} itself.  The return values
of @func{vector-for-each} are unspecified.

Analogous to @func{for-each}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn



@c page
@node baselib errors
@section Errors and violations


@deffn Procedure error @var{who} @var{message} @vari{irritant} @dots{}
@deffnx Procedure assertion-violation @var{who} @var{message} @vari{irritant} @dots{}
@var{who} must be a string or a symbol or @false{}.  @var{message} must
be a string.  The @var{irritant}s are arbitrary objects.

These procedures raise an exception.  The @func{error} procedure should
be called when an error has occurred, typically caused by something that
has gone wrong in the interaction of the program with the external world
or the user.  The @func{assertion-violation} procedure should be called
when an invalid call to a procedure was made, either passing an invalid
number of arguments, or passing an argument that it is not specified to
handle.

The @var{who} argument should describe the procedure or operation that
detected the exception.  The @var{message} argument should describe the
exceptional situation.  The @var{irritant}s should be the arguments to
the operation that detected the operation.

The condition object provided with the exception has the following
condition types:

@itemize
@item
If @var{who} is not @false{}, the condition has condition type
@code{&who}, with @var{who} as the value of its field.  In that case,
@var{who} should be the name of the procedure or entity that detected
the exception.  If it is @false{}, the condition does not have condition
type @code{&who}.

@item
The condition has condition type @code{&message}, with @var{message} as
the value of its field.

@item
The condition has condition type @code{&irritants}, and its field has as
its value a list of the @var{irritant}s.
@end itemize

Moreover, the condition created by @func{error} has condition type
@code{&error}, and the condition created by @func{assertion-violation}
has condition type @code{&assertion}.

@example
(define (fac n)
  (if (not (integer-valued? n))
      (assertion-violation
       'fac "non-integral argument" n))
  (if (negative? n)
      (assertion-violation
       'fac "negative argument" n))
  (letrec
    ((loop (lambda (n r)
             (if (zero? n)
                 r
                 (loop (- n 1) (* r n))))))
      (loop n 1)))

(fac 5)         => 120
(fac 4.5)       => exception &assertion
(fac -3)        => exception &assertion
@end example
@end deffn


@deffn Syntax assert @meta{expression}
An @func{assert} form is evaluated by evaluating @meta{expression}.  If
@meta{expression} returns a true value, that value is returned from the
@func{assert} expression.  If @meta{expression} returns @false{}, an
exception with condition types @code{&assertion} and @code{&message} is
raised.  The message provided in the condition object is
implementation--dependent.

@quotation
@emph{Note:} Implementations should exploit the fact that @func{assert}
is syntax to provide as much information as possible about the location
of the assertion failure.
@end quotation
@end deffn



@c page
@node baselib control
@section Control features


This chapter describes various primitive procedures which control the
flow of program execution in special ways.


@deffn Procedure apply @var{proc} @vari{arg} @dots{} @var{rest-args}
@var{rest-args} must be a list.  @var{proc} should accept @emph{n}
arguments, where @emph{n} is number of @var{arg}s plus the length of
@var{rest-args}.  The @func{apply} procedure calls @var{proc} with the
elements of the list:

@example
(append (list @vari{arg} @dots{}) @var{rest-args})
@end example

@noindent
as the actual arguments.

If a call to @func{apply} occurs in a tail context, the call to
@var{proc} is also in a tail context.

@example
(apply + (list 3 4))                    =>  7

(define compose
  (lambda (f g)
    (lambda args
      (f (apply g args)))))

((compose sqrt *) 12 75)                =>  30
@end example
@end deffn


@deffn Procedure call-with-current-continuation @var{proc}
@deffnx Procedure call/cc @var{proc}
@var{proc} should accept one argument.  The procedure @func{call/cc}
(which is the same as the procedure
@func{call-with-current-continuation}) packages the current continuation
as an ``escape procedure'' and passes it as an argument to @var{proc}.

The escape procedure is a Scheme procedure that, if it is later called,
will abandon whatever continuation is in effect at that later time and
will instead reinstate the continuation that was in effect when the
escape procedure was created.

Calling the escape procedure may cause the invocation of @var{before}
and @var{after} procedures installed using @func{dynamic-wind}.

The escape procedure accepts the same number of arguments as the
continuation of the original call to @func{call/cc}.

The escape procedure that is passed to @var{proc} has unlimited extent
just like any other procedure in Scheme.  It may be stored in variables
or data structures and may be called as many times as desired.

If a call to @func{call/cc} occurs in a tail context, the call to
@var{proc} is also in a tail context.

The following examples show only some ways in which @func{call/cc} is
used.  If all real uses were as simple as these examples, there would be
no need for a procedure with the power of @func{call/cc}.

@example
(call-with-current-continuation
  (lambda (exit)
    (for-each (lambda (x)
                (if (negative? x)
                    (exit x)))
              '(54 0 37 -3 245 19))
    #t))
=>  -3

(define list-length
  (lambda (obj)
    (call-with-current-continuation
      (lambda (return)
        (letrec ((r
                  (lambda (obj)
                    (cond ((null? obj) 0)
                          ((pair? obj)
                           (+ (r (cdr obj)) 1))
                          (else (return #f))))))
          (r obj))))))

(list-length '(1 2 3 4))                        =>  4
(list-length '(a b . c))                        => #f
(call-with-current-continuation procedure?)     => #t
@end example

@quotation
@emph{Note:} Calling an escape procedure reenters the dynamic extent of
the call to @func{call/cc}, and thus restores its dynamic environment.
@end quotation
@end deffn


@deffn Procedure values @var{obj} @dots{}
Delivers all of its arguments to its continuation.  The @func{values}
procedure might be defined as follows:

@example
(define (values . things)
  (call-with-current-continuation
    (lambda (cont) (apply cont things))))
@end example

The continuations of all non--final expressions within a sequence of
expressions, such as in @func{lambda}, @func{begin}, @func{let},
@func{let*}, @func{letrec}, @func{letrec*}, @func{let-values},
@func{let*-values}, @func{case}, and @func{cond} forms, usually take an
arbitrary number of values.

Except for these and the continuations created by
@func{call-with-values}, @func{let-values}, and @func{let*-values},
continuations implicitly accepting a single value, such as the
continuations of @meta{operator} and @meta{operand}s of procedure calls
or the @meta{test} expressions in conditionals, take exactly one value.
The effect of passing an inappropriate number of values to such a
continuation is undefined.
@end deffn


@deffn Procedure call-with-values @var{producer} @var{consumer}
@var{producer} must be a procedure and should accept zero arguments.
@var{consumer} must be a procedure and should accept as many values as
@var{producer} returns.  The @func{call-with-values} procedure calls
@var{producer} with no arguments and a continuation that, when passed
some values, calls the @var{consumer} procedure with those values as
arguments.  The continuation for the call to @var{consumer} is the
continuation of the call to @func{call-with-values}.

@example
(call-with-values
    (lambda () (values 4 5))
  (lambda (a b) b))
=>  5

(call-with-values * -)
=>  -1
@end example

If a call to @code{call-with-values} occurs in a tail context, the call
to @var{consumer} is also in a tail context.

@strong{Implementation responsibilities:} After @var{producer} returns,
the implementation must check that @var{consumer} accepts as many values
as @var{consumer} has returned.
@end deffn


@deffn Procedure dynamic-wind @var{before} @var{thunk} @var{after}
@var{before}, @var{thunk}, and @var{after} must be procedures, and each
should accept zero arguments.  These procedures may return any number of
values.

The @func{dynamic-wind} procedure calls @var{thunk} without arguments,
returning the results of this call.  Moreover, @func{dynamic-wind} calls
@var{before} without arguments whenever the dynamic extent of the call
to @var{thunk} is entered, and @var{after} without arguments whenever
the dynamic extent of the call to @var{thunk} is exited.  Thus, in the
absence of calls to escape procedures created by @func{call/cc},
@func{dynamic-wind} calls @var{before}, @var{thunk}, and @var{after}, in
that order.

While the calls to @var{before} and @var{after} are not considered to be
within the dynamic extent of the call to @var{thunk}, calls to the
@var{before} and @var{after} procedures of any other calls to
@func{dynamic-wind} that occur within the dynamic extent of the call to
@var{thunk} are considered to be within the dynamic extent of the call
to @var{thunk}.

More precisely, an escape procedure transfers control out of the dynamic
extent of a set of zero or more active @func{dynamic-wind} calls @emph{x
@dots{}} and transfer control into the dynamic extent of a set of zero
or more active @func{dynamic-wind} calls @emph{y @dots{}}.  It leaves
the dynamic extent of the most recent @emph{x} and calls without
arguments the corresponding @var{after} procedure.  If the @var{after}
procedure returns, the escape procedure proceeds to the next most recent
@emph{x}, and so on.  Once each @emph{x} has been handled in this
manner, the escape procedure calls without arguments the @var{before}
procedure corresponding to the least recent @emph{y}.  If the
@var{before} procedure returns, the escape procedure reenters the
dynamic extent of the least recent @emph{y} and proceeds with the next
least recent @emph{y}, and so on.  Once each @emph{y} has been handled
in this manner, control is transferred to the continuation packaged in
the escape procedure.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{thunk} and @var{after} only if they are
actually called.

@example
(let ((path '())
      (c #f))
  (let ((add (lambda (s)
               (set! path (cons s path)))))
    (dynamic-wind
      (lambda () (add 'connect))
      (lambda ()
        (add (call-with-current-continuation
               (lambda (c0)
                 (set! c c0)
                 'talk1))))
      (lambda () (add 'disconnect)))
    (if (< (length path) 4)
        (c 'talk2)
        (reverse path))))
=> (connect talk1 disconnect connect talk2 disconnect)

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        (lambda ()
          (set! n (+ n 1))
          (k))
        (lambda ()
          (set! n (+ n 2)))
        (lambda ()
          (set! n (+ n 4))))))
  n)
=> 1

(let ((n 0))
  (call-with-current-continuation
    (lambda (k)
      (dynamic-wind
        values
        (lambda ()
          (dynamic-wind
            values
            (lambda ()
              (set! n (+ n 1))
              (k))
            (lambda ()
              (set! n (+ n 2))
              (k))))
        (lambda ()
          (set! n (+ n 4))))))
  n)
=> 7
@end example

@quotation
@emph{Note:} Entering a dynamic extent restores its dynamic environment.
@end quotation
@end deffn



@c page
@node baselib iteration
@section Iteration


@cindex Named let


@deffn Syntax let @meta{variable} @meta{bindings} @meta{body}
``Named @func{let}'' is a variant on the syntax of @func{let} that
provides a general looping construct and may also be used to express
recursion.  It has the same syntax and semantics as ordinary @func{let}
except that @meta{variable} is bound within @meta{body} to a procedure
whose parameters are the bound variables and whose body is @meta{body}.
Thus the execution of @meta{body} may be repeated by invoking the
procedure named by @meta{variable}.

@example
(let loop ((numbers '(3 -2 1 6 -5))
           (nonneg '())
           (neg '()))
  (cond ((null? numbers) (list nonneg neg))
        ((>= (car numbers) 0)
         (loop (cdr numbers)
               (cons (car numbers) nonneg)
               neg))
        ((< (car numbers) 0)
         (loop (cdr numbers)
               nonneg
               (cons (car numbers) neg)))))
=>  ((6 1 3) (-5 -2))
@end example
@end deffn



@c page
@node baselib quasiquotation
@section Quasiquotation


@deffn Syntax quasiquote @meta{qq template}
@deffnx {Auxiliary Syntax} unquote
@deffnx {Auxiliary Syntax} unquote-splicing
``Backquote'' or ``quasiquote'' expressions are useful for constructing
a list or vector structure when some but not all of the desired
structure is known in advance.

@meta{qq template} should be as specified by the grammar at the end of
this entry.

If no @func{unquote} or @func{unquote-splicing} forms appear within the
@meta{qq template}, the result of evaluating @code{(quasiquote @meta{qq
template})} is equivalent to the result of evaluating @code{(quote
@meta{qq template})}.

If an @code{(unquote @meta{expression} @dots{})} form appears inside a
@meta{qq template}, however, the @meta{expression}s are evaluated
(``unquoted'') and their results are inserted into the structure instead
of the @code{unquote} form.

If an @code{(unquote-splicing @meta{expression} @dots{})} form appears
inside a @meta{qq template}, then the @meta{expression}s must evaluate
to lists; the opening and closing parentheses of the lists are then
``stripped away'' and the elements of the lists are inserted in place of
the @func{unquote-splicing} form.

Any @func{unquote-splicing} or multi--operand @func{unquote} form must
appear only within a list or vector @meta{qq template}.

The following abbreviations may be used:

@example
(quasiquote @meta{qq template})       =  `@meta{qq template}
(unquote @meta{expression})           =  ,@meta{expression}
(unquote-splicing @meta{expression})  =  ,@@@meta{expression}
@end example

Examples:

@example
`(list ,(+ 1 2) 4)                      => (list 3 4)

(let ((name 'a))
  `(list ,name ',name))                 => (list a (quote a))

`(a ,(+ 1 2) ,@@(map abs '(4 -5 6)) b)   => (a 3 4 5 6 b)

`((foo ,(- 10 3))
  ,@@(cdr '(c)) . ,(car '(cons)))        => ((foo 7) . cons)

`#(10 5 ,(sqrt 4) ,@@(map sqrt '(16 9)) 8)
                                        => #(10 5 2 4 3 8)

(let ((name 'foo))
  `((unquote name name name)))          => (foo foo foo)

(let ((name '(foo)))
  `((unquote-splicing name name name))) => (foo foo foo)

(let ((q '((append x y) (sqrt 9))))
  ``(foo ,,@@q))
=> `(foo (unquote (append x y) (sqrt 9)))

(let ((x '(2 3))
      (y '(4 5)))
  `(foo (unquote (append x y) (sqrt 9))))
=> (foo (2 3 4 5) 3)
@end example

Quasiquote forms may be nested.  Substitutions are made only for
unquoted components appearing at the same nesting level as the outermost
@func{quasiquote}.  The nesting level increases by one inside each
successive quasiquotation, and decreases by one inside each unquotation.

@example
`(a `(b ,(+ 1 2) ,(foo ,(+ 1 3) d) e) f)
=>  (a `(b ,(+ 1 2) ,(foo 4 d) e) f)

(let ((name1 'x)
      (name2 'y))
  `(a `(b ,,name1 ,',name2 d) e))
=>  (a `(b ,x ,'y d) e)
@end example

A @func{quasiquote} expression may return either fresh, mutable objects
or literal structure for any structure that is constructed at run time
during the evaluation of the expression.  Portions that do not need to
be rebuilt are always literal.  Thus:

@example
(let ((a 3))
  `((1 2) ,a ,4 ,'five 6))
@end example

@noindent
may be equivalent to either of the following expressions:

@example
'((1 2) 3 4 five 6)

(let ((a 3))
  (cons '(1 2)
        (cons a (cons 4 (cons 'five '(6))))))
@end example

However, it is not equivalent to this expression:

@example
(let ((a 3))
  (list (list 1 2) a 4 'five 6))
@end example

It is a syntax violation if any of the identifiers @func{quasiquote},
@func{unquote}, or @func{unquote-splicing} appear in positions within a
@meta{qq template} other than as described above.

The following grammar for quasiquote expressions is not context--free.
It is presented as a recipe for generating an infinite number of
production rules.  Imagine a copy of the following rules for @emph{D =
1, 2, 3, @dots{}}.  @emph{D} keeps track of the nesting depth.

@example
@meta{qq template} -> @meta{qq template 1}
@meta{qq template 0} -> @meta{expression}
@meta{quasiquotation @emph{D}} -> (quasiquote @meta{qq template @emph{D}})
@meta{qq template @emph{D}} -> @meta{lexeme datum}
    | @meta{list qq template @emph{D}}
    | @meta{vector qq template @emph{D}}
    | @meta{unquotation @emph{D}}
@meta{list qq template @emph{D}} -> (@arbno{@meta{qq template or splice @emph{D}}})
    | (@atleastone{@meta{qq template or splice @emph{D}}} . @meta{qq template @emph{D}})
    | @meta{quasiquotation @emph{D+1}}
@meta{vector qq template @emph{D}} -> #(@arbno{@meta{qq template or splice @emph{D}}})
@meta{unquotation @emph{D}} -> (unquote @meta{qq template @emph{D-1}})
@meta{qq template or splice @emph{D}} -> @meta{qq template @emph{D}}
    | @meta{splicing unquotation @emph{D}}
@meta{splicing unquotation @emph{D}} ->
      (unquote-splicing @arbno{@meta{qq template @emph{D-1}}})
    | (unquote @arbno{@meta{qq template @emph{D-1}}})
@end example

In @func{quasiquotation}s, a @meta{list qq template @emph{D}} can
sometimes be confused with either an @meta{unquotation @emph{D}} or a
@meta{splicing unquotation @emph{D}}.  The interpretation as an
@meta{unquotation} or @meta{splicing unquotation @emph{D}} takes
precedence.
@end deffn



@c page
@node baselib syntax binding
@section Binding constructs for syntactic keywords


@cindex Binding syntactic keywords
@cindex Syntactic keywords, binding


The @func{let-syntax} and @func{letrec-syntax} forms bind keywords.
Like a @func{begin} form, a @func{let-syntax} or @func{letrec-syntax}
form may appear in a definition context, in which case it is treated as
a definition, and the forms in the body must also be definitions.  A
@func{let-syntax} or @func{letrec-syntax} form may also appear in an
expression context, in which case the forms within their bodies must be
expressions.


@deffn Syntax let-syntax @meta{bindings} @meta{form} @dots{}
@meta{bindings} must have the form:

@example
((@meta{keyword} @meta{expression}) @dots{})
@end example

Each @meta{keyword} is an identifier, and each @meta{expression} is an
expression that evaluates, at macro--expansion time, to a
@emph{transformer}.  Transformers may be created by @func{syntax-rules}
or @func{identifier-syntax} or by one of the other mechanisms described
in library chapter ``@func{syntax-case}''.  It is a syntax violation for
@meta{keyword} to appear more than once in the list of keywords being
bound.

The @meta{form}s are expanded in the syntactic environment obtained by
extending the syntactic environment of the @func{let-syntax} form with
macros whose keywords are the @meta{keyword}s, bound to the specified
transformers.  Each binding of a @meta{keyword} has the @meta{form}s as
its region.

The @meta{form}s of a @func{let-syntax} form are treated, whether in
definition or expression context, as if wrapped in an implicit
@func{begin}.  Thus definitions in the result of expanding the
@meta{form}s have the same region as any definition appearing in place
of the @func{let-syntax} form would have.

@strong{Implementation responsibilities:} The implementation should
detect if the value of @meta{expression} cannot possibly be a
transformer.

@example
(let-syntax ([when (syntax-rules ()
                     ((when test stmt1 stmt2 ...)
                      (if test
                          (begin stmt1
                                 stmt2 ...))))])
  (let ([if #t])
    (when if (set! if 'now))
    if))
=>  now

(let ([x 'outer])
  (let-syntax ([m (syntax-rules () ((m) x))])
    (let ([x 'inner])
      (m))))
=>  outer

(let ()
  (let-syntax ([def (syntax-rules ()
                      [(def stuff ...) (define stuff ...)])])
    (def foo 42))
  foo)
=> 42

(let ()
  (let-syntax ())
  5)
=> 5
@end example
@end deffn


@deffn Syntax letrec-syntax @meta{bindings} @meta{form} @dots{}
Same as for @func{let-syntax}.

The @meta{form}s are expanded in the syntactic environment obtained by
extending the syntactic environment of the @func{letrec-syntax} form
with macros whose keywords are the @meta{keyword}s, bound to the
specified transformers.  Each binding of a @meta{keyword} has the
@meta{bindings} as well as the @meta{form}s within its region, so the
transformers can transcribe forms into uses of the macros introduced by
the @func{letrec-syntax} form.

The @meta{form}s of a @func{letrec-syntax} form are treated, whether in
definition or expression context, as if wrapped in an implicit
@func{begin}.  Thus definitions in the result of expanding the
@meta{form}s have the same region as any definition appearing in place
of the @func{letrec-syntax} form would have.

@strong{Implementation responsibilities:} The implementation should
detect if the value of @meta{expression} cannot possibly be a
transformer.

@example
(letrec-syntax
    ([my-or (syntax-rules ()
              [(my-or)    #f]
              [(my-or e)  e]
              [(my-or e1 e2 ...)  (let ([temp e1])
                                    (if temp
                                        temp
                                     (my-or e2 ...)))])])
  (let ([x      #f]
        [y      7]
        [temp   8]
        [let    odd?]
        [if     even?])
    (my-or x (let temp) (if y) y)))
=> 7
@end example

The following example highlights how @func{let-syntax} and
@func{letrec-syntax} differ.

@example
(let ([f (lambda (x) (+ x 1))])
  (let-syntax ([f (syntax-rules ()
                    [(f x) x])]
               [g (syntax-rules ()
                    [(g x) (f x)])])
    (list (f 1) (g 1))))
=> (1 2)

(let ([f (lambda (x) (+ x 1))])
  (letrec-syntax ([f (syntax-rules ()
                       [(f x) x])]
                  [g (syntax-rules ()
                       [(g x) (f x)])])
    (list (f 1) (g 1))))
=> (1 1)
@end example

The two expressions are identical except that the @func{let-syntax} form
in the first expression is a @func{letrec-syntax} form in the second.
In the first expression, the @code{f} occurring in @code{g} refers to
the @func{let}-bound variable @code{f}, whereas in the second it refers
to the keyword @code{f} whose binding is established by the
@func{letrec-syntax} form.
@end deffn



@c page
@node baselib transformers
@section Macro transformers


@cindex Macro transformers
@cindex Transformers, macro


@xref{examples macros}, for examples on macro writing.


@deffn {Syntax @code{(expand)}} syntax-rules (@meta{literal} @dots{}) @meta{syntax rule} @dots{}
@deffnx {Auxiliary Syntax @code{(expand)}} _
@deffnx {Auxiliary Syntax @code{(expand)}} ...
Each @meta{literal} must be an identifier.  Each @meta{syntax rule} must
have the following form:

@example
(@meta{srpattern} @meta{template})
@end example

An @meta{srpattern} is a restricted form of @meta{pattern}, namely, a
nonempty @meta{pattern} in one of four parenthesized forms below whose
first subform is an identifier or an underscore @code{_}.  A
@meta{pattern} is an identifier, constant, or one of the following.

@example
(@meta{pattern} @dots{})
(@meta{pattern} @meta{pattern} @dots{} . @meta{pattern})
(@meta{pattern} @dots{} @meta{pattern} @meta{ellipsis} @meta{pattern} @dots{})
(@meta{pattern} @dots{} @meta{pattern} @meta{ellipsis} @meta{pattern} @dots{} . @meta{pattern})
#(@meta{pattern} @dots{})
#(@meta{pattern} @dots{} @meta{pattern} @meta{ellipsis} @meta{pattern} @dots{})
@end example

An @meta{ellipsis} is the identifier @code{...} (three periods).

A @meta{template} is a pattern variable, an identifier that is not a
pattern variable, a pattern datum, or one of the following.

@example
(@meta{subtemplate} @dots{})
(@meta{subtemplate} @dots{} . @meta{template})
#(@meta{subtemplate} @dots{})
@end example

A @meta{subtemplate} is a @meta{template} followed by zero or more
ellipses.

An instance of @func{syntax-rules} evaluates, at macro--expansion time,
to a new macro transformer by specifying a sequence of hygienic rewrite
rules.  A use of a macro whose keyword is associated with a transformer
specified by @func{syntax-rules} is matched against the patterns
contained in the @meta{syntax rule}s, beginning with the leftmost
@meta{syntax rule}.  When a match is found, the macro use is transcribed
hygienically according to the template.  It is a syntax violation when
no match is found.

An identifier appearing within a @meta{pattern} may be an underscore
@code{_}, a literal identifier listed in the list of literals
@code{(@meta{literal} @dots{})}, or an ellipsis @code{...}.  All other
identifiers appearing within a @meta{pattern} are @emph{pattern
variables}.  It is a syntax violation if an ellipsis or underscore
appears in @code{(@meta{literal} @dots{})}.

While the first subform of @meta{srpattern} may be an identifier, the
identifier is not involved in the matching and is not considered a
pattern variable or literal identifier.

Pattern variables match arbitrary input subforms and are used to refer
to elements of the input.  It is a syntax violation if the same pattern
variable appears more than once in a @meta{pattern}.

Underscores, @code{_}, also match arbitrary input subforms but are not
pattern variables and so cannot be used to refer to those elements.
Multiple underscores may appear in a @meta{pattern}.

A @meta{literal} identifier matches an input subform if and only if the
input subform is an identifier and either both its occurrence in the
input expression and its occurrence in the list of literals have the
same lexical binding, or the two identifiers have the same name and both
have no lexical binding.

A subpattern followed by an ellipsis can match zero or more elements of
the input.

More formally, an input form @emph{F} matches a pattern @emph{P} if and
only if one of the following holds:

@itemize
@item
@emph{P} is an underscore (@code{_}).

@item
@emph{P} is a pattern variable.

@item
@emph{P} is a literal identifier and @emph{F} is an identifier such that
both @emph{P} and @emph{F} would refer to the same binding if both were
to appear in the output of the macro outside of any bindings inserted
into the output of the macro.  (If neither of two like--named
identifiers refers to any binding, i.e., both are undefined, they are
considered to refer to the same binding.)

@item
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_n})
@end example

@noindent
and @emph{F} is a list of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_n} . @emph{P_x})
@end example

@noindent
and @emph{F} is a list or improper list of @emph{n} or more elements
whose first @emph{n} elements match @emph{P_1} through @emph{P_n} and
whose @emph{n}th cdr matches @emph{P_x}.

@item
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_k} @emph{P_e} @meta{ellipsis} @emph{P_(m+1)} @dots{} @emph{P_n})
@end example

@noindent
where @meta{ellipsis} is the identifier @code{...}  and @emph{F} is a
list of @emph{n} elements whose first @emph{k} elements match @emph{P_1}
through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
(@emph{P_1} @dots{} @emph{P_k} @emph{P_e} @meta{ellipsis} @emph{P_(m+1)} @dots{} @emph{P_n} . @emph{P_x})
@end example

@noindent
where @meta{ellipsis} is the identifier @code{...} and @emph{F} is a
list or improper list of @emph{n} elements whose first @emph{k} elements
match @emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each
match @emph{P_e}, whose next @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}, and whose @emph{n}th and final cdr matches
@emph{P_x}.

@item
@emph{P} is of the form:

@example
#(@emph{P_1} @dots{} @emph{P_n})
@end example

@noindent
and @emph{F} is a vector of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
#(@emph{P_1} @dots{} @emph{P_k} @emph{P_e} @meta{ellipsis} @emph{P_(m+1)} @dots{} @emph{P_n})
@end example

@noindent
where @meta{ellipsis} is the identifier @code{...} and @emph{F} is a
vector of @emph{n} or more elements whose first @emph{k} elements match
@emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item
@emph{P} is a pattern datum (any nonlist, nonvector, nonsymbol datum)
and @emph{F} is equal to @emph{P} in the sense of the @func{equal?}
procedure.
@end itemize

When a macro use is transcribed according to the template of the
matching @meta{syntax rule}, pattern variables that occur in the
template are replaced by the subforms they match in the input.

Pattern data and identifiers that are not pattern variables or ellipses
are copied into the output.  A subtemplate followed by an ellipsis
expands into zero or more occurrences of the subtemplate.  Pattern
variables that occur in subpatterns followed by one or more ellipses may
occur only in subtemplates that are followed by (at least) as many
ellipses.  These pattern variables are replaced in the output by the
input subforms to which they are bound, distributed as specified.  If a
pattern variable is followed by more ellipses in the subtemplate than in
the associated subpattern, the input form is replicated as necessary.
The subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses
as the subpattern in which the pattern variable appears.  (Otherwise,
the expander would not be able to determine how many times the subform
should be repeated in the output.)  It is a syntax violation if the
constraints of this paragraph are not met.

A template of the form @code{(@meta{ellipsis} @meta{template})} is
identical to @meta{template}, except that ellipses within the template
have no special meaning.  That is, any ellipses contained within
@meta{template} are treated as ordinary identifiers.  In particular, the
template @code{(... ...)} produces a single ellipsis, @code{...}.  This
allows syntactic abstractions to expand into forms containing ellipses.

@example
(define-syntax be-like-begin
  (syntax-rules ()
    [(be-like-begin name)
     (define-syntax name
       (syntax-rules ()
         ((name expr (... ...))
          (begin expr (... ...)))))]))

(be-like-begin sequence)
(sequence 1 2 3 4) => 4
@end example

As an example for hygienic use of auxiliary identifier, if @func{let}
and @func{cond} are defined as in @ref{baselib expressions binding,let}
and @ref{lang derived,cond} then they are hygienic (as required) and the
following is not an error.

@example
(let ((=> #f))
  (cond (#t => 'ok)))           => ok
@end example

The macro transformer for @func{cond} recognizes @code{=>} as a local
variable, and hence an expression, and not as the identifier @code{=>},
which the macro transformer treats as a syntactic keyword.  Thus the
example expands into:

@example
(let ((=> #f))
  (if #t (begin => 'ok)))
@end example

@noindent
instead of:

@example
(let ((=> #f))
  (let ((temp #t))
    (if temp ('ok temp))))
@end example

@noindent
which would result in an assertion violation.
@end deffn


@deffn {Syntax @code{(expand)}} identifier-syntax @meta{template}
@deffnx {Syntax @code{(expand)}} identifier-syntax (@hyperi{id} @metai{template}) ((set! @hyperii{id} @meta{pattern}) @hyperii{template})
@deffnx {Auxiliary Syntax @code{(expand)}} set!
The @meta{id}s must be identifiers.  The @meta{template}s must be as for
@func{syntax-rules}.

When a keyword is bound to a transformer produced by the first form of
@func{identifier-syntax}, references to the keyword within the scope of
the binding are replaced by @meta{template}.

@example
(define p (cons 4 5))
(define-syntax p.car (identifier-syntax (car p)))
p.car => 4
(set! p.car 15) => exception &syntax
@end example

The second, more general, form of @func{identifier-syntax} permits the
transformer to determine what happens when @code{set!} is used.  In this
case, uses of the identifier by itself are replaced by
@hyperi{template}, and uses of @code{set!} with the identifier are
replaced by @hyperii{template}.

@example
(define p (cons 4 5))
(define-syntax p.car
  (identifier-syntax
    [_ (car p)]
    [(set! _ e) (set-car! p e)]))
(set! p.car 15)
p.car           => 15
p               => (15 . 5)
@end example
@end deffn



@c page
@node baselib tail call
@section Tail calls and tail contexts


@cindex Tail call
@cindex Tail contexts


A @emph{tail call} is a procedure call that occurs in a @emph{tail
context}.  Tail contexts are defined inductively.  Note that a tail
context is always determined with respect to a particular lambda
expression.

@itemize
@item
The last expression within the body of a lambda expression, shown as
@meta{tail expression} below, occurs in a tail context.

@example
(lambda @meta{formals}
  @arbno{@meta{definition}}
  @arbno{@meta{expression}} @meta{tail expression})
@end example

@item
If one of the following expressions is in a tail context, then the
subexpressions shown as @meta{tail expression} are in a tail context.
These were derived from specifications of the syntax of the forms
described in this chapter by replacing some occurrences of
@meta{expression} with @meta{tail expression}.  Only those rules that
contain tail contexts are shown here.

@example
(if @meta{expression} @meta{tail expression} @meta{tail expression})
(if @meta{expression} @meta{tail expression})

(cond @atleastone{@meta{cond clause}})
(cond @arbno{@meta{cond clause}} (else @meta{tail sequence}))

(case @meta{expression}
  @atleastone{@meta{case clause}})
(case @meta{expression}
  @arbno{@meta{case clause}}
  (else @meta{tail sequence}))

(and @arbno{@meta{expression}} @meta{tail expression})
(or @arbno{@meta{expression}} @meta{tail expression})

(let @meta{bindings} @meta{tail body})
(let @meta{variable} @meta{bindings} @meta{tail body})
(let* @meta{bindings} @meta{tail body})
(letrec* @meta{bindings} @meta{tail body})
(letrec @meta{bindings} @meta{tail body})
(let-values @meta{mv-bindings} @meta{tail body})
(let*-values @meta{mv-bindings} @meta{tail body})

(let-syntax @meta{bindings} @meta{tail body})
(letrec-syntax @meta{bindings} @meta{tail body})

(begin @meta{tail sequence})
@end example

A @meta{cond clause} is:

@example
(@meta{test} @meta{tail sequence})
@end example

@noindent
a @meta{case clause} is:

@example
((@arbno{@meta{datum}}) @meta{tail sequence})
@end example

@noindent
a @meta{tail body} is:

@example
@arbno{@meta{definition}} @meta{tail sequence}
@end example

@noindent
and a @meta{tail sequence} is:

@example
@arbno{@meta{expression}} @meta{tail expression}
@end example

@item
If a @func{cond} expression is in a tail context, and has a clause of
the form @code{(@hyperi{expression} => @hyperii{expression})} then the
(implied) call to the procedure that results from the evaluation of
@hyperii{expression} is in a tail context.  @hyperii{expression} itself
is not in a tail context.
@end itemize

Certain built--in procedures must also perform tail calls.  The first
argument passed to @func{apply} and to @func{call/cc}, and the second
argument passed to @func{call-with-values}, must be called via a tail
call.

In the following example the only tail call is the call to @func{f}.
None of the calls to @func{g} or @func{h} are tail calls.  The reference
to @code{x} is in a tail context, but it is not a call and thus is not a
tail call.

@example
(lambda ()
  (if (g)
      (let ((x (h)))
        x)
      (and (g) (f))))
@end example

@quotation
@emph{Note:} Implementations may recognize that some non--tail calls,
such as the call to @func{h} above, can be evaluated as though they were
tail calls.  In the example above, the @func{let} expression could be
compiled as a tail call to @func{h}.  (The possibility of @func{h}
returning an unexpected number of values can be ignored, because in that
case the effect of the @func{let} is explicitly unspecified and
implementation--dependent.)
@end quotation



@c page
@node stdlib
@chapter Standard libraries

@lowersections

@menu
* stdlib unicode::              Unicode.
* stdlib bytevector::           Bytevectors.
* stdlib list::                 List utilities.
* stdlib sorting::              Sorting.
* stdlib control::              Control structures.
* stdlib records::              Records.
* stdlib exceptions::           Exceptions and conditions.
* stdlib io::                   Input/output.
* stdlib files::                File system.
* stdlib programlib::           Command line access and exit values.
* stdlib arithmetics::          Arithmetics.
* stdlib syntax-case::          Syntax-case.
* stdlib hashtable::            Hashtables.
* stdlib enum::                 Enumerations.
* stdlib complib::              Composite library.
* stdlib eval::                 Evaluation.
* stdlib mutable pairs::        Mutable pairs.
* stdlib mutable strings::      Mutable strings.
* stdlib rfive compat::         @rnrs{5} compatibility.
@end menu


@c page
@node stdlib unicode
@chapter Unicode


The procedures exported by the @rsixlibrary{unicode} library provide
access to some aspects of the Unicode semantics for characters and
strings: category information, case--independent comparisons, case
mappings, and normalization.

Some of the procedures that operate on characters or strings ignore the
difference between upper case and lower case.  These procedures have
@code{-ci} (for ``case insensitive'') embedded in their names.


@menu
* stdlib unicode characters::   Characters.
* stdlib unicode strings::      Strings.
@end menu


@c page
@node stdlib unicode characters
@section Characters


@deffn Procedure char-upcase @var{char}
@deffnx Procedure char-downcase @var{char}
@deffnx Procedure char-titlecase @var{char}
@deffnx Procedure char-foldcase @var{char}
These procedures take a character argument and return a character
result.

If the argument is an upper--case or title--case character, and if there
is a single character that is its lower--case form, then
@func{char-downcase} returns that character.

If the argument is a lower--case or title--case character, and there is
a single character that is its upper--case form, then @func{char-upcase}
returns that character.

If the argument is a lower--case or upper--case character, and there is
a single character that is its title--case form, then
@func{char-titlecase} returns that character.

If the argument is not a title--case character and there is no single
character that is its title--case form, then @func{char-titlecase}
returns the upper--case form of the argument.

Finally, if the character has a case--folded character, then
@func{char-foldcase} returns that character.  Otherwise the character
returned is the same as the argument.

For Turkic characters @code{#\x130} and @code{#\x131},
@func{char-foldcase} behaves as the identity function; otherwise
@func{char-foldcase} is the same as @func{char-downcase} composed with
@func{char-upcase}.

@example
(char-upcase #\i)               => #\I
(char-downcase #\i)             => #\i
(char-titlecase #\i)            => #\I
(char-foldcase #\i)             => #\i
@end example

@quotation
@emph{Note:} @func{char-titlecase} does not always return a title--case
character.
@end quotation

@quotation
@emph{Note:} These procedures are consistent with Unicode's
locale--independent mappings from scalar values to scalar values for
upcase, downcase, titlecase, and case--folding operations.  These
mappings can be extracted from @file{UnicodeData.txt} and
@file{CaseFolding.txt} from the Unicode Consortium, ignoring Turkic
mappings in the latter.

Note that these character--based procedures are an incomplete
approximation to case conversion, even ignoring the user's locale.  In
general, case mappings require the context of a string, both in
arguments and in result.  The @func{string-upcase},
@func{string-downcase}, @func{string-titlecase}, and
@func{string-foldcase} procedures (@ref{stdlib unicode strings} perform
more general case conversion.
@end quotation
@end deffn


@deffn Procedure char-ci=? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci<? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci>? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci<=? @vari{char} @varii{char} @variii{char} @dots{}
@deffnx Procedure char-ci>=? @vari{char} @varii{char} @variii{char} @dots{}
These procedures are similar to @func{char=?}, etc., but operate on the
case--folded versions of the characters.

@example
(char-ci<? #\z #\Z)             => #f
(char-ci=? #\z #\Z)             => #f
@end example
@end deffn


@deffn Procedure char-alphabetic? @var{char}
@deffnx Procedure char-numeric? @var{char}
@deffnx Procedure char-whitespace? @var{char}
@deffnx Procedure char-upper-case? @var{char}
@deffnx Procedure char-lower-case? @var{char}
@deffnx Procedure char-title-case? @var{char}
These procedures return @true{} if their arguments are alphabetic,
numeric, whitespace, upper--case, lower--case, or title--case
characters, respectively; otherwise they return @false{}.

A character is alphabetic if it has the Unicode ``Alphabetic'' property.
A character is numeric if it has the Unicode ``Numeric'' property.  A
character is whitespace if has the Unicode ``White_Space'' property.  A
character is upper case if it has the Unicode ``Uppercase'' property,
lower case if it has the ``Lowercase'' property, and title case if it is
in the Lt general category.

@example
(char-alphabetic? #\a)          => #t
(char-numeric? #\1)             => #t
(char-whitespace? #\space)      => #t
(char-whitespace? #\x00A0)      => #t
(char-lower-case? #\x00AA)      => #t
(char-title-case? #\I)          => #f
(char-title-case? #\x01C5)      => #t
@end example
@end deffn


@deffn Procedure char-general-category @var{char}
Return a symbol representing the Unicode general category of
@var{char}, one of @code{Lu}, @code{Ll}, @code{Lt}, @code{Lm},
@code{Lo}, @code{Mn}, @code{Mc}, @code{Me}, @code{Nd}, @code{Nl},
@code{No}, @code{Ps}, @code{Pe}, @code{Pi}, @code{Pf}, @code{Pd},
@code{Pc}, @code{Po}, @code{Sc}, @code{Sm}, @code{Sk}, @code{So},
@code{Zs}, @code{Zp}, @code{Zl}, @code{Cc}, @code{Cf}, @code{Cs},
@code{Co}, or @code{Cn}.

@example
(char-general-category #\a)             => Ll
(char-general-category #\space)         => Zs
(char-general-category #\x10FFFF)       => Cn
@end example
@end deffn



@c page
@node stdlib unicode strings
@section Strings


@deffn Procedure string-upcase @var{string}
@deffnx Procedure string-downcase @var{string}
@deffnx Procedure string-titlecase @var{string}
@deffnx Procedure string-foldcase @var{string}
These procedures take a string argument and return a string result.
They are defined in terms of Unicode's locale--independent case mappings
from Unicode scalar--value sequences to scalar--value sequences.  In
particular, the length of the result string can be different from the
length of the input string.  When the specified result is equal in the
sense of @func{string=?} to the argument, these procedures may return
the argument instead of a newly allocated string.

The @func{string-upcase} procedure converts a string to upper case;
@func{string-downcase} converts a string to lower case.  The
@func{string-foldcase} procedure converts the string to its case--folded
counterpart, using the full case--folding mapping, but without the
special mappings for Turkic languages.  The @func{string-titlecase}
procedure converts the first cased character of each word, and downcases
all other cased characters.

@example
(string-upcase "Hi")                    => "HI"
(string-downcase "Hi")                  => "hi"
(string-foldcase "Hi")                  => "hi"

(string-titlecase "kNock KNoCK")        => "Knock Knock"
(string-titlecase "who's there?")       => "Who's There?"
(string-titlecase "r6rs")               => "R6rs"
(string-titlecase "R6RS")               => "R6rs"
@end example

@quotation
@emph{Note:} The case mappings needed for implementing these procedures
can be extracted from @file{UnicodeData.txt}, @file{SpecialCasing.txt},
@file{WordBreakProperty.txt} (the ``MidLetter'' property partly defines
case--ignorable characters), and @file{CaseFolding.txt} from the Unicode
Consortium.

Since these procedures are locale--independent, they may not be
appropriate for some locales.
@end quotation

@quotation
@emph{Note:} Word breaking, as needed for the correct casing of the
upper case greek sigma and for @func{string-titlecase}, is specified in
Unicode Standard Annex #29.
@end quotation
@end deffn


@deffn Procedure string-ci=? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci<? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci>? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci<=? @vari{string} @varii{string} @variii{string} @dots{}
@deffnx Procedure string-ci>=? @vari{string} @varii{string} @variii{string} @dots{}
These procedures are similar to @func{string=?}, etc., but operate on
the case--folded versions of the strings.

@example
(string-ci<? "z" "Z")                   => #f
(string-ci=? "z" "Z")                   => #t
@end example
@end deffn


@deffn Procedure string-normalize-nfd @var{string}
@deffnx Procedure string-normalize-nfkd @var{string}
@deffnx Procedure string-normalize-nfc @var{string}
@deffnx Procedure string-normalize-nfkc @var{string}
These procedures take a string argument and return a string result,
which is the input string normalized to Unicode normalization form D,
KD, C, or KC, respectively.  When the specified result is equal in the
sense of @func{string=?} to the argument, these procedures may return
the argument instead of a newly allocated string.

@example
(string-normalize-nfd "\xE9;")          => "\x65;\x301;"
(string-normalize-nfc "\xE9;")          => "\xE9;"
(string-normalize-nfd "\x65;\x301;")    => "\x65;\x301;"
(string-normalize-nfc "\x65;\x301;")    => "\xE9;"
@end example
@end deffn



@c page
@node stdlib bytevector
@chapter Bytevectors


Many applications deal with blocks of binary data by accessing them in
various ways---extracting signed or unsigned numbers of various sizes.
Therefore, the @rsixlibrary{bytevectors} library provides a single type
for blocks of binary data with multiple ways to access that data. It
deals with integers and floating--point representations in various sizes
with specified endianness.

Bytevectors are objects of a disjoint type.  Conceptually, a bytevector
represents a sequence of 8-bit bytes.  The description of bytevectors
uses the term @emph{byte} for an exact integer object in the interval
@code{(-128, @dots{}, 127)} and the term @emph{octet} for an exact
integer object in the interval @code{(0, @dots{}, 255)}.  A byte
corresponds to its two's complement representation as an octet.

The length of a bytevector is the number of bytes it contains. This
number is fixed.  A valid index into a bytevector is an exact,
non--negative integer object less than the length of the bytevector.
The first byte of a bytevector has index 0; the last byte has an index
one less than the length of the bytevector.

Generally, the access procedures come in different flavors according to
the size of the represented integer and the endianness of the
representation.  The procedures also distinguish signed and unsigned
representations.  The signed representations all use two's complement.

Like string literals, literals representing bytevectors do not need to
be quoted:

@example
#vu8(12 23 123) => #vu8(12 23 123)
@end example


@menu
* stdlib bytevector endianness::        Endianness.
* stdlib bytevector general::           General operations.
* stdlib bytevector bytes and octets::  Operations on bytes and octets.
* stdlib bytevector integers::          Operations on integers of
                                        arbitrary size.
* stdlib bytevector integers 16::       Operations on 16-bit integers.
* stdlib bytevector integers 32::       Operations on 32-bit integers.
* stdlib bytevector integers 64::       Operations on 64-bit integers.
* stdlib bytevector flonum::            Operations on @ieee{} 754
                                        representations.
* stdlib bytevector strings::           Operations on strings.
@end menu



@c page
@node stdlib bytevector endianness
@section Endianness


Many operations described in this chapter accept an @emph{endianness}
argument.  Endianness describes the encoding of exact integer objects as
several contiguous bytes in a bytevector.  For this purpose, the binary
representation of the integer object is split into consecutive bytes.
The little--endian encoding places the least significant byte of an
integer first, with the other bytes following in increasing order of
significance.  The big--endian encoding places the most significant byte
of an integer first, with the other bytes following in decreasing order
of significance.

This terminology also applies to @ieee{} 754 numbers: @ieee{} 754
describes how to represent a floating--point number as an exact integer
object, and endianness describes how the bytes of such an integer are
laid out in a bytevector.

@quotation
@emph{Note:} Little-- and big--endianness are only the most common kinds
of endianness.  Some architectures distinguish between the endianness at
different levels of a binary representation.
@end quotation



@c page
@node stdlib bytevector general
@section General operations


@deffn Syntax endianness @meta{endianness symbol}
The name of @meta{endianness symbol} must be a symbol describing an
endianness.  An implementation must support at least the symbols
@code{big} and @code{little}, but may support other endianness symbols.

@code{(endianness @meta{endianness symbol})} evaluates to the symbol
named @meta{endianness symbol}.  Whenever one of the procedures
operating on bytevectors accepts an endianness as an argument, that
argument must be one of these symbols.  It is a syntax violation for
@meta{endianness symbol} to be anything other than an endianness symbol
supported by the implementation.

@quotation
@emph{Note:} Implementors should use widely accepted designations for
endianness symbols other than @code{big} and @code{little}.
@end quotation

@quotation
@emph{Note:} Only the name of @meta{endianness symbol} is significant.
@end quotation
@end deffn


@deffn Procedure native-endianness
Return the endianness symbol associated implementation's preferred
endianness (usually that of the underlying machine architecture).  This
may be any @meta{endianness symbol}, including a symbol other than
@code{big} and @code{little}.
@end deffn


@deffn Procedure bytevector? @var{obj}
Return @true{} if @var{obj} is a bytevector, @false{} otherwise.
@end deffn


@deffn Procedure make-bytevector @var{k}
@deffnx Procedure make-bytevector @var{k} @var{fill}
Return a newly allocated bytevector of @var{k} bytes.  If the @var{fill}
argument is missing, the initial contents of the returned bytevector are
unspecified.  If the @var{fill} argument is present, it must be an exact
integer object in the interval @code{(-128, @dots{} 255)} that specifies
the initial value for the bytes of the bytevector: If @var{fill} is
positive, it is interpreted as an octet; if it is negative, it is
interpreted as a byte.
@end deffn


@deffn Procedure bytevector-length @var{bytevector}
Return, as an exact integer object, the number of bytes in
@var{bytevector}.
@end deffn


@deffn Procedure {bytevector=?} @vari{bytevector} @varii{bytevector}
Return @true{} if @vari{bytevector} and @varii{bytevector} are equal;
that is, if they have the same length and equal bytes at all valid
indices.  It returns @false{} otherwise.
@end deffn


@deffn Procedure {bytevector-fill!} @var{bytevector} @var{fill}
The @var{fill} argument is as in the description of the
@func{make-bytevector} procedure.  The @func{bytevector-fill!}
procedure stores @var{fill} in every element of @var{bytevector} and
returns unspecified values.  Analogous to @func{vector-fill!}.
@end deffn


@deffn Procedure {bytevector-copy!} @var{source} @var{source-start} @var{target} @var{target-start} @var{k}
@var{source} and @var{target} must be bytevectors.  @var{source-start},
@var{target-start}, and @var{k} must be non--negative exact integer
objects that satisfy:

@example
0 <= @var{source-start} <= @var{source-start} + @var{k} <= l_@var{source}
0 <= @var{target-start} <= @var{target-start} + @var{k} <= l_@var{target}
@end example

@noindent
where @emph{l_@var{source}} is the length of @var{source} and
@emph{l_@var{target}} is the length of @var{target}.

The @func{bytevector-copy!} procedure copies the bytes from @var{source}
at indices:

@example
@var{source-start}, @dots{}, @var{source-start} + @var{k} - 1
@end example

@noindent
to consecutive indices in @var{target} starting at @var{target-index}.

This must work even if the memory regions for the source and the target
overlap, i.e., the bytes at the target location after the copy must be
equal to the bytes at the source location before the copy.

This returns unspecified values.

@example
(let ((b (u8-list->bytevector '(1 2 3 4 5 6 7 8))))
  (bytevector-copy! b 0 b 3 4)
  (bytevector->u8-list b))
=> (1 2 3 1 2 3 4 8)
@end example
@end deffn


@deffn Procedure bytevector-copy @var{bytevector}
Return a newly allocated copy of @var{bytevector}.
@end deffn



@c page
@node stdlib bytevector bytes and octets
@section Operations on bytes and octets


@deffn Procedure bytevector-u8-ref @var{bytevector} @var{k}
@deffnx Procedure bytevector-s8-ref @var{bytevector} @var{k}
@var{k} must be a valid index of @var{bytevector}.

The @func{bytevector-u8-ref} procedure returns the byte at index @var{k}
of @var{bytevector}, as an octet.

The @func{bytevector-s8-ref} procedure returns the byte at index @var{k}
of @var{bytevector}, as a (signed) byte.

@example
(let ((b1 (make-bytevector 16 -127))
      (b2 (make-bytevector 16 255)))
  (list
    (bytevector-s8-ref b1 0)
    (bytevector-u8-ref b1 0)
    (bytevector-s8-ref b2 0)
    (bytevector-u8-ref b2 0)))
=> (-127 129 -1 255)
@end example
@end deffn


@deffn Procedure {bytevector-u8-set!} @var{bytevector} @var{k} @var{octet}
@deffnx Procedure {bytevector-s8-set!} @var{bytevector} @var{k} @var{byte}
@var{k} must be a valid index of @var{bytevector}.

The @func{bytevector-u8-set!} procedure stores @var{octet} in element
@var{k} of @var{bytevector}.

The @func{bytevector-s8-set!} procedure stores the two's--complement
representation of @var{byte} in element @var{k} of @var{bytevector}.

Both procedures return unspecified values.

@example
(let ((b (make-bytevector 16 -127)))

  (bytevector-s8-set! b 0 -126)
  (bytevector-u8-set! b 1 246)

  (list
    (bytevector-s8-ref b 0)
    (bytevector-u8-ref b 0)
    (bytevector-s8-ref b 1)
    (bytevector-u8-ref b 1)))
=> (-126 130 -10 246)
@end example
@end deffn


@deffn Procedure {bytevector->u8-list} @var{bytevector}
@deffnx Procedure {u8-list->bytevector} @var{list}
@var{list} must be a list of octets.

The @func{bytevector->u8-list} procedure returns a newly allocated list
of the octets of @var{bytevector} in the same order.

The @func{u8-list->bytevector} procedure returns a newly allocated
bytevector whose elements are the elements of list @var{list}, in the
same order.  It is analogous to @func{list->vector}.
@end deffn



@c page
@node stdlib bytevector integers
@section Operations on integers of arbitrary size


@deffn Procedure bytevector-uint-ref @var{bytevector} @var{k} @var{endianness} @var{size}
@deffnx Procedure bytevector-sint-ref @var{bytevector} @var{k} @var{endianness} @var{size}
@deffnx Procedure {bytevector-uint-set!} @var{bytevector} @var{k} @var{n} @var{endianness} @var{size}
@deffnx Procedure {bytevector-sint-set!} @var{bytevector} @var{k} @var{n} @var{endianness} @var{size}
@var{size} must be a positive exact integer object.  @var{k}, @dots{},
@var{k}+@var{size}-1 must be valid indices of @var{bytevector}.

The @func{bytevector-uint-ref} procedure retrieves the exact integer
object corresponding to the unsigned representation of size @var{size}
and specified by @var{endianness} at indices @var{k}, @dots{},
@var{k}+@var{size}-1.

The @func{bytevector-sint-ref} procedure retrieves the exact integer
object corresponding to the two's--complement representation of size
@var{size} and specified by @var{endianness} at indices @var{k},
@dots{}, @var{k}+@var{size}-1.

For @func{bytevector-uint-set!}, @var{n} must be an exact integer object
in the interval @code{(0, @dots{}, 256^(size-1))}.

The @func{bytevector-uint-set!} procedure stores the unsigned
representation of size @var{size} and specified by @var{endianness} into
@var{bytevector} at indices @var{k}, @dots{}, @var{k}+@var{size}-1.

For @func{bytevector-sint-set!}, @var{n} must be an exact integer object
in the interval @code{(-(256^size)/2, @dots{}, (256^(size))/2-1)}.
@func{bytevector-sint-set!} stores the two's--complement representation
of size @var{size} and specified by @var{endianness} into
@var{bytevector} at indices @var{k}, @dots{}, @var{k}+@var{size}-1.

The @code{...-set!} procedures return unspecified values.

@example
(define b (make-bytevector 16 -127))

(bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness little) 16)

(bytevector-uint-ref b 0 (endianness little) 16)
=> #xfffffffffffffffffffffffffffffffd

(bytevector-sint-ref b 0 (endianness little) 16)
=> -3

(bytevector->u8-list b)
=> (253 255 255 255 255 255 255 255
    255 255 255 255 255 255 255 255)

(bytevector-uint-set! b 0 (- (expt 2 128) 3) (endianness big) 16)

(bytevector-uint-ref b 0 (endianness big) 16)
=> #xfffffffffffffffffffffffffffffffd

(bytevector-sint-ref b 0 (endianness big) 16)
=> -3

(bytevector->u8-list b)
=> (255 255 255 255 255 255 255 255
    255 255 255 255 255 255 255 253))
@end example
@end deffn


@deffn Procedure {bytevector->uint-list} @var{bytevector} @var{endianness} @var{size}
@deffnx Procedure {bytevector->sint-list} @var{bytevector} @var{endianness} @var{size}
@deffnx Procedure {uint-list->bytevector} @var{list} @var{endianness} @var{size}
@deffnx Procedure {sint-list->bytevector} @var{list} @var{endianness} @var{size}
@var{size} must be a positive exact integer object.

For @func{uint-list->bytevector}, @var{list} must be a list of exact
integer objects in the interval @code{(0, @dots{}, (256^size)-1)}.

For @func{sint-list->bytevector}, @var{list} must be a list of exact
integer objects in the interval @code{(-(256^size)/2, @dots{},
(256^(size))/2-1)}.

The length of @var{bytevector} must be divisible by @var{size}.

These procedures convert between lists of integer objects and their
consecutive representations according to @var{size} and @var{endianness}
in the @var{bytevector} objects in the same way as
@func{bytevector->u8-list} and @func{u8-list->bytevector} do for
one--byte representations.

@example
(let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
  (bytevector->sint-list b (endianness little) 2))
=> (513 -253 513 513)

(let ((b (u8-list->bytevector '(1 2 3 255 1 2 1 2))))
  (bytevector->uint-list b (endianness little) 2))
=> (513 65283 513 513)
@end example
@end deffn



@c page
@node stdlib bytevector integers 16
@section Operations on 16--bit integers


@deffn Procedure {bytevector-u16-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-s16-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-u16-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-s16-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-u16-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-s16-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-u16-native-set!} @var{bytevector} @var{k} @var{n}
@deffnx Procedure {bytevector-s16-native-set!} @var{bytevector} @var{k} @var{n}
@var{k} must be a valid index of @var{bytevector}; so must @var{k}+1.

For @func{bytevector-u16-set!} and @func{bytevector-u16-native-set!},
@var{n} must be an exact integer object in the interval
@code{0 <= n <= 2^16-1}.

For @func{bytevector-s16-set!} and @func{bytevector-s16-native-set!},
@var{n} must be an exact integer object in the interval
@code{-2^15 <= n <= 2^15-1}.

These procedures retrieve and set two--byte representations of numbers
at indices @var{k} and @var{k}+1 according to the endianness specified
by @var{endianness}.  The procedures with @code{u16} in their names deal
with the unsigned representation; those with @code{s16} in their names
deal with the two's--complement representation.

The procedures with @code{native} in their names employ the native
endianness, and work only at aligned indices: @var{k} must be a multiple
of 2.

The @code{...-set!} procedures return unspecified values.

@example
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u16-ref b 14 (endianness little))           => 65023
(bytevector-s16-ref b 14 (endianness little))           => -513
(bytevector-u16-ref b 14 (endianness big))              => 65533
(bytevector-s16-ref b 14 (endianness big))              => -3

(bytevector-u16-set! b 0 12345 (endianness little))
(bytevector-u16-ref b 0 (endianness little))            => 12345

(bytevector-u16-native-set! b 0 12345)
(bytevector-u16-native-ref b 0)                         => 12345

(bytevector-u16-ref b 0 (endianness little))            => unspecified
@end example
@end deffn



@c page
@node stdlib bytevector integers 32
@section Operations on 32--bit integers


@deffn Procedure {bytevector-u32-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-s32-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-u32-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-s32-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-u32-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-s32-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-u32-native-set!} @var{bytevector} @var{k} @var{n}
@deffnx Procedure {bytevector-s32-native-set!} @var{bytevector} @var{k} @var{n}
@var{k}, @dots{}, @var{k}+3 must be valid indices of @var{bytevector}.

For @func{bytevector-u32-set!} and @func{bytevector-u32-native-set!},
@var{n} must be an exact integer object in the interval
@code{0 <= n <= 2^32-1}.

For @func{bytevector-s32-set!} and @func{bytevector-s32-native-set!},
@var{n} must be an exact integer object in the interval
@code{-2^31 <= n <= 2^32-1}.

These retrieve and set four--byte representations of numbers at indices
@var{k}, @dots{}, @var{k}+3, according to the endianness specified by
@var{endianness}.  The procedures with @code{u32} in their names deal
with the unsigned representation; those with @code{s32} with the
two's--complement representation.

The procedures with @code{native} in their names employ the native
endianness, and work only at aligned indices: @var{k} must be a multiple
of 4.

The @code{...-set!} procedures return unspecified values.

@example
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u32-ref b 12 (endianness little))   => 4261412863
(bytevector-s32-ref b 12 (endianness little))   => -33554433
(bytevector-u32-ref b 12 (endianness big))      => 4294967293
(bytevector-s32-ref b 12 (endianness big))      => -3
@end example
@end deffn



@c page
@node stdlib bytevector integers 64
@section Operations on 64--bit integers


@deffn Procedure {bytevector-u64-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-s64-ref} @var{bytevector} @var{k} @var{endianness}
@deffnx Procedure {bytevector-u64-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-s64-native-ref} @var{bytevector} @var{k}
@deffnx Procedure {bytevector-u64-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-s64-set!} @var{bytevector} @var{k} @var{n} @var{endianness}
@deffnx Procedure {bytevector-u64-native-set!} @var{bytevector} @var{k} @var{n}
@deffnx Procedure {bytevector-s64-native-set!} @var{bytevector} @var{k} @var{n}
@var{k}, @dots{}, @var{k}+7 must be valid indices of @var{bytevector}.

For @func{bytevector-u64-set!} and @func{bytevector-u64-native-set!},
@var{n} must be an exact integer object in the interval
@code{0 <= n <= 2^64-1}.

For @func{bytevector-s64-set!} and @func{bytevector-s64-native-set!},
@var{n} must be an exact integer object in the interval
@code{-2^63 <= n <= 2^64-1}.

These retrieve and set eight--byte representations of numbers at indices
@var{k}, @dots{}, @var{k}+7, according to the endianness specified by
@var{endianness}.  The procedures with @code{u64} in their names deal
with the unsigned representation; those with @code{s64} with the
two's--complement representation.

The procedures with @code{native} in their names employ the native
endianness, and work only at aligned indices: @var{k} must be a multiple
of 8.

The @code{...-set!} procedures return unspecified values.

@example
(define b
  (u8-list->bytevector
    '(255 255 255 255 255 255 255 255
      255 255 255 255 255 255 255 253)))

(bytevector-u64-ref b 8 (endianness little))    => 18302628885633695743
(bytevector-s64-ref b 8 (endianness little))    => -144115188075855873
(bytevector-u64-ref b 8 (endianness big))       => 18446744073709551613
(bytevector-s64-ref b 8 (endianness big))       => -3
@end example
@end deffn



@c page
@node stdlib bytevector flonum
@section Operations on @ieee{} 754 representations


@deffn Procedure bytevector-ieee-single-native-ref @var{bytevector} @var{k}
@deffnx Procedure bytevector-ieee-single-ref @var{bytevector} @var{k} @var{endianness}
@var{k}, @dots{}, @var{k}+3 must be valid indices of @var{bytevector}.

For @code{bytevector-ieee-single-native-ref}, @var{k} must be a multiple
of 4.

These procedures return the inexact real number object that best
represents the @ieee{} 754 single--precision number represented by the
four bytes beginning at index @var{k}.
@end deffn


@deffn Procedure bytevector-ieee-double-native-ref @var{bytevector} @var{k}
@deffnx Procedure bytevector-ieee-double-ref @var{bytevector} @var{k} @var{endianness}
@var{k}, @dots{}, @var{k}+7 must be valid indices of @var{bytevector}.

For @func{bytevector-ieee-double-native-ref}, @var{k} must be a multiple
of 8.

These procedures return the inexact real number object that best
represents the @ieee{} 754 double--precision number represented by the
eight bytes beginning at index @var{k}.
@end deffn


@deffn Procedure {bytevector-ieee-single-native-set!} @var{bytevector} @var{k} @var{x}
@deffnx Procedure {bytevector-ieee-single-set!} @var{bytevector} @var{k} @var{x} @var{endianness}
@var{k}, @dots{}, @var{k}+3 must be valid indices of @var{bytevector}.

For @func{bytevector-ieee-single-native-set!}, @var{k} must be a
multiple of 4.

These procedures store an @ieee{} 754 single--precision representation
of @var{x} into elements @var{k} through @var{k}+3 of @var{bytevector},
and return unspecified values.
@end deffn


@deffn Procedure {bytevector-ieee-double-native-set!} @var{bytevector} @var{k} @var{x}
@deffnx Procedure {bytevector-ieee-double-set!} @var{bytevector} @var{k} @var{x} @var{endianness}
@var{K}, @dots{}, @var{k}+7 must be valid indices of @var{bytevector}.

For @func{bytevector-ieee-double-native-set!}, @var{k} must be a
multiple of 8.

These procedures store an @ieee{} 754 double--precision representation
of @var{x} into elements @var{k} through @var{k}+7 of @var{bytevector},
and return unspecified values.
@end deffn



@c page
@node stdlib bytevector strings
@section Operations on strings


This section describes procedures that convert between strings and
bytevectors containing Unicode encodings of those strings.  When
decoding bytevectors, encoding errors are handled as with the
@code{replace} semantics of textual I/O: If an invalid or incomplete
character encoding is encountered, then the replacement character
@code{U+FFFD} is appended to the string being generated, an appropriate
number of bytes are ignored, and decoding continues with the following
bytes.


@deffn Procedure string->utf8 @var{string}
Return a newly allocated (unless empty) bytevector that contains the
@utf{}-8 encoding of the given string.
@end deffn


@deffn Procedure string->utf16 @var{string}
@deffnx Procedure string->utf16 @var{string} @var{endianness}
If @var{endianness} is specified, it must be the symbol @code{big} or
the symbol @code{little}.  The @func{string->utf16} procedure returns a
newly allocated (unless empty) bytevector that contains the @utf{}-16BE
or @utf{}-16LE encoding of the given string (with no byte--order mark).
If endianness is not specified or is @code{big}, then @utf{}-16BE is
used.  If endianness is @code{little}, then @utf{}-16LE is used.
@end deffn


@deffn Procedure string->utf32 @var{string}
@deffnx Procedure string->utf32 @var{string} @var{endianness}
If @var{endianness} is specified, it must be the symbol @code{big} or
the symbol @code{little}.  The @func{string->utf32} procedure returns a
newly allocated (unless empty) bytevector that contains the @utf{}-32BE
or @utf{}-32LE encoding of the given string (with no byte mark).  If
endianness is not specified or is @code{big}, then @utf{}-32BE is used.
If endianness is @code{little}, then @utf{}-32LE is used.
@end deffn


@deffn Procedure utf8->string @var{bytevector}
Return a newly allocated (unless empty) string whose character sequence
is encoded by the given bytevector.
@end deffn


@deffn Procedure utf16->string @var{bytevector} @var{endianness}
@deffnx Procedure utf16->string @var{bytevector} @var{endianness} @var{endianness-mandatory}
@var{endianness} must be the symbol @code{big} or the symbol
@code{little}.

The @func{utf16->string} procedure returns a newly allocated (unless
empty) string whose character sequence is encoded by the given
bytevector.

@var{bytevector} is decoded according to @utf{}-16, @utf{}-16BE,
@utf{}-16LE, or a fourth encoding scheme that differs from all three of
those as follows: If @var{endianness-mandatory} is absent or @false{},
@func{utf16->string} determines the endianness according to a @utf{}-16
BOM at the beginning of @var{bytevector} if a BOM is present; in this
case, the BOM is not decoded as a character.  Also in this case, if no
@utf{}-16 BOM is present, @var{endianness} specifies the endianness of
the encoding.  If @var{endianness-mandatory} is a true value,
@var{endianness} specifies the endianness of the encoding, and any
@utf{}-16 BOM in the encoding is decoded as a regular character.

@quotation
@emph{Note:} A @utf{}-16 BOM is either a sequence of bytes @code{#xFE},
@code{#xFF} specifying @code{big} and @utf{}-16BE, or @code{#xFF},
@code{#xFE} specifying @code{little} and @utf{}-16LE.
@end quotation
@end deffn


@deffn Procedure utf32->string @var{bytevector} @var{endianness}
@deffnx Procedure utf32->string @var{bytevector} @var{endianness} @var{endianness-mandatory}
@var{endianness} must be the symbol @code{big} or the symbol
@code{little}.

The @func{utf32->string} procedure returns a newly allocated (unless
empty) string whose character sequence is encoded by the given
bytevector.

@var{bytevector} is decoded according to @utf{}-32, @utf{}-32BE,
@utf{}-32LE, or a fourth encoding scheme that differs from all three of
those as follows: If @var{endianness-mandatory} is absent or @false{},
@func{utf32->string} determines the endianness according to a @utf{}-32
BOM at the beginning of @var{bytevector} if a BOM is present; in this
case, the BOM is not decoded as a character.  Also in this case, if no
@utf{}-32 BOM is present, @var{endianness} specifies the endianness of
the encoding.  If @var{endianness-mandatory} is a true value,
@var{endianness} specifies the endianness of the encoding, and any
@utf{}-32 BOM in the encoding is decoded as a regular character.

@quotation
@emph{Note:} A @utf{}-32 BOM is either a sequence of bytes @code{#x00},
@code{#x00}, @code{#xFE}, @code{#xFF} specifying @code{big} and
@utf{}-32BE, or @code{#xFF}, @code{#xFE}, @code{#x00}, @code{#x00},
specifying @code{little} and @utf{}-32LE.
@end quotation
@end deffn



@c page
@node stdlib list
@chapter List utilities


This chapter describes the @rsixlibrary{lists} library, which contains
various useful procedures that operate on lists.


@deffn Procedure find @var{proc} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.  The @func{find} procedure
applies @var{proc} to the elements of @var{list} in order.  If
@var{proc} returns a true value for an element, @func{find} immediately
returns that element.  If @var{proc} returns @false{} for all elements
of the list, @func{find} returns @false{}.  @var{proc} is always called
in the same dynamic environment as @func{find} itself.

@example
(find even? '(3 1 4 1 5 9))             => 4
(find even? '(3 1 5 1 5 9))             => #f
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs up to the found element, or that it
is indeed a list if no element is found.  It should not check that it is
a chain of pairs beyond the found element.  The implementation must
check the restrictions on @var{proc} to the extent performed by applying
it as described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure for-all @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
@deffnx Procedure exists @var{proc} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s should all have the same length, and @var{proc} should
accept @emph{n} arguments and return a single value.  @var{proc} should
not mutate the @var{list} arguments.

For natural numbers @emph{i} = 0, 1, @dots{}, the @func{for-all}
procedure successively applies @var{proc} to arguments @emph{x_i^1
@dots{} x_i^n}, where @emph{x_i^j} is the @emph{i}th element of
@var{listj}, until @false{} is returned.

If @var{proc} returns true values for all but the last element of
@vari{list}, @func{for-all} performs a tail call of @var{proc} on the
@emph{k}th elements, where @emph{k} is the length of @vari{list}.  If
@var{proc} returns @false{} on any set of elements, @func{for-all}
returns @false{} after the first such application of @var{proc}.  If the
@var{list}s are all empty, @func{for-all} returns @true{}.

For natural numbers @emph{i} = 0, 1, @dots{}, the @func{exists}
procedure applies @var{proc} successively to arguments @emph{x_i^1}
@dots{} @emph{x_i^n}, where @emph{x_i^j} is the @emph{i}th element of
@var{listj}, until a true value is returned.

If @var{proc} returns @false{} for all but the last elements of the
@var{list}s, @code{exists} performs a tail call of @var{proc} on the
@emph{k}th elements, where @emph{k} is the length of @vari{list}.  If
@var{proc} returns a true value on any set of elements, @code{ exists}
returns that value after the first such application of @var{proc}.  If
the @var{list}s are all empty, @code{exists} returns @false{}.

@var{proc} is always called in the same dynamic environment as
@func{for-all} or, respectively, @func{exists} itself.

@example
(for-all even? '(3 1 4 1 5 9))          => #f
(for-all even? '(3 1 4 1 5 9 . 2))      => #f
(for-all even? '(2 4 14))               => #t
(for-all even? '(2 4 14 . 9))           => exception &assertion
(for-all (lambda (n) (and (even? n) n))
         '(2 4 14))                     => 14
(for-all < '(1 2 3) '(2 3 4))           => #t
(for-all < '(1 2 4) '(2 3 4))           => #f

(exists even? '(3 1 4 1 5 9))           => #t
(exists even? '(3 1 1 5 9))             => #f
(exists even? '(3 1 1 5 9 . 2))         => exception &assertion
(exists (lambda (n) (and (even? n) n))
        '(2 1 4 14))                    => 2
(exists < '(1 2 4) '(2 3 4))            => #t
(exists > '(1 2 3) '(2 3 4))            => #f
@end example

@strong{Implementation responsibilities:} The implementation must check
that the @var{list}s are chains of pairs to the extent necessary to
determine the return value.  If this requires traversing the lists
entirely, the implementation should check that the @var{list}s all have
the same length.  If not, it should not check that the @var{list}s are
chains of pairs beyond the traversal.  The implementation must check the
restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure filter @var{proc} @var{list}
@deffnx Procedure partition @var{proc} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.

The @func{filter} procedure applies @var{proc} to each element of
@var{list} and returns a list of the elements of @var{list} for which
@var{proc} returned a true value.

The @func{partition} procedure also applies @var{proc} to each element
of @var{list}, but returns two values, the first one a list of the
elements of @var{list} for which @var{proc} returned a true value, and
the second a list of the elements of @var{list} for which @var{proc}
returned @false{}.

In both cases, the elements of the result list(s) are in the same order
as they appear in the input list.  @var{proc} is always called in the
same dynamic environment as @func{filter} or, respectively,
@func{partition} itself.  If multiple returns occur from @func{filter}
or @func{partitions}, the return values returned by earlier returns are
not mutated.

@example
(filter even? '(3 1 4 1 5 9 2 6))       => (4 2 6)

(partition even? '(3 1 4 1 5 9 2 6))    => (4 2 6) (3 1 1 5 9)
                                           ; two values
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure fold-left @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s should all have the same length.  @var{combine} must be
a procedure; it should accept one more argument than there are
@var{list}s and return a single value; it should not mutate the
@var{list} arguments.

The @func{fold-left} procedure iterates the @var{combine} procedure over
an accumulator value and the elements of the @var{list}s from left to
right, starting with an accumulator value of @var{nil}.

More specifically, @func{fold-left} returns @var{nil} if the @var{list}s
are empty.  If they are not empty, @var{combine} is first applied to
@var{nil} and the respective first elements of the @var{list}s in order.
The result becomes the new accumulator value, and @var{combine} is
applied to the new accumulator value and the respective next elements of
the @var{list}.  This step is repeated until the end of the list is
reached; then the accumulator value is returned.

@var{combine} is always called in the same dynamic environment as
@func{fold-left} itself.

@example
(fold-left + 0 '(1 2 3 4 5))            => 15

(fold-left (lambda (a e)
             (cons e a))
           '()
           '(1 2 3 4 5))                => (5 4 3 2 1)

(fold-left (lambda (count x)
             (if (odd? x)
                 (+ count 1)
               count))
           0
           '(3 1 4 1 5 9 2 6 5 3))      => 7

(fold-left (lambda (max-len s)
             (max max-len (string-length s)))
           0
           '("longest" "long" "longer"))
                                        => 7

(fold-left cons '(q) '(a b c))          => ((((q) . a) . b) . c)

(fold-left + 0 '(1 2 3) '(4 5 6))       => 21
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{combine} to the extent performed by
applying it as described.  An implementation may check whether
@var{combine} is an appropriate argument before applying it.
@end deffn


@deffn Procedure fold-right @var{combine} @var{nil} @vari{list} @varii{list} @dots{} @varn{list}
The @var{list}s should all have the same length.  @var{combine} must be
a procedure; it should accept one more argument than there are
@var{list}s and return a single value; @var{combine} should not mutate
the @var{list} arguments.

The @func{fold-right} procedure iterates the @var{combine} procedure
over the elements of the @var{list}s from right to left and an
accumulator value, starting with an accumulator value of @var{nil}.

More specifically, @func{fold-right} returns @var{nil} if the
@var{list}s are empty.  If they are not empty, @var{combine} is first
applied to the respective last elements of the @var{list}s in order and
@var{nil}.  The result becomes the new accumulator value, and
@var{combine} is applied to the respective previous elements of the
@var{list}s and the new accumulator value.  This step is repeated until
the beginning of the list is reached; then the accumulator value is
returned.

@var{proc} is always called in the same dynamic environment as
@func{fold-right} itself.

@example
(fold-right + 0 '(1 2 3 4 5))                   => 15

(fold-right cons '() '(1 2 3 4 5))              => (1 2 3 4 5)

(fold-right (lambda (x l)
              (if (odd? x) (cons x l) l))
            '()
            '(3 1 4 1 5 9 2 6 5))
                                                => (3 1 1 5 9 5)

(fold-right cons '(q) '(a b c))                 => (a b c q)

(fold-right + 0 '(1 2 3) '(4 5 6))              => 21
@end example

@strong{Implementation responsibilities:} The implementation should
check that the @var{list}s all have the same length.  The implementation
must check the restrictions on @var{combine} to the extent performed by
applying it as described.  An implementation may check whether
@var{combine} is an appropriate argument before applying it.
@end deffn


@deffn Procedure remp @var{proc} @var{list}
@deffnx Procedure remove @var{obj} @var{list}
@deffnx Procedure remv @var{obj} @var{list}
@deffnx Procedure remq @var{obj} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.

Each of these procedures returns a list of the elements of @var{list}
that do not satisfy a given condition.

The @func{remp} procedure applies @var{proc} to each element of
@var{list} and returns a list of the elements of @var{list} for which
@var{proc} returned @false{}.  @var{proc} is always called in the same
dynamic environment as @func{remp} itself.

The @func{remove}, @func{remv}, and @func{remq} procedures return a list
of the elements that are not @var{obj}.  The @func{remq} procedure uses
@func{eq?} to compare @var{obj} with the elements of @var{list}, while
@func{remv} uses @func{eqv?} and @func{remove} uses @func{equal?}.

The elements of the result list are in the same order as they appear in
the input list.  If multiple returns occur from @func{remp}, the return
values returned by earlier returns are not mutated.

@example
(remp even? '(3 1 4 1 5 9 2 6 5))       => (3 1 1 5 9 5)

(remove 1 '(3 1 4 1 5 9 2 6 5))         => (3 4 5 9 2 6 5)

(remv 1 '(3 1 4 1 5 9 2 6 5))           => (3 4 5 9 2 6 5)

(remq 'foo '(bar foo baz))              => (bar baz)
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure memp @var{proc} @var{list}
@deffnx Procedure member @var{obj} @var{list}
@deffnx Procedure memv @var{obj} @var{list}
@deffnx Procedure memq @var{obj} @var{list}
@var{proc} should accept one argument and return a single value.
@var{proc} should not mutate @var{list}.

These procedures return the first sublist of @var{list} whose car
satisfies a given condition, where the sublists of @var{lists} are the
lists returned by @code{(list-tail @var{list} @var{k})} for @var{k} less
than the length of @var{list}.

The @func{memp} procedure applies @var{proc} to the cars of the sublists
of @var{list} until it finds one for which @var{proc} returns a true
value.  @var{proc} is always called in the same dynamic environment as
@func{memp} itself.

The @func{member}, @func{memv}, and @func{memq} procedures look for the
first occurrence of @var{obj}.  If @var{list} does not contain an
element satisfying the condition, then @false{} (not the empty list) is
returned.  The @func{member} procedure uses @func{equal?} to compare
@var{obj} with the elements of @var{list}, while @func{memv} uses
@func{eqv?} and @func{memq} uses @func{eq?}.

@example
(memp even? '(3 1 4 1 5 9 2 6 5))       => (4 1 5 9 2 6 5)

(memq 'a '(a b c))                      => (a b c)
(memq 'b '(a b c))                      => (b c)
(memq 'a '(b c d))                      => #f
(memq (list 'a) '(b (a) c))             => #f
(member (list 'a) '(b (a) c))           => ((a) c)
(memq 101 '(100 101 102))               => unspecified
(memv 101 '(100 101 102))               => (101 102)
@end example

@strong{Implementation responsibilities:} The implementation must check
that @var{list} is a chain of pairs up to the found element, or that it
is indeed a list if no element is found.  It should not check that it is
a chain of pairs beyond the found element.  The implementation must
check the restrictions on @var{proc} to the extent performed by applying
it as described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure assp @var{proc} @var{alist}
@deffnx Procedure assoc @var{obj} @var{alist}
@deffnx Procedure assv @var{obj} @var{alist}
@deffnx Procedure assq @var{obj} @var{alist}
@var{alist} (for ``association list'') should be a list of pairs.
@var{proc} should accept one argument and return a single value.
@var{Proc} should not mutate @var{alist}.

These procedures find the first pair in @var{alist} whose car field
satisfies a given condition, and returns that pair without traversing
@var{alist} further.  If no pair in @var{alist} satisfies the condition,
then @false{} is returned.

The @func{assp} procedure successively applies @var{proc} to the car
fields of @var{alist} and looks for a pair for which it returns a true
value.  @var{proc} is always called in the same dynamic environment as
@func{assp} itself.

The @func{assoc}, @func{assv}, and @func{assq} procedures look for a
pair that has @var{obj} as its car.  The @func{assoc} procedure uses
@func{equal?} to compare @var{obj} with the car fields of the pairs in
@var{alist}, while @func{assv} uses @func{eqv?} and @func{assq} uses
@func{eq?}.

@strong{Implementation responsibilities:} The implementation must check
that @var{alist} is a chain of pairs containing pairs up to the found
pair, or that it is indeed a list of pairs if no element is found.  It
should not check that it is a chain of pairs beyond the found element.
The implementation must check the restrictions on @var{proc} to the
extent performed by applying it as described.  An implementation may
check whether @var{proc} is an appropriate argument before applying it.

@example
(define d '((3 a) (1 b) (4 c)))

(assp even? d)                                  => (4 c)
(assp odd? d)                                   => (3 a)

(define e '((a 1) (b 2) (c 3)))
(assq 'a e)                                     => (a 1)
(assq 'b e)                                     => (b 2)
(assq 'd e)                                     => #f
(assq (list 'a) '(((a)) ((b)) ((c))))           => #f
(assoc (list 'a) '(((a)) ((b)) ((c))))          => ((a))
(assq 5 '((2 3) (5 7) (11 13)))                 => unspecified
(assv 5 '((2 3) (5 7) (11 13)))                 => (5 7)
@end example
@end deffn


@deffn Procedure {cons*} @vari{obj} @dots{} @varn{obj} @var{obj}
@deffnx Procedure {cons*} @var{obj}
If called with at least two arguments, @func{cons*} returns a freshly
allocated chain of pairs whose cars are @vari{obj}, @dots{}, @varn{obj},
and whose last cdr is @var{obj}.  If called with only one argument,
@func{cons*} returns that argument.

@example
(cons* 1 2 '(3 4 5))            => (1 2 3 4 5)
(cons* 1 2 3)                   => (1 2 . 3)
(cons* 1)                       => 1
@end example
@end deffn



@c page
@node stdlib sorting
@chapter Sorting


This chapter describes the @rsixlibrary{sorting} library for sorting
lists and vectors.


@deffn Procedure list-sort @var{proc list}
@deffnx Procedure vector-sort @var{proc vector}
@var{proc} should accept any two elements of @var{list} or @var{vector},
and should not have any side effects.  @var{proc} should return a true
value when its first argument is strictly less than its second, and
@false{} otherwise.

The @func{list-sort} and @func{vector-sort} procedures perform a stable
sort of @var{list} or @var{vector} in ascending order according to
@var{proc}, without changing @var{list} or @var{vector} in any way.  The
@func{list-sort} procedure returns a list, and @func{vector-sort}
returns a vector.

The results may be @func{eq?} to the argument when the argument is
already sorted, and the result of @func{list-sort} may share structure
with a tail of the original list.

The sorting algorithm performs @emph{O(n log n)} calls to @var{proc}
where @emph{n} is the length of @var{list} or @var{vector}, and all
arguments passed to @var{proc} are elements of the list or vector being
sorted, but the pairing of arguments and the sequencing of calls to
@var{proc} are not specified.  If multiple returns occur from
@func{list-sort} or @func{vector-sort}, the return values returned by
earlier returns are not mutated.

@example
(list-sort < '(3 5 2 1))                => (1 2 3 5)
(vector-sort < '#(3 5 2 1))             => #(1 2 3 5)
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn


@deffn Procedure vector-sort! @var{proc} @var{vector}
@var{proc} should accept any two elements of the vector, and should not
have any side effects.  @var{proc} should return a true value when its
first argument is strictly less than its second, and @false{}
otherwise.

The @func{vector-sort!} procedure destructively sorts @var{vector} in
ascending order according to @var{proc}.  The sorting algorithm performs
@emph{O(n^2)} calls to @var{proc} where @emph{n} is the length of
@var{vector}, and all arguments passed to @var{proc} are elements of the
vector being sorted, but the pairing of arguments and the sequencing of
calls to @var{proc} are not specified.  The sorting algorithm may be
unstable.  The procedure returns unspecified values.

@example
(define v (vector 3 5 2 1))
(vector-sort! < v)              => unspecified
v                               => #(1 2 3 5)
@end example

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} to the extent performed by applying it as
described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn



@c page
@node stdlib control
@chapter Control structures


This chapter describes the @rsixlibrary{control} library, which provides
useful control structures.


@deffn Syntax when @meta{test} @hyperi{expression} @hyperii{expression} @dots{}
@deffnx Syntax unless @meta{test} @hyperi{expression} @hyperii{expression} @dots{}
@meta{test} must be an expression.

A @func{when} expression is evaluated by evaluating the @meta{test}
expression.  If @meta{test} evaluates to a true value, the remaining
@hyper{expression}s are evaluated in order, and the results of the last
@hyper{expression} are returned as the results of the entire @func{when}
expression.  Otherwise, the @func{when} expression returns unspecified
values.

An @func{unless} expression is evaluated by evaluating the @meta{test}
expression.  If @meta{test} evaluates to @false{}, the remaining
@hyper{expression}s are evaluated in order, and the results of the last
@hyper{expression} are returned as the results of the entire
@func{unless} expression.  Otherwise, the @func{unless} expression
returns unspecified values.

The final @hyper{expression} is in tail context if the @func{when} or
@func{unless} form is itself in tail context.

@example
(when (> 3 2) 'greater)         => greater
(when (< 3 2) 'greater)         => unspecified
(unless (> 3 2) 'less)          => unspecified
(unless (< 3 2) 'less)          => less
@end example

The @func{when} and @func{unless} expressions are derived forms.  They
could be defined by the following macros:

@example
(define-syntax @code{when}
  (syntax-rules ()
    ((when test result1 result2 ...)
     (if test
         (begin result1 result2 ...)))))

(define-syntax @code{unless}
  (syntax-rules ()
    ((unless test result1 result2 ...)
     (if (not test)
         (begin result1 result2 ...)))))
@end example
@end deffn


@deffn Syntax do ((@hyperi{variable} @hyperi{init} @hyperi{step}) @dots{}) (@meta{test} @hyper{expression} @dots{}) @meta{command} @dots{}
The @meta{init}s, @hyper{step}s, @hyper{test}s, and @hyper{command}s
must be expressions.  The @meta{variable}s must be pairwise distinct
variables.

The @func{do} expression is an iteration construct.  It specifies a set
of variables to be bound, how they are to be initialized at the start,
and how they are to be updated on each iteration.

A @func{do} expression is evaluated as follows: The @meta{init}
expressions are evaluated (in some unspecified order), the
@meta{variable}s are bound to fresh locations, the results of the
@meta{init} expressions are stored in the bindings of the
@meta{variable}s, and then the iteration phase begins.

Each iteration begins by evaluating @meta{test}; if the result is
@false{}, then the @meta{command}s are evaluated in order for effect,
the @meta{step} expressions are evaluated in some unspecified order, the
@meta{variable}s are bound to fresh locations holding the results, and
the next iteration begins.

If @meta{test} evaluates to a true value, the @meta{expression}s are
evaluated from left to right and the values of the last
@meta{expression} are returned.  If no @hyper{expression}s are present,
then the @code{do} expression returns unspecified values.

The region consists of the entire @func{do} expression except for the
@meta{init}s.

A @meta{step} may be omitted, in which case the effect is the same as if
@code{(@meta{variable} @hyper{init} @hyper{variable})} had been written
instead of @code{(@meta{variable} @hyper{init})}.

If a @code{do} expression appears in a tail context, the
@meta{expression}s are a @hyper{tail sequence} in the sense of report
section @ref{baselib tail call}, i.e., the last @meta{expression} is
also in a tail context.

@example
(do ((vec (make-vector 5))
     (i 0 (+ i 1)))
    ((= i 5) vec)
  (vector-set! vec i i))                => #(0 1 2 3 4)

(let ((x '(1 3 5 7 9)))
  (do ((x x (cdr x))
       (sum 0 (+ sum (car x))))
      ((null? x) sum)))                 => 25
@end example

The following definition of @func{do} uses a trick to expand the
variable clauses.

@example
(define-syntax do
  (syntax-rules ()
    ((do ((var init step ...) ...)
         (test expr ...)
         command ...)
     (letrec
       ((loop
         (lambda (var ...)
           (if test
               (begin
                 #f ; avoid empty begin
                 expr ...)
               (begin
                 command
                 ...
                 (loop (do "step" var step ...)
                       ...))))))
       (loop init ...)))
    ((do "step" x)
     x)
    ((do "step" x y)
     y)))
@end example
@end deffn


@deffn Syntax case-lambda @meta{case-lambda clause} @dots{}
Each @meta{case-lambda clause} must be of the form:

@example
(@meta{formals} @hyper{body})
@end example

@meta{formals} must be as in a @func{lambda} form (@ref{baselib
expressions procedures}), and @meta{body} is as described in report
section @ref{baselib bodies}.

A @func{case-lambda} expression evaluates to a procedure.  This
procedure, when applied, tries to match its arguments to the
@meta{case-lambda clause}s in order.  The arguments match a clause if
one of the following conditions is fulfilled:

@itemize
@item
@meta{formals} has the form @code{(@hyper{variable} @dots{})} and the
number of arguments is the same as the number of formal parameters in
@meta{formals}.

@item
@meta{formals} has the form:

@example
(@hyperi{variable} @dots{} @hypern{variable} . @meta{variable_(n+1)})
@end example

@noindent
and the number of arguments is at least @emph{n}.

@item
@meta{formals} has the form @code{@hyper{variable}}.
@end itemize

For the first clause matched by the arguments, the variables of the
@meta{formals} are bound to fresh locations containing the argument
values in the same arrangement as with @func{lambda}.

The last expression of a @meta{body} in a @func{case-lambda} expression
is in tail context.

If the arguments match none of the clauses, an exception with condition
type @code{&assertion} is raised.

@example
(define foo
  (case-lambda
   (() 'zero)
   ((x) (list 'one x))
   ((x y) (list 'two x y))
   ((a b c d . e) (list 'four a b c d e))
   (rest (list 'rest rest))))

(foo)                                   => zero
(foo 1)                                 => (one 1)
(foo 1 2)                               => (two 1 2)
(foo 1 2 3)                             => (rest (1 2 3))
(foo 1 2 3 4)                           => (four 1 2 3 4 ())
@end example

The @func{case-lambda} keyword can be defined in terms of @func{lambda}
by the following macros:

@example
(define-syntax case-lambda
  (syntax-rules ()
    ((_ (fmls b1 b2 ...))
     (lambda fmls b1 b2 ...))
    ((_ (fmls b1 b2 ...) ...)
     (lambda args
       (let ((n (length args)))
         (case-lambda-help args n
           (fmls b1 b2 ...) ...))))))

(define-syntax case-lambda-help
  (syntax-rules ()
    ((_ args n)
     (assertion-violation #f
       "unexpected number of arguments"))
    ((_ args n ((x ...) b1 b2 ...) more ...)
     (if (= n (length '(x ...)))
         (apply (lambda (x ...) b1 b2 ...) args)
         (case-lambda-help args n more ...)))
    ((_ args n ((x1 x2 ... . r) b1 b2 ...) more ...)
     (if (>= n (length '(x1 x2 ...)))
         (apply (lambda (x1 x2 ... . r) b1 b2 ...)
                   args)
         (case-lambda-help args n more ...)))
    ((_ args n (r b1 b2 ...) more ...)
     (apply (lambda r b1 b2 ...) args))))
@end example
@end deffn




@c page
@node stdlib records
@chapter Records


This section describes abstractions for creating new data types
representing records.

@menu
* stdlib records intro::                Introduction.
* stdlib records mutability::           Mutability and equivalence
                                        of records.
* stdlib records syntactic layer::      Syntactic layer.
* stdlib records procedural layer::     Procedural layer.
* stdlib records inspection::           Inspection.
@end menu



@c page
@node stdlib records intro
@section Introduction


A record is a compound data structure with a fixed number of components,
called @emph{fields}.  Each record has an associated type specified by a
@emph{record-type descriptor}, which is an object that specifies the
fields of the record and various other properties that all records of
that type share.  Record objects are created by a @emph{record
constructor}, a procedure that creates a fresh record object and
initializes its fields to values.  Records of different types can be
distinguished from each other and from other types of objects by
@emph{record predicates}.  A record predicate returns @true{} when
passed a record of the type specified by the record--type descriptor and
@false{} otherwise.  An @emph{accessor} extracts from a record the
component associated with a field, and a @emph{mutator} changes the
component to a different value.

Record types can be extended via single inheritance, allowing record
types to model hierarchies that occur in applications like algebraic
data types as well as single--inheritance class systems.  If a record
type @var{t} extends another record type @var{p}, each record of type
@var{t} is also a record of type @var{p}, and the predicate, accessors,
and mutators applicable to a record of type @var{p} are also applicable
to a record of type @var{t}.  The extension relationship is transitive
in the sense that a type extends its parent's parent, if any, and so on.
A record type that does not extend another record type is called a
@emph{base record type}.

A record type can be @emph{sealed} to prevent it from being extended.
Moreover, a record type can be @emph{nongenerative}, i.e., it is
globally identified by a ``uid'', and new, compatible definitions of a
nongenerative record type with the same uid as a previous always yield
the same record type.

The record mechanism spans three libraries:

@table @rsixlibrary
@item records syntactic
library, a syntactic layer for defining a record type and associated
constructor, predicate, accessor, and mutators,

@item records procedural
library, a procedural layer for creating and manipulating record types
and creating constructors, predicates, accessors, and mutators;

@item records inspection
library, a set of inspection procedures.
@end table

The inspection procedures allow programs to obtain from a record
instance a descriptor for the type and from there obtain access to the
fields of the record instance. This facility allows the creation of
portable printers and inspectors.  A program may prevent access to a
record's type (and thereby protect the information stored in the record
from the inspection mechanism) by declaring the type opaque.  Thus,
opacity as presented here can be used to enforce abstraction barriers.

Any of the standard types mentioned in this report may or may not be
implemented as an opaque record type.  Thus, it may be possible to use
inspection on objects of the standard types.

The procedural layer is particularly useful for writing interpreters
that construct host--compatible record types.  It may also serve as a
target for expansion of the syntactic layers.  The record operations
provided through the procedural layer may, however, be less efficient
than the operations provided through the syntactic layer, which is
designed to allow expand--time determination of record--instance sizes
and field offsets.  Therefore, alternative implementations of syntactic
record--type definition should, when possible, expand into the syntactic
layer rather than the procedural layer.

The syntactic layer is used more commonly and therefore described first.
This chapter uses the @var{rtd} and @var{constructor-descriptor}
parameter names for arguments that must be record-type descriptors and
constructor descriptors, respectively.



@c page
@node stdlib records mutability
@section Mutability and equivalence of records


The fields of a record type are designated @emph{mutable} or
@emph{immutable}.  Correspondingly, a record type with no mutable field
is called @emph{immutable}, and all records of that type are immutable
objects.  All other record types are @emph{mutable}, and so are their
records.

Each call to a record constructor returns a new record with a fresh
location (@ref{lang basic storage model}).  Consequently, for two
records @vari{obj} and @varii{obj}, the return value of @code{(eqv?
@vari{obj} @varii{obj})}, as well as the return value of @code{(eq?
@vari{obj} @varii{obj})}, adheres to the following criteria
(@ref{baselib predicates}):

@itemize
@item
If @vari{obj} and @varii{obj} have different record types (i.e., their
record--type descriptors are not @func{eqv?}), @func{eqv?}  returns
@false{}.

@item
If @vari{obj} and @varii{obj} are both records of the same record type,
and are the results of two separate calls to record constructors, then
@func{eqv?} returns @false{}.
@item
If @vari{obj} and @varii{obj} are both the result of a single call to a
record constructor, then @func{eqv?} returns @true{}.

@item
If @vari{obj} and @varii{obj} are both records of the same record type,
where applying an accessor to both yields results for which @func{eqv?}
returns @false{}, then @func{eqv?} returns @false{}.
@end itemize



@c page
@node stdlib records syntactic layer
@section Syntactic layer


The syntactic layer is provided by the @rsixlibrary{records syntactic}
library.  Some details of the specification are explained in terms of
the specification of the procedural layer below.

The record--type--defining form @func{define-record-type} is a
definition and can appear anywhere any other @meta{definition} can
appear.


@deffn Syntax define-record-type @meta{name spec} @arbno{@hyper{record clause}}
@deffnx {Auxiliary Syntax} fields
@deffnx {Auxiliary Syntax} mutable
@deffnx {Auxiliary Syntax} immutable
@deffnx {Auxiliary Syntax} parent
@deffnx {Auxiliary Syntax} protocol
@deffnx {Auxiliary Syntax} sealed
@deffnx {Auxiliary Syntax} opaque
@deffnx {Auxiliary Syntax} nongenerative
@deffnx {Auxiliary Syntax} parent-rtd
A @func{define-record-type} form defines a record type along with
associated constructor descriptor and constructor, predicate, field
accessors, and field mutators.  The @func{define-record-type} form
expands into a set of definitions in the environment where
@func{define-record-type} appears; hence, it is possible to refer to the
bindings (except for that of the record type itself) recursively.

The @meta{name spec} specifies the names of the record type,
constructor, and predicate. It must take one of the following forms:

@example
(@meta{record name} @hyper{constructor name} @hyper{predicate name})
@meta{record name}
@end example

@meta{record name}, @hyper{constructor name}, and @hyper{predicate name}
must all be identifiers.

@meta{record name}, taken as a symbol, becomes the name of the record
type.  (See the description of @func{make-record-type-descriptor}
below.)  Additionally, it is bound by this definition to an expand--time
or run--time representation of the record type and can be used as parent
name in syntactic record--type definitions that extend this
definition. It can also be used as a handle to gain access to the
underlying record--type descriptor and constructor descriptor (see
@func{record-type-descriptor} and @func{record-constructor-descriptor}
below).

@meta{constructor name} is defined by this definition to be a
constructor for the defined record type, with a protocol specified by
the @code{protocol} clause, or, in its absence, using a default
protocol.  For details, see the description of the @code{protocol}
clause below.

@meta{predicate name} is defined by this definition to a predicate for
the defined record type.

The second form of @meta{name spec} is an abbreviation for the first
form, where the name of the constructor is generated by prefixing the
record name with @code{make-}, and the predicate name is generated by
adding a question mark (@code{?}) to the end of the record name. For
example, if the record name is @code{frob}, the name of the constructor
is @func{make-frob}, and the predicate name is @func{frob?}.

Each @meta{record clause} must take one of the following forms; it is a
syntax violation if multiple @meta{record clause}s of the same kind
appear in a @func{define-record-type} form.
@end deffn


@deffn {Auxiliary Syntax} fields @arbno{@meta{field spec}}
Each @meta{field spec} has one of the following forms

@example
(immutable @meta{field name} @hyper{accessor name})
(mutable @meta{field name}
         @meta{accessor name} @hyper{mutator name})
(immutable @meta{field name})
(mutable @meta{field name})
@meta{field name}
@end example

@meta{field name}, @hyper{accessor name}, and @hyper{mutator name} must
all be identifiers.  The first form declares an immutable field called
@meta{field name}, with the corresponding accessor named @meta{accessor
name}.  The second form declares a mutable field called @meta{field
name}, with the corresponding accessor named @meta{accessor name}, and
with the corresponding mutator named @meta{mutator name}.

If @meta{field spec} takes the third or fourth form, the accessor name
is generated by appending the record name and field name with a hyphen
separator, and the mutator name (for a mutable field) is generated by
adding a @code{-set!} suffix to the accessor name.  For example, if the
record name is @code{frob} and the field name is @code{widget}, the
accessor name is @func{frob-widget} and the mutator name is
@func{frob-widget-set!}.

If @meta{field spec} is just a @hyper{field name} form, it is an
abbreviation for @code{(immutable @meta{field name})}.

The @meta{field name}s become, as symbols, the names of the fields in
the record--type descriptor being created, in the same order.

The @code{fields} clause may be absent; this is equivalent to an empty
@code{fields} clause.
@end deffn


@deffn {Auxiliary Syntax} parent @meta{parent name}
Specifies that the record type is to have parent type @hyper{parent
name}, where @meta{parent name} is the @hyper{record name} of a record
type previously defined using @func{define-record-type}.  The
record--type definition associated with @meta{parent name} must not be
sealed.  If no @code{parent} clause and no @code{parent-rtd} (see below)
clause is present, the record type is a base type.
@end deffn


@deffn {Auxiliary Syntax} protocol @meta{expression}
@meta{expression} is evaluated in the same environment as the
@func{define-record-type} form, and must evaluate to a protocol
appropriate for the record type being defined.

The protocol is used to create a record--constructor descriptor as
described below.  If no @code{protocol} clause is specified, a
constructor descriptor is still created using a default protocol.  The
clause can be absent only if the record type being defined has no parent
type, or if the parent definition does not specify a protocol.
@end deffn


@deffn {Auxiliary Syntax} sealed #t
@deffnx {Auxiliary Syntax} sealed #f
If this option is specified with operand @true{}, the defined record
type is sealed, i.e., no extensions of the record type can be created.
If this option is specified with operand @false{}, or is absent, the
defined record type is not sealed.
@end deffn


@deffn {Auxiliary Syntax} opaque #t
@deffnx {Auxiliary Syntax} opaque #f
If this option is specified with operand @true{}, or if an opaque parent
record type is specified, the defined record type is opaque.  Otherwise,
the defined record type is not opaque.  See the specification of
@code{record-rtd} below for details.
@end deffn


@deffn {Auxiliary Syntax} nongenerative @meta{uid}
@deffnx {Auxiliary Syntax} nongenerative
This specifies that the record type is nongenerative with uid
@meta{uid}, which must be an @hyper{identifier}.  If @meta{uid} is
absent, a unique uid is generated at macro--expansion time.  If two
record--type definitions specify the same @var{uid}, then the
record--type definitions should be equivalent, i.e., the implied
arguments to @func{make-record-type-descriptor} must be equivalent as
described under @func{make-record-type-descriptor}.

If this condition is not met, it is either considered a syntax violation
or an exception with condition type @code{&assertion} is raised.  If the
condition is met, a single record type is generated for both
definitions.

In the absence of a @code{nongenerative} clause, a new record type is
generated every time a @func{define-record-type} form is evaluated:

@example
(let ((f (lambda (x)
           (define-record-type r ...)
           (if x r? (make-r ...)))))
  ((f #t) (f #f)))
=> #f
@end example
@end deffn


@deffn {Auxiliary Syntax} parent-rtd @meta{parent rtd} @hyper{parent cd}
Specifies that the record type is to have its parent type specified by
@meta{parent rtd}, which should be an expression evaluating to a
record--type descriptor, and @meta{parent cd}, which should be an
expression evaluating to a constructor descriptor (see below).  Either
@meta{parent rtd} or @meta{parent cd} can evaluate to @false{}.  The
record--type definition associated with the value of @meta{parent rtd}
must not be sealed.  Moreover, a record--type definition must not have
both a @code{parent} and a @code{parent-rtd} clause.
@end deffn


@quotation
@emph{Note:} The syntactic layer is designed to allow record--instance
sizes and field offsets to be determined at expand time, i.e., by a
macro definition of @func{define-record-type}, as long as the parent (if
any) is known.  Implementations that take advantage of this may generate
less efficient constructor, accessor, and mutator code when the
@code{parent-rtd} clause is used, since the type of the parent is
generally not known until run time.  The @code{parent} clause should
therefore be used instead when possible.
@end quotation

All bindings created by @func{define-record-type} (for the record type,
the constructor, the predicate, the accessors, and the mutators) must
have names that are pairwise distinct.

The constructor created by a @func{define-record-type} form is a
procedure as follows:

@itemize
@item
If there is no @code{parent} clause and no @code{protocol} clause, the
constructor accepts as many arguments as there are fields, in the same
order as they appear in the @code{fields} clause, and returns a record
object with the fields initialized to the corresponding arguments.

@item
If there is no @code{parent} or @code{parent-rtd} clause and a
@code{protocol} clause, the protocol expression must evaluate to a
procedure that accepts a single argument.  The protocol procedure is
called once during the evaluation of the @func{define-record-type} form
with a procedure @var{p} as its argument.  It should return a procedure,
which will become the constructor bound to @meta{constructor name}.  The
procedure @var{p} accepts as many arguments as there are fields, in the
same order as they appear in the @code{fields} clause, and returns a
record object with the fields initialized to the corresponding
arguments.

The constructor returned by the protocol procedure can accept an
arbitrary number of arguments, and should call @var{p} once to construct
a record object, and return that record object.

For example, the following protocol expression for a record--type
definition with three fields creates a constructor that accepts values
for all fields, and initialized them in the reverse order of the
arguments:

@example
(lambda (p)
  (lambda (v1 v2 v3)
    (p v3 v2 v1)))
@end example

@item
If there is both a @code{parent} clause and a @code{protocol} clause,
then the protocol procedure is called once with a procedure @var{n} as
its argument.  As in the previous case, the protocol procedure should
return a procedure, which will become the constructor bound to
@meta{constructor name}.  However, @var{n} is different from @var{p} in
the previous case: It accepts arguments corresponding to the arguments
of the constructor of the parent type.  It then returns a procedure
@var{p} that accepts as many arguments as there are (additional) fields
in this type, in the same order as in the @code{fields} clause, and
returns a record object with the fields of the parent record types
initialized according to their constructors and the arguments to
@var{n}, and the fields of this record type initialized to its arguments
of @var{p}.

The constructor returned by the protocol procedure can accept an
arbitrary number of arguments, and should call @var{n} once to construct
the procedure @var{p}, and call @var{p} once to create the record
object, and finally return that record object.

For example, the following protocol expression assumes that the
constructor of the parent type takes three arguments:

@example
(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))
@end example

The resulting constructor accepts seven arguments, and initializes the
fields of the parent types according to the constructor of the parent
type, with @var{v1}, @var{v2}, and @var{v3} as arguments.  It also
initializes the fields of this record type to the values of @var{x1},
@dots{}, @var{x4}.

@item
If there is a @code{parent} clause, but no @code{protocol} clause, then
the parent type must not have a @code{protocol} clause itself.  The
constructor bound to @meta{constructor name} is a procedure that accepts
arguments corresponding to the parent types' constructor first, and then
one argument for each field in the same order as in the @code{fields}
clause.  The constructor returns a record object with the fields
initialized to the corresponding arguments.

@item
If there is a @code{parent-rtd} clause, then the constructor is as with
a @code{parent} clause, except that the constructor of the parent type
is determined by the constructor descriptor of the @code{parent-rtd}
clause.
@end itemize

A protocol may perform other actions consistent with the requirements
described above, including mutation of the new record or other side
effects, before returning the record.

Any definition that takes advantage of implicit naming for the
constructor, predicate, accessor, and mutator names can be rewritten
trivially to a definition that specifies all names explicitly. For
example, the implicit--naming record definition:

@example
(define-record-type frob
  (fields (mutable widget))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
@end example

@noindent
is equivalent to the following explicit--naming record definition.

@example
(define-record-type (frob make-frob frob?)
  (fields (mutable widget
                   frob-widget
                   frob-widget-set!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
@end example

Also, the implicit--naming record definition:

@example
(define-record-type point (fields x y))
@end example

@noindent
is equivalent to the following explicit--naming record definition:

@example
(define-record-type (point make-point point?)
  (fields
    (immutable x point-x)
    (immutable y point-y)))
@end example

With implicit naming, it is still possible to specify some of the names
explicitly; for example, the following overrides the choice of accessor
and mutator names for the widget field.

@example
(define-record-type frob
  (fields (mutable widget getwid setwid!))
  (protocol
    (lambda (p)
      (lambda (n) (p (make-widget n))))))
@end example


@deffn Syntax record-type-descriptor @meta{record name}
Evaluates to the record--type descriptor (see below) associated with the
type specified by @meta{record name}.

@quotation
@emph{Note:} The @func{record-type-descriptor} procedure works on both
opaque and non--opaque record types.
@end quotation
@end deffn


@deffn Syntax record-constructor-descriptor @meta{record name}
Evaluates to the record--constructor descriptor (see below) associated
with @meta{record name}.
@end deffn


The following example uses the @func{record?} procedure from the
@rsixlibrary{records inspection} library:

@example
(define-record-type (point make-point point?)
  (fields (immutable x point-x)
          (mutable y point-y set-point-y!))
  (nongenerative
    point-4893d957-e00b-11d9-817f-00111175eb9e))

(define-record-type (cpoint make-cpoint cpoint?)
  (parent point)
  (protocol
   (lambda (n)
     (lambda (x y c)
       ((n x y) (color->rgb c)))))
  (fields
    (mutable rgb cpoint-rgb cpoint-rgb-set!)))

(define (color->rgb c)
  (cons 'rgb c))

(define p1 (make-point 1 2))
(define p2 (make-cpoint 3 4 'red))

(point? p1)                             => #t
(point? p2)                             => #t
(point? (vector))                       => #f
(point? (cons 'a 'b))                   => #f
(cpoint? p1)                            => #f
(cpoint? p2)                            => #f
(point-x p1)                            => 1
(point-y p1)                            => 2
(point-x p2)                            => 3
(point-y p2)                            => 4
(cpoint-rgb p2)                         => (rgb . red)

(set-point-y! p1 17)                    => unspecified
(point-y p1)                            => 17

(record-rtd p1)
=> (record-type-descriptor point)

(define-record-type (ex1 make-ex1 ex1?)
  (protocol (lambda (p) (lambda a (p a))))
  (fields (immutable f ex1-f)))

(define ex1-i1 (make-ex1 1 2 3))
(ex1-f ex1-i1)                          => (1 2 3)

(define-record-type (ex2 make-ex2 ex2?)
  (protocol
    (lambda (p) (lambda (a . b) (p a b))))
  (fields (immutable a ex2-a)
          (immutable b ex2-b)))

(define ex2-i1 (make-ex2 1 2 3))
(ex2-a ex2-i1)                          => 1
(ex2-b ex2-i1)                          => (2 3)

(define-record-type (unit-vector
                     make-unit-vector
                     unit-vector?)
  (protocol
   (lambda (p)
     (lambda (x y z)
       (let ((length
               (sqrt (+ (* x x)
                        (* y y)
                        (* z z)))))
         (p (/ x length)
            (/ y length)
            (/ z length))))))
  (fields (immutable x unit-vector-x)
          (immutable y unit-vector-y)
          (immutable z unit-vector-z)))

(define *ex3-instance* #f)

(define-record-type ex3
  (parent cpoint)
  (protocol
   (lambda (n)
     (lambda (x y t)
       (let ((r ((n x y 'red) t)))
         (set! *ex3-instance* r)
         r))))
  (fields
   (mutable thickness))
  (sealed #t) (opaque #t))

(define ex3-i1 (make-ex3 1 2 17))
(ex3? ex3-i1)                           => #t
(cpoint-rgb ex3-i1) => (rgb . red)
(ex3-thickness ex3-i1)                  => 17
(ex3-thickness-set! ex3-i1 18)          => unspecified
(ex3-thickness ex3-i1)                  => 18
*ex3-instance*                          => ex3-i1

(record? ex3-i1)                        => #f
@end example




@c page
@node stdlib records procedural layer
@section Procedural layer


The procedural layer is provided by the @rsixlibrary{records procedural}
library.


@deffn Procedure make-record-type-descriptor @var{name} @var{parent} @var{uid} @var{sealed?} @var{opaque?} @var{fields}
Return a @emph{record-type descriptor}, or @emph{rtd}, representing a
record type distinct from all built--in types and other record types.

The @var{name} argument must be a symbol.  It names the record type, and
is intended purely for informational purposes and may be used for
printing by the underlying Scheme system.

The @var{parent} argument must be either @false{} or an rtd. If it is an
rtd, the returned record type, @var{t}, extends the record type @var{p}
represented by @var{parent}.  An exception with condition type
@code{&assertion} is raised if @var{parent} is sealed (see below).

The @var{uid} argument must be either @false{} or a symbol.  If
@var{uid} is a symbol, the record--creation operation is
@emph{nongenerative} i.e., a new record type is created only if no
previous call to @func{make-record-type-descriptor} was made with the
@var{uid}.  If @var{uid} is @false{}, the record--creation operation is
@emph{generative}, i.e., a new record type is created even if a previous
call to @func{make-record-type-descriptor} was made with the same
arguments.

If @func{make-record-type-descriptor} is called twice with the same
@var{uid} symbol, the parent arguments in the two calls must be
@func{eqv?}, the @var{fields} arguments @func{equal?}, the @var{sealed?}
arguments boolean--equivalent (both @false{} or both true), and the
@var{opaque?} arguments boolean--equivalent.  If these conditions are
not met, an exception with condition type @code{&assertion} is raised
when the second call occurs.  If they are met, the second call returns,
without creating a new record type, the same record--type descriptor (in
the sense of @func{eqv?}) as the first call.

@quotation
@emph{Note:} Users are encouraged to use symbol names constructed using
the @acronym{UUID} namespace (for example, using the record--type name
as a prefix) for the uid argument.
@end quotation

The @var{sealed?} flag must be a boolean.  If true, the returned record
type is sealed, i.e., it cannot be extended.

The @var{opaque?} flag must be a boolean.  If true, the record type is
opaque.  If passed an instance of the record type, @func{record?}
returns @false{}.  Moreover, if @code{record-rtd} (see ``Inspection''
below) is called with an instance of the record type, an exception with
condition type @code{&assertion} is raised.  The record type is also
opaque if an opaque parent is supplied.  If @var{opaque?} is @false{}
and an opaque parent is not supplied, the record is not opaque.

The @var{fields} argument must be a vector of field specifiers. Each
field specifier must be a list of the form @code{(mutable @var{name})}
or a list of the form @code{(immutable @var{name})}.  Each name must be
a symbol and names the corresponding field of the record type; the names
need not be distinct.  A field identified as mutable may be modified,
whereas, when a program attempts to obtain a mutator for a field
identified as immutable, an exception with condition type
@code{&assertion} is raised.  Where field order is relevant, e.g., for
record construction and field access, the fields are considered to be
ordered as specified, although no particular order is required for the
actual representation of a record instance.

The specified fields are added to the parent fields, if any, to
determine the complete set of fields of the returned record type.  If
@var{fields} is modified after @func{make-record-type-descriptor} has
been called, the effect on the returned rtd is unspecified.

A generative record--type descriptor created by a call to
@func{make-record-type-descriptor} is not @func{eqv?} to any
record--type descriptor (generative or nongenerative) created by another
call to @func{make-record-type-descriptor}.  A generative record--type
descriptor is @func{eqv?}  only to itself, i.e., @code{(eqv? @vari{rtd}
@varii{rtd})} if, and only if, @code{(eq? @vari{rtd} @varii{rtd})}.
Also, two nongenerative record--type descriptors are @func{eqv?} if, and
only if, they were created by calls to
@func{make-record-type-descriptor} with the same uid arguments.
@end deffn


@deffn Procedure record-type-descriptor? @var{obj}
Return @true{} if the argument is a record--type descriptor, @false{}
otherwise.
@end deffn


@deffn Procedure make-record-constructor-descriptor @var{rtd} @var{parent-constructor-descriptor} @var{protocol}
Return a @emph{record-constructor descriptor} (or @emph{constructor
descriptor} for short) that specifies a @emph{record constructor} (or
@emph{constructor} for short), that can be used to construct record
values of the type specified by @var{rtd}, and which can be obtained via
@func{record-constructor}.  A constructor descriptor can also be used to
create other constructor descriptors for subtypes of its own record
type.  @var{rtd} must be a record--type descriptor.  @var{protocol} must
be a procedure or @false{}.  If it is @false{}, a default @var{protocol}
procedure is supplied.

If @var{protocol} is a procedure, it is handled analogously to the
protocol expression in a @func{define-record-type} form.

If @var{rtd} is a base record type @var{parent-constructor-descriptor}
must be @false{}.  In this case, @var{protocol} is called by
@func{record-constructor} with a single argument @var{p}.  @var{p} is a
procedure that expects one argument for every field of @var{rtd} and
returns a record with the fields of @var{rtd} initialized to these
arguments.  The procedure returned by @var{protocol} should call @var{p}
once with the number of arguments @var{p} expects and return the
resulting record as shown in the simple example below:

@example
(lambda (p)
  (lambda (v1 v2 v3)
    (p v1 v2 v3)))
@end example

Here, the call to @code{p} returns a record whose fields are initialized
with the values of @code{v1}, @code{v2}, and @code{v3}.  The expression
above is equivalent to @code{(lambda (p) p)}.  Note that the procedure
returned by @var{protocol} is otherwise unconstrained; specifically, it
can take any number of arguments.

If @var{rtd} is an extension of another record type @var{parent-rtd} and
@var{protocol} is a procedure, @var{parent-constructor-descriptor} must
be a constructor descriptor of @var{parent-rtd} or @false{}.  If
@var{parent-constructor-descriptor} is a constructor descriptor,
@var{protocol} it is called by @code{record-constructor} with a single
argument @var{n}, which is a procedure that accepts the same number of
arguments as the constructor of @var{parent-constructor-descriptor} and
returns a procedure @var{p} that, when called, constructs the record
itself.  The @var{p} procedure expects one argument for every field of
@var{rtd} (not including parent fields) and returns a record with the
fields of @var{rtd} initialized to these arguments, and the fields of
@var{parent-rtd} and its parents initialized as specified by
@var{parent-constructor-descriptor}.

The procedure returned by @var{protocol} should call @var{n} once with
the number of arguments @var{n} expects, call the procedure @var{p} it
returns once with the number of arguments @var{p} expects and return the
resulting record.  A simple @var{protocol} in this case might be written
as follows:

@example
(lambda (n)
  (lambda (v1 v2 v3 x1 x2 x3 x4)
    (let ((p (n v1 v2 v3)))
      (p x1 x2 x3 x4))))
@end example

This passes arguments @var{v1}, @var{v2}, @var{v3} to @var{n} for
@var{parent-constructor-descriptor} and calls @func{p} with @var{x1},
@dots{}, @var{x4} to initialize the fields of @var{rtd} itself.

Thus, the constructor descriptors for a record type form a sequence of
protocols parallel to the sequence of record--type parents.  Each
constructor descriptor in the chain determines the field values for the
associated record type.  Child record constructors need not know the
number or contents of parent fields, only the number of arguments
accepted by the parent constructor.

@var{protocol} may be @false{}, specifying a default constructor that
accepts one argument for each field of @var{rtd} (including the fields
of its parent type, if any).  Specifically, if @var{rtd} is a base type,
the default @var{protocol} procedure behaves as if it were @code{(lambda
(p) p)}.  If @var{rtd} is an extension of another type, then
@var{parent-constructor-descriptor} must be either @false{} or itself
specify a default constructor, and the default @var{protocol} procedure
behaves as if it were:

@example
(lambda (n)
  (lambda (@vari{v} @dots{} @varj{v} @vari{x} @dots{} @vark{x})
    (let ((p (n @vari{v} @dots{} @varj{v})))
      (p @vari{x} @dots{} @vark{x}))))
@end example

The resulting constructor accepts one argument for each of the record
type's complete set of fields (including those of the parent record
type, the parent's parent record type, etc.) and returns a record with
the fields initialized to those arguments, with the field values for the
parent coming before those of the extension in the argument list.  (In
the example, @emph{j} is the complete number of fields of the parent
type, and $k$ is the number of fields of @var{rtd} itself.)

If @var{rtd} is an extension of another record type and
@var{parent-constructor-descriptor} is @false{},
@var{parent-constructor-descriptor} is treated as if it were a
constructor descriptor for the parent rtd of @var{rtd} with a default
protocol.

@strong{Implementation responsibilities:} If @var{protocol} is a
procedure, the implementation must check the restrictions on it to the
extent performed by applying it as described when the constructor is
called.  An implementation may check whether @var{protocol} is an
appropriate argument before applying it.

@example
(define rtd1
  (make-record-type-descriptor
   'rtd1 #f #f #f #f
   '#((immutable x1) (immutable x2))))

(define rtd2
  (make-record-type-descriptor
   'rtd2 rtd1 #f #f #f
   '#((immutable x3) (immutable x4))))

(define rtd3
  (make-record-type-descriptor
   'rtd3 rtd2 #f #f #f
   '#((immutable x5) (immutable x6))))

(define protocol1
  (lambda (p)
    (lambda (a b c)
      (p (+ a b) (+ b c)))))

(define protocol2
  (lambda (n)
    (lambda (a b c d e f)
      (let ((p (n a b c)))
        (p (+ d e) (+ e f))))))

(define protocol3
  (lambda (n)
    (lambda (a b c d e f g h i)
      (let ((p (n a b c d e f)))
        (p (+ g h) (+ h i))))))

(define cd1
  (make-record-constructor-descriptor
    rtd1 #f protocol1))

(define cd2
  (make-record-constructor-descriptor
    rtd2 cd1 protocol2))

(define cd3
  (make-record-constructor-descriptor
    rtd3 cd2 protocol3))

(define make-rtd1 (record-constructor cd1))

(define make-rtd2 (record-constructor cd2))

(define make-rtd3 (record-constructor cd3))

(make-rtd3 1 2 3 4 5 6 7 8 9)
=> <record with fields initialized to 3, 5, 9, 11, 15, 17>
@end example
@end deffn


@deffn Procedure record-constructor @var{constructor-descriptor}
Call the @var{protocol} of @var{constructor-descriptor} (as described
for @func{make-record-constructor-descriptor}) and returns the resulting
constructor @var{constructor} for records of the record type associated
with @var{constructor-descriptor}.
@end deffn


@deffn Procedure record-predicate @var{rtd}
Return a procedure that, given an object @var{obj}, returns @true{} if
@var{obj} is a record of the type represented by @var{rtd}, and @false{}
otherwise.
@end deffn


@deffn Procedure record-accessor @var{rtd} @var{k}
@var{k} must be a valid field index of @var{rtd}.  The
@func{record-accessor} procedure returns a one--argument procedure whose
argument must be a record of the type represented by @var{rtd}.  This
procedure returns the value of the selected field of that record.

The field selected corresponds to the @var{k}th element (0--based) of
the @var{fields} argument to the invocation of
@func{make-record-type-descriptor} that created @var{rtd}.  Note that
@var{k} cannot be used to specify a field of any type @var{rtd} extends.
@end deffn


@deffn Procedure record-mutator @var{rtd} @var{k}
@var{k} must be a valid field index of @var{rtd}.  The
@func{record-mutator} procedure returns a two--argument procedure whose
arguments must be a record record @var{r} of the type represented by
@var{rtd} and an object @var{obj}.  This procedure stores @var{obj}
within the field of @var{r} specified by @var{k}.  The @var{k} argument
is as in @func{record-accessor}.  If @var{k} specifies an immutable
field, an exception with condition type @code{&assertion} is raised.
The mutator returns unspecified values.
@end deffn


@example
(define :point
  (make-record-type-descriptor
    'point #f
    #f #f #f
    '#((mutable x) (mutable y))))

(define :point-cd
  (make-record-constructor-descriptor :point #f #f))

(define make-point (record-constructor :point-cd))

(define point? (record-predicate :point))
(define point-x (record-accessor :point 0))
(define point-y (record-accessor :point 1))
(define point-x-set! (record-mutator :point 0))
(define point-y-set! (record-mutator :point 1))

(define p1 (make-point 1 2))
(point? p1)                             => #t
(point-x p1)                            => 1
(point-y p1)                            => 2
(point-x-set! p1 5)                     => unspecified
(point-x p1)                            => 5

(define :point2
  (make-record-type-descriptor
    'point2 :point
    #f #f # f '#((mutable x) (mutable y))))

(define make-point2
  (record-constructor
    (make-record-constructor-descriptor :point2
      #f #f)))
(define point2? (record-predicate :point2))
(define point2-xx (record-accessor :point2 0))
(define point2-yy (record-accessor :point2 1))

(define p2 (make-point2 1 2 3 4))
(point? p2)                             => #t
(point-x p2)                            => 1
(point-y p2)                            => 2
(point2-xx p2)                          => 3
(point2-yy p2)                          => 4

(define :point-cd/abs
  (make-record-constructor-descriptor
   :point #f
   (lambda (new)
     (lambda (x y)
       (new (abs x) (abs y))))))

(define make-point/abs
  (record-constructor :point-cd/abs))

(point-x (make-point/abs -1 -2))        => 1
(point-y (make-point/abs -1 -2))        => 2

(define :cpoint
  (make-record-type-descriptor
   'cpoint :point
   #f #f #f
   '#((mutable rgb))))

(define make-cpoint
  (record-constructor
   (make-record-constructor-descriptor
    :cpoint :point-cd
    (lambda (p)
      (lambda (x y c)
	((p x y) (color->rgb c)))))))

(define make-cpoint/abs
  (record-constructor
   (make-record-constructor-descriptor
    :cpoint :point-cd/abs
    (lambda (p)
      (lambda (x y c)
	((p x y) (color->rgb c)))))))

(define cpoint-rgb
  (record-accessor :cpoint 0))

(define (color->rgb c)
  (cons 'rgb c))

(cpoint-rgb (make-cpoint -1 -3 'red))   => (rgb . red)
(point-x (make-cpoint -1 -3 'red))      => -1
(point-x (make-cpoint/abs -1 -3 'red))  => 1
@end example



@c page
@node stdlib records inspection
@section Inspection


The @rsixlibrary{records inspection} library provides procedures for
inspecting records and their record--type descriptors.  These procedures
are designed to allow the writing of portable printers and inspectors.

On the one hand, @func{record?} and @func{record-rtd} treat records of
opaque record types as if they were not records.  On the other hand, the
inspection procedures that operate on record--type descriptors
themselves are not affected by opacity.  In other words, opacity
controls whether a program can obtain an rtd from a record.  If the
program has access to the original rtd via
@func{make-record-type-descriptor} or @func{record-type-descriptor}, it
can still make use of the inspection procedures.


@deffn Procedure record? @var{obj}
Return @true{} if @var{obj} is a record, and its record type is not
opaque, and return @false{} otherwise.
@end deffn


@deffn Procedure record-rtd @var{record}
Return the rtd representing the type of @var{record} if the type is not
opaque.  The rtd of the most precise type is returned; that is, the type
@var{t} such that @var{record} is of type @var{t} but not of any type
that extends @var{t}.  If the type is opaque, an exception is raised
with condition type @code{&assertion}.
@end deffn


@deffn Procedure record-type-name @var{rtd}
Return the name of the record--type descriptor @var{rtd}.
@end deffn


@deffn Procedure record-type-parent @var{rtd}
Return the parent of the record--type descriptor @var{rtd}, or @false{}
if it has none.
@end deffn


@deffn Procedure record-type-uid @var{rtd}
Return the uid of the record--type descriptor rtd, or @false{} if it has
none.  (An implementation may assign a generated uid to a record type
even if the type is generative, so the return of a uid does not
necessarily imply that the type is nongenerative.)
@end deffn


@deffn Procedure record-type-generative? @var{rtd}
Return @true{} if @var{rtd} is generative, and @false{} if not.
@end deffn


@deffn Procedure record-type-sealed? @var{rtd}
Return @true{} if the record-type descriptor is sealed, and @false{} if
not.
@end deffn


@deffn Procedure record-type-opaque? @var{rtd}
Return @true{} if the the record-type descriptor is opaque, and @false{}
if not.
@end deffn


@deffn Procedure record-type-field-names @var{rtd}
Return a vector of symbols naming the fields of the type represented by
@var{rtd} (not including the fields of parent types) where the fields
are ordered as described under @func{make-record-type-descriptor}.  The
returned vector may be immutable.  If the returned vector is modified,
the effect on @var{rtd} is unspecified.
@end deffn


@deffn Procedure record-field-mutable? @var{rtd} @var{k}
Returns @true{} if the field specified by @var{k} of the type
represented by @var{rtd} is mutable, and @false{} if not.  @var{k} is as
in @func{record-accessor}.
@end deffn



@c page
@node stdlib exceptions
@chapter Exceptions and conditions


Scheme allows programs to deal with exceptional situations using two
cooperating facilities: The exception system for raising and handling
exceptional situations, and the condition system for describing these
situations.

The exception system allows the program, when it detects an exceptional
situation, to pass control to an exception handler, and to dynamically
establish such exception handlers.  Exception handlers are always
invoked with an object describing the exceptional situation.  Scheme's
condition system provides a standardized taxonomy of such descriptive
objects, as well as a facility for extending the taxonomy.


@menu
* stdlib exceptions exceptions::        Exceptions.
* stdlib exceptions conditions::        Conditions.
@end menu



@c page
@node stdlib exceptions exceptions
@section Exceptions


@cindex Catching exceptions


This section describes Scheme's exception--handling and
exception--raising constructs provided by the @rsixlibrary{exceptions}
library.

Exception handlers are one--argument procedures that determine the
action the program takes when an exceptional situation is signalled.
The system implicitly maintains a current exception handler.

The program raises an exception by invoking the current exception
handler, passing it an object encapsulating information about the
exception.  Any procedure accepting one argument may serve as an
exception handler and any object may be used to represent an exception.

The system maintains the current exception handler as part of the
dynamic environment of the program; @ref{lang basic dynamic extent}.

When a program begins its execution, the current exception handler is
expected to handle all @code{&serious} conditions by interrupting
execution, reporting that an exception has been raised, and displaying
information about the condition object that was provided.  The handler
may then exit, or may provide a choice of other options.  Moreover, the
exception handler is expected to return when passed any other
non--@code{&serious} condition.  Interpretation of these expectations
necessarily depends upon the nature of the system in which programs are
executed, but the intent is that users perceive the raising of an
exception as a controlled escape from the situation that raised the
exception, not as a crash.


@deffn Procedure with-exception-handler @var{handler} @var{thunk}
@var{handler} must be a procedure and should accept one argument.
@var{thunk} must be a procedure that accepts zero arguments.  The
@func{with-exception-handler} procedure returns the results of invoking
@var{thunk}.  @var{handler} is installed as the current exception
handler for the dynamic extent (as determined by @func{dynamic-wind}) of
the invocation of @var{thunk}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{handler} to the extent performed by applying it
as described when it is called as a result of a call to @func{raise} or
@func{raise-continuable}.  An implementation may check whether
@var{handler} is an appropriate argument before applying it.
@end deffn


@deffn Syntax guard (@meta{variable} @hyperi{cond clause} @hyperii{cond clause} @dots{}) @meta{body}
@deffnx {Auxiliary Syntax} {=>}
@deffnx {Auxiliary Syntax} else
Each @meta{cond clause} is as in the specification of @func{cond}.  (See
report section @ref{baselib expressions derived cond}.)  @code{=>} and
@code{else} are the same as in the @rsixlibrary{base} library.

Evaluating a @func{guard} form evaluates @meta{body} with an exception
handler that binds the raised object to @meta{variable} and within the
scope of that binding evaluates the clauses as if they were the clauses
of a @func{cond} expression.  That implicit @func{cond} expression is
evaluated with the continuation and dynamic environment of the
@func{guard} form.  If every @meta{cond clause}'s @hyper{test} evaluates
to @false{} and there is no @code{else} clause, then
@func{raise-continuable} is re--invoked on the raised object within the
dynamic environment of the original call to @func{raise} except that the
current exception handler is that of the @func{guard} expression.

The final expression in a @meta{cond} clause is in a tail context if the
@func{guard} expression itself is.
@end deffn


@deffn Procedure raise @var{obj}
Raise a non--continuable exception by invoking the current exception
handler on @var{obj}.  The handler is called with a continuation whose
dynamic environment is that of the call to @func{raise}, except that the
current exception handler is the one that was in place when the handler
being called was installed.  When the handler returns, a
non--continuable exception with condition type @code{&non-continuable}
is raised in the same dynamic environment as the handler.
@end deffn


@deffn Procedure raise-continuable @var{obj}
Raise a @emph{continuable exception} by invoking the current exception
handler on @var{obj}. The handler is called with a continuation that is
equivalent to the continuation of the call to @func{raise-continuable},
with these two exceptions:

@enumerate
@item
the current exception handler is the one that was in place when the
handler being called was installed, and

@item
if the handler being called returns, then it will again become the
current exception handler.
@end enumerate

If the handler returns, the values it returns become the values returned
by the call to @code{raise-continuable}.
@end deffn

@example
(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred"))
          'error)
         ((violation? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "the program has a bug"))
          'violation))
  (raise
    (condition
      (make-error)
      (make-message-condition "I am an error"))))
   ;; prints: I am an error
=> error

(guard (con
         ((error? con)
          (if (message-condition? con)
              (display (condition-message con))
              (display "an error has occurred"))
          'error))
  (raise
    (condition
      (make-violation)
      (make-message-condition "I am an error"))))
=> exception &violation

(guard (con
         ((error? con)
          (display "error opening file")
          #f))
  (call-with-input-file "foo.scm" read))
   ;; prints: error opening file
=> #f

(with-exception-handler
  (lambda (con)
    (cond
      ((not (warning? con))
       (raise con))
      ((message-condition? con)
       (display (condition-message con)))
      (else
       (display "a warning has been issued")))
    42)
  (lambda ()
    (+ (raise-continuable
         (condition
           (make-warning)
           (make-message-condition
             "should be a number")))
       23)))
   ;; prints: should be a number
=> 65
@end example



@c page
@node stdlib exceptions conditions
@section Conditions


This section describes Scheme's @rsixlibrary{conditions} library for
creating and inspecting condition types and values.  A condition value
encapsulates information about an exceptional situation.  Scheme also
defines a number of basic condition types.

Scheme conditions provides two mechanisms to enable communication about
an exceptional situation: subtyping among condition types allows
handling code to determine the general nature of an exception even
though it does not anticipate its exact nature, and compound conditions
allow an exceptional situation to be described in multiple ways.


@menu
* stdlib exceptions conditions objects::        Condition objects.
* stdlib exceptions conditions types::          Standard condition types.
@end menu


@c page
@node stdlib exceptions conditions objects
@subsection Condition objects


Conceptually, there are two different kinds of condition objects:
@emph{simple conditions} and @emph{compound conditions}.  An object that
is either a simple condition or a compound condition is simply a
@emph{condition}.  Compound conditions form a type disjoint from the
base types described in report section @ref{baselib types}.  A simple
condition describes a single aspect of an exceptional situation.  A
compound condition represents multiple aspects of an exceptional
situation as a list of simple conditions, its @emph{components}.  Most
of the operations described in this section treat a simple condition
identically to a compound condition with itself as its own sole
component.  For a subtype @var{t} of @code{&condition}, a
@emph{condition of type @var{t}} is either a record of type @var{t} or a
compound condition containing a component of type @var{t}.


@tindex &condition
@deffn {Condition Type} {&condition}
Simple conditions are records of subtypes of the @code{&condition}
record type.  The @code{&condition} type has no fields and is neither
sealed nor opaque.
@end deffn


@deffn Procedure condition @vari{condition} @dots{}
The @func{condition} procedure returns a condition object with the
components of the @var{condition}s as its components, in the same order,
i.e., with the components of @vari{condition} appearing first in the
same order as in @vari{condition}, then with the components of
@varii{condition}, and so on.  The returned condition is compound if the
total number of components is zero or greater than one.  Otherwise, it
may be compound or simple.
@end deffn


@deffn Procedure simple-conditions @var{condition}
The @func{simple-conditions} procedure returns a list of the components
of @var{condition}, in the same order as they appeared in the
construction of @var{condition}.  The returned list is immutable.  If
the returned list is modified, the effect on @var{condition} is
unspecified.

@quotation
@emph{Note:} Because @func{condition} decomposes its arguments into
simple conditions, @func{simple-conditions} always returns a
``flattened'' list of simple conditions.
@end quotation
@end deffn


@deffn Procedure {condition?} @var{obj}
Return @true{} if @var{obj} is a (simple or compound) condition,
otherwise returns @false{}.
@end deffn


@deffn Procedure condition-predicate @var{rtd}
@var{rtd} must be a record--type descriptor of a subtype of
@code{&condition}.  The @func{condition-predicate} procedure returns a
procedure that takes one argument.  This procedure returns @true{} if
its argument is a condition of the condition type represented by
@var{rtd}, i.e., if it is either a simple condition of that record type
(or one of its subtypes) or a compound conditition with such a simple
condition as one of its components, and @false{} otherwise.
@end deffn


@deffn Procedure condition-accessor @var{rtd} @var{proc}
@var{rtd} must be a record--type descriptor of a subtype of
@code{&condition}.  @var{proc} should accept one argument, a record of
the record type of @var{rtd}.  The @func{condition-accessor} procedure
returns a procedure that accepts a single argument, which must be a
condition of the type represented by @var{rtd}.  This procedure extracts
the first component of the condition of the type represented by
@var{rtd}, and returns the result of applying @var{proc} to that
component.
@end deffn

@example
(define-record-type (&cond1 make-cond1 real-cond1?)
  (parent &condition)
  (fields
   (immutable x real-cond1-x)))

(define cond1?
  (condition-predicate
    (record-type-descriptor &cond1)))
(define cond1-x
  (condition-accessor
    (record-type-descriptor &cond1)
    real-cond1-x))

(define foo (make-cond1 'foo))

(condition? foo)                        => #t
(cond1? foo)                            => #t
(cond1-x foo)                           => foo

(define-record-type (&cond2 make-cond2 real-cond2?)
  (parent &condition)
  (fields
   (immutable y real-cond2-y)))

(define cond2?
  (condition-predicate
    (record-type-descriptor &cond2)))
(define cond2-y
  (condition-accessor
     (record-type-descriptor &cond2)
     real-cond2-y))

(define bar (make-cond2 'bar))

(condition? (condition foo bar))        => #t
(cond1? (condition foo bar))            => #t
(cond2? (condition foo bar))            => #t
(cond1? (condition foo))                => #t
(real-cond1? (condition foo))           => unspecified
(real-cond1? (condition foo bar))       => #f
(cond1-x (condition foo bar))           => foo
(cond2-y (condition foo bar))           => bar

(equal? (simple-conditions (condition foo bar))
        (list foo bar))                 => #t

(equal? (simple-conditions
          (condition foo (condition bar)))
        (list foo bar))                 => #t
@end example


@deffn Syntax define-condition-type @meta{condition-type} @meta{supertype} @meta{constructor} @hyper{predicate} @hyperi{field-spec} @dots{}
@meta{condition-type}, @hyper{supertypes}, @meta{constructor}, and
@hyper{predicate} must all be identifiers.  Each @meta{field-spec} must
be of the form

@example
(@meta{field} @hyper{accessor})
@end example

@noindent
where both @meta{field} and @hyper{accessor} must be identifiers.

The @func{define-condition-type} form expands into a record--type
definition for a record type @meta{condition-type}.  The record type
will be non--opaque, non--sealed, and its fields will be immutable.  It
will have @meta{supertype} has its parent type.  The remaining
identifiers will be bound as follows:

@itemize
@item
@meta{constructor} is bound to a default constructor for the type: It
accepts one argument for each of the record type's complete set of
fields (including parent types, with the fields of the parent coming
before those of the extension in the arguments) and returns a condition
object initialized to those arguments.

@item
@meta{predicate} is bound to a predicate that identifies conditions of
type @meta{condition-type} or any of its subtypes.

@item
Each @meta{accessor} is bound to a procedure that extracts the
corresponding field from a condition of type @meta{condition-type}.
@end itemize
@end deffn

@example
(define-condition-type &c &condition
  make-c c?
  (x c-x))

(define-condition-type &c1 &c
  make-c1 c1?
  (a c1-a))

(define-condition-type &c2 &c
  make-c2 c2?
  (b c2-b))
@end example

@example
(define v1 (make-c1 "V1" "a1"))

(c? v1)        => #t
(c1? v1)       => #t
(c2? v1)       => #f
(c-x v1)       => "V1"
(c1-a v1)      => "a1"
@end example

@example
(define v2 (make-c2 "V2" "b2"))

(c? v2)        => #t
(c1? v2)       => #f
(c2? v2)       => #t
(c-x v2)       => "V2"
(c2-b v2)      => "b2"
@end example

@example
(define v3 (condition
             (make-c1 "V3/1" "a3")
             (make-c2 "V3/2" "b3")))

(c? v3)        => #t
(c1? v3)       => #t
(c2? v3)       => #t
(c-x v3)       => "V3/1"
(c1-a v3)      => "a3"
(c2-b v3)      => "b3"
@end example

@example
(define v4 (condition v1 v2))

(c? v4)        => #t
(c1? v4)       => #t
(c2? v4)       => #t
(c-x v4)       => "V1"
(c1-a v4)      => "a1"
(c2-b v4)      => "b2"
@end example

@example
(define v5 (condition v2 v3))

(c? v5)        => #t
(c1? v5)       => #t
(c2? v5)       => #t
(c-x v5)       => "V2"
(c1-a v5)      => "a3"
(c2-b v5)      => "b2"
@end example



@c page
@node stdlib exceptions conditions types
@subsection Standard condition types


Hierarchy of standard condition types:

@example
&condition
   |
   +-----> &warning
   |
   +-----> &message
   |       &irritants
   |       &who
   |
   +-----> &serious
              |
              +-----> &error
              |
              +-----> &violation
                         |
                         +-----> &assertion
                         |
                         +-----> &non-continuable
                         |
                         +-----> &implementation-restriction
                         |
                         +-----> &lexical
                         |
                         +-----> &syntax
                         |
                          -----> &undefined
@end example


@tindex &message
@deffn {Condition Type} {&message}
@deffnx Procedure make-message-condition @var{message}
@deffnx Procedure message-condition? @var{obj}
@deffnx Procedure condition-message @var{condition}
This condition type could be defined by:

@example
(define-condition-type &message &condition
  make-message-condition message-condition?
  (message condition-message))
@end example

It carries a message further describing the nature of the condition to
humans.
@end deffn


@tindex &warning
@deffn {Condition Type} {&warning}
@deffnx Procedure make-warning
@deffnx Procedure warning? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &warning &condition
  make-warning warning?)
@end example

This type describes conditions that do not, in principle, prohibit
immediate continued execution of the program, but may interfere with the
program's execution later.
@end deffn


@tindex &serious
@deffn {Condition Type} {&serious}
@deffnx Procedure make-serious-condition
@deffnx Procedure serious-condition? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &serious &condition
  make-serious-condition serious-condition?)
@end example

This type describes conditions serious enough that they cannot safely be
ignored.  This condition type is primarily intended as a supertype of
other condition types.
@end deffn


@tindex &error
@deffn {Condition Type} {&error}
@deffnx Procedure make-error
@deffnx Procedure error? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &error &serious
  make-error error?)
@end example

This type describes errors, typically caused by something that has gone
wrong in the interaction of the program with the external world or the
user.
@end deffn


@tindex &violation
@deffn {Condition Type} {&violation}
@deffnx Procedure make-violation
@deffnx Procedure violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &violation &serious
  make-violation violation?)
@end example

This type describes violations of the language standard or a library
standard, typically caused by a programming error.
@end deffn


@tindex &assertion
@deffn {Condition Type} {&assertion}
@deffnx Procedure make-assertion-violation
@deffnx Procedure assertion-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &assertion &violation
  make-assertion-violation assertion-violation?)
@end example

This type describes an invalid call to a procedure, either passing an
invalid number of arguments, or passing an argument of the wrong type.
@end deffn


@tindex &irritants
@deffn {Condition Type} {&irritants}
@deffnx Procedure make-irritants-condition @var{irritants}
@deffnx Procedure irritants-condition? @var{obj}
@deffnx Procedure condition-irritants @var{condition}
This condition type could be defined by:

@example
(define-condition-type &irritants &condition
  make-irritants-condition irritants-condition?
  (irritants condition-irritants))
@end example

@var{irritants} should be a list of objects.  This condition provides
additional information about a condition, typically the argument list of
a procedure that detected an exception.  Conditions of this type are
created by the @func{error} and @func{assertion-violation} procedures of
report section @ref{baselib errors}.
@end deffn


@tindex &who
@deffn {Condition Type} {&who}
@deffnx Procedure make-who-condition @var{who}
@deffnx Procedure who-condition? @var{obj}
@deffnx Procedure condition-who @var{condition}
This condition type could be defined by:

@example
(define-condition-type &who &condition
  make-who-condition who-condition?
  (who condition-who))
@end example

@var{who} should be a symbol or string identifying the entity reporting
the exception.  Conditions of this type are created by the @func{error}
and @func{assertion-violation} procedures (report section @ref{baselib
errors}), and the @func{syntax-violation} procedure (section @ref{lang
basic syntax violations}).
@end deffn


@tindex &non-continuable
@deffn {Condition Type} {&non-continuable}
@deffnx Procedure make-non-continuable-violation
@deffnx Procedure non-continuable-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &non-continuable &violation
  make-non-continuable-violation
  non-continuable-violation?)
@end example

This type indicates that an exception handler invoked via @func{raise}
has returned.
@end deffn


@tindex &implementation-restriction
@deffn {Condition Type} {&implementation-restriction}
@deffnx Procedure make-implementation-restriction-violation
@deffnx Procedure implementation-restriction-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &implementation-restriction
    &violation
  make-implementation-restriction-violation
  implementation-restriction-violation?)
@end example

This type describes a violation of an implementation restriction allowed
by the specification, such as the absence of representations for NaNs
and infinities.
@end deffn


@tindex &lexical
@deffn {Condition Type} {&lexical}
@deffnx Procedure make-lexical-violation
@deffnx Procedure lexical-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &lexical &violation
  make-lexical-violation lexical-violation?)
@end example

This type describes syntax violations at the level of the datum syntax.
@end deffn


@tindex &syntax
@deffn {Condition Type} {&syntax}
@deffnx Procedure make-syntax-violation @var{form} @var{subform}
@deffnx Procedure syntax-violation? @var{obj}
@deffnx Procedure syntax-violation-form @var{condition}
@deffnx Procedure syntax-violation-subform @var{condition}
This condition type could be defined by:

@example
(define-condition-type &syntax &violation
  make-syntax-violation syntax-violation?
  (form syntax-violation-form)
  (subform syntax-violation-subform))
@end example

This type describes syntax violations.  @var{form} should be the
erroneous syntax object or a datum representing the code of the
erroneous form.  @var{subform} should be an optional syntax object or
datum within the erroneous form that more precisely locates the
violation.  It can be @false{} to indicate the absence of more precise
information.
@end deffn


@tindex &undefined
@deffn {Condition Type} {&undefined}
@deffnx Procedure make-undefined-violation
@deffnx Procedure undefined-violation? @var{obj}
This condition type could be defined by:

@example
(define-condition-type &undefined &violation
  make-undefined-violation undefined-violation?)
@end example

This type describes unbound identifiers in the program.
@end deffn



@c page
@node stdlib io
@chapter Input/output


This chapter describes Scheme's libraries for performing input and
output:

@table @rsixlibrary
@item io ports
it is an I/O layer for conventional, imperative buffered input and
output with text and binary data;

@item io simple
it is a convenience library atop the @rsixlibrary{io ports} library for
textual I/O, compatible with the traditional Scheme I/O procedures.
@end table

The section on conditions defines a condition--type hierarchy that is
exported by both the @rsixlibrary{io ports} and @rsixlibrary{io simple}
libraries.


@menu
* stdlib io conditions::        Condition types.
* stdlib io port::              Port input/output.
* stdlib io simple::            Simple input/output.
@end menu


@c page
@node stdlib io conditions
@section Condition types


The procedures described in this chapter, when they detect an
exceptional situation that arises from an ``I/O errors'', raise an
exception with condition type @code{&i/o}.

The condition types and corresponding predicates and accessors are
exported by both the @rsixlibrary{io ports} and @rsixlibrary{io simple}
libraries.  They are also exported by the @rsixlibrary{files} library.


@tindex &i/o
@deffn {Condition Type} {&i/o}
@deffnx Procedure {make-i/o-error}
@deffnx Procedure {i/o-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o &error
  make-i/o-error i/o-error?)
@end example

This is a supertype for a set of more specific I/O errors.
@end deffn


@tindex &i/o-read
@deffn {Condition Type} {&i/o-read}
@deffnx Procedure {make-i/o-read-error}
@deffnx Procedure {i/o-read-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-read &i/o
  make-i/o-read-error i/o-read-error?)
@end example

This condition type describes read errors that occurred during an I/O
operation.
@end deffn


@tindex &i/o-write
@deffn {Condition Type} {&i/o-write}
@deffnx Procedure {make-i/o-write-error}
@deffnx Procedure {i/o-write-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-write &i/o
  make-i/o-write-error i/o-write-error?)
@end example

This condition type describes write errors that occurred during an I/O
operation.
@end deffn


@tindex &i/o-invalid-position
@deffn {Condition Type} {&i/o-invalid-position}
@deffnx Procedure {make-i/o-invalid-position-error} @var{position}
@deffnx Procedure {i/o-invalid-position-error?} @var{obj}
@deffnx Procedure {i/o-error-position} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-invalid-position &i/o
  make-i/o-invalid-position-error
  i/o-invalid-position-error?
  (position i/o-error-position))
@end example

This condition type describes attempts to set the file position to an
invalid position.  @var{position} should be the file position that the
program intended to set.  This condition describes a range error, but
not an assertion violation.
@end deffn


@tindex &i/o-filename
@deffn {Condition Type} {&i/o-filename}
@deffnx Procedure {make-i/o-filename-error} @var{filename}
@deffnx Procedure {i/o-filename-error?} @var{obj}
@deffnx Procedure {i/o-error-filename} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-filename &i/o
  make-i/o-filename-error i/o-filename-error?
  (filename i/o-error-filename))
@end example

This condition type describes an I/O error that occurred during an
operation on a named file.  @var{filename} should be the name of the
file.
@end deffn


@tindex &i/o-file-protection
@deffn {Condition Type} {&i/o-file-protection}
@deffnx Procedure {make-i/o-file-protection-error} @var{filename}
@deffnx Procedure {i/o-file-protection-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-protection
    &i/o-filename
  make-i/o-file-protection-error
  i/o-file-protection-error?)
@end example

A condition of this type specifies that an operation tried to operate on
a named file with insufficient access rights.
@end deffn


@tindex &i/o-file-is-read-only
@deffn {Condition Type} {&i/o-file-is-read-only}
@deffnx Procedure {make-i/o-file-is-read-only-error} @var{filename}
@deffnx Procedure {i/o-file-is-read-only-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-is-read-only
    &i/o-file-protection
  make-i/o-file-is-read-only-error
  i/o-file-is-read-only-error?)
@end example

A condition of this type specifies that an operation tried to operate on
a named read--only file under the assumption that it is writeable.
@end deffn


@tindex &i/o-file-already-exists
@deffn {Condition Type} {&i/o-file-already-exists}
@deffnx Procedure {make-i/o-file-already-exists-error} @var{filename}
@deffnx Procedure {i/o-file-already-exists-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-already-exists
    &i/o-filename
  make-i/o-file-already-exists-error
  i/o-file-already-exists-error?)
@end example

A condition of this type specifies that an operation tried to operate on
an existing named file under the assumption that it did not exist.
@end deffn


@tindex &i/o-file-does-not-exist
@deffn {Condition Type} {&i/o-file-does-not-exist}
@deffnx Procedure {make-i/o-file-does-not-exist-error} @var{filename}
@deffnx Procedure {i/o-file-does-not-exist-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-file-does-not-exist
    &i/o-filename
  make-i/o-file-does-not-exist-error
  i/o-file-does-not-exist-error?)
@end example

A condition of this type specifies that an operation tried to operate on
an non--existent named file under the assumption that it existed.
@end deffn


@tindex &i/o-port
@deffn {Condition Type} {&i/o-port}
@deffnx Procedure {make-i/o-port-error} @var{port}
@deffnx Procedure {i/o-port-error?} @var{obj}
@deffnx Procedure {i/o-error-port} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-port &i/o
  make-i/o-port-error i/o-port-error?
  (port i/o-error-port))
@end example

This condition type specifies the port with which an I/O error is
associated.  @var{port} should be the port.  Conditions raised by
procedures accepting a port as an argument should include an
@code{&i/o-port-error} condition.
@end deffn



@c page
@node stdlib io port
@section Port input/output


The @rsixlibrary{io ports} library defines an I/O layer for
conventional, imperative buffered input and output.  A @emph{port}
represents a buffered access object for a data sink or source or both
simultaneously.  The library allows ports to be created from arbitrary
data sources and sinks.

The @rsixlibrary{io ports} library distinguishes between @emph{input
ports} and @emph{output ports}.  An input port is a source for data,
whereas an output port is a sink for data.  A port may be both an input
port and an output port; such a port typically provides simultaneous
read and write access to a file or other data.

The @rsixlibrary{io ports} library also distinguishes between
@emph{binary ports}, which are sources or sinks for uninterpreted bytes,
and @emph{textual ports}, which are sources or sinks for characters and
strings.

This section uses @var{input-port}, @var{output-port},
@var{binary-port}, @var{textual-port}, @var{binary-input-port},
@var{textual-input-port}, @var{binary-output-port},
@var{textual-output-port}, and @var{port} as names for arguments that
must be input ports (or combined input/output ports), output ports (or
combined input/output ports), binary ports, textual ports, binary input
ports, textual input ports, binary output ports, textual output ports,
or any kind of port, respectively.


@menu
* stdlib io port file names::           File names.
* stdlib io port file options::         File options.
* stdlib io port buffer modes::         Buffer modes.
* stdlib io port transcoders::          Transcoders.
* stdlib io port eof object::           End of file object.
* stdlib io port io ports::             Input and output ports.
* stdlib io port input ports::          Input ports.
* stdlib io port binary input::         Binary input.
* stdlib io port textual input::        Textual input.
* stdlib io port output ports::         Output ports.
* stdlib io port binary output::        Binary output.
* stdlib io port textual output::       Textual output.
* stdlib io port input output ports::   Input/output ports.
@end menu



@c page
@node stdlib io port file names
@subsection File names


Some of the procedures described in this chapter accept a file name as
an argument.  Valid values for such a file name include strings that
name a file using the native notation of filesystem paths on an
implementation's underlying operating system, and may include
implementation--dependent values as well.

A @var{filename} parameter name means that the corresponding argument
must be a file name.



@c page
@node stdlib io port file options
@subsection File options


When opening a file, the various procedures in this library accept a
@code{file-options} object that encapsulates flags to specify how the
file is to be opened.  A @code{file-options} object is an enum--set over
the symbols constituting valid file options.  A @var{file-options}
parameter name means that the corresponding argument must be a
file--options object.


@deffn Syntax file-options @meta{file-options symbol} @dots{}
Each @meta{file-options symbol} must be a symbol.  The
@code{file-options} syntax returns a file--options object that
encapsulates the specified options.

When supplied to an operation that opens a file for output, the
file--options object returned by @code{(file-options)} (without
arguments) specifies that the file is created if it does not exist and
an exception with condition type @code{&i/o-file-already-exists} is
raised if it does exist.  The following standard options can be included
to modify the default behavior.

@table @code
@item no-create
If the file does not already exist, it is not created; instead, an
exception with condition type @code{&i/o-file-does-not-exist} is raised.
If the file already exists, the exception with condition type
@code{&i/o-file-already-exists} is not raised and the file is truncated
to zero length.

@item no-fail
If the file already exists, the exception with condition type
@code{&i/o-file-already-exists} is not raised, even if @code{no-create}
is not included, and the file is truncated to zero length.

@item no-truncate
If the file already exists and the exception with condition type
@code{&i/o-file-already-exists} has been inhibited by inclusion of
@code{no-create} or @code{no-fail}, the file is not truncated, but the
port's current position is still set to the beginning of the file.
@end table

These options have no effect when a file is opened only for input.
Symbols other than those listed above may be used as @meta{file-options
symbol}s; they have implementation--specific meaning, if any.

@quotation
@emph{Note:} Only the name of @meta{file-options symbol} is significant.
@end quotation
@end deffn



@c page
@node stdlib io port buffer modes
@subsection Buffer modes


Each port has an associated buffer mode.  For an output port, the buffer
mode defines when an output operation flushes the buffer associated with
the output port.  For an input port, the buffer mode defines how much
data will be read to satisfy read operations.  The possible buffer modes
are the symbols:

@table @code
@item none
for no buffering,

@item line
for flushing upon line endings and reading up to line endings, or other
implementation--dependent behavior,

@item block
for arbitrary buffering.
@end table

This section uses the parameter name @var{buffer-mode} for arguments
that must be buffer-mode symbols.

If two ports are connected to the same mutable source, both ports are
unbuffered, and reading a byte or character from that shared source via
one of the two ports would change the bytes or characters seen via the
other port, a lookahead operation on one port will render the peeked
byte or character inaccessible via the other port, while a subsequent
read operation on the peeked port will see the peeked byte or character
even though the port is otherwise unbuffered.

In other words, the semantics of buffering is defined in terms of side
effects on shared mutable sources, and a lookahead operation has the
same side effect on the shared source as a read operation.


@deffn Syntax buffer-mode @meta{buffer-mode symbol}
@meta{buffer-mode symbol} must be a symbol whose name is one of
@code{none}, @code{line}, and @code{block}.  The result is the
corresponding symbol, and specifies the associated buffer mode.

@quotation
@emph{Note:} Only the name of @meta{buffer-mode symbol} is significant.
@end quotation
@end deffn


@deffn Procedure {buffer-mode?} @var{obj}
Return @true{} if the argument is a valid buffer--mode symbol, and
returns @false{} otherwise.
@end deffn



@c page
@node stdlib io port transcoders
@subsection Transcoders


Several different Unicode encoding schemes describe standard ways to
encode characters and strings as byte sequences and to decode those
sequences.  Within this document, a @emph{codec} is an immutable Scheme
object that represents a Unicode or similar encoding scheme.

An @emph{end--of--line style} is a symbol that, if it is not
@code{none}, describes how a textual port transcodes representations of
line endings.

A @emph{transcoder} is an immutable Scheme object that combines a codec
with an end--of--line style and a method for handling decoding errors.
Each transcoder represents some specific bidirectional (but not
necessarily lossless), possibly stateful translation between byte
sequences and Unicode characters and strings.  Every transcoder can
operate in the input direction (bytes to characters) or in the output
direction (characters to bytes).  A @var{transcoder} parameter name
means that the corresponding argument must be a transcoder.

A @emph{binary port} is a port that supports binary I/O, does not have
an associated transcoder and does not support textual I/O.  A
@emph{textual port} is a port that supports textual I/O, and does not
support binary I/O.  A textual port may or may not have an associated
transcoder.


@deffn Procedure latin-1-codec
@deffnx Procedure utf-8-codec
@deffnx Procedure utf-16-codec
These are predefined codecs for the @iso{} 8859-1, @utf{}-8, and
@utf{}-16 encoding schemes.

A call to any of these procedures returns a value that is equal in the
sense of @func{eqv?} to the result of any other call to the same
procedure.
@end deffn


@deffn Syntax eol-style @meta{eol-style symbol}
@meta{eol-style symbol} should be a symbol whose name is one of
@code{lf}, @code{cr}, @code{crlf}, @code{nel}, @code{crnel}, @code{ls},
and @code{none}.

The form evaluates to the corresponding symbol.  If the name of
@meta{eol-style symbol} is not one of these symbols, the effect and
result are implementation--dependent; in particular, the result may be
an eol--style symbol acceptable as an @var{eol-style} argument to
@code{make-transcoder}.  Otherwise, an exception is raised.

All eol--style symbols except @code{none} describe a specific
line--ending encoding:

@example
lf              @meta{linefeed}
cr              @meta{carriage return}
crlf            @meta{carriage return} @meta{linefeed}
nel             @meta{next line}
crnel           @meta{carriage return} @meta{next line}
ls              @meta{line separator}
@end example

For a textual port with a transcoder, and whose transcoder has an
eol--style symbol @code{none}, no conversion occurs.  For a textual
input port, any eol--style symbol other than @code{none} means that all
of the above line-ending encodings are recognized and are translated
into a single linefeed.  For a textual output port, @code{none} and
@code{lf} are equivalent.  Linefeed characters are encoded according to
the specified eol-style symbol, and all other characters that
participate in possible line endings are encoded as is.

@quotation
@emph{Note:} Only the name of @meta{eol-style symbol} is significant.
@end quotation
@end deffn


@deffn Procedure native--eol--style
Return the default end--of--line style of the underlying platform, e.g.,
@code{lf} on Unix and @code{crlf} on Windows.
@end deffn


@tindex i/o-decoding
@deffn {Condition Type} {i/o-decoding}
@deffnx Procedure {make-i/o-decoding-error} @var{port}
@deffnx Procedure {i/o-decoding-error?} @var{obj}
This condition type could be defined by:

@example
(define-condition-type &i/o-decoding &i/o-port
  make-i/o-decoding-error i/o-decoding-error?)
@end example

An exception with this type is raised when one of the operations for
textual input from a port encounters a sequence of bytes that cannot be
translated into a character or string by the input direction of the
port's transcoder.

When such an exception is raised, the port's position is past the
invalid encoding.
@end deffn


@tindex i/o-encoding
@deffn {Condition Type} {i/o-encoding}
@deffnx Procedure {make-i/o-encoding-error} @var{pobj} @var{cobj}
@deffnx Procedure {i/o-encoding-error?} @var{obj}
@deffnx Procedure {i/o-encoding-error-char} @var{condition}
This condition type could be defined by:

@example
(define-condition-type &i/o-encoding &i/o-port
  make-i/o-encoding-error i/o-encoding-error?
  (char i/o-encoding-error-char))
@end example

An exception with this type is raised when one of the operations for
textual output to a port encounters a character that cannot be
translated into bytes by the output direction of the port's transcoder.
@var{cobj} is the character that could not be encoded.
@end deffn


@deffn Syntax error-handling-mode @meta{error-handling-mode symbol}
@meta{error-handling-mode symbol} should be a symbol whose name is one
of @code{ignore}, @code{raise}, and @code{replace}.

The form evaluates to the corresponding symbol.  If
@meta{error-handling-mode symbol} is not one of these identifiers,
effect and result are implementation--dependent: The result may be an
error--handling--mode symbol acceptable as a @var{handling-mode}
argument to @func{make-transcoder}.  If it is not acceptable as a
@var{handling-mode} argument to @func{make-transcoder}, an exception is
raised.

@quotation
@emph{Note:} Only the name of @meta{error-handling-style symbol} is
significant.
@end quotation

The error--handling mode of a transcoder specifies the behavior of
textual I/O operations in the presence of encoding or decoding errors.

If a textual input operation encounters an invalid or incomplete
character encoding, and the error--handling mode is @code{ignore}, an
appropriate number of bytes of the invalid encoding are ignored and
decoding continues with the following bytes.  If the error--handling
mode is @code{replace}, the replacement character @code{U+FFFD} is
injected into the data stream, an appropriate number of bytes are
ignored, and decoding continues with the following bytes.  If the
error--handling mode is @code{raise}, an exception with condition type
@code{&i/o-decoding} is raised.

If a textual output operation encounters a character it cannot encode,
and the error--handling mode is @code{ignore}, the character is ignored
and encoding continues with the next character.  If the error--handling
mode is @code{replace}, a codec--specific replacement character is
emitted by the transcoder, and encoding continues with the next
character.  The replacement character is @code{U+FFFD} for transcoders
whose codec is one of the Unicode encodings, but is the @code{?}
character for the Latin--1 encoding.  If the error--handling mode is
@code{raise}, an exception with condition type @code{&i/o-encoding} is
raised.
@end deffn


@deffn Procedure make-transcoder @var{codec}
@deffnx Procedure make-transcoder @var{codec} @var{eol-style}
@deffnx Procedure make-transcoder @var{codec} @var{eol-style} @var{handling-mode}
@var{codec} must be a codec; @var{eol-style}, if present, an eol--style
symbol; and @var{handling-mode}, if present, an error--handling--mode
symbol.

@var{eol-style} may be omitted, in which case it defaults to the native
end--of--line style of the underlying platform.  @var{handling-mode} may
be omitted, in which case it defaults to @code{replace}.  The result is
a transcoder with the behavior specified by its arguments.
@end deffn


@deffn Procedure native-transcoder
Return an implementation--dependent transcoder that represents a
possibly locale-dependent ``native'' transcoding.
@end deffn


@deffn Procedure transcoder-codec @var{transcoder}
@deffnx Procedure transcoder-eol-style @var{transcoder}
@deffnx Procedure transcoder-error-handling-mode @var{transcoder}
These are accessors for transcoder objects; when applied to a transcoder
returned by @func{make-transcoder}, they return the @var{codec},
@var{eol-style}, and @var{handling-mode} arguments, respectively.
@end deffn


@deffn Procedure {bytevector->string} @var{bytevector} @var{transcoder}
Return the string that results from transcoding the @var{bytevector}
according to the input direction of the transcoder.
@end deffn


@deffn Procedure {string->bytevector} @var{string} @var{transcoder}
Return the bytevector that results from transcoding the @var{string}
according to the output direction of the transcoder.
@end deffn



@c page
@node stdlib io port eof object
@subsection End--of--file object


The end--of--file object is returned by various I/O procedures when they
reach end of file.


@deffn Procedure eof-object
Return the end--of--file object.

@example
(eqv? (eof-object) (eof-object))        => #t
(eq? (eof-object) (eof-object))         => #t
@end example
@end deffn

@quotation
@emph{Note:} The end--of--file object is not a datum value, and thus has
no external representation.
@end quotation


@deffn Procedure {eof-object?} @var{obj}
Return @true{} if @var{obj} is the end--of--file object, @false{}
otherwise.
@end deffn



@c page
@node stdlib io port io ports
@subsection Input and output ports


The operations described in this section are common to input and output
ports, both binary and textual.  A port may also have an associated
@emph{position} that specifies a particular place within its data sink
or source, and may also provide operations for inspecting and setting
that place.


@deffn Procedure {port?} @var{obj}
Return @true{} if the argument is a port, @false{} otherwise.
@end deffn


@deffn Procedure port-transcoder @var{port}
Return the transcoder associated with @var{port} if @var{port} is
textual and has an associated transcoder, and returns @false{} if
@var{port} is binary or does not have an associated transcoder.
@end deffn


@deffn Procedure {textual-port?} @var{port}
@deffnx Procedure {binary-port?} @var{port}
The @func{textual-port?} procedure returns @true{} if @var{port} is
textual, and returns @false{} otherwise.

The @func{binary-port?}  procedure returns @true{} if @var{port} is
binary, and returns @false{} otherwise.
@end deffn


@deffn Procedure {transcoded-port} @var{binary-port} @var{transcoder}
The @func{transcoded-port} procedure returns a new textual port with the
specified @var{transcoder}.  Otherwise the new textual port's state is
largely the same as that of @var{binary-port}.

If @var{binary-port} is an input port, the new textual port will be an
input port and will transcode the bytes that have not yet been read from
@var{binary-port}.  If @var{binary-port} is an output port, the new
textual port will be an output port and will transcode output characters
into bytes that are written to the byte sink represented by
@var{binary-port}.

As a side effect, however, @func{transcoded-port} closes
@var{binary-port} in a special way that allows the new textual port to
continue to use the byte source or sink represented by
@var{binary-port}, even though @var{binary-port} itself is closed and
cannot be used by the input and output operations described in this
chapter.
@end deffn


@deffn Procedure {port-has-port-position?} @var{port}
@deffnx Procedure port-position @var{port}
The @func{port-has-port-position?} procedure returns @true{} if the port
supports the @func{port-position} operation, and @false{} otherwise.

For a binary port, the @func{port-position} procedure returns the index
of the position at which the next byte would be read from or written to
the port as an exact non--negative integer object.  For a textual port,
@func{port-position} returns a value of some implementation--dependent
type representing the port's position; this value may be useful only as
the @var{pos} argument to @func{set-port-position!}, if the latter is
supported on the port (see below).

If the port does not support the operation, @func{port-position} raises
an exception with condition type @code{&assertion}.

@quotation
@emph{Note:} For a textual port, the port position may or may not be an
integer object.  If it is an integer object, the integer object does not
necessarily correspond to a byte or character position.
@end quotation
@end deffn


@deffn Procedure {port-has-set-port-position!?} @var{port}
@deffnx Procedure {set-port-position!} @var{port} @var{pos}
If @var{port} is a binary port, @var{pos} should be a non--negative
exact integer object.  If @var{port} is a textual port, @var{pos} should
be the return value of a call to @func{port-position} on @var{port}.

The @func{port-has-set-port-position!?} procedure returns @true{} if the
port supports the @func{set-port-position!} operation, and @false{}
otherwise.

The @func{set-port-position!} procedure raises an exception with
condition type @code{&assertion} if the port does not support the
operation, and an exception with condition type
@code{&i/o-invalid-position} if @var{pos} is not in the range of valid
positions of @var{port}.  Otherwise, it sets the current position of the
port to @var{pos}.  If @var{port} is an output port,
@func{set-port-position!} first flushes @var{port}.

If @var{port} is a binary output port and the current position is set
beyond the current end of the data in the underlying data sink, the
object is not extended until new data is written at that position.  The
contents of any intervening positions are unspecified.  Binary ports
created by @func{open-file-output-port} and
@func{open-file-input/output-port} can always be extended in this manner
within the limits of the underlying operating system.  In other cases,
attempts to set the port beyond the current end of data in the
underlying object may result in an exception with condition type
@code{&i/o-invalid-position}.
@end deffn


@deffn Procedure close-port @var{port}
Closes the port, rendering the port incapable of delivering or accepting
data. If @var{port} is an output port, it is flushed before being
closed.  This has no effect if the port has already been closed.  A
closed port is still a port.  The @func{close-port} procedure returns
unspecified values.
@end deffn


@deffn Procedure call-with-port @var{port} @var{proc}
@var{proc} must accept one argument.  The @func{call-with-port}
procedure calls @var{proc} with @var{port} as an argument.  If
@var{proc} returns, @var{port} is closed automatically and the values
returned by @var{proc} are returned.  If @var{proc} does not return,
@var{port} is not closed automatically, except perhaps when it is
possible to prove that @var{port} will never again be used for an input
or output operation.
@end deffn



@c page
@node stdlib io port input ports
@subsection Input ports


An input port allows the reading of an infinite sequence of bytes or
characters punctuated by end--of--file objects.  An input port connected
to a finite data source ends in an infinite sequence of end--of--file
objects.

It is unspecified whether a character encoding consisting of several
bytes may have an end of file between the bytes.  If, for example,
@func{get-char} raises an @code{&i/o-decoding} exception because the
character encoding at the port's position is incomplete up to the next
end of file, a subsequent call to @func{get-char} may successfully
decode a character if bytes completing the encoding are available after
the end of file.


@deffn Procedure {input-port?} @var{obj}
Return @true{} if the argument is an input port (or a combined input and
output port), and returns @false{} otherwise.
@end deffn


@deffn Procedure {port-eof?} @var{input-port}
Return @true{} if the @func{lookahead-u8} procedure (if @var{input-port}
is a binary port) or the @func{lookahead-char} procedure (if
@var{input-port} is a textual port) would return the end--of--file
object, and @false{} otherwise.  The operation may block indefinitely if
no data is available but the port cannot be determined to be at end of
file.
@end deffn


@deffn Procedure {open-file-input-port} @var{filename}
@deffnx Procedure {open-file-input-port} @var{filename} @var{file-options}
@deffnx Procedure {open-file-input-port} @var{filename} @var{file-options} @var{buffer-mode}
@deffnx Procedure {open-file-input-port} @var{filename} @var{file-options} @var{buffer-mode} @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-file-input-port} procedure returns an input port for the
named file.  The @var{file-options} and @var{maybe-transcoder} arguments
are optional.

The @var{file-options} argument, which may determine various aspects of
the returned port, defaults to the value of @code{(file-options)}.

The @var{buffer-mode} argument, if supplied, must be one of the symbols
that name a buffer mode.  The @var{buffer-mode} argument defaults to
@code{block}.

If @var{maybe-transcoder} is a transcoder, it becomes the transcoder
associated with the returned port.

If @var{maybe-transcoder} is @false{} or absent, the port will be a
binary port and will support the @func{port-position} and
@func{set-port-position!} operations.  Otherwise the port will be a
textual port, and whether it supports the @func{port-position} and
@func{set-port-position!} operations is implementation-dependent (and
possibly transcoder-dependent).
@end deffn


@deffn Procedure {open-bytevector-input-port} @var{bytevector}
@deffnx Procedure {open-bytevector-input-port} @var{bytevector} @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-bytevector-input-port} procedure returns an input port
whose bytes are drawn from @var{bytevector}.  If @var{transcoder} is
specified, it becomes the transcoder associated with the returned port.

If @var{maybe-transcoder} is @false{} or absent, the port will be a
binary port and will support the @func{port-position} and
@func{set-port-position!} operations.  Otherwise the port will be a
textual port, and whether it supports the @func{port-position} and
@func{set-port-position!} operations will be implementation--dependent
(and possibly transcoder--dependent).

If @var{bytevector} is modified after @code{open-bytevector-input-port}
has been called, the effect on the returned port is unspecified.
@end deffn


@deffn Procedure {open-string-input-port} @var{string}
Return a textual input port whose characters are drawn from
@var{string}.  The port may or may not have an associated transcoder; if
it does, the transcoder is implementation--dependent.  The port should
support the @func{port-position} and @func{set-port-position!}
operations.

If @var{string} is modified after @func{open-string-input-port} has been
called, the effect on the returned port is unspecified.
@end deffn


@deffn Procedure {standard-input-port}
Return a fresh binary input port connected to standard input.  Whether
the port supports the @func{port-position} and @func{set-port-position!}
operations is implementation--dependent.
@end deffn


@deffn Procedure {current-input-port}
This returns a default textual port for input.  Normally, this default
port is associated with standard input, but can be dynamically
re--assigned using the @func{with-input-from-file} procedure from the
@rsixlibrary{io simple} library.  The port may or may not have an
associated transcoder; if it does, the transcoder is
implementation--dependent.
@end deffn


@deffn Procedure make-custom-binary-input-port @var{id} @var{read!} @var{get-position} @var{set-position!} @var{close}
Return a newly created binary input port whose byte source is an
arbitrary algorithm represented by the @func{read!} procedure.  @var{id}
must be a string naming the new port, provided for informational
purposes only.  @var{read!} must be a procedure and should behave as
specified below; it will be called by operations that perform binary
input.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified below.

@table @code
@item (@var{read!} @var{bytevector} @var{start} @var{count})
@var{start} will be a non--negative exact integer object, @var{count}
will be a positive exact integer object, and @var{bytevector} will be a
bytevector whose length is at least @var{start}+@var{count}.

The @var{read!} procedure should obtain up to @var{count} bytes from the
byte source, and should write those bytes into @var{bytevector} starting
at index @var{start}.  The @var{read!} procedure should return an exact
integer object.  This integer object should represent the number of
bytes that it has read.  To indicate an end of file, the @var{read!}
procedure should write no bytes and return 0.

@item (@var{get-position})
The @var{get-position} procedure (if supplied) should return an exact
integer object representing the current position of the input port.  If
not supplied, the custom port will not support the @func{port-position}
operation.

@item (@var{set-position!} @var{pos})
@var{pos} will be a non--negative exact integer object.  The
@var{set-position!} procedure (if supplied) should set the position of
the input port to @var{pos}.  If not supplied, the custom port will not
support the @func{set-port-position!} operation.

@item (@var{close})
The @var{close} procedure (if supplied) should perform any actions that
are necessary when the input port is closed.
@end table

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{read!} and @var{get-position} only when it
actually calls them as part of an I/O operation requested by the
program.  The implementation is not required to check that these
procedures otherwise behave as described.  If they do not, however, the
behavior of the resulting port is unspecified.
@end deffn


@deffn Procedure make-custom-textual-input-port @var{id} @var{read!} @var{get-position} @var{set-position!} @var{close}
Return a newly created textual input port whose character source is an
arbitrary algorithm represented by the @var{read!} procedure.  @var{id}
must be a string naming the new port, provided for informational
purposes only.  @var{read!} must be a procedure and should behave as
specified below; it will be called by operations that perform textual
input.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified below.

@table @code
@item (@var{read!} @var{string} @var{start} @var{count})
@var{start} will be a non--negative exact integer object, @var{count}
will be a positive exact integer object, and @var{string} will be a
string whose length is at least @var{start}+@var{count}.

The @var{read!} procedure should obtain up to @var{count} characters
from the character source, and should write those characters into
@var{string} starting at index @var{start}.  The @var{read!} procedure
should return an exact integer object representing the number of
characters that it has written.  To indicate an end of file, the
@var{read!}  procedure should write no bytes and return 0.

@item (@var{get-position})
The @var{get-position} procedure (if supplied) should return a single
value.  The return value should represent the current position of the
input port.  If not supplied, the custom port will not support the
@func{port-position} operation.

@item (@var{set-position!} @var{pos})
The @var{set-position!} procedure (if supplied) should set the position
of the input port to @var{pos} if @var{pos} is the return value of a
call to @var{get-position}.  If not supplied, the custom port will not
support the @func{set-port-position!} operation.

@item (@var{close})
The @var{close} procedure (if supplied) should perform any actions that
are necessary when the input port is closed.
@end table

The port may or may not have an an associated transcoder; if it does,
the transcoder is implementation--dependent.

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{read!} and @var{get-position} only when it
actually calls them as part of an I/O operation requested by the
program.  The implementation is not required to check that these
procedures otherwise behave as described.  If they do not, however, the
behavior of the resulting port is unspecified.
@end deffn



@c page
@node stdlib io port binary input
@subsection Binary input


@deffn Procedure get-u8 @var{binary-input-port}
Read from @var{binary-input-port}, blocking as necessary, until a byte
is available from @var{binary-input-port} or until an end of file is
reached.  If a byte becomes available, @code{get-u8} returns the byte as
an octet and updates @var{binary-input-port} to point just past that
byte. If no input byte is seen before an end of file is reached, the
end--of--file object is returned.
@end deffn


@deffn Procedure lookahead-u8 @var{binary-input-port}
The @func{lookahead-u8} procedure is like @code{get-u8}, but it does not
update @var{binary-input-port} to point past the byte.
@end deffn


@deffn Procedure get-bytevector-n @var{binary-input-port} @var{count}
@var{count} must be an exact, non--negative integer object representing
the number of bytes to be read.

The @func{get-bytevector-n} procedure reads from
@var{binary-input-port}, blocking as necessary, until @var{count} bytes
are available from @var{binary-input-port} or until an end of file is
reached.

If @var{count} bytes are available before an end of file,
@func{get-bytevector-n} returns a bytevector of size @var{count}.

If fewer bytes are available before an end of file,
@func{get-bytevector-n} returns a bytevector containing those bytes. In
either case, the input port is updated to point just past the bytes
read.

If an end of file is reached before any bytes are available,
@func{get-bytevector-n} returns the end--of--file object.
@end deffn


@deffn Procedure {get-bytevector-n!} @var{binary-input-port} @var{bytevector} @var{start} @var{count}
@var{count} must be an exact, non--negative integer object, representing
the number of bytes to be read. @var{bytevector} must be a bytevector
with at least @var{start}+@var{count} elements.

The @func{get-bytevector-n!} procedure reads from
@var{binary-input-port}, blocking as necessary, until @var{count} bytes
are available from @var{binary-input-port} or until an end of file is
reached.

If @var{count} bytes are available before an end of file, they are
written into @var{bytevector} starting at index @var{start}, and the
result is @var{count}.

If fewer bytes are available before the next end of file, the available
bytes are written into @var{bytevector} starting at index @var{start},
and the result is a number object representing the number of bytes
actually read.

In either case, the input port is updated to point just past the bytes
read. If an end of file is reached before any bytes are available,
@func{get-bytevector-n!} returns the end--of--file object.
@end deffn


@deffn Procedure get-bytevector-some @var{binary-input-port}
Read from @var{binary-input-port}, blocking as necessary, until bytes
are available from @var{binary-input-port} or until an end of file is
reached.  If bytes become available, @func{get-bytevector-some} returns
a freshly allocated bytevector containing the initial available bytes
(at least one), and it updates @var{binary-input-port} to point just
past these bytes.  If no input bytes are seen before an end of file is
reached, the end--of--file object is returned.
@end deffn


@deffn Procedure get-bytevector-all @var{binary-input-port}
Attempts to read all bytes until the next end of file, blocking as
necessary.  If one or more bytes are read, @func{get-bytevector-all}
returns a bytevector containing all bytes up to the next end of file.
Otherwise, @func{get-bytevector-all} returns the end--of--file object.
The operation may block indefinitely waiting to see if more bytes will
become available, even if some bytes are already available.
@end deffn



@c page
@node stdlib io port textual input
@subsection Textual input


@deffn Procedure get-char @var{textual-input-port}
Read from @var{textual-input-port}, blocking as necessary, until a
complete character is available from @var{textual-input-port}, or until
an end of file is reached.

If a complete character is available before the next end of file,
@func{get-char} returns that character and updates the input port to
point past the character. If an end of file is reached before any
character is read, @func{get-char} returns the end--of--file object.
@end deffn


@deffn Procedure lookahead-char @var{textual-input-port}
The @func{lookahead-char} procedure is like @func{get-char}, but it does
not update @var{textual-input-port} to point past the character.

@quotation
@emph{Note:} With some of the standard transcoders described in this
document, up to four bytes of lookahead are needed.  Non--standard
transcoders may need even more lookahead.
@end quotation
@end deffn


@deffn Procedure get-string-n @var{textual-input-port} @var{count}
@var{count} must be an exact, non--negative integer object, representing
the number of characters to be read.

The @func{get-string-n} procedure reads from @var{textual-input-port},
blocking as necessary, until @var{count} characters are available, or
until an end of file is reached.

If @var{count} characters are available before end of file,
@func{get-string-n} returns a string consisting of those @var{count}
characters.

If fewer characters are available before an end of file, but one or more
characters can be read, @func{get-string-n} returns a string containing
those characters.

In either case, the input port is updated to point just past the
characters read. If no characters can be read before an end of file, the
end-of-file object is returned.
@end deffn


@deffn Procedure {get-string-n!} @var{textual-input-port} @var{string} @var{start} @var{count}
@var{start} and @var{count} must be exact, non--negative integer
objects, with @var{count} representing the number of characters to be
read.  @var{string} must be a string with at least
@var{start}+@var{count} characters.

The @func{get-string-n!} procedure reads from @var{textual-input-port}
in the same manner as @func{get-string-n}.

If @var{count} characters are available before an end of file, they are
written into @var{string} starting at index @var{start}, and @var{count}
is returned.

If fewer characters are available before an end of file, but one or more
can be read, those characters are written into @var{string} starting at
index @var{start} and the number of characters actually read is returned
as an exact integer object.

If no characters can be read before an end of file, the end--of--file
object is returned.
@end deffn


@deffn Procedure get-string-all @var{textual-input-port}
Read from @var{textual-input-port} until an end of file, decoding
characters in the same manner as @func{get-string-n} and
@func{get-string-n!}.

If characters are available before the end of file, a string containing
all the characters decoded from that data are returned.  If no character
precedes the end of file, the end--of--file object is returned.
@end deffn


@deffn Procedure get-line @var{textual-input-port}
Read from @var{textual-input-port} up to and including the linefeed
character or end of file, decoding characters in the same manner as
@func{get-string-n} and @func{get-string-n!}.

If a linefeed character is read, a string containing all of the text up
to (but not including) the linefeed character is returned, and the port
is updated to point just past the linefeed character.

If an end of file is encountered before any linefeed character is read,
but some characters have been read and decoded as characters, a string
containing those characters is returned.

If an end of file is encountered before any characters are read, the
end--of--file object is returned.

@quotation
@emph{Note:} The end--of--line style, if not @code{none}, will cause all
line endings to be read as linefeed characters.
@end quotation
@end deffn


@deffn Procedure get-datum @var{textual-input-port}
Read an external representation from @var{textual-input-port} and
returns the datum it represents.  The @func{get-datum} procedure returns
the next datum that can be parsed from the given
@var{textual-input-port}, updating @var{textual-input-port} to point
exactly past the end of the external representation of the object.

Any @meta{interlexeme space} (@ref{lang lex syntax}) in the input is
first skipped.  If an end of file occurs after the @meta{interlexeme
space}, the end--of--file object is returned.

If a character inconsistent with an external representation is
encountered in the input, an exception with condition types
@code{&lexical} and @code{&i/o-read} is raised.

Also, if the end of file is encountered after the beginning of an
external representation, but the external representation is incomplete
and therefore cannot be parsed, an exception with condition types
@code{&lexical} and @code{&i/o-read} is raised.
@end deffn



@c page
@node stdlib io port output ports
@subsection Output ports


An output port is a sink to which bytes or characters are written.  The
written data may control external devices or may produce files and other
objects that may subsequently be opened for input.


@deffn Procedure {output-port?} @var{obj}
Return @true{} if the argument is an output port (or a combined input
and output port), @false{} otherwise.
@end deffn


@deffn Procedure {flush-output-port} @var{output-port}
Flushe any buffered output from the buffer of @var{output-port} to the
underlying file, device, or object.  The @func{flush-output-port}
procedure returns unspecified values.
@end deffn


@deffn Procedure {output-port-buffer-mode} @var{output-port}
Return the symbol that represents the buffer mode of @var{output-port}.
@end deffn


@deffn Procedure open-file-output-port @var{filename}
@deffnx Procedure open-file-output-port @var{filename} @var{file-options}
@deffnx Procedure open-file-output-port @var{filename} @var{file-options} @var{buffer-mode}
@deffnx Procedure open-file-output-port @var{filename} @var{file-options} @var{buffer-mode} @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-file-output-port} procedure returns an output port for
the named file.

The @var{file-options} argument, which may determine various aspects of
the returned port, defaults to the value of @code{(file-options)}.

The @var{buffer-mode} argument, if supplied, must be one of the symbols
that name a buffer mode.  The @var{buffer-mode} argument defaults to
@code{block}.

If @var{maybe-transcoder} is a transcoder, it becomes the transcoder
associated with the port.

If @var{maybe-transcoder} is @false{} or absent, the port will be a
binary port and will support the @func{port-position} and
@func{set-port-position!}  operations.  Otherwise the port will be a
textual port, and whether it supports the @func{port-position} and
@func{set-port-position!} operations is implementation--dependent (and
possibly transcoder--dependent).
@end deffn


@deffn Procedure open-bytevector-output-port
@deffnx Procedure open-bytevector-output-port @var{maybe-transcoder}
@var{maybe-transcoder} must be either a transcoder or @false{}.

The @func{open-bytevector-output-port} procedure returns two values: an
output port and an extraction procedure.  The output port accumulates
the bytes written to it for later extraction by the procedure.

If @var{maybe-transcoder} is a transcoder, it becomes the transcoder
associated with the port.  If @var{maybe-transcoder} is @false{} or
absent, the port will be a binary port and will support the
@func{port-position} and @func{set-port-position!}  operations.
Otherwise the port will be a textual port, and whether it supports the
@code{port-position} and @func{set-port-position!} operations is
implementation--dependent (and possibly transcoder--dependent).

The extraction procedure takes no arguments.  When called, it returns a
bytevector consisting of all the port's accumulated bytes (regardless of
the port's current position), removes the accumulated bytes from the
port, and resets the port's position.
@end deffn


@deffn Procedure call-with-bytevector-output-port @var{proc}
@deffnx Procedure call-with-bytevector-output-port @var{proc} @var{maybe-transcoder}
@var{proc} must accept one argument.  @var{maybe-transcoder} must be
either a transcoder or @false{}.

The @func{call-with-bytevector-output-port} procedure creates an output
port that accumulates the bytes written to it and calls @var{proc} with
that output port as an argument.

Whenever @var{proc} returns, a bytevector consisting of all of the
port's accumulated bytes (regardless of the port's current position) is
returned and the port is closed.

The transcoder associated with the output port is determined as for a
call to @func{open-bytevector-output-port}.
@end deffn


@deffn Procedure open-string-output-port
Return two values: a textual output port and an extraction procedure.
The output port accumulates the characters written to it for later
extraction by the procedure.

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the
@func{port-position} and @func{set-port-position!} operations.

The extraction procedure takes no arguments.  When called, it returns a
string consisting of all of the port's accumulated characters
(regardless of the current position), removes the accumulated characters
from the port, and resets the port's position.
@end deffn


@deffn Procedure call-with-string-output-port @var{proc}
@var{proc} must accept one argument.

The @func{call-with-string-output-port} procedure creates a textual
output port that accumulates the characters written to it and calls
@var{proc} with that output port as an argument.

Whenever @var{proc} returns, a string consisting of all of the port's
accumulated characters (regardless of the port's current position) is
returned and the port is closed.

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.  The port should support the
@func{port-position} and @func{set-port-position!} operations.
@end deffn


@deffn Procedure standard-output-port
@deffnx Procedure standard-error-port
Return a fresh binary output port connected to the standard output or
standard error respectively.  Whether the port supports the
@func{port-position} and @func{set-port-position!} operations is
implementation--dependent.
@end deffn


@deffn Procedure current-output-port
@deffnx Procedure current-error-port
These return default textual ports for regular output and error output.
Normally, these default ports are associated with standard output, and
standard error, respectively.

The return value of @func{current-output-port} can be dynamically
re--assigned using the @func{with-output-to-file} procedure from the
@rsixlibrary{io simple} library.  A port returned by one of these
procedures may or may not have an associated transcoder; if it does, the
transcoder is implementation--dependent.
@end deffn


@deffn Procedure make-custom-binary-output-port @var{id} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created binary output port whose byte sink is an
arbitrary algorithm represented by the @var{write!} procedure.  @var{id}
must be a string naming the new port, provided for informational
purposes only.  @var{write!} must be a procedure and should behave as
specified below; it will be called by operations that perform binary
output.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-binary-input-port}.

@table @code
@item (@var{write!} @var{bytevector} @var{start} @var{count})
@var{start} and @var{count} will be non-negative exact integer objects,
and @var{bytevector} will be a bytevector whose length is at least
@var{start}+@var{count}.

The @var{write!} procedure should write up to @var{count} bytes from
@var{bytevector} starting at index @var{start} to the byte sink.  In any
case, the @var{write!} procedure should return the number of bytes that
it wrote, as an exact integer object.
@end table

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{write!} only when it actually calls
@var{write!} as part of an I/O operation requested by the program.  The
implementation is not required to check that @var{write!} otherwise
behaves as described.  If it does not, however, the behavior of the
resulting port is unspecified.
@end deffn


@deffn Procedure make-custom-textual-output-port @var{id} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created textual output port whose byte sink is an
arbitrary algorithm represented by the @var{write!} procedure.  @var{Id}
must be a string naming the new port, provided for informational
purposes only.  @var{Write!} must be a procedure and should behave as
specified below; it will be called by operations that perform textual
output.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-textual-input-port}.

@table @code
@item (@var{write!} @var{string} @var{start} @var{count})
@var{start} and @var{count} will be non--negative exact integer objects,
and @var{string} will be a string whose length is at least
@var{start}+@var{count}.

The @var{write!} procedure should write up to @var{count} characters
from @var{string} starting at index @var{start} to the character sink.
In any case, the @var{write!} procedure should return the number of
characters that it wrote, as an exact integer object.
@end table

The port may or may not have an associated transcoder; if it does, the
transcoder is implementation-dependent.

@strong{Implementation responsibilities:} The implementation must check
the return values of @var{write!} only when it actually calls
@var{write!} as part of an I/O operation requested by the program.  The
implementation is not required to check that @var{write!} otherwise
behaves as described.  If it does not, however, the behavior of the
resulting port is unspecified.
@end deffn



@c page
@node stdlib io port binary output
@subsection Binary output


@deffn Procedure put-u8 @var{binary-output-port} @var{octet}
Write @var{octet} to the output port and returns unspecified values.
@end deffn


@deffn Procedure put-bytevector @var{binary-output-port} @var{bytevector}
@deffnx Procedure put-bytevector @var{binary-output-port} @var{bytevector} @var{start}
@deffnx Procedure put-bytevector @var{binary-output-port} @var{bytevector} @var{start} @var{count}
@var{start} and @var{count} must be non--negative exact integer objects
that default to 0 and:

@example
(- (bytevector-length @var{bytevector}) @var{start})
@end example

@noindent
respectively.  @var{bytevector} must have a length of at least
@var{start}+@var{count}.  The @func{put-bytevector} procedure writes the
@var{count} bytes of the bytevector @var{bytevector} starting at index
@var{start} to the output port.  The @func{put-bytevector} procedure
returns unspecified values.
@end deffn



@c page
@node stdlib io port textual output
@subsection Textual output


@deffn Procedure put-char @var{textual-output-port} @var{char}
Write @var{char} to the port. The @func{put-char} procedure returns
unspecified values.
@end deffn


@deffn Procedure put-string @var{textual-output-port} @var{string}
@deffnx Procedure put-string @var{textual-output-port} @var{string} @var{start}
@deffnx Procedure put-string @var{textual-output-port} @var{string} @var{start} @var{count}
@var{start} and @var{count} must be non--negative exact integer objects.
@var{String} must have a length of at least @var{start}+@var{count}.

@var{start} defaults to 0.  @var{count} defaults to:

@example
(- (string-length @var{string}) @var{start})
@end example

The @func{put-string} procedure writes the @var{count} characters of
@var{string} starting at index @var{start} to the port.  The
@func{put-string} procedure returns unspecified values.
@end deffn


@deffn Procedure put-datum @var{textual-output-port} @var{datum}
@var{datum} should be a datum value.

The @func{put-datum} procedure writes an external representation of
@var{datum} to @var{textual-output-port}.  The specific external
representation is implementation--dependent.  However, whenever
possible, an implementation should produce a representation for which
@func{get-datum}, when reading the representation, will return an object
equal (in the sense of @func{equal?}) to @var{datum}.

@quotation
@emph{Note:} Not all datums may allow producing an external
representation for which @func{get-datum} will produce an object that is
equal to the original.  Specifically, NaNs contained in @var{datum} may
make this impossible.
@end quotation

@quotation
@emph{Note:} The @func{put-datum} procedure merely writes the external
representation, but no trailing delimiter.  If @func{put-datum} is used
to write several subsequent external representations to an output port,
care should be taken to delimit them properly so they can be read back
in by subsequent calls to @func{get-datum}.
@end quotation
@end deffn



@c page
@node stdlib io port input output ports
@subsection Input/output ports


@deffn Procedure {open-file-input/output-port} @var{filename}
@deffnx Procedure {open-file-input/output-port} @var{filename} @var{file-options}
@deffnx Procedure {open-file-input/output-port} @var{filename} @var{file-options} @var{buffer-mode}
@deffnx Procedure {open-file-input/output-port} @var{filename} @var{file-options} @var{buffer-mode} @var{transcoder}
Return a single port that is both an input port and an output port for
the named file.  The optional arguments default as described in the
specification of @func{open-file-output-port}.  If the input/output port
supports @func{port-position} and/or @func{set-port-position!}, the same
port position is used for both input and output.
@end deffn


@deffn Procedure {make-custom-binary-input/output-port} @var{id} @var{read!} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created binary input/output port whose byte source and
sink are arbitrary algorithms represented by the @var{read!} and
@var{write!}  procedures.

@var{id} must be a string naming the new port, provided for
informational purposes only.

@var{read!} and @var{write!} must be procedures, and should behave as
specified for the @func{make-custom-binary-input-port} and
@func{make-custom-binary-output-port} procedures.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-binary-input-port}.
@end deffn


@deffn Procedure {make-custom-textual-input/output-port} @var{id} @var{read!} @var{write!} @var{get-position} @var{set-position!} @var{close}
Return a newly created textual input/output port whose textual source
and sink are arbitrary algorithms represented by the @var{read!} and
@var{write!}  procedures.

@var{id} must be a string naming the new port, provided for
informational purposes only.

@var{read!} and @var{write!} must be procedures, and should behave as
specified for the @func{make-custom-textual-input-port} and
@func{make-custom-textual-output-port} procedures.

Each of the remaining arguments may be @false{}; if any of those
arguments is not @false{}, it must be a procedure and should behave as
specified in the description of @func{make-custom-textual-input-port}.
@end deffn



@c page
@node stdlib io simple
@section Simple input/output


This section describes the @rsixlibrary{io simple} library, which
provides a somewhat more convenient interface for performing textual I/O
on ports.  This library implements most of the I/O procedures of the
previous revision of this report.

The ports created by the procedures of this library are textual ports
associated implementation--dependent transcoders.


@deffn Procedure {eof-object}
@deffnx Procedure {eof-object?} @var{obj}
These are the same as @func{eof-object} and @func{eof-object?} from the
@rsixlibrary{ports} library.
@end deffn


@deffn Procedure call-with-input-file @var{filename} @var{proc}
@deffnx Procedure call-with-output-file @var{filename} @var{proc}
@var{proc} should accept one argument.

These procedures open the file named by @var{filename} for input or for
output, with no specified file options, and call @var{proc} with the
obtained port as an argument.

If @var{proc} returns, the port is closed automatically and the values
returned by @var{proc} are returned.

If @var{proc} does not return, the port is not closed automatically,
unless it is possible to prove that the port will never again be used
for an I/O operation.
@end deffn


@deffn Procedure input-port? @var{obj}
@deffnx Procedure output-port? @var{obj}
These are the same as the @func{input-port?} and @func{output-port?}
procedures in the @rsixlibrary{io ports} library.
@end deffn


@deffn Procedure current-input-port
@deffnx Procedure current-output-port
@deffnx Procedure current-error-port
These are the same as the @func{current-input-port},
@func{current-output-port}, and @func{current-error-port} procedures
from the @rsixlibrary{io ports} library.
@end deffn


@deffn Procedure with-input-from-file @var{filename} @var{thunk}
@deffnx Procedure with-output-to-file @var{filename} @var{thunk}
@var{thunk} must be a procedure and must accept zero arguments.

The file is opened for input or output using empty file options, and
@var{thunk} is called with no arguments.

During the dynamic extent of the call to @var{thunk}, the obtained port
is made the value returned by @func{current-input-port} or
@func{current-output-port} procedures; the previous default values are
reinstated when the dynamic extent is exited.

When @var{thunk} returns, the port is closed automatically.  The values
returned by @var{thunk} are returned.

If an escape procedure is used to escape back into the call to
@var{thunk} after @var{thunk} is returned, the behavior is unspecified.
@end deffn


@deffn Procedure open-input-file @var{filename}
Open @var{filename} for input, with empty file options, and returns the
obtained port.
@end deffn


@deffn Procedure open-output-file @var{filename}
Open @var{filename} for output, with empty file options, and returns the
obtained port.
@end deffn


@deffn Procedure close-input-port @var{input-port}
@deffnx Procedure close-output-port @var{output-port}
Close @var{input-port} or @var{output-port}, respectively.
@end deffn


@deffn Procedure read-char
@deffnx Procedure read-char @var{textual-input-port}
Reads from @var{textual-input-port}, blocking as necessary until a
character is available from @var{textual-input-port}, or the data that
are available cannot be the prefix of any valid encoding, or an end of
file is reached.

If a complete character is available before the next end of file,
@func{read-char} returns that character, and updates the input port to
point past that character.

If an end of file is reached before any data are read, @func{read-char}
returns the end--of--file object.

If @var{textual-input-port} is omitted, it defaults to the value
returned by @func{current-input-port}.
@end deffn


@deffn Procedure peek-char
@deffnx Procedure peek-char @var{textual-input-port}
This is the same as @func{read-char}, but does not consume any data from
the port.
@end deffn


@deffn Procedure read
@deffnx Procedure read @var{textual-input-port}
Read an external representation from @var{textual-input-port} and
returns the datum it represents.

The @func{read} procedure operates in the same way as @func{get-datum}.

If @var{textual-input-port} is omitted, it defaults to the value
returned by @func{current-input-port}.
@end deffn


@deffn Procedure write-char @var{char}
@deffnx Procedure write-char @var{char} @var{textual-output-port}
Write an encoding of the character @var{char} to the
@var{textual-output-port}, and returns unspecified values.

If @var{textual-output-port} is omitted, it defaults to the value
returned by @func{current-output-port}.
@end deffn


@deffn Procedure newline
@deffnx Procedure newline @var{textual-output-port}
This is equivalent to using @func{write-char} to write @code{#\linefeed}
to @var{textual-output-port}.

If @var{textual-output-port} is omitted, it defaults to the value
returned by @func{current-output-port}.
@end deffn


@deffn Procedure display @var{obj}
@deffnx Procedure display @var{obj} @var{textual-output-port}
Write a representation of @var{obj} to the given
@var{textual-output-port}.

Strings that appear in the written representation are not enclosed in
doublequotes, and no characters are escaped within those strings.

Character objects appear in the representation as if written by
@func{write-char} instead of by @code{write}.

The @func{display} procedure returns unspecified values.

The @var{textual-output-port} argument may be omitted, in which case it
defaults to the value returned by @func{current-output-port}.
@end deffn


@deffn Procedure write @var{obj}
@deffnx Procedure write @var{obj} @var{textual-output-port}
Write the external representation of @var{obj} to
@var{textual-output-port}.

The @func{write} procedure operates in the same way as @func{put-datum}.

If @var{textual-output-port} is omitted, it defaults to the value
returned by @func{current-output-port}.
@end deffn



@c page
@node stdlib files
@chapter File system


This chapter describes the @rsixlibrary{files} library for operations on
the file system.  This library, in addition to the procedures described
here, also exports the I/O condition types described in section
@ref{stdlib io conditions}.


@deffn Procedure {file-exists?} @var{filename}
@var{filename} must be a file name.

The @func{file-exists?} procedure returns @true{} if the named file
exists at the time the procedure is called, @false{} otherwise.
@end deffn

@deffn Procedure delete-file @var{filename}
@var{filename} must be a file name.

The @func{delete-file} procedure deletes the named file if it exists and
can be deleted, and returns unspecified values.  If the file does not
exist or cannot be deleted, an exception with condition type
@code{&i/o-filename} is raised.
@end deffn



@c page
@node stdlib programlib
@chapter Command line access and exit values


The procedures described in this section are exported by the
@rsixlibrary{programs} library.


@deffn Procedure command-line
Return a nonempty list of strings.  The first element is an
implementation--specific name for the running top--level program.  The
remaining elements are command--line arguments according to the
operating system's conventions.
@end deffn


@deffn Procedure exit
@deffnx Procedure exit @var{obj}
Exit the running program and communicates an exit value to the operating
system.

If no argument is supplied, the @func{exit} procedure should communicate
to the operating system that the program exited normally.

If an argument is supplied, the @func{exit} procedure should translate
the argument into an appropriate exit value for the operating system.
If @var{obj} is @false{}, the exit is assumed to be abnormal.
@end deffn



@c page
@node stdlib arithmetics
@chapter Arithmetics


This chapter describes Scheme's libraries for more specialized numerical
operations: fixnum and flonum arithmetic, as well as bitwise operations
on exact integer objects.


@menu
* stdlib arithmetics bitwise::          Bitwise operations.
* stdlib arithmetics fixnum::           Fixnums.
* stdlib arithmetics flonum::           Flonums.
* stdlib arithmetics exact bitwise::    Exact bitwise arithmetic.
@end menu


@c page
@node stdlib arithmetics bitwise
@section Bitwise operations


A number of procedures operate on the binary two's--complement
representations of exact integer objects: Bit positions within an exact
integer object are counted from the right, i.e. bit 0 is the least
significant bit.  Some procedures allow extracting @emph{bit fields},
i.e., number objects representing subsequences of the binary
representation of an exact integer object.  Bit fields are always
positive, and always defined using a finite number of bits.



@c page
@node stdlib arithmetics fixnum
@section Fixnums


Every implementation must define its fixnum range as a closed interval:

@example
[-2^(w-1), 2^(w-1)-1]
@end example

@noindent
such that @emph{w} is a (mathematical) integer @emph{w >= 24}.  Every
mathematical integer within an implementation's fixnum range must
correspond to an exact integer object that is representable within the
implementation.  A fixnum is an exact integer object whose value lies
within this fixnum range.

This section describes the @rsixlibrary{arithmetic fixnums} library,
which defines various operations on fixnums.  Fixnum operations perform
integer arithmetic on their fixnum arguments, but raise an exception
with condition type @code{&implementation-restriction} if the result is
not a fixnum.

This section uses @var{fx}, @vari{fx}, @varii{fx}, etc., as names for
arguments that must be fixnums.


@deffn Procedure fixnum? @var{obj}
Return @true{} if @var{obj} is an exact integer object within the fixnum
range, @false{} otherwise.
@end deffn


@deffn Procedure fixnum-width
@deffnx Procedure least-fixnum
@deffnx Procedure greatest-fixnum
These procedures return @emph{w}, @emph{-2^(w-1)} and @emph{2^(w-1)-1}:
the width, minimum and the maximum value of the fixnum range,
respectively.
@end deffn


@deffn Procedure {fx=?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx>?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx<?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx>=?} @vari{fx} @varii{fx} @variii{fx} @dots{}
@deffnx Procedure {fx<=?} @vari{fx} @varii{fx} @variii{fx} @dots{}
These procedures return @true{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, @false{} otherwise.
@end deffn


@deffn Procedure {fxzero?} @var{fx}
@deffnx Procedure {fxpositive?} @var{fx}
@deffnx Procedure {fxnegative?} @var{fx}
@deffnx Procedure {fxodd?} @var{fx}
@deffnx Procedure {fxeven?} @var{fx}
These numerical predicates test a fixnum for a particular property,
returning @true{} or @false{}.  The five properties tested by these
procedures are: whether the number object is zero, greater than zero,
less than zero, odd, or even.
@end deffn


@deffn Procedure {fxmax} @vari{fx} @varii{fx} @dots{}
@deffnx Procedure {fxmin} @vari{fx} @varii{fx} @dots{}
These procedures return the maximum or minimum of their arguments.
@end deffn


@deffn Procedure {fx+} @vari{fx} @varii{fx}
@deffnx Procedure {fx*} @vari{fx} @varii{fx}
These procedures return the sum or product of their arguments, provided
that sum or product is a fixnum.  An exception with condition type
@code{&implementation-restriction} is raised if that sum or product is
not a fixnum.
@end deffn


@deffn Procedure {fx-} @vari{fx} @varii{fx}
@deffnx Procedure {fx-} @var{fx}
With two arguments, this procedure returns the difference
@vari{fx}-@varii{fx}, provided that difference is a fixnum.

With one argument, this procedure returns the additive inverse of its
argument, provided that integer object is a fixnum.

An exception with condition type @code{&implementation-restriction} is
raised if the mathematically correct result of this procedure is not a
fixnum.

@example
(fx- (least-fixnum))  => exception &assertion
@end example
@end deffn


@deffn Procedure {fxdiv-and-mod} @vari{fx} @varii{fx}
@deffnx Procedure {fxdiv} @vari{fx} @varii{fx}
@deffnx Procedure {fxmod} @vari{fx} @varii{fx}
@deffnx Procedure {fxdiv0-and-mod0} @vari{fx} @varii{fx}
@deffnx Procedure {fxdiv0} @vari{fx} @varii{fx}
@deffnx Procedure {fxmod0} @vari{fx} @varii{fx}
@varii{fx} must be nonzero.

These procedures implement number--theoretic integer division and return
the results of the corresponding mathematical operations specified in
report section``Integer division''.

@example
(fxdiv @vari{fx} @varii{fx})         => @vari{fx} div @varii{fx}
(fxmod @vari{fx} @varii{fx})         => @vari{fx} mod @varii{fx}
(fxdiv-and-mod @vari{fx} @varii{fx}) => @vari{fx} div @varii{fx}, @vari{fx} mod @varii{fx}
                                        ; two return values
(fxdiv0 @vari{fx} @varii{fx})        => @vari{fx} div_0 @varii{fx}
(fxmod0 @vari{fx} @varii{fx})        => @vari{fx} mod_0 @varii{fx}
(fxdiv0-and-mod0 @vari{fx} @varii{fx})
=> @vari{fx} @vari{fx} div_0 @varii{fx}, @vari{fx} mod_0 @varii{fx}
   ; two return values
@end example
@end deffn


@deffn Procedure {fx+/carry} @vari{fx} @varii{fx} @variii{fx}
Return the two fixnum results of the following computation:

@example
(let* ((s (+ @vari{fx} @varii{fx} @variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))
@end example
@end deffn


@deffn Procedure {fx-/carry} @vari{fx} @varii{fx} @variii{fx}
Return the two fixnum results of the following computation:

@example
(let* ((d (- @vari{fx} @varii{fx} @variii{fx}))
       (d0 (mod0 d (expt 2 (fixnum-width))))
       (d1 (div0 d (expt 2 (fixnum-width)))))
  (values d0 d1))
@end example
@end deffn


@deffn Procedure {fx*/carry} @vari{fx} @varii{fx} @variii{fx}
Return the two fixnum results of the following computation:

@example
(let* ((s (+ (* @vari{fx} @varii{fx}) @variii{fx}))
       (s0 (mod0 s (expt 2 (fixnum-width))))
       (s1 (div0 s (expt 2 (fixnum-width)))))
  (values s0 s1))
@end example
@end deffn


@deffn Procedure {fxnot} @var{fx}
Return the unique fixnum that is congruent mod @emph{2^w} to the
one's--complement of @var{fx}.
@end deffn


@deffn Procedure {fxand} @vari{fx} @dots{}
@deffnx Procedure {fxior} @vari{fx} @dots{}
@deffnx Procedure {fxxor} @vari{fx} @dots{}
These procedures return the fixnum that is the bit--wise ``and'',
``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the fixnum (either @emph{-1} or @emph{0}) that acts as
identity for the operation.
@end deffn


@deffn Procedure {fxif} @vari{fx} @varii{fx} @variii{fx}
Return the fixnum that is the bit--wise ``if'' of the two's complement
representations of its arguments, i.e. for each bit, if it is 1 in
@vari{fx}, the corresponding bit in @varii{fx} becomes the value of the
corresponding bit in the result, and if it is 0, the corresponding bit
in @variii{fx} becomes the corresponding bit in the value of the result.
This is the fixnum result of the following computation:

@example
(fxior (fxand @vari{fx} @varii{fx})
       (fxand (fxnot @vari{fx}) @variii{fx}))
@end example
@end deffn


@deffn Procedure {fxbit-count} @var{fx}
If @var{fx} is non--negative, this procedure returns the number of 1
bits in the two's complement representation of @var{fx}.  Otherwise it
returns the result of the following computation:

@example
(fxnot (fxbit-count (fxnot @var{ei})))
@end example
@end deffn


@deffn Procedure {fxlength} @var{fx}
Return the number of bits needed to represent @var{fx} if it is
positive, and the number of bits needed to represent @code{(fxnot
@var{fx})} if it is negative, which is the fixnum result of the
following computation:

@example
(do ((result 0 (+ result 1))
     (bits (if (fxnegative? @var{fx})
               (fxnot @var{fx})
               @var{fx})
           (fxarithmetic-shift-right bits 1)))
    ((fxzero? bits)
     result))
@end example
@end deffn


@deffn Procedure {fxfirst-bit-set} @var{fx}
Return the index of the least significant 1 bit in the two's complement
representation of @var{fx}.  If @var{fx} is 0, then -1 is returned.

@example
(fxfirst-bit-set 0)        =>  -1
(fxfirst-bit-set 1)        =>  0
(fxfirst-bit-set -4)       =>  2
@end example
@end deffn


@deffn Procedure {fxbit-set?} @vari{fx} @varii{fx}
@varii{fx} must be non--negative and less than @code{(fixnum-width)}.

The @func{fxbit-set?} procedure returns @true{} if the @varii{fx}th bit
is 1 in the two's complement representation of @vari{fx}, and @false{}
otherwise.  This is the fixnum result of the following computation:

@example
(not
  (fxzero?
    (fxand @vari{fx}
           (fxarithmetic-shift-left 1 @varii{fx}))))
@end example
@end deffn


@deffn Procedure {fxcopy-bit} @vari{fx} @varii{fx} @variii{fx}
@varii{fx} must be non--negative and less than @code{(fixnum-width)}.
@variii{Fx} must be 0 or 1.

The @func{fxcopy-bit} procedure returns the result of replacing the
@varii{fx}th bit of @vari{fx} by @variii{fx}, which is the result of the
following computation:

@example
(let* ((mask (fxarithmetic-shift-left 1 @varii{fx})))
  (fxif mask
        (fxarithmetic-shift-left @variii{fx} @varii{fx})
        @vari{fx}))
@end example
@end deffn


@deffn Procedure {fxbit-field} @vari{fx} @varii{fx} @variii{fx}
@varii{fx} and @variii{fx} must be non-negative and less than
@code{(fixnum-width)}.  Moreover, @varii{fx} must be less than or equal
to @variii{fx}.

The @code{fxbit-field} procedure returns the number represented by the
bits at the positions from @varii{fx} (inclusive) to @variii{fx}
(exclusive), which is the fixnum result of the following computation:

@example
(let* ((mask (fxnot
              (fxarithmetic-shift-left -1 @variii{fx}))))
  (fxarithmetic-shift-right (fxand @vari{fx} mask)
                            @varii{fx}))
@end example
@end deffn


@deffn Procedure {fxcopy-bit-field} @vari{fx} @varii{fx} @variii{fx} @variv{fx}
@varii{fx} and @variii{fx} must be non-negative and less than
@code{(fixnum-width)}.  Moreover, @varii{fx} must be less than or equal
to @variii{fx}.

The @func{fxcopy-bit-field} procedure returns the result of replacing in
@vari{fx} the bits at positions from @varii{fx} (inclusive) to
@variii{fx} (exclusive) by the bits in @variv{fx} from position 0
(inclusive) to position @variii{fx}-@varii{fx} (exclusive), which is the
fixnum result of the following computation:

@example
(let* ((to    @vari{fx})
       (start @varii{fx})
       (end   @variii{fx})
       (from  @variv{fx})
       (mask1 (fxarithmetic-shift-left -1 start))
       (mask2 (fxnot (fxarithmetic-shift-left -1 end)))
       (mask  (fxand mask1 mask2))
       (mask3 (fxnot (fxarithmetic-shift-left -1 (- end start)))))
  (fxif mask
        (fxarithmetic-shift-left (fxand from mask3)
                                 start)
        to))
@end example
@end deffn


@deffn Procedure {fxarithmetic-shift} @vari{fx} @varii{fx}
The absolute value of @varii{fx} must be less than
@code{(fixnum-width)}.

If:

@example
(floor (* @vari{fx} (expt 2 @varii{fx})))
@end example

@noindent
is a fixnum, then that fixnum is returned.  Otherwise an exception with
condition type @code{&implementation-restriction} is raised.
@end deffn


@deffn Procedure {fxarithmetic-shift-left} @vari{fx} @varii{fx}
@deffnx Procedure {fxarithmetic-shift-right} @vari{fx} @varii{fx}
@varii{fx} must be non--negative, and less than @code{(fixnum-width)}.


The @func{fxarithmetic-shift-left} procedure behaves the same as
@func{fxarithmetic-shift}, and @code{(fxarithmetic-shift-right @vari{fx}
@varii{fx})} behaves the same as @code{(fxarithmetic-shift @vari{fx}
(fx- @varii{fx}))}.
@end deffn


@deffn Procedure {fxrotate-bit-field} @vari{fx} @varii{fx} @variii{fx} @variv{fx}
@varii{fx}, @variii{fx}, and @variv{fx} must be non--negative and less
than @code{(fixnum-width)}.  @varii{fx} must be less than or equal to
@variii{fx}.  @variv{fx} must be less than the difference between
@variii{fx} and @varii{fx}.

The @func{fxrotate-bit-field} procedure returns the result of cyclically
permuting in @vari{fx} the bits at positions from @varii{fx} (inclusive)
to @variii{fx} (exclusive) by @variv{fx} bits towards the more
significant bits, which is the result of the following computation:

@example
(let* ((n     @vari{fx})
       (start @varii{fx})
       (end   @variii{fx})
       (count @variv{fx})
       (width (fx- end start)))
  (if (fxpositive? width)
      (let* ((count (fxmod count width))
             (field0
               (fxbit-field n start end))
             (field1
               (fxarithmetic-shift-left
                 field0 count))
             (field2
               (fxarithmetic-shift-right
                 field0 (fx- width count)))
             (field (fxior field1 field2)))
        (fxcopy-bit-field n start end field))
      n))
@end example
@end deffn


@deffn Procedure {fxreverse-bit-field} @vari{fx} @varii{fx} @variii{fx}
@varii{fx} and @variii{fx} must be non-negative and less than
@code{(fixnum-width)}.  Moreover, @varii{fx} must be less than or equal
to @variii{fx}.

The @code{fxreverse-bit-field} procedure returns the fixnum obtained
from @vari{fx} by reversing the order of the bits at positions from
@varii{fx} (inclusive) to @variii{fx} (exclusive).

@example
(fxreverse-bit-field #b1010010 1 4)       =>  88 ; #b1011000
@end example
@end deffn



@c page
@node stdlib arithmetics flonum
@section Flonums


This section describes the @rsixlibrary{arithmetic flonums} library.

This section uses @var{fl}, @vari{fl}, @varii{fl}, etc., as parameter
names for arguments that must be flonums, and @var{ifl} as a name for
arguments that must be integer--valued flonums, i.e., flonums for which
the @func{integer-valued?} predicate returns true.


@deffn Procedure {flonum?} @var{obj}
Return @true{} if @var{obj} is a flonum, @false{} otherwise.
@end deffn


@deffn Procedure {real->flonum} @var{x}
Return the best flonum representation of @var{x}.

The value returned is a flonum that is numerically closest to the
argument.

@quotation
@emph{Note:} If flonums are represented in binary floating point, then
implementations should break ties by preferring the floating--point
representation whose least significant bit is zero.
@end quotation
@end deffn


@deffn Procedure {fl=?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl<?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl<=?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl>?} @vari{fl} @varii{fl} @variii{fl} @dots{}
@deffnx Procedure {fl>=?} @vari{fl} @varii{fl} @variii{fl} @dots{}
These procedures return @true{} if their arguments are (respectively):
equal, monotonically increasing, monotonically decreasing, monotonically
nondecreasing, or monotonically nonincreasing, @false{} otherwise.
These predicates must be transitive.

@example
(fl=? +inf.0 +inf.0)           => #t
(fl=? -inf.0 +inf.0)           => #f
(fl=? -inf.0 -inf.0)           => #t
(fl=? 0.0 -0.0)                => #t
(fl<? 0.0 -0.0)                => #f
(fl=? +nan.0 @var{fl})         => #f
(fl<? +nan.0 @var{fl})         => #f
@end example
@end deffn


@deffn Procedure {flinteger?} @var{fl}
@deffnx Procedure {flzero?} @var{fl}
@deffnx Procedure {flpositive?} @var{fl}
@deffnx Procedure {flnegative?} @var{fl}
@deffnx Procedure {flodd?} @var{ifl}
@deffnx Procedure {fleven?} @var{ifl}
@deffnx Procedure {flfinite?} @var{fl}
@deffnx Procedure {flinfinite?} @var{fl}
@deffnx Procedure {flnan?} @var{fl}
These numerical predicates test a flonum for a particular property,
returning @true{} or @false{}:

@table @func
@item flinteger?
procedure tests whether the number object is an integer,

@item flzero?
tests whether it is @func{fl=?} to zero,

@item flpositive?
tests whether it is greater than zero,

@item flnegative?
tests whether it is less than zero,

@item flodd?
tests whether it is odd,

@item fleven?
tests whether it is even,

@item flfinite?
tests whether it is not an infinity and not a NaN,

@item flinfinite?
tests whether it is an infinity,

@item flnan?
tests whether it is a NaN.
@end table

@example
(flnegative? -0.0)              => #f
(flfinite?   +inf.0)            => #f
(flfinite?   5.0)               => #t
(flinfinite? 5.0)               => #f
(flinfinite? +inf.0)            => #t
@end example

@quotation
@emph{Note:} @code{(flnegative? -0.0)} must return @false{}, else it
would lose the correspondence with @code{(fl< -0.0 0.0)}, which is
@false{} according to @ieee{} 754.
@end quotation
@end deffn


@deffn Procedure {flmax} @vari{fl} @varii{fl} @dots{}
@deffnx Procedure {flmin} @vari{fl} @varii{fl} @dots{}
These procedures return the maximum or minimum of their arguments.  They
always return a NaN when one or more of the arguments is a NaN.
@end deffn


@deffn Procedure {fl+} @vari{fl} @dots{}
@deffnx Procedure {fl*} @vari{fl} @dots{}
These procedures return the flonum sum or product of their flonum
arguments.  In general, they should return the flonum that best
approximates the mathematical sum or product.  (For implementations that
represent flonums using @ieee{} binary floating point, the meaning of
``best'' is defined by the @ieee{} standards.)

@example
(fl+ +inf.0 -inf.0)             =>  +nan.0
(fl+ +nan.0 @var{fl})           =>  +nan.0
(fl* +nan.0 @var{fl})           =>  +nan.0
@end example
@end deffn


@deffn Procedure {fl-} @vari{fl} @varii{fl} @dots{}
@deffnx Procedure {fl-} @var{fl}
@deffnx Procedure {fl/} @vari{fl} @varii{fl} @dots{}
@deffnx Procedure {fl/} @var{fl}
With two or more arguments, these procedures return the flonum
difference or quotient of their flonum arguments, associating to the
left.

With one argument, however, they return the additive or multiplicative
flonum inverse of their argument.

In general, they should return the flonum that best approximates the
mathematical difference or quotient.  (For implementations that
represent flonums using @ieee{} binary floating point, the meaning of
``best'' is reasonably well--defined by the @ieee{} standards.)

@example
(fl- +inf.0 +inf.0)      =>  +nan.0
@end example

For undefined quotients, @func{fl/} behaves as specified by the @ieee{}
standards:

@example
(fl/ 1.0 0.0)                   => +inf.0
(fl/ -1.0 0.0)                  => -inf.0
(fl/ 0.0 0.0)                   => +nan.0
@end example
@end deffn


@deffn Procedure {flabs} @var{fl}
Return the absolute value of @var{fl}.
@end deffn


@deffn Procedure {fldiv-and-mod} @vari{fl} @varii{fl}
@deffnx Procedure {fldiv} @vari{fl} @varii{fl}
@deffnx Procedure {flmod} @vari{fl} @varii{fl}
@deffnx Procedure {fldiv0-and-mod0} @vari{fl} @varii{fl}
@deffnx Procedure {fldiv0} @vari{fl} @varii{fl}
@deffnx Procedure {flmod0} @vari{fl} @varii{fl}
These procedures implement number--theoretic integer division and return
the results of the corresponding mathematical operations specified in
report section @ref{baselib math semantics integer}.

In the cases where the mathematical requirements in @ref{baselib math
semantics} cannot be satisfied by any number object, either an exception
is raised with condition type @code{&implementation-restriction}, or
unspecified flonums (one for @func{fldiv}, @func{flmod}, @func{fldiv0}
and @func{flmod0}, two for @func{fldiv-and-mod} and
@func{fldiv0-and-mod0}) are returned.

@example
(fldiv @vari{fl} @varii{fl})         => @vari{fl} div @varii{fl}
(flmod @vari{fl} @varii{fl})         => @vari{fl} mod @varii{fl}
(fldiv-and-mod @vari{fl} @varii{fl}) => @vari{fl} div @varii{fl}, @vari{fl} mod @varii{fl}
                                        ; two return values
(fldiv0 @vari{fl} @varii{fl})        => @vari{fl} div_0 @varii{fl}
(flmod0 @vari{fl} @varii{fl})        => @vari{fl} mod_0 @varii{fl}
(fldiv0-and-mod0 @vari{fl} @varii{fl})
=> @vari{fl} div_0 @varii{fl}, @vari{fl} mod_0 @varii{fl}
   ; two return values
@end example
@end deffn


@deffn Procedure {flnumerator} @var{fl}
@deffnx Procedure {fldenominator} @var{fl}
These procedures return the numerator or denominator of @var{fl} as a
flonum; the result is computed as if @var{fl} was represented as a
fraction in lowest terms.  The denominator is always positive.  The
denominator of 0.0 is defined to be 1.0.

@example
(flnumerator +inf.0)           =>  +inf.0
(flnumerator -inf.0)           =>  -inf.0
(fldenominator +inf.0)         =>  1.0
(fldenominator -inf.0)         =>  1.0
(flnumerator 0.75)             =>  3.0 ; probably
(fldenominator 0.75)           =>  4.0 ; probably
@end example

Implementations should implement following behavior:

@example
(flnumerator -0.0)             => -0.0
@end example
@end deffn


@deffn Procedure {flfloor} @var{fl}
@deffnx Procedure {flceiling} @var{fl}
@deffnx Procedure {fltruncate} @var{fl}
@deffnx Procedure {flround} @var{fl}
These procedures return integral flonums for flonum arguments that are
not infinities or NaNs.

@table @func
@item flfloor
Returns the largest integral flonum not larger than @var{fl}.

@item flceiling
Returns the smallest integral flonum not smaller than @var{fl}.

@item fltruncate
Returns the integral flonum closest to @var{fl} whose absolute value is
not larger than the absolute value of @var{fl}.

@item flround
Returns the closest integral flonum to @var{fl}, rounding to even when
@var{fl} represents a number halfway between two integers.
@end table

Although infinities and NaNs are not integer objects, these procedures
return an infinity when given an infinity as an argument, and a NaN when
given a NaN:

@example
(flfloor +inf.0)                       =>  +inf.0
(flceiling -inf.0)                     =>  -inf.0
(fltruncate +nan.0)                    =>  +nan.0
@end example
@end deffn


@deffn Procedure {flexp} @var{fl}
@deffnx Procedure {fllog} @var{fl}
@deffnx Procedure {fllog} @vari{fl} @varii{fl}
@deffnx Procedure {flsin} @var{fl}
@deffnx Procedure {flcos} @var{fl}
@deffnx Procedure {fltan} @var{fl}
@deffnx Procedure {flasin} @var{fl}
@deffnx Procedure {flacos} @var{fl}
@deffnx Procedure {flatan} @var{fl}
@deffnx Procedure {flatan} @vari{fl} @varii{fl}
These procedures compute the usual transcendental functions.

@table @func
@item flexp
Computes the base-E exponential of @var{fl}.

@item fllog
With a single argument computes the natural logarithm of @var{fl} (not
the base ten logarithm); @code{(fllog @vari{fl} @varii{fl})} computes
the base--@varii{fl} logarithm of @vari{fl}.

@item flasin
@itemx flacos
@item flatan
Compute arcsine, arccosine, and arctangent, respectively.  @code{(flatan
@vari{fl} @varii{fl})} computes the arc tangent of @vari{fl}/@varii{fl}.
@end table

@ref{baselib math ops trascend} for the underlying mathematical
operations.  In the event that these operations do not yield a real
result for the given arguments, the result may be a NaN, or may be some
unspecified flonum.

Implementations that use @ieee{} binary floating--point arithmetic
should follow the relevant standards for these procedures.

@example
(flexp +inf.0)                => +inf.0
(flexp -inf.0)                => 0.0
(fllog +inf.0)                => +inf.0
(fllog 0.0)                   => -inf.0
(fllog -0.0)                  => unspecified ; if -0.0 is distinguished
(fllog -inf.0)                => +nan.0
(flatan -inf.0)               => -1.5707963267948965  ; approximately
(flatan +inf.0)               => 1.5707963267948965   ; approximately
@end example
@end deffn


@deffn Procedure {flsqrt} @var{fl}
Returns the principal square root of @var{fl}. For -0.0, @func{flsqrt}
should return -0.0; for other negative arguments, the result may be a
NaN or some unspecified flonum.

@example
(flsqrt +inf.0)               => +inf.0
(flsqrt -0.0)                 => -0.0
@end example
@end deffn


@deffn Procedure {flexpt} @vari{fl} @varii{fl}
Either @vari{fl} should be non--negative, or, if @vari{fl} is negative,
@varii{fl} should be an integer object.

The @func{flexpt} procedure returns @vari{fl} raised to the power
@varii{fl}.  If @vari{fl} is negative and @varii{fl} is not an integer
object, the result may be a NaN, or may be some unspecified flonum.

If @vari{fl} and @varii{fl} are both zero, the result is @code{1.0}.  If
@vari{fl} is zero and @varii{fl} is positive, the result is zero.  If
@vari{fl} is negative, the result may be a NaN, or may be some
unspecified flonum.
@end deffn


@tindex &no-infinities
@deffn {Condition Type} {&no-infinities}
@deffnx Procedure {make-no-infinities-violation}
@deffnx Procedure {no-infinities-violation?} @var{obj}
@deffnx {Condition Type} {&no-nans}
@deffnx Procedure {make-no-nans-violation}
@deffnx Procedure {no-nans-violation?} @var{obj}
These condition types could be defined by the following code:

@example
(define-condition-type &no-infinities
    &implementation-restriction
  make-no-infinities-violation
  no-infinities-violation?)

(define-condition-type &no-nans
    &implementation-restriction
  make-no-nans-violation no-nans-violation?)
@end example

These types describe that a program has executed an arithmetic
operations that is specified to return an infinity or a NaN,
respectively, on a Scheme implementation that is not able to represent
the infinity or NaN.  @ref{baselib math infinities}.
@end deffn


@deffn Procedure {fixnum->flonum} @var{fx}
Return a flonum that is numerically closest to @var{fx}.

@quotation
@emph{Note:} The result of this procedure may not be numerically equal
to @var{fx}, because the fixnum precision may be greater than the flonum
precision.
@end quotation
@end deffn



@c page
@node stdlib arithmetics exact bitwise
@section Exact bitwise arithmetic


This section describes the @rsixlibrary{arithmetic bitwise} library.
The exact bitwise arithmetic provides generic operations on exact
integer objects.  This section uses @var{ei}, @vari{ei}, @varii{ei},
etc., as parameter names that must be exact integer objects.


@deffn Procedure bitwise-not @var{ei}
Returns the exact integer object whose two's complement representation
is the one's complement of the two's complement representation of
@var{ei}.
@end deffn


@deffn Procedure bitwise-and @vari{ei} @dots{}
@deffnx Procedure bitwise-ior @vari{ei} @dots{}
@deffnx Procedure bitwise-xor @vari{ei} @dots{}
These procedures return the exact integer object that is the bit--wise
``and'', ``inclusive or'', or ``exclusive or'' of the two's complement
representations of their arguments.  If they are passed only one
argument, they return that argument.  If they are passed no arguments,
they return the integer object (either -1 or 0) that acts as identity
for the operation.
@end deffn


@deffn Procedure bitwise-if @vari{ei} @varii{ei} @variii{ei}
Return the exact integer object that is the bit-wise ``if'' of the two's
complement representations of its arguments, i.e. for each bit, if it is
1 in @vari{ei}, the corresponding bit in @varii{ei} becomes the value of
the corresponding bit in the result, and if it is 0, the corresponding
bit in @variii{ei} becomes the corresponding bit in the value of the
result.  This is the result of the following computation:

@example
(bitwise-ior (bitwise-and @vari{ei} @varii{ei})
             (bitwise-and (bitwise-not @vari{ei}) @variii{ei}))
@end example
@end deffn


@deffn Procedure bitwise-bit-count @var{ei}
If @var{ei} is non--negative, this procedure returns the number of 1
bits in the two's complement representation of @var{ei}.  Otherwise it
returns the result of the following computation:

@example
(bitwise-not (bitwise-bit-count (bitwise-not @var{ei})))
@end example
@end deffn


@deffn Procedure bitwise-length @var{ei}
Return the number of bits needed to represent @var{ei} if it is
positive, and the number of bits needed to represent @code{(bitwise-not
@var{ei})} if it is negative, which is the exact integer object that is
the result of the following computation:

@example
(do ((result 0 (+ result 1))
     (bits (if (negative? @var{ei})
               (bitwise-not @var{ei})
               @var{ei})
           (bitwise-arithmetic-shift bits -1)))
    ((zero? bits)
     result))
@end example
@end deffn


@deffn Procedure bitwise-first-bit-set @var{ei}
Returns the index of the least significant 1 bit in the two's complement
representation of @var{ei}.  If @var{ei} is 0, then -1 is returned.

@example
(bitwise-first-bit-set 0)        =>  -1
(bitwise-first-bit-set 1)        =>  0
(bitwise-first-bit-set -4)       =>  2
@end example
@end deffn


@deffn Procedure bitwise-bit-set? @vari{ei} @varii{ei}
@varii{ei} must be non--negative.

The @func{bitwise-bit-set?} procedure returns @true{} if the
@varii{ei}th bit is 1 in the two's complement representation of
@vari{ei}, and @false{} otherwise.  This is the result of the following
computation:

@example
(not (zero?
       (bitwise-and
         (bitwise-arithmetic-shift-left 1 @varii{ei})
         @vari{ei})))
@end example
@end deffn


@deffn Procedure bitwise-copy-bit @vari{ei} @varii{ei} @variii{ei}
@varii{ei} must be non--negative, and @variii{ei} must be either 0 or 1.

The @func{bitwise-copy-bit} procedure returns the result of replacing
the @varii{ei}th bit of @vari{ei} by @variii{ei}, which is the result of
the following computation:

@example
(let* ((mask (bitwise-arithmetic-shift-left 1 @varii{ei})))
  (bitwise-if mask
            (bitwise-arithmetic-shift-left @variii{ei} @varii{ei})
            @vari{ei}))
@end example
@end deffn


@deffn Procedure bitwise-bit-field @vari{ei} @varii{ei} @variii{ei}
@varii{ei} and @variii{ei} must be non--negative, and @varii{ei} must be
less than or equal to @variii{ei}.

The @func{bitwise-bit-field} procedure returns the number represented by
the bits at the positions from @varii{ei} (inclusive) to @variii{ei}
(exclusive), which is the result of the following computation:

@example
(let ((mask
       (bitwise-not
        (bitwise-arithmetic-shift-left -1 @variii{ei}))))
  (bitwise-arithmetic-shift-right
    (bitwise-and @vari{ei} mask)
    @varii{ei}))
@end example
@end deffn


@deffn Procedure bitwise-copy-bit-field @vari{ei} @varii{ei} @variii{ei} @variv{ei}
@varii{ei} and @variii{ei} must be non--negative, and @varii{ei} must be
less than or equal to @variii{ei}.

The @func{bitwise-copy-bit-field} procedure returns the result of
replacing in @vari{ei} the bits at positions from @varii{ei} (inclusive)
to @variii{ei} (exclusive) by the bits in @variv{ei} from position 0
(inclusive) to position @variii{ei}-@varii{ei} (exclusive) which is the
result of the following computation:

@example
(let* ((to    @vari{ei})
       (start @varii{ei})
       (end   @variii{ei})
       (from  @variv{ei})
       (mask1
         (bitwise-arithmetic-shift-left -1 start))
       (mask2
         (bitwise-not
           (bitwise-arithmetic-shift-left -1 end)))
       (mask (bitwise-and mask1 mask2)))
  (bitwise-if mask
              (bitwise-arithmetic-shift-left from
                                             start)
              to))
@end example
@end deffn


@deffn Procedure bitwise-arithmetic-shift @vari{ei} @varii{ei}
Return the result of the following computation:

@example
(floor (* @vari{ei} (expt 2 @varii{ei})))
@end example

Examples:

@example
(bitwise-arithmetic-shift -6 -1)    => -3
(bitwise-arithmetic-shift -5 -1)    => -3
(bitwise-arithmetic-shift -4 -1)    => -2
(bitwise-arithmetic-shift -3 -1)    => -2
(bitwise-arithmetic-shift -2 -1)    => -1
(bitwise-arithmetic-shift -1 -1)    => -1
@end example
@end deffn


@deffn Procedure bitwise-arithmetic-shift-left @vari{ei} @varii{ei}
@deffnx Procedure bitwise-arithmetic-shift-right @vari{ei} @varii{ei}
@varii{ei} must be non--negative.

The @func{bitwise-arithmetic-shift-left} procedure returns the same
result as @func{bitwise-arithmetic-shift}, and:

@example
(bitwise-arithmetic-shift-right @vari{ei} @varii{ei})
@end example

@noindent
returns the same result as:

@example
(bitwise-arithmetic-shift @vari{ei} (- @varii{ei}))
@end example
@end deffn


@deffn Procedure bitwise-rotate-bit-field @vari{ei} @varii{ei} @variii{ei} @variv{ei}
@varii{ei}, @variii{ei}, @variv{ei} must be non--negative, @varii{ei}
must be less than or equal to @variii{ei}, and @variv{ei} must be
non-negative.

The procedure returns the result of cyclically permuting in @vari{ei}
the bits at positions from @varii{ei} (inclusive) to @variii{ei}
(exclusive) by @variv{ei} bits towards the more significant bits, which
is the result of the following computation:

@example
(let* ((n     @vari{ei})
       (start @varii{ei})
       (end   @variii{ei})
       (count @variv{ei})
       (width (- end start)))
  (if (positive? width)
      (let* ((count (mod count width))
             (field0
               (bitwise-bit-field n start end))
             (field1 (bitwise-arithmetic-shift-left
                       field0 count))
             (field2 (bitwise-arithmetic-shift-right
                       field0
                       (- width count)))
             (field (bitwise-ior field1 field2)))
        (bitwise-copy-bit-field n start end field))
      n))
@end example
@end deffn


@deffn Procedure bitwise-reverse-bit-field @vari{ei} @varii{ei} @variii{ei}
@varii{ei} and @variii{ei} must be non--negative, and @varii{ei} must be
less than or equal to @variii{ei}.

The @func{bitwise-reverse-bit-field} procedure returns the result
obtained from @vari{ei} by reversing the order of the bits at positions
from @varii{ei} (inclusive) to @variii{ei} (exclusive).

@example
(bitwise-reverse-bit-field #b1010010 1 4)      =>  88 ; #b1011000
@end example
@end deffn



@c page
@node stdlib syntax-case
@chapter Syntax--case


The @rsixlibrary{syntax-case} library provides support for writing
low--level macros in a high--level style, with automatic syntax
checking, input destructuring, output restructuring, maintenance of
lexical scoping and referential transparency (hygiene), and support for
controlled identifier capture.


@menu
* stdlib syntax-case hygiene::          Hygiene.
* stdlib syntax-case objects::          Syntax objects.
* stdlib syntax-case transformers::     Transformers.
* stdlib syntax-case parsing::          Parsing input and producing
                                        output.
* stdlib syntax-case identifier::       Identifier predicates.
* stdlib syntax-case conversion::       Syntax-object and datum
                                        conversions.
* stdlib syntax-case temporaries::      Generating lists of temporaries.
* stdlib syntax-case derived::          Derived forms and procedures.
* stdlib syntax-case violations::       Syntax violations.

Examples

* stdlib syntax-case define-macro::     Common Lisp style macros.
@end menu



@c page
@node stdlib syntax-case hygiene
@section Hygiene


Barendregt's @emph{hygiene condition} for the lambda calculus is an
informal notion that requires the free variables of an expression
@emph{N} that is to be substituted into another expression @emph{M} not
to be captured by bindings in @emph{M} when such capture is not
intended.

Kohlbecker, et al. propose a corresponding @emph{hygiene condition for
macro expansion} that applies in all situations where capturing is not
explicit: ``Generated identifiers that become binding instances in the
completely expanded program must only bind variables that are generated
at the same transcription step''.  In the terminology of this document,
the ``generated identifiers'' are those introduced by a transformer
rather than those present in the form passed to the transformer, and a
``macro transcription step'' corresponds to a single call by the
expander to a transformer.  Also, the hygiene condition applies to all
introduced bindings rather than to introduced variable bindings alone.

This leaves open what happens to an introduced identifier that appears
outside the scope of a binding introduced by the same call.  Such an
identifier refers to the lexical binding in effect where it appears
(within a @code{syntax} @hyper{template}) inside the transformer body or
one of the helpers it calls.  This is essentially the referential
transparency property described by Clinger and Rees.  Thus, the hygiene
condition can be restated as follows:

@quotation
A binding for an identifier introduced into the output of a transformer
call from the expander must capture only references to the identifier
introduced into the output of the same transformer call.

A reference to an identifier introduced into the output of a transformer
refers to the closest enclosing binding for the introduced identifier
or, if it appears outside of any enclosing binding for the introduced
identifier, the closest enclosing lexical binding where the identifier
appears (within a @code{syntax} @hyper{template}) inside the transformer
body or one of the helpers it calls.
@end quotation

Explicit captures are handled via @func{datum->syntax}.

Operationally, the expander can maintain hygiene with the help of
@emph{marks}.  Marks are applied selectively by the expander to the
output of each transformer it invokes, and substitutions are applied to
the portions of each binding form that are supposed to be within the
scope of the bound identifiers.  Marks are used to distinguish
like--named identifiers that are introduced at different times (either
present in the source or introduced into the output of a particular
transformer call), and substitutions are used to map identifiers to
their expand-time values.

Each time the expander encounters a macro use, it applies an
@emph{antimark} to the input form, invokes the associated transformer,
then applies a fresh mark to the output.  Marks and antimarks cancel, so
the portions of the input that appear in the output are effectively left
unmarked, while the portions of the output that are introduced are
marked with the fresh mark.

Each time the expander encounters a binding form it creates a set of
substitutions, each mapping one of the (possibly marked) bound
identifiers to information about the binding.  (For a @func{lambda}
expression, the expander might map each bound identifier to a
representation of the formal parameter in the output of the expander.
For a @func{let-syntax} form, the expander might map each bound
identifier to the associated transformer.)  These substitutions are
applied to the portions of the input form in which the binding is
supposed to be visible.

Marks and substitutions together form a @emph{wrap} that is layered on
the form being processed by the expander and pushed down toward the
leaves as necessary.  A wrapped form is referred to as a @emph{wrapped
syntax object}.  Ultimately, the wrap may rest on a leaf that represents
an identifier, in which case the wrapped syntax object is also referred
to as an @emph{identifier}.  An identifier contains a name along with
the wrap.  (Names are typically represented by symbols.)

When a substitution is created to map an identifier to an expand--time
value, the substitution records the name of the identifier and the set
of marks that have been applied to that identifier, along with the
associated expand--time value.  The expander resolves identifier
references by looking for the latest matching substitution to be applied
to the identifier, i.e., the outermost substitution in the wrap whose
name and marks match the name and marks recorded in the substitution.
The name matches if it is the same name (if using symbols, then by
@func{eq?}), and the marks match if the marks recorded with the
substitution are the same as those that appear @emph{below} the
substitution in the wrap, i.e., those that were applied @emph{before}
the substitution.  Marks applied after a substitution, i.e., appear over
the substitution in the wrap, are not relevant and are ignored.

An algebra that defines how marks and substitutions work more precisely
is given in section 2.4 of Oscar Waddell's PhD thesis.



@c page
@node stdlib syntax-case objects
@section Syntax objects


A @emph{syntax object} is a representation of a Scheme form that
contains contextual information about the form in addition to its
structure.  This contextual information is used by the expander to
maintain lexical scoping and may also be used by an implementation to
maintain source--object correlation.

A syntax object may be wrapped.  It may also be unwrapped, fully or
partially, i.e., consist of list and vector structure with wrapped
syntax objects or nonsymbol values at the leaves.  More formally, a
syntax object is:

@itemize
@item
a pair of syntax objects,

@item
a vector of syntax objects,

@item
a nonpair, nonvector, nonsymbol value, or

@item
a wrapped syntax object.
@end itemize

The distinction between the terms ``syntax object'' and ``wrapped syntax
object'' is important.  For example, when invoked by the expander, a
transformer must accept a wrapped syntax object but may return any
syntax object, including an unwrapped syntax object.

Syntax objects representing identifiers are always wrapped and are
distinct from other types of values.  Wrapped syntax objects that are
not identifiers may or may not be distinct from other types of values.



@c page
@node stdlib syntax-case transformers
@section Transformers


In @func{define-syntax}, @func{let-syntax}, and @func{letrec-syntax}
forms, a binding for a syntactic keyword is an expression that evaluates
to a @emph{transformer}.

A transformer is a @emph{transformation procedure} or a @emph{variable
transformer}.  A transformation procedure is a procedure that must
accept one argument, a wrapped syntax object representing the input, and
return a syntax object representing the output.  The transformer is
called by the expander whenever a reference to a keyword with which it
has been associated is found.  If the keyword appears in the car of a
list--structured input form, the transformer receives the entire
list--structured form, and its output replaces the entire form.  Except
with variable transformers (see below), if the keyword is found in any
other definition or expression context, the transformer receives a
wrapped syntax object representing just the keyword reference, and its
output replaces just the reference.  Except with variable transformers,
an exception with condition type @code{&syntax} is raised if the keyword
appears on the left--hand side of a @func{set!} expression.


@deffn Procedure make-variable-transformer @var{proc}
@var{proc} should accept one argument, a wrapped syntax object, and
return a syntax object.

The @func{make-variable-transformer} procedure creates a @emph{variable
transformer}.  A variable transformer is like an ordinary transformer
except that, if a keyword associated with a variable transformer appears
on the left--hand side of a @func{set!} expression, an exception is not
raised.  Instead, @var{proc} is called with a wrapped syntax object
representing the entire @func{set!} expression as its argument, and its
return value replaces the entire @func{set!}  expression.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{proc} only to the extent performed by applying
it as described.  An implementation may check whether @var{proc} is an
appropriate argument before applying it.
@end deffn



@c page
@node stdlib syntax-case parsing
@section Parsing input and producing output


Transformers can destructure their input with @func{syntax-case} and
rebuild their output with @code{syntax}.


@deffn Syntax syntax-case @hyper{expression} (@hyper{literal} @dots{}) @hyper{syntax-case clause} @dots{}
@deffnx {Auxiliary Syntax} _
@deffnx {Auxiliary Syntax} {...}
Each @hyper{literal} must be an identifier.  Each @hyper{syntax-case
clause} must take one of the following two forms.

@example
(@hyper{pattern} @hyper{output expression})
(@hyper{pattern} @hyper{fender} @hyper{output expression})
@end example

@hyper{fender} and @hyper{output expression} must be
@hyper{expression}s.

A @hyper{pattern} is an identifier, constant, or one of the following.

@example
(@hyper{pattern} @dots{})
(@hyper{pattern} @hyper{pattern} @dots{} . @hyper{pattern})
(@hyper{pattern} @dots{} @hyper{pattern} @hyper{ellipsis} @hyper{pattern} @dots{})
(@hyper{pattern} @dots{} @hyper{pattern} @hyper{ellipsis} @hyper{pattern} @dots{} . @hyper{pattern})
#(@hyper{pattern} @dots{})
#(@hyper{pattern} @dots{} @hyper{pattern} @hyper{ellipsis} @hyper{pattern} @dots{})
@end example

An @hyper{ellipsis} is the identifier ``@code{...}'' (three periods).

An identifier appearing within a @hyper{pattern} may be an underscore
@code{_}, a literal identifier listed in the list of literals
@code{(@hyper{literal} @dots{})}, or an ellipsis @code{...}.  All other
identifiers appearing within a @hyper{pattern} are @emph{pattern
variables}.  It is a syntax violation if an ellipsis or underscore
appears in @code{(@hyper{literal} @dots{})}.

@code{_} and @code{...} are the same as in the @rsixlibrary{base}
library.

Pattern variables match arbitrary input subforms and are used to refer
to elements of the input.  It is a syntax violation if the same pattern
variable appears more than once in a @hyper{pattern}.

Underscores also match arbitrary input subforms but are not pattern
variables and so cannot be used to refer to those elements.  Multiple
underscores may appear in a @hyper{pattern}.

A literal identifier matches an input subform if and only if the input
subform is an identifier and either both its occurrence in the input
expression and its occurrence in the list of literals have the same
lexical binding, or the two identifiers have the same name and both have
no lexical binding.

A subpattern followed by an ellipsis can match zero or more elements of
the input.

More formally, an input form @emph{F} matches a pattern @emph{P} if and
only if one of the following holds:

@itemize
@item
@emph{P} is an underscore (@code{_}).

@item
@emph{P} is a pattern variable.

@item
@emph{P} is a literal identifier and @emph{F} is an equivalent
identifier in the sense of @func{free-identifier=?}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_n)
@end example

@noindent
and @emph{F} is a list of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_n . P_x)
@end example

@noindent
and @emph{F} is a list or improper list of @emph{n} or more elements
whose first @emph{n} elements match @emph{P_1} through @emph{P_n} and
whose @emph{n}th cdr matches @emph{P_x}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_k P_e @hyper{ellipsis} P_(m+1) ... P_n)
@end example

@noindent
where @hyper{ellipsis} is the identifier @code{...}  and @emph{F} is a
proper list of @emph{n} elements whose first @emph{k} elements match
@emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
(P_1 ... P_k P_e @hyper{ellipsis} P_(m+1) ... P_n . P_x)
@end example

@noindent
where @hyper{ellipsis} is the identifier @code{...}  and @emph{F} is a
list or improper list of @emph{n} elements whose first @emph{k} elements
match @emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each
match @emph{P_e}, whose next @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}, and whose @emph{n}th and final cdr matches
@emph{P_x}.

@item
@emph{P} is of the form:

@example
#(P_1 ... P_n)
@end example

@noindent
and @emph{F} is a vector of @emph{n} elements that match @emph{P_1}
through @emph{P_n}.

@item
@emph{P} is of the form:

@example
#(P_1 ... P_k P_e @hyper{ellipsis} P_(m+1) ... P_n)
@end example

@noindent
where @hyper{ellipsis} is the identifier @code{...}  and @emph{F} is a
vector of @emph{n} or more elements whose first @emph{k} elements match
@emph{P_1} through @emph{P_k}, whose next @emph{m-k} elements each match
@emph{P_e}, and whose remaining @emph{n-m} elements match @emph{P_(m+1)}
through @emph{P_n}.

@item
@emph{P} is a pattern datum (any nonlist, nonvector, nonsymbol datum)
and @emph{F} is equal to @emph{P} in the sense of the @func{equal?}
procedure.
@end itemize

A @func{syntax-case} expression first evaluates @hyper{expression}.  It
then attempts to match the @hyper{pattern} from the first
@hyper{syntax-case clause} against the resulting value, which is
unwrapped as necessary to perform the match.  If the pattern matches the
value and no @hyper{fender} is present, @hyper{output expression} is
evaluated and its value returned as the value of the @func{syntax-case}
expression.  If the pattern does not match the value, @func{syntax-case}
tries the second @hyper{syntax-case clause}, then the third, and so on.
It is a syntax violation if the value does not match any of the
patterns.

If the optional @hyper{fender} is present, it serves as an additional
constraint on acceptance of a clause.  If the @hyper{pattern} of a given
@hyper{syntax-case clause} matches the input value, the corresponding
@hyper{fender} is evaluated.  If @hyper{fender} evaluates to a true
value, the clause is accepted; otherwise, the clause is rejected as if
the pattern had failed to match the value.  Fenders are logically a part
of the matching process, i.e., they specify additional matching
constraints beyond the basic structure of the input.

Pattern variables contained within a clause's @hyper{pattern} are bound
to the corresponding pieces of the input value within the clause's
@hyper{fender} (if present) and @hyper{output expression}.  Pattern
variables can be referenced only within @code{syntax} expressions (see
below).  Pattern variables occupy the same name space as program
variables and keywords.

If the @func{syntax-case} form is in tail context, the @hyper{output
expression}s are also in tail position.
@end deffn


@deffn Syntax syntax @hyper{template}
A @func{syntax} expression is similar to a @func{quote} expression
except that:

@enumerate
@item
the values of pattern variables appearing within @hyper{template} are
inserted into @hyper{template},

@item
contextual information associated both with the input and with the
template is retained in the output to support lexical scoping, and

@item
the value of a @func{syntax} expression is a syntax object.
@end enumerate

@quotation
@emph{Note:} The following sharp--quote expression:

@example
#'@hyper{template}
@end example

@noindent
is equivalent to:

@example
(syntax @hyper{template})
@end example

@noindent
@ref{lang lex datum abbreviations} for the other abbreviations.
@end quotation

A @hyper{template} can be one among: a pattern variable, an identifier
that is not a pattern variable, a pattern datum, or one of the
following.

@example
(@hyper{subtemplate} @dots{})
(@hyper{subtemplate} @dots{} . @hyper{template})
#(@hyper{subtemplate} @dots{})
@end example

A @hyper{subtemplate} is a @hyper{template} followed by zero or more
ellipses.

The value of a @code{syntax} form is a copy of @hyper{template} in which
the pattern variables appearing within the template are replaced with
the input subforms to which they are bound:

@itemize
@item
pattern data and identifiers that are not pattern variables or ellipses
are copied directly into the output;

@item
a subtemplate followed by an ellipsis expands into zero or more
occurrences of the subtemplate;

@item
pattern variables that occur in subpatterns followed by one or more
ellipses may occur only in subtemplates that are followed by (at least)
as many ellipses:

@itemize -
@item
these pattern variables are replaced in the output by the input subforms
to which they are bound, distributed as specified;

@item
if a pattern variable is followed by more ellipses in the subtemplate
than in the associated subpattern, the input form is replicated as
necessary;

@item
the subtemplate must contain at least one pattern variable from a
subpattern followed by an ellipsis, and for at least one such pattern
variable, the subtemplate must be followed by exactly as many ellipses
as the subpattern in which the pattern variable appears (otherwise, the
expander would not be able to determine how many times the subform
should be repeated in the output);
@end itemize
@end itemize

@noindent
it is a syntax violation if the above constraints are not met.

A template of the form @code{(@hyper{ellipsis} @hyper{template})} is
identical to @hyper{template}, except that ellipses within the template
have no special meaning.  That is, any ellipses contained within
@hyper{template} are treated as ordinary identifiers.  In particular,
the template @code{(... ...)} produces a single ellipsis.  This allows
macro uses to expand into forms containing ellipses.

The output produced by @func{syntax} is wrapped or unwrapped according
to the following rules.

@itemize
@item
the copy of @code{(@hyperi{t} .  @hyperii{t})} is a pair if @hyperi{t}
or @hyperii{t} contain any pattern variables,

@item
the copy of @code{(@hyper{t} @hyper{ellipsis})} is a list if @hyper{t}
contains any pattern variables,

@item
the copy of @code{#(@hyperi{t} ... @hypern{t})} is a vector if any of
@hyperi{t}, @dots{}, @hypern{t} contain any pattern variables,

@item
the copy of any portion of @hyper{t} not containing any pattern
variables is a wrapped syntax object.
@end itemize

The input subforms inserted in place of the pattern variables are
wrapped if and only if the corresponding input subforms are wrapped.
@end deffn


The following definitions of @func{or} illustrate @func{syntax-case} and
@func{syntax}.  The second is equivalent to the first but uses the
@code{#'} prefix instead of the full @func{syntax} form.

@example
(define-syntax or
  (lambda (x)
    (syntax-case x ()
      [(_) (syntax #f)]
      [(_ e) (syntax e)]
      [(_ e1 e2 e3 ...)
       (syntax (let ([t e1])
                 (if t t (or e2 e3 ...))))])))

(define-syntax or
  (lambda (x)
    (syntax-case x ()
      [(_) #'#f]
      [(_ e) #'e]
      [(_ e1 e2 e3 ...)
       #'(let ([t e1])
           (if t t (or e2 e3 ...)))])))
@end example

The examples below define @emph{identifier macros}, macro uses
supporting keyword references that do not necessarily appear in the
first position of a list--structured form.  The second example uses
@func{make-variable-transformer} to handle the case where the keyword
appears on the left-hand side of a @func{set!}  expression.

@example
(define p (cons 4 5))
(define-syntax p.car
  (lambda (x)
    (syntax-case x ()
      [(_ . rest) #'((car p) . rest)]
      [_  #'(car p)])))

p.car                                   => 4
(set! p.car 15)                         => exception &syntax

(define p (cons 4 5))
(define-syntax p.car
  (make-variable-transformer
    (lambda (x)
      (syntax-case x (set!)
        [(set! _ e) #'(set-car! p e)]
        [(_ . rest) #'((car p) . rest)]
        [_  #'(car p)]))))
(set! p.car 15)

p.car                                   => 15
p                                       => (15 . 5)
@end example



@c page
@node stdlib syntax-case identifier
@section Identifier predicates


@deffn Procedure {identifier?} @var{obj}
Return @true{} if @var{obj} is an identifier, i.e., a syntax object
representing an identifier, and @false{} otherwise.

The @func{identifier?} procedure is often used within a fender to verify
that certain subforms of an input form are identifiers, as in the
definition of @code{rec}, which creates self--contained recursive
objects, below.

@example
(define-syntax rec
  (lambda (x)
    (syntax-case x ()
      [(_ x e)
       (identifier? #'x)
       #'(letrec ([x e]) x)])))

(map (rec fact
       (lambda (n)
         (if (= n 0)
             1
             (* n (fact (- n 1))))))
     '(1 2 3 4 5))    => (1 2 6 24 120)

(rec 5 (lambda (x) x)) => exception &syntax
@end example
@end deffn


The procedures @func{bound-identifier=?} and @func{free-identifier=?}
each take two identifier arguments and return @true{} if their arguments
are equivalent and @false{} otherwise.  These predicates are used to
compare identifiers according to their @emph{intended use} as free
references or bound identifiers in a given context.


@deffn Procedure {bound-identifier=?} @vari{id} @varii{id}
@vari{id} and @varii{id} must be identifiers.

The procedure @func{bound-identifier=?} returns @true{} if a binding for
one would capture a reference to the other in the output of the
transformer, assuming that the reference appears within the scope of the
binding, and @false{} otherwise.

In general, two identifiers are @func{bound-identifier=?} only if both
are present in the original program or both are introduced by the same
transformer application (perhaps implicitly, see @func{datum->syntax}).

Operationally, two identifiers are considered equivalent by
@func{bound-identifier=?} if and only if they have the same name and
same marks.

The @func{bound-identifier=?} procedure can be used for detecting
duplicate identifiers in a binding construct or for other preprocessing
of a binding construct that requires detecting instances of the bound
identifiers.
@end deffn


@deffn Procedure {free-identifier=?} @vari{id} @varii{id}
@vari{id} and @varii{id} must be identifiers.

The @func{free-identifier=?} procedure returns @true{} if and only if
the two identifiers would resolve to the same binding if both were to
appear in the output of a transformer outside of any bindings inserted
by the transformer.  (If neither of two like--named identifiers resolves
to a binding, i.e., both are unbound, they are considered to resolve to
the same binding.)

Operationally, two identifiers are considered equivalent by
@func{free-identifier=?} if and only the topmost matching substitution
for each maps to the same binding or the identifiers have the same name
and no matching substitution.

The @func{syntax-case} and @func{syntax-rules} forms internally use
@func{free-identifier=?} to compare identifiers listed in the literals
list against input identifiers.

@example
(let ([fred 17])
  (define-syntax a
    (lambda (x)
      (syntax-case x ()
        [(_ id) #'(b id fred)])))
  (define-syntax b
    (lambda (x)
      (syntax-case x ()
        [(_ id1 id2)
         #`(list
             #,(free-identifier=? #'id1 #'id2)
             #,(bound-identifier=? #'id1 #'id2))])))
  (a fred))
=> (#t #f)
@end example

The following definition of unnamed @func{let} uses
@func{bound-identifier=?} to detect duplicate identifiers.

@example
(define-syntax let
  (lambda (x)
    (define unique-ids?
      (lambda (ls)
        (or (null? ls)
            (and (let notmem?
                        ([x (car ls)] [ls (cdr ls)])
                   (or (null? ls)
                       (and (not (bound-identifier=?
                                   x (car ls)))
                            (notmem? x (cdr ls)))))
                 (unique-ids? (cdr ls))))))
    (syntax-case x ()
      [(_ ((i v) ...) e1 e2 ...)
       (unique-ids? #'(i ...))
       #'((lambda (i ...) e1 e2 ...) v ...)])))
@end example

The argument @code{#'(i ...)} to @func{unique-ids?} is guaranteed to be
a list by the rules given in the description of @func{syntax} above.

With this definition of @func{let}:

@example
(let ([a 3] [a 4]) (+ a a))    => exception &syntax
@end example

However,

@example
(let-syntax
  ([dolet (lambda (x)
            (syntax-case x ()
              [(_ b)
               #'(let ([a 3] [b 4]) (+ a b))]))])
  (dolet a))
=> 7
@end example

@noindent
since the identifier @code{a} introduced by @func{dolet} and the
identifier @code{a} extracted from the input form are not
@func{bound-identifier=?}.

Rather than including @code{else} in the literals list as before, this
version of @func{case} explicitly tests for @code{else} using
@func{free-identifier=?}.

@example
(define-syntax case
  (lambda (x)
    (syntax-case x ()
      [(_ e0 [(k ...) e1 e2 ...] ...
              [else-key else-e1 else-e2 ...])
       (and (identifier? #'else-key)
            (free-identifier=? #'else-key #'else))
       #'(let ([t e0])
           (cond
             [(memv t '(k ...)) e1 e2 ...]
             ...
             [else else-e1 else-e2 ...]))]
      [(_ e0 [(ka ...) e1a e2a ...]
              [(kb ...) e1b e2b ...] ...)
       #'(let ([t e0])
           (cond
             [(memv t '(ka ...)) e1a e2a ...]
             [(memv t '(kb ...)) e1b e2b ...]
             ...))])))
@end example

With either definition of @func{case}, @code{else} is not recognized as
an auxiliary keyword if an enclosing lexical binding for @code{else}
exists.  For example,

@example
(let ([else @false{}])
  (case 0 [else (write "oops")]))    => exception &syntax
@end example

@noindent
since @code{else} is bound lexically and is therefore not the same
@code{else} that appears in the definition of @func{case}.
@end deffn



@c page
@node stdlib syntax-case conversion
@section Syntax--object and datum conversions


@deffn Procedure {syntax->datum} @var{syntax-object}
Strip all syntactic information from a syntax object and returns the
corresponding Scheme datum.

Identifiers stripped in this manner are converted to their symbolic
names, which can then be compared with @func{eq?}.  Thus, a predicate
@code{symbolic-identifier=?} might be defined as follows.

@example
(define symbolic-identifier=?
  (lambda (x y)
    (eq? (syntax->datum x)
         (syntax->datum y))))
@end example
@end deffn


@deffn Procedure {datum->syntax} @var{template-id} @var{datum}
@var{template-id} must be a template identifier and @var{datum} should
be a datum value.

The @func{datum->syntax} procedure returns a syntax-object
representation of @var{datum} that contains the same contextual
information as @var{template-id}, with the effect that the syntax object
behaves as if it were introduced into the code when @var{template-id}
was introduced.

The @func{datum->syntax} procedure allows a transformer to ``bend''
lexical scoping rules by creating @emph{implicit identifiers} that
behave as if they were present in the input form, thus permitting the
definition of macros that introduce visible bindings for or references
to identifiers that do not appear explicitly in the input form.  For
example, the following defines a @func{loop} expression that uses this
controlled form of identifier capture to bind the variable @code{break}
to an escape procedure within the loop body.  (The derived
@func{with-syntax} form is like @func{let} but binds pattern variables.)

@example
(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(k e ...)
       (with-syntax
           ([break (datum->syntax #'k 'break)])
         #'(call-with-current-continuation
             (lambda (break)
               (let f () e ... (f)))))])))

(let ((n 3) (ls '()))
  (loop
    (if (= n 0) (break ls))
    (set! ls (cons 'a ls))
    (set! n (- n 1))))
=> (a a a)
@end example

Were @code{loop} to be defined as:

@example
(define-syntax loop
  (lambda (x)
    (syntax-case x ()
      [(_ e ...)
       #'(call-with-current-continuation
           (lambda (break)
             (let f () e ... (f))))])))
@end example

@noindent
the variable @code{break} would not be visible in @code{e ...}.

The datum argument @var{datum} may also represent an arbitrary Scheme
form, as demonstrated by the following definition of @func{include}.

@example
(define-syntax include
  (lambda (x)
    (define read-file
      (lambda (fn k)
        (let ([p (open-file-input-port fn)])
          (let f ([x (get-datum p)])
            (if (eof-object? x)
                (begin (close-port p) '())
                (cons (datum->syntax k x)
                      (f (get-datum p))))))))
    (syntax-case x ()
      [(k filename)
       (let ([fn (syntax->datum #'filename)])
         (with-syntax ([(exp ...)
                        (read-file fn #'k)])
           #'(begin exp ...)))])))
@end example

@code{(include "filename")} expands into a @func{begin} expression
containing the forms found in the file named by @code{"filename"}.  For
example, if the file @file{flib.ss} contains:

@example
(define f (lambda (x) (g (* x x))))
@end example

@noindent
and the file @file{glib.ss} contains:

@example
(define g (lambda (x) (+ x x)))
@end example

@noindent
the expression:

@example
(let ()
  (include "flib.ss")
  (include "glib.ss")
  (f 5))
@end example

@noindent
evaluates to @code{50}.

The definition of @func{include} uses @func{datum->syntax} to convert
the objects read from the file into syntax objects in the proper lexical
context, so that identifier references and definitions within those
expressions are scoped where the @func{include} form appears.
@end deffn



@c page
@node stdlib syntax-case temporaries
@section Generating lists of temporaries


Transformers can introduce a fixed number of identifiers into their
output simply by naming each identifier.  In some cases, however, the
number of identifiers to be introduced depends upon some characteristic
of the input expression.  A straightforward definition of @func{letrec},
for example, requires as many temporary identifiers as there are binding
pairs in the input expression.  The procedure
@func{generate-temporaries} is used to construct lists of temporary
identifiers.


@deffn Procedure generate-temporaries @var{l}
@var{l} must be be a list or syntax object representing a
list--structured form; its contents are not important.

The number of temporaries generated is the number of elements in
@var{l}.  Each temporary is guaranteed to be unique, i.e., different
from all other identifiers.

A definition of @func{letrec} equivalent to the one using
@func{syntax-rules} given in @ref{lang derived} is shown below.

@example
(define-syntax letrec
  (lambda (x)
    (syntax-case x ()
      ((_ ((i e) ...) b1 b2 ...)
       (with-syntax
           (((t ...) (generate-temporaries #'(i ...))))
         #'(let ((i <undefined>) ...)
             (let ((t e) ...)
               (set! i t) ...
               (let () b1 b2 ...))))))))
@end example

This version uses @func{generate-temporaries} instead of recursively
defined helper to generate the necessary temporaries.
@end deffn



@c page
@node stdlib syntax-case derived
@section Derived forms and procedures


The forms and procedures described in this section can be defined in
terms of the forms and procedures described in earlier sections of this
chapter.


@deffn Syntax with-syntax ((@hyper{pattern} @hyper{expression}) @dots{}) @hyper{body}
The @func{with-syntax} form is used to bind pattern variables, just as
@func{let} is used to bind variables.  This allows a transformer to
construct its output in separate pieces, then put the pieces together.

Each @hyper{pattern} is identical in form to a @func{syntax-case}
pattern.  The value of each @hyper{expression} is computed and
destructured according to the corresponding @hyper{pattern}, and pattern
variables within the @hyper{pattern} are bound as with
@func{syntax-case} to the corresponding portions of the value within
@hyper{body}.

The @func{with-syntax} form may be defined in terms of
@func{syntax-case} as follows.

@example
(define-syntax with-syntax
  (lambda (x)
    (syntax-case x ()
      ((_ ((p e0) ...) e1 e2 ...)
       (syntax (syntax-case (list e0 ...) ()
                 ((p ...) (let () e1 e2 ...))))))))
@end example

The following definition of @func{cond} demonstrates the use of
@func{with-syntax} to support transformers that employ recursion
internally to construct their output.  It handles all @func{cond} clause
variations and takes care to produce one-armed @func{if} expressions
where appropriate.

@example
(define-syntax cond
  (lambda (x)
    (syntax-case x ()
      [(_ c1 c2 ...)
       (let f ([c1 #'c1] [c2* #'(c2 ...)])
         (syntax-case c2* ()
           [()
            (syntax-case c1 (else =>)
              [(else e1 e2 ...) #'(begin e1 e2 ...)]
              [(e0) #'e0]
              [(e0 => e1)
               #'(let ([t e0]) (if t (e1 t)))]
              [(e0 e1 e2 ...)
               #'(if e0 (begin e1 e2 ...))])]
           [(c2 c3 ...)
            (with-syntax ([rest (f #'c2 #'(c3 ...))])
              (syntax-case c1 (=>)
                [(e0) #'(let ([t e0]) (if t t rest))]
                [(e0 => e1)
                 #'(let ([t e0]) (if t (e1 t) rest))]
                [(e0 e1 e2 ...)
                 #'(if e0
                        (begin e1 e2 ...)
                        rest)]))]))])))
@end example
@end deffn


@deffn Syntax quasisyntax @hyper{template}
@deffnx {Auxiliary Syntax} unsyntax
@deffnx {Auxiliary Syntax} unsyntax-splicing
The @func{quasisyntax} form is similar to @func{syntax}, but it allows
parts of the quoted text to be evaluated, in a manner similar to the
operation of @func{quasiquote} (@ref{baselib quasiquotation}).

Within a @func{quasisyntax} @var{template}, subforms of @func{unsyntax}
and @func{unsyntax-splicing} forms are evaluated, and everything else is
treated as ordinary template material, as with @func{syntax}.

The value of each @func{unsyntax} subform is inserted into the output in
place of the @func{unsyntax} form, while the value of each
@func{unsyntax-splicing} subform is spliced into the surrounding list or
vector structure.  Uses of @func{unsyntax} and @func{unsyntax-splicing}
are valid only within @func{quasisyntax} expressions.

A @func{quasisyntax} expression may be nested, with each
@func{quasisyntax} introducing a new level of syntax quotation and each
@func{unsyntax} or @func{unsyntax-splicing} taking away a level of
quotation.  An expression nested within @emph{n} @func{quasisyntax}
expressions must be within @emph{n} @emph{unsyntax} or
@func{unsyntax-splicing} expressions to be evaluated.

As noted in @ref{lang lex datum abbreviations},
@code{#`@hyper{template}} is equivalent to @code{(quasisyntax
@hyper{template})}, @code{#,@hyper{template}} is equivalent to
@code{(unsyntax @hyper{template})}, and @code{#,@@@hyper{template}} is
equivalent to @code{(unsyntax-splicing @hyper{template})}.

The @func{quasisyntax} keyword can be used in place of
@func{with-syntax} in many cases.  For example, the definition of
@func{case} shown under the description of @func{with-syntax} above can
be rewritten using @func{quasisyntax} as follows.

@example
(define-syntax case
  (lambda (x)
    (syntax-case x ()
      [(_ e c1 c2 ...)
       #`(let ([t e])
           #,(let f ([c1 #'c1] [cmore #'(c2 ...)])
               (if (null? cmore)
                   (syntax-case c1 (else)
                     [(else e1 e2 ...)
                      #'(begin e1 e2 ...)]
                     [((k ...) e1 e2 ...)
                      #'(if (memv t '(k ...))
                            (begin e1 e2 ...))])
                   (syntax-case c1 ()
                     [((k ...) e1 e2 ...)
                      #`(if (memv t '(k ...))
                            (begin e1 e2 ...)
                            #,(f (car cmore)
                                  (cdr cmore)))]))))])))
@end example

Uses of @func{unsyntax} and @func{unsyntax-splicing} with zero or more
than one subform are valid only in splicing (list or vector) contexts.
@code{(unsyntax @var{template} @dots{})} is equivalent to
@code{(unsyntax @var{template}) ...}, and @code{(unsyntax-splicing
@var{template} ...)} is equivalent to @code{(unsyntax-splicing
@var{template}) ...}.  These forms are primarily useful as intermediate
forms in the output of the @func{quasisyntax} expander.

@quotation
@emph{Note:} Uses of @func{unsyntax} and @func{unsyntax-splicing} with
zero or more than one subform enable certain idioms, such as
@code{#,@@#,@@}, which has the effect of a doubly indirect splicing when
used within a doubly nested and doubly evaluated @func{quasisyntax}
expression, as with the nested @func{quasiquote} examples shown in
section @ref{baselib quasiquotation}.
@end quotation
@end deffn

@quotation
@emph{Note:} Any @func{syntax-rules} form can be expressed with
@func{syntax-case} by making the @func{lambda} expression and
@func{syntax} expressions explicit, and @func{syntax-rules} may be
defined in terms of @func{syntax-case} as follows.

@example
(define-syntax syntax-rules
  (lambda (x)
    (syntax-case x ()
      [(_ (lit ...) [(k . p) t] ...)
       (for-all identifier? #'(lit ... k ...))
       #'(lambda (x)
           (syntax-case x (lit ...)
             [(_ . p) #'t] ...))])))
@end example
@end quotation

@quotation
@emph{Note:} The @func{identifier-syntax} form of the base library
(@ref{baselib transformers}) may be defined in terms of
@func{syntax-case}, @func{syntax}, and @func{make-variable-transformer}
as follows.

@example
(define-syntax identifier-syntax
  (syntax-rules (set!)
    [(_ e)
     (lambda (x)
       (syntax-case x ()
         [id (identifier? #'id) #'e]
         [(_ x (... ...)) #'(e x (... ...))]))]
    [(_ (id exp1) ((set! var val) exp2))
     (and (identifier? #'id) (identifier? #'var))
     (make-variable-transformer
       (lambda (x)
         (syntax-case x (set!)
           [(set! var val) #'exp2]
           [(id x (... ...)) #'(exp1 x (... ...))]
           [id (identifier? #'id) #'exp1])))]))
@end example
@end quotation



@c page
@node stdlib syntax-case violations
@section Syntax violations


@deffn Procedure syntax-violation @var{who message form}
@deffnx Procedure syntax-violation @var{who message form subform}
@var{who} must be @false{} or a string or a symbol.  @var{message} must
be a string.  @var{form} must be a syntax object or a datum value.
@var{subform} must be a syntax object or a datum value.

The @func{syntax-violation} procedure raises an exception, reporting a
syntax violation.  @var{who} should describe the macro transformer that
detected the exception.  The @var{message} argument should describe the
violation.  @var{form} should be the erroneous source syntax object or a
datum value representing a form. The optional @var{subform} argument
should be a syntax object or datum value representing a form that more
precisely locates the violation.

If @var{who} is @false{}, @func{syntax-violation} attempts to infer an
appropriate value for the condition object (see below) as follows: When
@var{form} is either an identifier or a list-structured syntax object
containing an identifier as its first element, then the inferred value
is the identifier's symbol.  Otherwise, no value for @var{who} is
provided as part of the condition object.

The condition object provided with the exception has the following
condition types:

@itemize
@item
If @var{who} is not @false{} or can be inferred, the condition has
condition type @code{&who}, with @var{who} as the value of its field.
In that case, @var{who} should identify the procedure or entity that
detected the exception.  If it is @false{}, the condition does not have
condition type @code{&who}.

@item
The condition has condition type @code{&message}, with @var{message} as
the value of its field.

@item
The condition has condition type @code{&syntax} with @var{form} and
@var{subform} as the value of its fields.  If @var{subform} is not
provided, the value of the subform field is @false{}.
@end itemize
@end deffn



@c page
@node stdlib syntax-case define-macro
@section Common Lisp style macros


@findex lisp-transformer
@findex define-macro
@cindex Common Lisp style macros


Using @func{datum->syntax}, it is even possible to break hygiene
entirely and write macros in the style of old Lisp macros.  The
@func{lisp-transformer} procedure defined below creates a transformer
that converts its input into a datum, calls the programmer's procedure
on this datum, and converts the result back into a syntax object scoped
where the original macro use appeared.

@example
(define lisp-transformer
  (lambda (p)
    (lambda (x)
      (syntax-case x ()
        [(kwd . rest)
         (datum->syntax #'kwd
           (p (syntax->datum x)))]))))
@end example


@c page
@node stdlib hashtable
@chapter Hashtables


The @rsixlibrary{hashtables} library provides a set of operations on
hashtables.

A @emph{hashtable} is a data structure that associates keys with values.
Any object can be used as a key, provided a @emph{hash function} and a
suitable @emph{equivalence function} is available.

A hash function is a procedure that maps keys to exact integer objects.
It is the programmer's responsibility to ensure that the hash function
is compatible with the equivalence function, which is a procedure that
accepts two keys and returns true if they are equivalent and @false{}
otherwise.

Standard hashtables for arbitrary objects based on the @func{eq?} and
@func{eqv?} predicates (@ref{baselib predicates}) are provided.  Also,
hash functions for arbitrary objects, strings, and symbols are provided.

This section uses the @var{hashtable} parameter name for arguments that
must be hashtables, and the @var{key} parameter name for arguments that
must be hashtable keys.


@menu
* stdlib hashtable constructors::       Constructors.
* stdlib hashtable procedures::         Procedures.
* stdlib hashtable inspection::         Inspection.
* stdlib hashtable hash functions::     Hash functions.
@end menu


@c page
@node stdlib hashtable constructors
@section Constructors


@deffn Procedure make-eq-hashtable
@deffnx Procedure make-eq-hashtable @var{k}
Return a newly allocated mutable hashtable that accepts arbitrary
objects as keys, and compares those keys with @func{eq?}.  If an
argument is given, the initial capacity of the hashtable is set to
approximately @var{k} elements.
@end deffn


@deffn Procedure make-eqv-hashtable
@deffnx Procedure make-eqv-hashtable @var{k}
Return a newly allocated mutable hashtable that accepts arbitrary
objects as keys, and compares those keys with @func{eqv?}.  If an
argument is given, the initial capacity of the hashtable is set to
approximately @var{k} elements.
@end deffn


@deffn Procedure make-hashtable @var{hash-function} @var{equiv}
@deffnx Procedure make-hashtable @var{hash-function} @var{equiv} @var{k}
@var{hash-function} and @var{equiv} must be procedures.
@var{hash-function} should accept a key as an argument and should return
a non--negative exact integer object.  @var{equiv} should accept two
keys as arguments and return a single value.  Neither procedure should
mutate the hashtable returned by @func{make-hashtable}.

The @func{make-hashtable} procedure returns a newly allocated mutable
hashtable using @var{hash-function} as the hash function and @var{equiv}
as the equivalence function used to compare keys.  If a third argument
is given, the initial capacity of the hashtable is set to approximately
@var{k} elements.

Both @var{hash-function} and @var{equiv} should behave like pure
functions on the domain of keys.  For example, the @func{string-hash}
and @func{string=?} procedures are permissible only if all keys are
strings and the contents of those strings are never changed so long as
any of them continues to serve as a key in the hashtable.  Furthermore,
any pair of keys for which @var{equiv} returns true should be hashed to
the same exact integer objects by @var{hash-function}.

@strong{Implementation responsibilities:} The implementation must check
the restrictions on @var{hash-function} and @var{equiv} to the extent
performed by applying them as described.

@quotation
@emph{Note:} Hashtables are allowed to cache the results of calling the
hash function and equivalence function, so programs cannot rely on the
hash function being called for every lookup or update.  Furthermore any
hashtable operation may call the hash function more than once.
@end quotation
@end deffn



@c page
@node stdlib hashtable procedures
@section Procedures


@deffn Procedure {hashtable?} @var{obj}
Return @true{} if @var{obj} is a hashtable, @false{} otherwise.
@end deffn


@deffn Procedure hashtable-size @var{hashtable}
Return the number of keys contained in @var{hashtable} as an exact
integer object.
@end deffn


@deffn Procedure hashtable-ref @var{hashtable} @var{key} @var{default}
Return the value in @var{hashtable} associated with @var{key}.  If
@var{hashtable} does not contain an association for @var{key},
@var{default} is returned.
@end deffn


@deffn Procedure {hashtable-set!} @var{hashtable} @var{key} @var{obj}
Change @var{hashtable} to associate @var{key} with @var{obj}, adding a
new association or replacing any existing association for @var{key}, and
returns unspecified values.
@end deffn


@deffn Procedure {hashtable-delete!} @var{hashtable} @var{key}
Remove any association for @var{key} within @var{hashtable} and returns
unspecified values.
@end deffn


@deffn Procedure {hashtable-contains?} @var{hashtable} @var{key}
Return @true{} if @var{hashtable} contains an association for @var{key},
@false{} otherwise.
@end deffn


@deffn Procedure {hashtable-update!} @var{hashtable} @var{key} @var{proc} @var{default}
@var{proc} should accept one argument, should return a single value, and
should not mutate @var{hashtable}.

The @func{hashtable-update!} procedure applies @var{proc} to the value
in @var{hashtable} associated with @var{key}, or to @var{default} if
@var{hashtable} does not contain an association for @var{key}.  The
@var{hashtable} is then changed to associate @var{key} with the value
returned by @var{proc}.

The behavior of @func{hashtable-update!} is equivalent to the following
code, but may be implemented more efficiently in cases where the
implementation can avoid multiple lookups of the same key:

@example
(hashtable-set!
  hashtable key
  (proc (hashtable-ref
         hashtable key default)))
@end example
@end deffn


@deffn Procedure hashtable-copy @var{hashtable}
@deffnx Procedure hashtable-copy @var{hashtable} @var{mutable}
Return a copy of @var{hashtable}.  If the @var{mutable} argument is
provided and is true, the returned hashtable is mutable; otherwise it is
immutable.
@end deffn


@deffn Procedure {hashtable-clear!} @var{hashtable}
@deffnx Procedure {hashtable-clear!} @var{hashtable} @var{k}
Remove all associations from @var{hashtable} and returns unspecified
values.

If a second argument is given, the current capacity of the hashtable is
reset to approximately @var{k} elements.
@end deffn


@deffn Procedure hashtable-keys @var{hashtable}
Return a vector of all keys in @var{hashtable}.  The order of the vector
is unspecified.
@end deffn


@deffn Procedure hashtable-entries @var{hashtable}
Return two values, a vector of the keys in @var{hashtable}, and a vector
of the corresponding values.

Example:

@example
(let ((h (make-eqv-hashtable)))
  (hashtable-set! h 1 'one)
  (hashtable-set! h 2 'two)
  (hashtable-set! h 3 'three)
  (hashtable-entries h))
=> #(1 2 3) #(one two three) ; two return values
@end example

@noindent
the order of the entries in the result vectors is not known.
@end deffn



@c page
@node stdlib hashtable inspection
@section Inspection


@deffn Procedure hashtable-equivalence-function @var{hashtable}
Return the equivalence function used by @var{hashtable} to compare keys.
For hashtables created with @func{make-eq-hashtable} and
@func{make-eqv-hashtable}, returns @func{eq?} and @func{eqv?}
respectively.
@end deffn


@deffn Procedure hashtable-hash-function @var{hashtable}
Return the hash function used by @var{hashtable}.  For hashtables
created by @func{make-eq-hashtable} or @func{make-eqv-hashtable},
@false{} is returned.
@end deffn


@deffn Procedure {hashtable-mutable?} @var{hashtable}
Return @true{} if @var{hashtable} is mutable, otherwise @false{}.
@end deffn



@c page
@node stdlib hashtable hash functions
@section Hash functions


The @func{equal-hash}, @func{string-hash}, and @func{string-ci-hash}
procedures of this section are acceptable as the hash functions of a
hashtable only if the keys on which they are called are not mutated
while they remain in use as keys in the hashtable.


@deffn Procedure equal-hash @var{obj}
Return an integer hash value for @var{obj}, based on its structure and
current contents.  This hash function is suitable for use with
@func{equal?} as an equivalence function.

@quotation
@emph{Note:} Like @func{equal?}, the @func{equal-hash} procedure must
always terminate, even if its arguments contain cycles.
@end quotation

@quotation
@emph{Note:} At least up to revision 1694, Ikarus does not implement
this function.  A possible implementation is:

@example
(define (equal-hash obj)
    (string-hash
     (call-with-string-output-port
         (lambda () (write obj)))))
@end example
@end quotation
@end deffn


@deffn Procedure string-hash @var{string}
Return an integer hash value for @var{string}, based on its current
contents.  This hash function is suitable for use with @func{string=?}
as an equivalence function.
@end deffn


@deffn Procedure string-ci-hash @var{string}
Return an integer hash value for @var{string} based on its current
contents, ignoring case.  This hash function is suitable for use with
@func{string-ci=?} as an equivalence function.
@end deffn


@deffn Procedure symbol-hash @var{symbol}
Return an integer hash value for @var{symbol}.
@end deffn



@c page
@node stdlib enum
@chapter Enumerations


This chapter describes the @rsixlibrary{enums} library for dealing with
enumerated values and sets of enumerated values.  Enumerated values are
represented by ordinary symbols, while finite sets of enumerated values
form a separate type, known as the @emph{enumeration sets}.  The
enumeration sets are further partitioned into sets that share the same
@emph{universe} and @emph{enumeration type}.  These universes and
enumeration types are created by the @func{make-enumeration} procedure.
Each call to that procedure creates a new enumeration type.

This library interprets each enumeration set with respect to its
specific universe of symbols and enumeration type.  This facilitates
efficient implementation of enumeration sets and enables the complement
operation.

In the descriptions of the following procedures, @var{enum-set} ranges
over the enumeration sets, which are defined as the subsets of the
universes that can be defined using @func{make-enumeration}.


@deffn Procedure make-enumeration @var{symbol-list}
@var{symbol-list} must be a list of symbols.

The @func{make-enumeration} procedure creates a new enumeration type
whose universe consists of those symbols (in canonical order of their
first appearance in the list) and returns that universe as an
enumeration set whose universe is itself and whose enumeration type is
the newly created enumeration type.
@end deffn


@deffn Procedure enum-set-universe @var{enum-set}
Return the set of all symbols that comprise the universe of its
argument, as an enumeration set.
@end deffn


@deffn Procedure enum-set-indexer @var{enum-set}
Return a unary procedure that, given a symbol that is in the universe of
@var{enum-set}, returns its 0--origin index within the canonical
ordering of the symbols in the universe; given a symbol not in the
universe, the unary procedure returns @false{}.

@example
(let* ((e (make-enumeration '(red green blue)))
       (i (enum-set-indexer e)))
  (list (i 'red) (i 'green) (i 'blue) (i 'yellow)))
=> (0 1 2 #f)
@end example

The @func{enum-set-indexer} procedure could be defined as follows using
the @func{memq} procedure from the @rsixlibrary{lists} library:

@example
(define (enum-set-indexer set)
  (let* ((symbols (enum-set->list
                    (enum-set-universe set)))
         (cardinality (length symbols)))
    (lambda (x)
      (cond
       ((memq x symbols)
        => (lambda (probe)
             (- cardinality (length probe))))
       (else #f)))))
@end example
@end deffn


@deffn Procedure enum-set-constructor @var{enum-set}
Return a unary procedure that, given a list of symbols that belong to
the universe of @var{enum-set}, returns a subset of that universe that
contains exactly the symbols in the list.  The values in the list must
all belong to the universe.
@end deffn


@deffn Procedure enum-set->list @var{enum-set}
Return a list of the symbols that belong to its argument, in the
canonical order of the universe of @var{enum-set}.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list (c '(blue red))))    => (red blue)
@end example
@end deffn


@deffn Procedure {enum-set-member?} @var{symbol} @var{enum-set}
@deffnx Procedure {enum-set-subset?} @vari{enum-set} @varii{enum-set}
@deffnx Procedure {enum-set=?} @vari{enum-set} @varii{enum-set}
The @func{enum-set-member?} procedure returns @true{} if its first
argument is an element of its second argument, @false{} otherwise.

The @func{enum-set-subset?} procedure returns @true{} if the universe of
@vari{enum-set} is a subset of the universe of @varii{enum-set}
(considered as sets of symbols) and every element of @vari{enum-set} is
a member of @varii{enum-set}.  It returns @false{} otherwise.

The @func{enum-set=?} procedure returns @true{} if @vari{enum-set} is a
subset of @varii{enum-set} and vice versa, as determined by the
@func{enum-set-subset?} procedure.  This implies that the universes of
the two sets are equal as sets of symbols, but does not imply that they
are equal as enumeration types.  Otherwise, @false{} is returned.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list
   (enum-set-member? 'blue (c '(red blue)))
   (enum-set-member? 'green (c '(red blue)))
   (enum-set-subset? (c '(red blue)) e)
   (enum-set-subset? (c '(red blue)) (c '(blue red)))
   (enum-set-subset? (c '(red blue)) (c '(red)))
   (enum-set=? (c '(red blue)) (c '(blue red)))))
=> (#t #f #t #t #f #t)
@end example
@end deffn


@deffn Procedure enum-set-union @vari{enum-set} @varii{enum-set}
@deffnx Procedure enum-set-intersection @vari{enum-set} @varii{enum-set}
@deffnx Procedure enum-set-difference @vari{enum-set} @varii{enum-set}
@vari{enum-set} and @varii{enum-set} must be enumeration sets that have
the same enumeration type.

The @func{enum-set-union} procedure returns the union of @vari{enum-set}
and @varii{enum-set}.  The @func{enum-set-intersection} procedure
returns the intersection of @vari{enum-set} and @varii{enum-set}.  The
@func{enum-set-difference} procedure returns the difference of
@vari{enum-set} and @varii{enum-set}.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (list (enum-set->list
         (enum-set-union (c '(blue)) (c '(red))))
        (enum-set->list
         (enum-set-intersection (c '(red green))
                                (c '(red blue))))
        (enum-set->list
         (enum-set-difference (c '(red green))
                              (c '(red blue))))))
=> ((red blue) (red) (green))
@end example
@end deffn


@deffn Procedure enum-set-complement @var{enum-set}
Return @var{enum-set}'s complement with respect to its universe.

@example
(let* ((e (make-enumeration '(red green blue)))
       (c (enum-set-constructor e)))
  (enum-set->list
    (enum-set-complement (c '(red)))))
=> (green blue)
@end example
@end deffn


@deffn Procedure enum-set-projection @vari{enum-set} @varii{enum-set}
Project @vari{enum-set} into the universe of @varii{enum-set}, dropping
any elements of @vari{enum-set} that do not belong to the universe of
@varii{enum-set}.  (If @vari{enum-set} is a subset of the universe of
its second, no elements are dropped, and the injection is returned.)

@example
(let ((e1 (make-enumeration
            '(red green blue black)))
      (e2 (make-enumeration
            '(red black white))))
  (enum-set->list
    (enum-set-projection e1 e2))))
=> (red black)
@end example
@end deffn


@deffn Syntax define-enumeration @hyper{type-name} (@hyper{symbol} @dots{}) @hyper{constructor-syntax}
The @func{define-enumeration} form defines an enumeration type and
provides two macros for constructing its members and sets of its
members.

A @func{define-enumeration} form is a definition and can appear anywhere
any other @hyper{definition} can appear.

@hyper{type-name} is an identifier that is bound as a syntactic keyword;
@hyper{symbol} @dots{} are the symbols that comprise the universe of the
enumeration (in order).

@code{(@hyper{type-name} @hyper{symbol})} checks at macro-expansion time
whether the name of @hyper{symbol} is in the universe associated with
@hyper{type-name}.  If it is, @code{(@hyper{type-name} @hyper{symbol})}
is equivalent to @code{@hyper{symbol}}.  It is a syntax violation if it
is not.

@hyper{constructor-syntax} is an identifier that is bound to a macro
that, given any finite sequence of the symbols in the universe, possibly
with duplicates, expands into an expression that evaluates to the
enumeration set of those symbols.

@code{(@hyper{constructor-syntax} @hyper{symbol} ...)} checks at
macro-expansion time whether every @hyper{symbol} ... is in the universe
associated with @hyper{type-name}.  It is a syntax violation if one or
more is not.  Otherwise:

@example
(@hyper{constructor-syntax} @hyper{symbol} ...)
@end example

@noindent
is equivalent to:

@example
((enum-set-constructor (@hyper{constructor-syntax}))
 '(@hyper{symbol} ...))
@end example

Example:

@example
(define-enumeration color
  (black white purple maroon)
  color-set)

(color black)                      => black
(color purpel)                     => exception &syntax
(enum-set->list (color-set))       => ()
(enum-set->list
  (color-set maroon white))        => (white maroon)
@end example

@quotation
@emph{Note:} In @code{(@hyper{type-name} @hyper{symbol})} and
@code{(@hyper{constructor-syntax} @hyper{symbol} ...)} forms, only the
names of the @hyper{symbol}s are significant.
@end quotation
@end deffn



@c page
@node stdlib complib
@chapter Composite library


The @rsixlibrary{} library is a composite of most of the libraries
described in this report.  The only exceptions are:

@table @rsixlibrary
@item eval
@item mutable-pairs
@item mutable-strings
@item r5rs
@end table

The library exports all procedures and syntactic forms provided by the
component libraries.

All of the bindings exported by @rsixlibrary{} are exported for both
@code{run} and @code{expand}; @ref{lang library import export}.


@c page
@node stdlib eval
@chapter Evaluation


The @rsixlibrary{eval} library allows a program to create Scheme
expressions as data at run time and evaluate them.


@deffn Procedure eval @var{expression} @var{environment}
Evaluate @var{expression} in the specified environment and returns its
value.  @var{expression} must be a syntactically valid Scheme expression
represented as a datum value, and @var{environment} must be an
@emph{environment}, which can be created using the @func{environment}
procedure described below.

If the first argument to @code{eval} is determined not to be a
syntactically correct expression, then @func{eval} must raise an
exception with condition type @code{&syntax}.  Specifically, if the
first argument to @code{eval} is a definition or a splicing @func{begin}
form containing a definition, it must raise an exception with condition
type @code{&syntax}.
@end deffn


@deffn Procedure environment @var{import-spec} @dots{}
@var{import-spec} must be a datum representing an @hyper{import spec}
(@ref{lang library form}).

The @func{environment} procedure returns an environment corresponding to
@var{import-spec}.

The bindings of the environment represented by the specifier are
immutable: If @func{eval} is applied to an expression that is determined
to contain an assignment to one of the variables of the environment,
then @func{eval} must raise an exception with a condition type
@code{&syntax}.
@ignore
The errata corrige says to append the following here:

  for consistency with treatement of similar situations as syntax
  violations in section 7.1 of the base document.

but I see no &syntax in section 7.1 of R6RS document.
@end ignore

@example
(library (foo)
  (export)
  (import (rnrs)
          (rnrs eval))
  (write
    (eval '(let ((x 3)) x)
          (environment '(rnrs)))))      ;; writes 3

(library (foo)
  (export)
  (import (rnrs)
          (rnrs eval))
  (write
    (eval
      '(eval:car (eval:cons 2 4))
      (environment
        '(prefix (only (rnrs) car cdr cons null?)
                 eval:)))))             ;; writes 2
@end example
@end deffn



@c page
@node stdlib mutable pairs
@chapter Mutable pairs


The procedures provided by the @rsixlibrary{mutable-pairs} library allow
new values to be assigned to the car and cdr fields of previously
allocated pairs.


@deffn Procedure {set-car!} @var{pair} @var{obj}
Store @var{obj} in the car field of @var{pair}.  The @func{set-car!}
procedure returns unspecified values.

@example
(define (f) (list 'not-a-constant-list))
(define (g) '(constant-list))
(set-car! (f) 3)             => unspecified
(set-car! (g) 3)             => unspecified
                                ; should raise exception &assertion
@end example

If an immutable pair is passed to @func{set-car!}, an exception with
condition type @code{&assertion} should be raised.
@end deffn


@deffn Procedure {set-cdr!} @var{pair} @var{obj}
Store @var{obj} in the cdr field of @var{pair}.  The @func{set-cdr!}
procedure returns unspecified values.

If an immutable pair is passed to @func{set-cdr!}, an exception with
condition type @code{&assertion} should be raised.

@example
(let ((x (list 'a 'b 'c 'a))
      (y (list 'a 'b 'c 'a 'b 'c 'a)))
  (set-cdr! (list-tail x 2) x)
  (set-cdr! (list-tail y 5) y)
  (list
   (equal? x x)
   (equal? x y)
   (equal? (list x y 'a) (list y x 'b))))    =>  (#t #t #f)
@end example
@end deffn



@c page
@node stdlib mutable strings
@chapter Mutable strings


The @func{string-set!} procedure provided by the
@rsixlibrary{mutable-strings} library allows mutating the characters of
a string in--place.


@deffn Procedure {string-set!} @var{string} @var{k} @var{char}
@var{k} must be a valid index of @var{string}.

The @func{string-set!} procedure stores @var{char} in element @var{k} of
@var{string} and returns unspecified values.

Passing an immutable string to @func{string-set!} should cause an
exception with condition type @code{&assertion} to be raised.

@example
(define (f) (make-string 3 #\*))
(define (g) "***")
(string-set! (f) 0 #\?)                 => unspecified
(string-set! (g) 0 #\?)                 => unspecified
                                ; should raise exception &assertion

(string-set! (symbol->string 'immutable)
             0
             #\?)                       => unspecified
                                ; should raise exception &assertion
@end example

@quotation
@emph{Note:} Implementors should make @func{string-set!} run in constant
time.
@end quotation
@end deffn


@deffn Procedure {string-fill!} @var{string} @var{char}
Store @var{char} in every element of the given @var{string} and returns
unspecified values.
@end deffn



@c page
@node stdlib rfive compat
@chapter @rnrs{5} compatibility


The features described in this chapter are exported from the
@rsixlibrary{r5rs} library and provide some functionality of the
preceding revision of this report that was omitted from the main part of
the current report.


@deffn Procedure exact->inexact @var{z}
@deffnx Procedure inexact->exact @var{z}
These are the same as the @code{inexact} and @code{exact} procedures;
@ref{baselib math ops exactness}.
@end deffn


@deffn Procedure quotient @vari{n} @varii{n}
@deffnx Procedure remainder @vari{n} @varii{n}
@deffnx Procedure modulo @vari{n} @varii{n}
These procedures implement number--theoretic (integer) division.
@varii{N} must be non--zero.  All three procedures return integer
objects.  If @vari{n}/@varii{n} is an integer object:

@example
(quotient @vari{n} @varii{n})   => @vari{n}/@varii{n}
(remainder @vari{n} @varii{n})  => 0
(modulo @vari{n} @varii{n})     => 0
@end example

If @vari{n}/@varii{n} is not an integer object:

@example
(quotient @vari{n} @varii{n})   => @var{n_q}
(remainder @vari{n} @varii{n})  => @var{n_r}
(modulo @vari{n} @varii{n})     => @var{n_m}
@end example

@noindent
where @var{n_q} is @vari{n}/@varii{n} rounded towards zero,

@example
0 < |@var{n_r}| < |@varii{n}|
0 < |@var{n_m}| < |@varii{n}|
@end example

@noindent
@var{n_r} and @var{n_m} differ from @vari{n} by a multiple of @varii{n},
@var{n_r} has the same sign as @vari{n}, and @var{n_m} has the same sign
as @varii{n}.

Consequently, for integer objects @vari{n} and @varii{n} with @varii{n}
not equal to 0,

@example
(= @vari{n} (+ (* @varii{n} (quotient @vari{n} @varii{n}))
               (remainder @vari{n} @varii{n})))
=> #t
@end example

@noindent
provided all number object involved in that computation are exact.

@example
(modulo 13 4)           =>  1
(remainder 13 4)        =>  1

(modulo -13 4)          =>  3
(remainder -13 4)       =>  -1

(modulo 13 -4)          =>  -3
(remainder 13 -4)       =>  1

(modulo -13 -4)         =>  -1
(remainder -13 -4)      =>  -1

(remainder -13 -4.0)    =>  -1.0
@end example

@quotation
@emph{Note:} These procedures could be defined in terms of @func{div}
and @func{mod} (@ref{baselib math ops arithmetic}) as follows (without
checking of the argument types):

@example
(define (sign n)
  (cond
    ((negative? n) -1)
    ((positive? n) 1)
    (else 0)))

(define (quotient n1 n2)
  (* (sign n1) (sign n2) (div (abs n1) (abs n2))))

(define (remainder n1 n2)
  (* (sign n1) (mod (abs n1) (abs n2))))

(define (modulo n1 n2)
  (* (sign n2) (mod (* (sign n2) n1) (abs n2))))
@end example
@end quotation
@end deffn


@deffn Syntax delay @hyper{expression}
The @func{delay} construct is used together with the procedure
@func{force} to implement @emph{lazy evaluation} or @emph{call by need}.

@code{(delay @hyper{expression})} returns an object called a
@emph{promise} which at some point in the future may be asked (by the
@func{force} procedure) to evaluate @hyper{expression}, and deliver the
resulting value.  The effect of @hyper{expression} returning multiple
values is unspecified.
@end deffn


@deffn Procedure force @var{promise}
@var{promise} must be a promise.

The @func{force} procedure forces the value of @var{promise}.  If no
value has been computed for the promise, then a value is computed and
returned.  The value of the promise is cached (or ``memoized'') so that
if it is forced a second time, the previously computed value is
returned.

@example
(force (delay (+ 1 2)))                 =>  3

(let ((p (delay (+ 1 2))))
  (list (force p) (force p)))           =>  (3 3)

(define a-stream
  (letrec ((next
            (lambda (n)
              (cons n (delay (next (+ n 1)))))))
    (next 0)))
(define head car)
(define tail
  (lambda (stream) (force (cdr stream))))

(head (tail (tail a-stream)))           =>  2
@end example

Promises are mainly intended for programs written in functional style.
The following examples should not be considered to illustrate good
programming style, but they illustrate the property that only one value
is computed for a promise, no matter how many times it is forced.

@example
(define count 0)
(define p
  (delay (begin (set! count (+ count 1))
                (if (> count x)
                    count
                    (force p)))))
(define x 5)
p                     =>  a promise
(force p)             =>  6
p                     =>  a promise, still
(begin (set! x 10)
       (force p))     =>  6
@end example

Here is a possible implementation of @func{delay} and @func{force}.
Promises are implemented here as procedures of no arguments, and
@func{force} simply calls its argument:

@example
(define force
  (lambda (object)
    (object)))
@end example

The expression:

@example
(delay @hyper{expression})
@end example

@noindent
has the same meaning as the procedure call:

@example
(make-promise (lambda () @hyper{expression}))
@end example

@noindent
as follows:

@example
(define-syntax delay
  (syntax-rules ()
    ((delay expression)
     (make-promise (lambda () expression)))))
@end example

@noindent
where @func{make-promise} is defined as follows:

@example
(define make-promise
  (lambda (proc)
    (let ((result-ready?  #f)
          (result         #f))
      (lambda ()
        (if result-ready?
            result
            (let ((x (proc)))
              (if result-ready?
                  result
                  (begin (set! result-ready? #t)
                         (set! result x)
                         result))))))))
@end example
@end deffn


@deffn Procedure null-environment @var{n}
@var{n} must be the exact integer object 5.

The @func{null-environment} procedure returns an environment specifier
suitable for use with @func{eval} representing an environment that is
empty except for the (syntactic) bindings for all keywords described in
the previous revision of this report, including bindings for @code{=>},
@code{...}, @code{else}, and @code{_} that are the same as those in the
@rsixlibrary{base} library.
@end deffn


@deffn Procedure scheme-report-environment @var{n}
@var{n} must be the exact integer object 5.

The @func{scheme-report-environment} procedure returns an environment
specifier for an environment that is empty except for the bindings for
the identifiers described in the previous revision of this report,
omitting @func{load}, @func{interaction-environment},
@func{transcript-on}, @func{transcript-off}, and @func{char-ready?}.

The variable bindings have as values the procedures of the same names
described in this report, and the keyword bindings, including @code{=>},
@code{...}, @code{else}, and @code{_} are the same as those described in
this report.
@end deffn


@c ------------------------------------------------------------




@c page
@c ------------------------------------------------------------
@c End of lowersections for the standard libraries chapter.
@c ------------------------------------------------------------

@raisesections


@c page
@node ikaruslib
@chapter The Ikarus library


@noindent
In addition to the libraries listed in the @rnrs{6} standard, Ikarus
contains the @library{ikarus} library which provides additional useful
features.  The @library{ikarus} library is a composite library---it
exports a superset of all the supported bindings of @rnrs{6}.  While not
all of the exports of @code{(ikarus)} are documented at this time, this
chapter attempts to describe a few of these useful extensions.
Extensions to Scheme's lexical syntax are also documented.

@menu
* ikaruslib cross::             Writing cross--implementation libraries.
* ikaruslib reader::            Reader.
* ikaruslib cafe::              Cafe.
* ikaruslib environment::       Environments.
* ikaruslib load::              Loading source files.
* ikaruslib import::            Local library imports.
* ikaruslib modules::           Local modules.
* ikaruslib parameters::        Parameters.
* ikaruslib gensym::            Gensyms.
* ikaruslib printing::          Printing.
* ikaruslib tracing::           Tracing.
* ikaruslib timing::            Timing.
* ikaruslib guardians::         Guardians.
* ikaruslib io::                Input/output library.
* ikaruslib posix::             @posix{} functions.
* ikaruslib foreign::           Foreign interface library.
* ikaruslib misc::              Miscellaneous functions.
@end menu



@c page
@node ikaruslib cross
@section Writing cross--implementation libraries


@noindent
When searching for a library, Ikarus appends a suffix to the appropriate
file pathname; the initial set of suffixes is:

@ignore
Wed Oct 22, 2008: notice that these extensions are in the files
"scheme/ikarus.main.ss" and "psyntax.library-manager.ss".
@end ignore
@example
/main.ikarus.sls
/main.ikarus.ss
/main.ikarus.scm
/main.sls
/main.ss
/main.scm
.ikarus.sls
.ikarus.ss
.ikarus.scm
.sls
.ss
.scm
@end example

This list of file suffixes is iterated sequentially.  As a consequence,
files ending with the @code{.ikarus.*} suffixes are given precedence
over files that have generic Scheme extensions.  The rationale for this
behaviour is to facilitate writing cross--implementation libraries: ones
that take advantage of implementation--specific features, while at the
same time to provide a fail--safe alternative for other @rnrs{6}
implementations.

Consider for example a program which would like to use the
@func{pretty-print} procedure to format some code, and suppose further
that pretty printing is just a nice add--on (e.g. using @file{write}
suffices, but pretty--printing is @emph{just prettier}) Ikarus exports a
good pretty--printing facility in its @library{ikarus} library.
However, since @func{pretty-print} is not a standard procedure, a
program that uses it would be rendered unportable to other @rnrs{6}
Scheme implementations.

The programmer can put the @code{.ikarus.*} extensions to use in this
situation, by writing two versions of a @library{pretty-printing}
library: one for use by Ikarus, and one portable for other
implementations.

@example
;; pretty-printing.ikarus.ss --
;;
;; Can be used only by Ikarus Scheme.

(library (pretty-printing)
  (export pretty-print)
  (import (only (ikarus) pretty-print)))

;;; end of file
@end example

@example
;; pretty-printing.sls --
;;
;; For any other Scheme implementation, portable though
;; not very pretty.

(library (pretty-printing)
  (export pretty-print)
  (import (rnrs))
  (define (pretty-print x port)
    (write x port)
    (newline port)))

;;; end of file
@end example

The @code{/main.*} suffixes serve a different purpose.  Often, a set of
libraries is distributed in a single package and it is convenient for
the programmer to group related files in directories.  If a package
contains the libraries @library{foo}, @library{foo core}, and
@library{foo compat}, then putting all such library files together in
one directory makes it easier to package, install, and remove these
libraries en masse.  The layout of the package would look like:

@example
foo/README              :              ignored by Ikarus
foo/COPYING             :
foo/main.ss             : (foo)        implementation independent
foo/core.ss             : (foo core)
foo/compat.ss           : (foo compat) default @rnrs{6} library
foo/compat.ikarus.ss    :              specific for Ikarus
foo/compat.mzscheme.ss  :              specific for MzScheme
@end example


@c page
@node ikaruslib reader
@section Reader


@deffn {Reader Syntax} {#!ikarus}
Ikarus extends Scheme's lexical syntax (@rnrs{6} Chapter 4) in a variety
of ways including:

@itemize
@item
end--of--file marker, @code{#!eof};

@item
gensym syntax, @code{#@{gensym@}};

@item
graph syntax, @code{#nn= #nn#}.
@end itemize

The syntax extensions are made available by default on all input ports,
until the @code{#!r6rs} token is read.  Thus, reading the @code{#!r6rs}
token disables all extensions to the lexical syntax on the specific
port, and the @code{#!ikarus} enables them again.

When writing code that is intended to be portable across different
Scheme implementations, we should add the @code{#!r6rs} token to the top
of every script and library that you write; this allows Ikarus to alert
us when using non--portable features.  When writing code that's intended
to be Ikarus--specific, we should add the @code{#!ikarus} token in order
to get an immediate error when the code is run under other
implementations.
@end deffn


@deffn Procedure port-mode @var{input-port}
Accept an input port as argument and return a symbol among
@code{r6rs-mode} and @code{ikarus-mode} as result.  All input ports
start under @code{ikarus-mode} and thus accept Ikarus--specific reader
extensions.  When the @code{#!r6rs} token is read from a port, its mode
changes to @code{ikarus-mode}.

@example
> (port-mode (current-input-port))
ikarus-mode
> #!r6rs (port-mode (current-input-port))
r6rs-mode
> #!ikarus (port-mode (current-input-port))
ikarus-mode
@end example
@end deffn


@deffn Procedure set-port-mode! @var{input-port} @var{mode}
Modifiy the lexical syntax accepted by subsequent calls to @func{read}
on the input port.  The mode is a symbol among @code{r6rs-mode} and
@code{ikarus-mode}.  The effect of setting the port mode is similar to
that of reading the @code{#!r6rs} or @code{#ikarus} from that port.

@example
> (set-port-mode! (current-input-port) 'r6rs-mode)
> (port-mode (current-input-port))
r6rs-mode
@end example
@end deffn


@deffn {Reader Syntax} {#!eof}
The end--of--file marker, @code{#!eof}, is an extension to the @rnrs{6}
syntax.  The primary utility of the @code{#!eof} marker is to stop the
reader (e.g. @func{read} and @func{get-datum}) from reading the rest of
the file.

@example
#!/usr/bin/env scheme-script
(import (ikarus))
<some code>
(display "goodbye\n")

#!eof
<some junk>
@end example

The @code{#!eof} marker also serves as a datum in Ikarus, much like
@true{} and @false{}, when it is found inside other expressions.

@example
> (eof-object)
#!eof
> (read (open-input-string ""))
#!eof
> (read (open-input-string "#!eof"))
#!eof
> (quote #!eof)
#!eof
> (eof-object? '#!eof)
#t
> #!r6rs #!eof
Unhandled exception
Condition components:
  1. &error
  2. &who: tokenize
  3. &message: "invalid syntax: #!e"
> #!ikarus #!eof
$
@end example
@end deffn


@c page
@node ikaruslib cafe
@section Cafe


@defun new-cafe @var{eval}
The procedure @func{new-cafe} starts a new read--eval--print loop inside
the current cafe (if one exists).  It prompts the user for an
expression, evaluates it, prints the result back, and repeats the
process.  If @func{new-cafe} is called with an argument, @var{eval},
then that argument must be a procedure that takes a single argument.
The eval procedure will be used to evaluate the expressions.

Every time a new cafe is started, the prompt is changed to reflect the
depth of the current cafe (i.e. how many eof objects is takes to exit
the outermost cafe).

Input and output performed by the cafe can be changed by the
@func{console-input-port} and @func{console-output-port} parameters.

If a @func{die} occurs during reading, evaluating, or printing an
expression, then the die is printed to the error--port and the
operations of the cafe resume as normal.

To exit from a cafe we can write the @code{#!eof} object.
@end defun




@c page
@node ikaruslib environment
@section Environments


@cindex Environment, interaction


@defun interaction-environment
Return an environment object representing the environment active at the
@repl{}.  To be used as argument for @func{eval}.

@unstable{1661}
@end defun



@c page
@node ikaruslib load
@section Loading source files


Loading of source files can be done explicitly or by requesting a
library with the @func{import} form.  Here we see how to load files by
specifying their pathname on the file system.


@defun load @var{pathname} [@var{eval-proc}]
Read and evaluate the file selected by the string @var{pathname}.

If @var{eval-proc} is given: it must be a procedure that takes a single
argument, an annotated form, and evaluates it.  The default
@var{eval-proc} looks like this:

@example
(define (load-handler x)
  (eval x (interaction-environment)))
@end example

The format of the annotated source is the one which is comprehensible by
@func{eval}.
@end defun



@c page
@node ikaruslib import
@section Local library imports


@deffn Syntax import import-spec* ...
The @func{import} keyword which is exported from the @code{(ikarus)}
library can be used anywhere definitions can occur: at a script body,
library's top--level, or in internal definitions context.  The syntax of
the local @func{import} form is similar to the @func{import} that
appears at the top of a library or a script form, and carries with it
the same restrictions: no identifier name may be imported twice unless
it denotes the same identifier; no identifier may be both imported and
defined; and imported identifiers are immutable.

Local @func{import} forms are useful for two reasons: (1) they minimize
the namespace clutter that usually occurs when many libraries are
imported at the top level, and (2) they limit the scope of the import
and thus help modularize a library's dependencies.

Suppose you are constructing a large library and at some point you
realize that one of your procedures needs to make use of some other
library for performing a specific task.  Importing that library at top
level makes it available for the entire library.  Consequently, even if
that library is no longer used anywhere in the code (say when the code
that uses it is deleted), it becomes very hard to delete the import
without first examiniming the entire library body for potential usage
leaks.  By locally importing a library into the appropriate scope, we
gain the ability to delete the @func{import} form when the procedure
that was using it is deleted.
@end deffn



@c page
@node ikaruslib modules
@section Local modules


@unstable{1661}


Modules are somewhat like libraries in that they define a set of
bindings in a ``private namespace''; bindings can be exported from a
module and imported into other modules and libraries.  The main
difference between modules and @rnrs{6} libraries is that modules are
defined in a single form nested into a library; so, in a way, they are
sub--libraries.

@quotation
@emph{Note:} In the official documentation of Ikarus 0.0.3+ (revision
1648) modules are yet not documented.  Please refer to Section 10.5 of
Chez Scheme User's Guide, Chapter 3 of Oscar Waddel's Ph.D Thesis, and
its POPL99 paper for details on using the @func{module} and
@func{import} keywords.  Ikarus's internal module system is similar in
spirit to that of Chez Scheme.
@end quotation


@menu
* ikaruslib modules examples::  Usage example for modules.
* ikaruslib modules api::       Modules programming interface.
@end menu


@c page
@node ikaruslib modules examples
@subsection Usage example for modules


@menu
* ikaruslib modules examples anonymous::        Anonymous modules.
* ikaruslib modules examples named::            Named modules.
* ikaruslib modules examples utils::            Utilities examples.
@end menu


@c page
@node ikaruslib modules examples anonymous
@subsubsection Anonymous modules


@unstable{1661}


The following example defines an anonymous module, without expressions,
and invokes its functions from the enclosing environment (which is the
top level):

@example
(import (ikarus))

[module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden)]

(printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three))
@end example

@noindent
notice that the @func{hidden} function is visible inside the module but
not in the enclosing environment.

The following example defines a module, with expressions, and invokes
its functions from the enclosing environment (which is the top level):

@example
(import (ikarus))

[module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (cons 'three (hidden)))
    (define (hidden)    'hidden)

    (printf "defining an anonymous module~%")]

(printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three))
@end example

@noindent
notice that when the enclosing environment is the top level: the
expressions at the end of a module are evaluated @strong{after} the
expressions at the top level; so the output from the example is:

@example
calling anonymous: one two (three . hidden)
defining an anonymous module
@end example

@noindent
this can lead to undesired results if the module's expressions are meant
to initialise the state of the module, and the expressions at the top
level invoke the module's functions (before initialisation).  On the
other hand: this behaviour allows the module to access definitions from
the enclosing environment and the top level environment despite their
placement in the file; see below for an example.  The same behaviour is
shown by named modules.

The following example defines a module, with expressions, and invokes
its functions from the enclosing environment (which is a @func{let}
form):

@example
(import (ikarus))

(let ()
  [module (one two three)
      (define (one)       'one)
      (define (two)       'two)
      (define (three)     (cons 'three (hidden)))
      (define (hidden)    'hidden)

      (printf "defining an anonymous module~%")]

  (printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three)))
@end example

@noindent
notice that when the enclosing environment is @strong{not} the top
level: the expressions at the end of a module are evaluated
@strong{before} the expressions in the body of the enclosing
environment; so the output from the example is:

@example
defining an anonymous module
calling anonymous: one two (three . hidden)
@end example

@noindent
so the state of the module can be correctly initialised before its
functions are invoked.  The same behaviour is shown by named modules.

The following example shows that bindings from the enclosing environment
and the top level environment are accessible from the modules:

@example
(import (ikarus))

(define (top-level-before) 'top-level-before)

(let ()

  (define (outer-before) 'outer-before)

  [module (one two three)
    (define (one)       'one)
    (define (two)       'two)
    (define (three)     (list 'three
                              (outer-before)
                              (outer-after)
                              (top-level-before)
                              (top-level-after)))]

  (define (outer-after) 'outer-after)

  (printf "calling anonymous: ~s ~s ~s~%" (one) (two) (three)))

(define (top-level-after) 'top-level-after)
@end example

@noindent
this happens both when the enclosing environment is the top level and
when the enclosing environment is not the top level.  The same behaviour
is shown by named modules.



@c page
@node ikaruslib modules examples named
@subsubsection Named modules


The following example defines a module named @code{blue} and invokes
functions from it in the top level environment:

@example
(import (ikarus))

[module blue (blue-one blue-two blue-three)
    (define (blue-one)          'blue-one)
    (define (blue-two)          'blue-two)
    (define (blue-three)        (cons 'blue-three (hidden)))
    (define (hidden)            'blue-hidden)]

(import blue)
(printf "calling blue: ~s ~s ~s~%"
        (blue-one) (blue-two) (blue-three))
@end example

@noindent
notice that bindings from a named module are accessible only if imported
in the enclosing environment.

The following example defines two modules named @code{green} and
@code{red}, then it imports their bindings in different environments:

@example
(import (ikarus))

(let ()

  [module green (one two three)
    (define (one)       'green-one)
    (define (two)       'green-two)
    (define (three)     (cons 'green-three (hidden)))
    (define (hidden)    'green-hidden)]

  [module red (one two three)
    (define (one)       'red-one)
    (define (two)       'red-two)
    (define (three)     (cons 'red-three (hidden)))
    (define (hidden)    'red-hidden)]

  (import green)

  [let ()
    (import red)
    (printf "calling red: ~s ~s ~s~%" (one) (two) (three))]

  (printf "calling green: ~s ~s ~s~%" (one) (two) (three)))
@end example

The following example shows that modules in the same enclosing
environment can import their bindings:

@example
(import (ikarus))

(let ()

  [module green (one two)
    (define (one)       'one)
    (define (two)       'two)]

  [module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
while the following example shows that bindings from an anonymous module
are automatically available in modules defined in the same enclosing
environment:

@example
(import (ikarus))

(let ()

  [module (one two)
    (define (one)       'one)
    (define (two)       'two)]

  [module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
and the following example shows that the order of module definitions
does not matter in determining visibility of bindings from
@strong{anonymous} modules:

@example
(import (ikarus))

(let ()

  [module red (f g)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  [module (one two)
    (define (one)       'one)
    (define (two)       'two)]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example

@noindent
the following is an @strong{error} because it tries to import bindings
from a @strong{named} module before its definition:

@example
(import (ikarus))

(let ()

  [module red (f g)
    (import green)
    (define (f)         (cons 'f (one)))
    (define (g)         (cons 'g (two)))]

  [module green (one two)
    (define (one)       'one)
    (define (two)       'two)]

  (import red)
  (printf "calling red: ~s ~s~%" (f) (g)))
@end example



@c page
@node ikaruslib modules examples utils
@subsubsection Utilities examples


The following example shows how syntactic abstractions can be used to
access definitions in a module without using the @func{import} form:

@example
(import (ikarus))

(let ()

  (define-syntax in-module
    (syntax-rules ()
      [(_ ?module ?expr ...)
       (let () (import ?module) ?expr ...)]))

  [module red (one two)
    (define (one arg)   (cons 'red-one arg))
    (define (two arg)   (cons 'red-two arg))]

  [module green (one two)
    (define (one arg)   (cons 'green-one arg))
    (define (two arg)   (cons 'green-two arg))]

  (printf "calling ones: ~s ~s~%"
          [(in-module red one)   123]
          [(in-module green one) 456]))
@end example



@c page
@node ikaruslib modules api
@subsection Modules programming interface


@deffn Syntax module @var{interface} @var{definitions} ... @var{expressions} ...
@deffnx Syntax module @var{name} @var{interface} @var{definitions} ... @var{expressions} ...
Define a new local module.  The first form defines an @emph{anonymous}
module, while the second form defines a @emph{named} module called
@var{name}, which must be a symbol.

@var{interface} is a list of symbols that select bindings from this
module to be exported.  Every listed symbol must be bound in this
module's @var{definitions}, otherwise an error is raised.

@var{definitions} is a set of bindings like the one that may appear at
the beginning of a @func{let} body, with the addition of @func{import}
forms that may import bindings from libraries and other modules.

@var{expressions} is a set of expressions that is evaluated at module's
definition time.

Modules ``exist'' only in the enclosing region, bindings exported from a
module are not accessible outside of the enclosing region.  Modules can
be nested and import/export relations are possible according to the
regions nesting hierarchy.

Bindings in the @var{interface} declared by anonymous modules are
imported by default in the enclosing region: there is no need to use
@func{import}.  Bindings in the @var{interface} declared by named
modules are visible only in regions that @func{import} the module.

@var{definitions} and @var{expressions} have no default access to the
bindings in the enclosing region; only imported bindings are visible
from the module.
@end deffn



@c page
@node ikaruslib parameters
@section Parameters


@noindent
Parameters in Ikarus@footnote{Parameters are found in many Scheme
implementations such as Chez Scheme and MzScheme.} are intended for
customizing the behavior of a procedure during the dynamic execution of
some piece of code.  Parameters are first class entities (represented as
procedures) that hold the parameter value.  A parameter procedure
accepts either zero or one argument.  If given no arguments, it returns
the current value of the parameter.  If given a single argument, it must
set the state to the value of the argument.

Parameters replace the older concept of using starred @code{*global*}
customization variables.  For example, instead of writing:

@example
(define *screen-width* 72)
@end example

@noindent
and then mutating the variable @code{*screen-width*} with @code{set!},
we could wrap the variable @code{*screen-width*} with a
@code{screen-width} parameter as follows:

@example
(define *screen-width* 72)
(define screen-width
   (case-lambda
     [()  *screen-width*]
     [(x) (set! *screen-width* x)]))
@end example

The value of @code{screen-width} can now be passed as argument, returned
as a value, and exported from libraries.


@deffn Procedure make-parameter @var{x}
@deffnx Procedure make-parameter @var{x} @var{f}
As parameters are common in Ikarus, the procedure @func{make-parameter}
is defined to model the common usage pattern of parameter construction.

@code{(make-parameter x)} constructs a parameter with @var{x} as the
initial value.  For example, the code above could be written succinctly
as:

@example
(define screen-width (make-parameter 72))
@end example

@code{(make-parameter x f)} constructs a parameter which filters the
assigned values through the procedure @var{f}.  The initial value of the
parameter is the result of calling @code{(f x)}.  Typical uses of the
filter procedure include checking some constraints on the passed
argument or converting it to a different data type.  The
@code{screen-width} parameter may be constructed more robustly as:

@example
(define screen-width
  (make-parameter 72
    (lambda (w)
      (assert (and (integer? w) (exact? w)))
      (max w 1))))
@end example

This definition ensures, through @func{assert}, that the argument passed
is an exact integer.  It also ensures, through @func{max} that the
assigned value is always positive.
@end deffn


@deffn Syntax parameterize ([lhs* rhs*] ...) body body* ...
Parameters can be assigned to by simply calling the parameter procedure
with a single argument.  The @func{parameterize} syntax is used to set
the value of a parameter within the dynamic extent of the @code{body
body* ...} expressions.

The @code{lhs* ...} are expressions, each of which must evaluate to a
parameter.  Such parameters are not necessarily constructed by
@func{make-parameter}---any procedure that follows the parameters
protocol works.

The advantage of using @func{parameterize} over explicitly assigning to
parameters (same argument applies to global variables) is that you're
guaranteed that whenever control exits the body of a @func{parameterize}
expression, the value of the parameter is reset back to what it was
before the body expressions were entered.  This is true even in the
presence of @func{call/cc}, errors, and exceptions.

The following example shows how to set the text property of a terminal
window.  The parameter @code{terminal-property} sends an @ansi{} escape
sequence to the terminal whenever the parameter value is changed.  The
use of @code{terminal-property} within @func{parameterize} changes the
property before @code{(display "RED!")} is called and resets it back to
normal when the body returns.

@example
(define terminal-property
  (make-parameter "0"
    (lambda (x)
      (display "\x1b;[")
      (display x)
      (display "m")
      x)))

(display "Normal and ")
(parameterize ([terminal-property "41;37"])
  (display "RED!"))
(newline)
@end example
@end deffn



@c page
@node ikaruslib gensym
@section Gensyms


@noindent
Gensym stands for @emph{generated symbol}---a fresh symbol that is
generated at run time and is guaranteed to be @emph{not} @func{eq?} to
any other symbol present in the system.  Gensyms are useful in many
applications including expanders, compilers, and interpreters when
generating an arbitrary number of unique names is needed.

Ikarus is similar to Chez Scheme in that the readers (including the
@func{read} procedure) and writers (including @func{write} and
@func{pretty-print}) maintain the read/write invariance on gensyms.
When a gensym is written to an output port, the system automatically
generates a random unique identifier for the gensym.  When the gensym is
read back though the @code{#@{gensym@}} read syntax, a new gensym is
@emph{not} regenerated, but instead, it is looked up in the global
symbol table.

A gensym's name is composed of two parts: a @emph{pretty} string and a
@emph{unique} string.  The Scheme procedure @func{symbol->string}
returns the pretty string of the gensym and not its unique string.
Gensyms are printed by default as @code{#@{pretty-string unique-string@}}.


@deffn Procedure gensym
@deffnx Procedure gensym @var{string}
@deffnx Procedure gensym @var{symbol}
Construct a new gensym.  If passed no arguments, construct a gensym with
no pretty name.  The pretty name is constructed when and if the pretty
name of the resulting gensym is needed.  If @func{gensym} is passed a
string, that string is used as the pretty name.  If @func{gensym} is
passed a symbol, the pretty name of the symbol is used as the pretty
name of the returned gensym.  See @func{gensym-prefix} and
@func{gensym-count} for details.

@example
> (gensym)
#@{g0 |y0zf>GlFvcTJE0xw|@}
> (gensym)
#@{g1 |U%X&sF6kX!YC8LW=|@}
> (eq? (gensym) (gensym))
#f
@end example

@code{(gensym string)} constructs a new gensym with @var{string} as its
pretty name.  Similarly, @code{(gensym symbol)} constructs a new gensym
with the pretty name of @var{symbol}, if it has one, as its pretty name.

@example
> (gensym "foo")
#@{foo |>VgOllCM&$dSvRN=|@}
> (gensym 'foo)
#@{foo |!TqQLmtw2hoEYfU>|@}
> (gensym (gensym 'foo))
#@{foo |N2C>5O0>C?OROUBU|@}
@end example
@end deffn


@deffn Procedure gensym? @var{x}
Return @true{} if its argument is a gensym, return @false{} otherwise.

@example
> (gensym? (gensym))
#t
> (gensym? 'foo)
#f
> (gensym? 12)
#f
@end example
@end deffn


@deffn Procedure gensym->unique-string @var{gensym}
Return the unique name associated with the gensym argument.

@example
> (gensym->unique-string (gensym))
"YukrolLMgP?%ElcR"
@end example
@end deffn


@deffn {Reader Syntax} {#@{gensym@}}
@deffnx {Reader Syntax} {#@{unique-name@}}
@deffnx {Reader Syntax} {#@{pretty-name unique-name@}}
@deffnx {Reader Syntax} {#:pretty-name}
Ikarus's @func{read} and @func{write} procedures extend the lexical
syntax of Scheme by the ability to read and write gensyms using one of
these three forms.

@code{#@{unique-name@}} constructs, at read time, a gensym whose unique
name is the one specified.  If a gensym with the same unique name
already exists in the system's symbol table, that gensym is returned.

@example
> '#@{some-long-name@}
#@{g0 |some-long-name|@}
> (gensym? '#@{some-long-unique-name@})
#t
> (eq? '#@{another-unique-name@} '#@{another-unique-name@})
#t
@end example

The two--part @code{#@{pretty-name unique-name@}} gensym syntax is
similar to the syntax shown above with the exception that if a new
gensym is constructed (that is, if the gensym did not already exist in
the symbol table), the pretty name of the constructed gensym is set to
@code{pretty-name}.

@example
> '#@{foo unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{unique-identifier@}
#@{foo |unique-identifier|@}
> '#@{bar unique-identifier@}
#@{foo |unique-identifier|@}
@end example

The @code{#:pretty-name} form constructs, at read time, a gensym whose
pretty name is @code{pretty-name} and whose unique name is fresh.  This
form guarantees that the resulting gensym is not @func{eq?} to any other
symbol in the system.

@example
> '#:foo
#@{foo |j=qTGlEwS/Zlp2Dj|@}
> (eq? '#:foo '#:foo)
#f
@end example
@end deffn


@c ------------------------------------------------------------

@subsection An example


@noindent
The @library{rnrs syntax-case} library provides a
@func{generate-temporaries} procedure, which takes a syntax object
(representing a list of things) and returns a list of fresh identifiers.
Using @func{gensym}, that procedure can be defined as follows:

@example
(define (generate-temporaries* stx)
  (syntax-case stx ()
    [(x* ...)
     (map (lambda (x)
            (datum->syntax #'unimportant
              (gensym
                (if (identifier? x)
                    (syntax->datum x)
                    't))))
          #'(x* ...))]))
@end example

The above definition works by taking the input @var{stx} and
destructuring it into the list of syntax objects @code{x* ...}.  The
inner procedure maps each @var{x} into a new syntax object (constructed
with @func{datum->syntax}).  The datum is a gensym, whose name is the
same name as @var{x} if @var{x} is an identifier, or the symbol @code{t}
if @var{x} is not an identifier.  The output of
@func{generate-temporaries*} generates names similar to their input
counterpart:

@example
> (print-gensym #f)
> (generate-temporaries* #'(x y z 1 2))
(#<syntax x> #<syntax y> #<syntax z> #<syntax t> #<syntax t>)
@end example


@c page
@node ikaruslib printing
@section Printing


@deffn Procedure pretty-print @var{datum}
@deffnx Procedure pretty-print @var{datum} @var{output-port}
The procedure @func{pretty-print} is intended for printing Scheme data,
typically Scheme programs, in a format close to how a Scheme programmer
would write it.  Unlike @func{write}, which writes its input all in one
line, @func{pretty-print} inserts spaces and new lines in order to
produce more pleasant output.

@example
(define fact-code
  '(letrec ([fact (lambda (n)
                    (if (zero? n)
                        1
                      (* n (fact (- n 1)))))])
     (fact 5)))

> (pretty-print fact-code)
(letrec ((fact
          (lambda (n) (if (zero? n) 1 (* n (fact (- n 1)))))))
  (fact 5))
@end example

The second argument to @func{pretty-print}, if supplied, must be an
output port.  If not supplied, the @func{current-output-port} is used.

@quotation
@emph{Limitations:} As shown in the output above, the current
implementation of @func{pretty-print} does not handle printing of square
brackets properly.
@end quotation
@end deffn


@deffn Parameter pretty-width
@deffnx Parameter pretty-width @var{n}
The parameter @func{pretty-width} controls the number of characters
after which the @func{pretty-print} starts breaking long lines into
multiple lines.  The initial value of @func{pretty-width} is set to 60
characters, which is suitable for most terminals and printed material.

@example
> (parameterize ([pretty-width 40])
     (pretty-print fact-code))
(letrec ((fact
          (lambda (n)
            (if (zero? n)
                1
                (* n (fact (- n 1)))))))
  (fact 5))
@end example

Note that @func{pretty-width} does not guarantee that the output will
not extend beyond the specified number.  Very long symbols, for
examples, cannot be split into multiple lines and may force the printer
to go beyond the value of @func{pretty-width}.
@end deffn


@deffn Procedure format @var{fmt-string} @var{args} ...
The procedure @func{format} produces a string formatted according to
@func{fmt-string} and the supplied arguments.  The format string
contains markers in which the string representation of each argument is
placed.  The markers include:

@table @code
@item ~s
instructs the formatter to place the next argument as if the procedure
@func{write} has printed it; if the argument contains a string, the
string will be quoted and all quotes and backslashes in the string will
be escaped; similarly, characters will be printed using the @code{#\x}
notation;

@item ~a
instructs the formatter to place the next argument as if the procedure
@func{display} has printed it; strings and characters are placed as they
are in the output;

@item ~b
instructs the formatter to convert the next argument to its binary (base
2) representation; the argument must be an exact number;

@item ~o
is similar to @code{~b} except that the number is printed in octal (base
8);

@item ~x
is similar to @code{~b} except that the number is printed in hexadecimal
(base 16);

@item ~d
outputs the next argument, which can be an exact or inexact number, in
its decimal (base 10) representation;

@item ~~
instructs the formatter to place a tilde character, @code{~}, in the
output without consuming an argument;

@item ~%
instructs the formatter to place a newline character in the output
without consuming an argument.
@end table

Note that the @code{#b}, @code{#o}, and @code{#x} numeric prefixes are
not added to the output when @code{~b}, @code{~o}, and @code{~x} are
used.

@example
> (format "message: ~s, ~s, and ~s" 'symbol "string" #\c)
"message: symbol, \"string\", and #\\c"

> (format "message: ~a, ~a, and ~a" 'symbol "string" #\c)
"message: symbol, string, and c"
@end example
@end deffn


@deffn Procedure printf @var{fmt-string} @var{args} ...
The procedure @func{printf} is similar to @func{format} except that the
output is sent to the @code{current-output-port} instead of being
collected in a string.

@example
> (let ([n (+ (expt 2 32) #b11001)])
    (printf "~d = #b~b = #x~x\n" n n n))
4294967321 = #b100000000000000000000000000011001 = #x100000019
@end example
@end deffn


@deffn Procedure fprintf @var{output-port} @var{fmt-string} @var{args} ...
The procedure @func{fprintf} is similar to @func{printf} except that the
output port to which the output is sent is specified as the first
argument.
@end deffn


@deffn Parameter print-graph
@deffnx Parameter print-graph #t
@deffnx Parameter print-graph #f
The graph notation is a way of marking and referencing parts of a data
structure and, consequently, creating shared and cyclic data structures
at read time instead of resorting to explicit mutation at run time.  The
@code{#n=} marks the following data structure with mark @var{n}, where
@var{n} is a nonnegative integer.  The @code{#n#} references the data
structure marked @var{n}.  Marks can be assigned and referenced in any
order but each mark must be assigned to exactly once in an expression.

@example
> (let ([x '#0=(1 2 3)])
    (eq? x '#0#))
#t
> (let ([x '#0#] [y '#0=(1 2 3)])
    (eq? x y))
#t
> (eq? (cdr '(12 . #1#)) '#1=(1 2 3))
#t
> (let ([x '#1=(#1# . #1#)])
    (and (eq? x (car x))
         (eq? x (cdr x))))
#t
@end example

The @func{print-graph} parameter controls how the writers (e.g.
@func{pretty-print} and @func{write}) handle shared and cyclic data
structures.  In Ikarus, all writers detect cyclic data structures and
they all terminate on all input, cyclic or otherwise.

If the value of @func{print-graph} is set to @false{} (the default),
then the writers do not attempt to detect shared data structures.  Any
part of the input that is shared is printed as if no sharing is present.
If the value of @func{print-graph} is set to @true{}, all sharing of
data structures is marked using the @code{#n=} and @code{#n#} notation.

@example
> (parameterize ([print-graph #f])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
((1 2 3 4) (1 2 3 4) (1 2 3 4))

> (parameterize ([print-graph #t])
    (let ([x (list 1 2 3 4)])
      (pretty-print (list x x x))))
(#0=(1 2 3 4) #0# #0#)

> (parameterize ([print-graph #f])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=((1 2) (1 2) (1 2) #0#) #0#)

> (parameterize ([print-graph #t])
    (let ([x (list 1 2)])
      (let ([y (list x x x x)])
        (set-car! (last-pair y) y)
        (pretty-print (list y y)))))
(#0=(#1=(1 2) #1# #1# #0#) #0#)
@end example
@end deffn


@deffn Parameter print-unicode
@deffnx Parameter print-unicode #t
@deffnx Parameter print-unicode #f
Unstable.
@end deffn


@deffn Parameter print-gensym
@deffnx Parameter print-gensym #t
@deffnx Parameter print-gensym #f
@deffnx Parameter print-gensym 'pretty
The parameter @code{print-gensym} controls how gensyms are printed by
the various writers.

If the value of @code{print-gensym} is @false{}, then gensym syntax is
suppressed by the writers and only the gensyms' pretty names are
printed.  If the value of @code{print-gensym} is @true{}, then the full
@code{#@{pretty unique@}} syntax is printed.  Finally, if the value of
@code{print-gensym} is the symbol @code{pretty}, then gensyms are
printed using the @code{#:pretty} notation.

@example
> (parameterize ([print-gensym #f])
    (pretty-print (list (gensym) (gensym))))
(g0 g1)

> (parameterize ([print-gensym #t])
    (pretty-print (list (gensym) (gensym))))
(#@{g2 |KR1M2&CTt1<B0n/m|@} #@{g3 |FBAb&7NC6&=c82!O|@})

> (parameterize ([print-gensym 'pretty])
    (pretty-print (list (gensym) (gensym))))
(#:g4 #:g5)
@end example

The initial value of @code{print-gensym} is @true{}.

@end deffn


@deffn Parameter gensym-prefix
@deffnx Parameter gensym-prefix @var{string}
The parameter @code{gensym-prefix} specifies the string to be used as
the prefix to generated pretty names.  The default value of
@code{gensym-prefix} is the string @code{g}, which causes generated
strings to have pretty names in the sequence @code{g0}, @code{g1},
@code{g2}, etc.

@example
> (parameterize ([gensym-prefix "var"]
                 [print-gensym #f])
     (pretty-print (list (gensym) (gensym) (gensym))))
(var0 var1 var2)
@end example

Beware that the @code{gensym-prefix} controls how pretty names are
generated, and has nothing to do with how @func{gensym} constructs a new
gensym.  In particular, notice the difference between the output in the
first example with the output of the examples below:

@example
> (pretty-print
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (list (gensym) (gensym) (gensym))))
(g3 g4 g5)

> (let ([ls (list (gensym) (gensym) (gensym))])
    (parameterize ([gensym-prefix "var"] [print-gensym #f])
      (pretty-print ls)))
(var5 var6 var7)
@end example
@end deffn


@deffn Parameter gensym-count
@deffnx Parameter gensym-count @var{n}
The parameter @code{gensym-count} determines the number which is
attached to the @code{gensym-prefix} when gensyms' pretty names are
generated.  The initial value of @code{gensym-count} is 0 and is
incremented every time a pretty name is generated.  It might be set to
any non-negative integer value.

@example
> (let ([x (gensym)])
    (parameterize ([gensym-count 100] [print-gensym #f])
      (pretty-print (list (gensym) x (gensym)))))
(g100 g101 g102)
@end example
@end deffn

Notice from all the examples so far that pretty names are generated in
the order at which the gensyms are printed, not in the order in which
gensyms were created.



@c page
@node ikaruslib tracing
@section Tracing


@deffn Syntax trace-define (name . args) body body* ...
@deffnx Syntax trace-define name expression
The @func{trace-define} syntax is similar to @func{define} except that
the bound value, which must be a procedure, becomes a traced procedure.
A traced procedure prints its arguments when it is called and prints its
values when it returns.

@example
> (trace-define (fact n)
    (if (zero? n) 1 (* n (fact (- n 1)))))
> (fact 5)
|(fact 5)
| (fact 4)
| |(fact 3)
| | (fact 2)
| | |(fact 1)
| | | (fact 0)
| | | 1
| | |1
| | 2
| |6
| 24
|120
120
@end example

The tracing facility in Ikarus preserves and shows tail recursion and
distinguishes it from non--tail recursion by showing tail calls starting
at the same line in which their parent was called.

@example
> (trace-define (fact n)
    (trace-define (fact-aux n m)
      (if (zero? n) m (fact-aux (- n 1) (* n m))))
    (fact-aux n 1))
> (fact 5)
|(fact 5)
|(fact-aux 5 1)
|(fact-aux 4 5)
|(fact-aux 3 20)
|(fact-aux 2 60)
|(fact-aux 1 120)
|(fact-aux 0 120)
|120
120
@end example

Moreover, the tracing facility interacts well with continuations and
exceptions.

@example
> (call/cc
    (lambda (k)
      (trace-define (loop n)
        (if (zero? n)
            (k 'done)
            (+ (loop (- n 1)) 1)))
      (loop 5)))
|(loop 5)
| (loop 4)
| |(loop 3)
| | (loop 2)
| | |(loop 1)
| | | (loop 0)
done
@end example
@end deffn


@deffn Syntax trace-lambda name args body body* ...
The @func{trace-lambda} macro is similar to @func{lambda} except that
the resulting procedure is traced: it prints the arguments it receives
and the results it returns.
@end deffn


@deffn Procedure make-traced-procedure @var{name} @var{proc}
The procedure @func{make-traced-procedure} takes a name (typically a
symbol) and a procedure.  It returns a procedure similar to @var{proc}
except that it traces its arguments and values.

@example
> (define (fact n)
    (if (zero? n)
        (lambda (k) (k 1))
        (lambda (k)
          ((fact (- n 1))
           (make-traced-procedure `(k ,n)
             (lambda (v)
               (k (* v n))))))))
> (call/cc
    (lambda (k)
      ((fact 5) (make-traced-procedure 'K k))))
|((k 1) 1)
|((k 2) 1)
|((k 3) 2)
|((k 4) 6)
|((k 5) 24)
|(K 120)
120
@end example
@end deffn



@c page
@node ikaruslib timing
@section Timing


This section describes some of Ikarus's timing facilities which may be
useful for benchmarking and performance tuning.


@deffn Syntax time @var{expression}
The @func{time} macro performs the following: it evaluates
@var{expression}, then prints a summary of the run time statistics, then
returns the values returned by @var{expression}.  The run--time summary
includes the number of bytes allocated, the number of garbage collection
runs, and the time spent in both the mutator and the collector.

@example
> (let ()                                   ;;; 10 million
    (define ls (time (vector->list (make-vector 10000000))))
    (time (append ls ls))
    (values))
running stats for (vector->list (make-vector 10000000)):
    3 collections
    672 ms elapsed cpu time, including 547 ms collecting
    674 ms elapsed real time, including 549 ms collecting
    120012328 bytes allocated
running stats for (append ls ls):
    4 collections
    1536 ms elapsed cpu time, including 1336 ms collecting
    1538 ms elapsed real time, including 1337 ms collecting
    160000040 bytes allocated
@end example

@quotation
@emph{Note:} The output listed above is @emph{just a sample} that was
taken at some point on some machine.  The output on your machine at the
time you read this may vary.
@end quotation
@end deffn


@deffn Procedure time-it @var{who} @var{thunk}
The procedure @func{time-it} takes a datum denoting the name of the
computation and a thunk (i.e. a procedure with no arguments), invokes
the thunk, prints the stats, and returns the values obtained from
invoking the thunk.  If the value of @var{who} is non--false, @var{who}
is used when displaying the run--time statistics.  If the value of
@var{who} is @false{}, then no name for the computation is displayed.

@example
> (time-it "a very fast computation"
    (lambda () (values 1 2 3)))
running stats for a very fast computation:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    24 bytes allocated
1
2
3

> (time-it #f (lambda () 12))
running stats:
    no collections
    0 ms elapsed cpu time, including 0 ms collecting
    0 ms elapsed real time, including 0 ms collecting
    0 bytes allocated
12
@end example
@end deffn



@c page
@node ikaruslib guardians
@section Guardians


Quoting @bibref{DYBGUA}:

@quotation
Guardians provide a means to protect objects from destruction by the
garbage collector.  A guardian is an object with which objects can be
registered for preservation and from which objects actually saved from
destruction can be retrieved, one at a time, at the convenience of the
program.
@end quotation

Guardians are available in the @library{ikarus} library.

@menu
* ikaruslib guardians examples::        Usage examples for guardians.
* ikaruslib guardians api::             Guardians programming interface.
@end menu


@c page
@node ikaruslib guardians examples
@subsection Usage examples for guardians


Let's say that we use the Ikarus @ffi{} to handle some memory block
(@ref{ikaruslib foreign} for details on the @ffi{}); memory blocks
allocated with @func{malloc} are not released by the Ikarus garbage
collector: we have to explicitly apply @func{free} to the pointer value
referencing them.

If we use the blocks synchronously with the evaluation of forms, we do:

@example
(import (ikarus)
        (ikarus foreign))

(define (do-something-with . args)
  (display args)
  (newline))

(let ([p        #f]
      [size     4096])
  (dynamic-wind
      (lambda ()
        (set! p (malloc size))
        (unless p (error "memory allocation")))
      (lambda ()
        (do-something-with p))
      (lambda ()
        (free p))))
@end example

@noindent
and we can define a syntax for it:

@example
(import (ikarus)
        (ikarus foreign))

(define (do-something-with . args)
  (display args)
  (newline))

(define-syntax with-block
  (syntax-rules ()
    [(_ ?pointer ?size ?body ...)
     (let ([?pointer    #f])
       (dynamic-wind
           (lambda ()
             (set! ?pointer (malloc ?size))
             (unless ?pointer (error "memory allocation")))
           (lambda ()
             ?body ...)
           (lambda ()
             (free ?pointer))))]))

(with-block p 2048
  (do-something-with p))

(with-block p 4096
  (do-something-with p))

(with-block p 8192
  (do-something-with p))
@end example

If we need the block in an event driven program: we will probably need
to use it asynchronously with the evaluation of forms.  For example, we
store the pointer value that references a block in a thunk (a closure
that takes no arguments):

@example
(import (ikarus)
        (ikarus foreign))

;; This queue does not scale.
(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        [reverse (cons event (reverse *event-source*))]))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ([event (car *event-source*)])
      (set! *event-source* (cdr *event-source*))
      event)))

;; Usage:

(define (do-something-with . args)
  (display args)
  (newline))

(let ([p (malloc 4096)])
  (unless p (error "memory allocation"))
  (enqueue-event (lambda ()
                   (do-something-with p)))
  (enqueue-event (lambda ()
                   (do-something-with 123)))
  (enqueue-event (lambda ()
                   (do-something-with p))))

(do ([event (pop-event) (pop-event)])
    ([not event])
  (event))
@end example

@noindent
once the thunks have been evaluated, the pointer value is garbage
collected, but the allocated memory block becomes leaked memory.  We
need a way to be notified of the pointer value garbage collection, so
that we can apply @func{free} to it; this is the job for guardians.

The following script shows the usage of a guardian to free a memory
block:

@example
(import (ikarus)
        (ikarus foreign))

(define g (make-guardian))

(let ([a (malloc (expt 2 20))])
  (unless p (error "memory allocation"))
  (g a)
  (printf "value ~s~%" a))

(printf "value from guardian ~s~%" (g))

;; This triggers a garbage collection (do not ask).
(foreign-call "ik_collect" 5)

(let ([p (g)])
  (printf "value from guardian ~s~%" p)
  (free p))
@end example

In an event driven program what we have to do is to register the pointer
into the guardian, and then periodically enqueue as event a call to the
guardian:

@example
(import (ikarus)
  	(ikarus foreign))

;; Event source handling.

(define *event-source* '())

(define (enqueue-event event)
  (set! *event-source*
        [reverse (cons event (reverse *event-source*))]))

(define (pop-event)
  (if (null? *event-source*)
      #f
    (let ([event (car *event-source*)])
      (set! *event-source* (cdr *event-source*))
      event)))

;; Block guardian.

(define block-guardian (make-guardian))

(define (run-block-guardian)
  (do ([p (block-guardian) (block-guardian)])
       [not p])
    (printf "collecting ~s~%" p)
    (free p)))

(define (run-garbage-collection)
  (foreign-call "ik_collect" 5))

;; Application follows.

(define (do-something-with . args)
  (display args)
  (newline))

(let ([p (malloc (expt 2 20))])
  (unless p (error "memory allocation"))
  (block-guardian p)
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 123)))
  (enqueue-event (lambda () (do-something-with p)))
  (enqueue-event (lambda () (do-something-with 456))))

(do ([event (pop-event) (pop-event)]
     [i 1 (+ i 1)])
    ([= i 20])
  (when event
    (event))
  (when (= 0 (modulo i 10))
    (run-garbage-collection)
    (enqueue-event run-block-guardian)))
@end example



@c page
@node ikaruslib guardians api
@subsection Guardians programming interface


@defun make-guardian
Build and return a new guardian object: a closure that can be called
with one or zero arguments, and that is interfaced with the garbage
collector of the Scheme implementation (in a non--portable way).

The guardian works like this:

@itemize
@item
when the closure is called with one argument: it adds the argument to an
internal set of ``guarded values'', accessible to the garbage collector;

@item
when the garbage collector detects no other references to a value in the
set of guarded values: the guardian removes it from the set and appends
it to an internal queue (@acronym{FIFO});

@item
when the closure is called with zero arguments: it removes the first
value from the internal queue and returns it; if no values are in the
queue it returns @false{}.
@end itemize

After an object has been returned by the guardian, it is no more
``guarded'' so it will be garbage collected when it will become
inaccessible (unsless it is registered in a guardian).

@quotation
@emph{Note:} it is possible to register an object in more than one
guardian, when the object is found inaccessible all the guardian
closures that have it will return it to the caller.  This may lead to
invalid finalisation operations, it is the responsibility of the
programmer to avoid this.
@end quotation

@quotation
@emph{Note:} it is possible to register an object multiple times in the
same guardian, when the object is found inaccessible the guardian
closure that has it will return it to the caller multiple times.  This
may lead to invalid finalisation operations, it is the responsibility of
the programmer to avoid this.
@end quotation
@end defun



@c page
@node ikaruslib io
@section Input/output library


@unstable{1661}


@menu
* ikaruslib io process::        Spawning processes.
* ikaruslib io socket::         Using network sockets.
* ikaruslib io non-block::      Non--blocking mode for ports.
@end menu



@c page
@node ikaruslib io process
@subsection Spawning processes


@unstable{1661}


@defun process @var{command} . @var{options}
Run a subprocess with a set of command line options.  @var{command} is a
string selecting the executable pathname.  @var{options} is a list of
strings interpreted as command line options.

If @var{command} does not not contain a @code{/} character, the command
is searched in the directories listed in the @env{PATH} environment
variable.

Return multiple values:

@enumerate
@item
the subprocess pid;
@item
an output port that writes to the subprocess' standard input channel;
@item
an input port that reads from the subprocess' standard output channel;
@item
an input port that reads from the subprocess' standard error channel.
@end enumerate

If an error occurs: an exception is raised.

Example:

@example
(call-with-values
    (lambda ()
      (process "ls" "-l"))
  (lambda (pid stdin-out stdout-in stderr-in)
    (do-something)))
@end example

@noindent
with @func{receive}:

@example
(receive (pid stdin-out stdout-in stderr-in)
    (process "ls" "-l")
  (do-something))
@end example

@noindent
with @func{let-values}:

@example
(let-values ([(pid stdin-out stdout-in stderr-in)
              (process "ls" "-l")])
  (do-something))
@end example

@quotation
@forunix{} @func{process} makes use of the @cfunc{fork} and
@cfunc{execvp} system functions.@*

@glibcref{Creating a Process}@* @glibcref{Executing a File}@*
@glibcref{Standard Environment}
@end quotation
@end defun


@defun process-nonblocking @var{command} . @var{options}
Like @func{process} but the returned ports have their underlying file
descriptors configured to non--blocking mode (@ref{ikaruslib io
non-block}).
@end defun



@c page
@node ikaruslib io socket
@subsection Using network sockets


@unstable{1661}


@menu
* ikaruslib io socket client::  Establishing client network
                                connections.
* ikaruslib io socket server::  Opening server network services.
@end menu



@c page
@node ikaruslib io socket client
@subsubsection Establishing client network connections


@unstable{1661}


@defun tcp-connect @var{hostname} @var{service}
@defunx udp-connect @var{hostname} @var{service}
@defunx tcp-connect-nonblocking @var{hostname} @var{service}
@defunx udp-connect-nonblocking @var{hostname} @var{service}
Establish a network connection using the @tcp{} or @udp{} protocol, to
the host selected by the string @var{hostname}, port/service selected by
the string @var{service}.  The @code{-nonblocking} version sets the
underlying socket descriptor to non--blocking mode (@ref{ikaruslib io
non-block}).  Upon success, return a port; if an error occurs an
exception is raised.

@var{hostname} can be a dotted decimal address for IPv4, or a
hexadecimal string for IPv6, or a network address.

@var{service} can be a numerical string representing the port, or the
``official'' name of a service, like @code{smtp} or @code{pop3}.

@quotation
@forunix{} These functions use of the @cfunc{socket}, @cfunc{connect}
and @cfunc{getaddrinfo} system functions.

@glibcref{Creating a Socket}@*
@glibcref{Connecting}@*
See the @cfunc{getaddrinfo} manual page.@*
See the @file{/etc/services} configuration file.
@end quotation
@end defun



@c page
@node ikaruslib io socket server
@subsubsection Opening server network services


@unstable{1661}


@defun tcp-server-socket @var{server-port-number}
@defunx tcp-server-socket-nonblocking @var{server-port-number}
Build a new @tcp{} server object for the selected port number (which
must be an exact integer).  The @code{-nonblocking} versions set the
underlying socket descriptor to non--blocking mode (@ref{ikaruslib io
non-block}).  Upon success, return a server--object; if an error occurs
an exception is raised.

@quotation
@forunix{} These functions make use of the @cfunc{socket},
@cfunc{setsockopt}, @cfunc{bind} and @cfunc{listen} system functions.
The socket is configured with the @code{AF_INET}, @code{INADDR_ANY},
@code{SO_REUSEADDR} values and options (Ikarus version 0.0.3+, checkout
1468).

@glibcref{Creating a Socket}@*
@glibcref{Socket Option Functions}@*
@glibcref{Setting Address}@*
@glibcref{Listening}@*
@end quotation
@end defun


@defun accept-connection @var{server-object}
@defunx accept-connection-nonblocking @var{server-object}
Accept the next incoming connection to the selected server.  If success
return two values:

@enumerate
@item
an output port to be used to send data;

@item
an input port to be used to receive data;
@end enumerate

@noindent
if an error occurs: an exception is raised.  The @code{-nonblocking}
versions set the underlying socket descriptor to non--blocking mode
(@ref{ikaruslib io non-block}).

If the server socket was configured as blocking: this function suspends
the process waiting for an incoming connection.

@quotation
@fixme{What happens when the server socket is configured as
non--blocking?}
@end quotation

@quotation
@forunix{} These functions make use of the @cfunc{accept} system call.

@glibcref{Accepting Connections}
@end quotation
@end defun


@defun close-tcp-server-socket @var{server-object}
Close a server socket causing it to stop listening.

@quotation
@forunix{} this function makes use of the @cfunc{shutdown} system
function.

@glibcref{Closing a Socket}
See also the @cfunc{shutdown} manual page.
@end quotation
@end defun


@defun register-callback @var{server-object} @var{proc}
Register a callback function to be invoked whenever a new incoming
connection request happens on @var{server-object}.  The callback will be
invoked by the Ikarus event loop.

@quotation
@fixme{What are the parameters that get passed to @var{proc}?  Look for
@func{make-t} and @func{t-proc} in @file{ikarus.io.ss}.}
@end quotation
@end defun


@deffn Parameter input-socket-buffer-size
Select the size in bytes of the input buffer for server sockets.  The
value must be a fixnum greater or equal to 128.
@end deffn


@deffn Parameter output-socket-buffer-size
Select the size in bytes of the output buffer for server sockets.  The
value must be a fixnum greater than zero.
@end deffn



@c page
@node ikaruslib io non-block
@subsection Non--blocking mode for ports


@forunix{} Non--blocking mode is setup with a call like:

@example
fcntl(fd, F_SETFL, O_NONBLOCK);
@end example

@noindent
@glibcref{Control Operations}@*
@glibcref{Open-time Flags}



@c page
@node ikaruslib posix
@section @posix{} functions


@unstable{1661}


@menu
* ikaruslib posix process::     Spawning processes and the like.
* ikaruslib posix waitpid::     Waiting for terminated children.
* ikaruslib posix signal::      Delivering signals to processes.
* ikaruslib posix file::        Interfacing with the file system.
* ikaruslib posix env::         Interfacing with the execution
                                environment.
* ikaruslib posix misc::        Miscellaneous functions.
@end menu



@c page
@node ikaruslib posix process
@subsection Spawning processes and the like


@unstable{1661}


@defun fork @var{parent-proc} @var{child-thunk}
Fork a new process using the system @cfunc{fork} function.

If the operation is successful: in the parent process @var{parent-proc}
is evaluated by applying it to an exact integer representing the child
pid; in the child process @var{child-thunk} is evaluated.

If an error occurs: an exception is raised.

Example:

@example
(fork
  (lambda (child-pid)
    (printf "in parent, child pid = ~s\n" child-pid))
  (lambda ()
    (printf "in child\n")
    (exit)))

(printf "here we are in the parent\n")
@end example

@glibcref{Creating a Process}
@end defun


@defun system @var{command-string}
Executes a command using the @cfunc{system} function, which uses the
system shell.  If success: return the exit code of the process.  If
error: raise an exception.

Example:

@example
(system "ls -l")
@end example

@glibcref{Running a Command}
@end defun



@c page
@node ikaruslib posix waitpid
@subsection Waiting for terminated children


@unstable{1661}


@defun waitpid [@var{pid} [@var{block?} [@var{want-error?}]]]
Wait for another process termination using the system @cfunc{waitpid}
function and return informations about its status.

If successful and there is a child waiting to be noticed: the returned
value is a record of type @code{wstatus}, whose interface is described
below.  If successful but no child is waiting to be noticed: the
returned value is @false{}.

If an error occurs and @var{want-error?} is @true{}, an exception is
raised.  If an error occurs and @var{want-error?} is @false{}: the
return value is @false{}.  @var{want-error?} defaults to @true{}.

@var{pid} is the id of the process to wait for; it defaults to
@code{-1}.  If it is:

@table @asis
@item @emph{a positive integer}
return informations about the process having that pid;

@item @code{0}
return informations about a process in the set of terminated children in
the same group of the calling process; if more eligible children exists,
one is selected at random;

@item @code{-1}
return informations about a process in the set of terminated children;
if more eligible children exists, one is selected at random;

@item @emph{a negative integer other than @code{-1}}
wait for a process in the set of terminated children whose process group
id is equal to the absolute value of @var{pid}.
@end table

If @var{block?} is @true{} (the default), then the process is suspended
waiting for an eligible child; if @var{block?} is @false{} the process
is not suspended and the return value is @false{}.

@glibcref{Process Completion}
@end defun


The following example tests @func{waitpid}:

@example
(fork
   (lambda (child-pid)
     (printf "in parent, child pid = ~s\n" child-pid)
     (let ([status (waitpid child-pid)])
       (printf "in parent, child status: ~s\n" status)))
   (lambda ()
     (printf "in child\n")
     (exit 1)))
@end example

@noindent
the following example test killing with a signal:

@example
(fork
   (lambda (child-pid)
     (printf "in parent, child pid = ~s\n" child-pid)
     (kill child-pid 'SIGKILL)
     (let ([status (waitpid child-pid)])
       (printf "in parent, child status: ~s\n" status)))
   (lambda ()
     (printf "in child\n")
     (nanosleep 5 0)))
@end example

@c ------------------------------------------------------------

@subsubheading Status record interface

@ignore
Notice that in Ikarus 1648 the predicate WSTATUS? is not exported from
the library.  Dunny why.
@end ignore


@defun wstatus-pid @var{status}
Return the pid of the process extracting it from @var{status}.
@end defun


@defun wstatus-exit-status @var{status}
Return the exit code of the process extracting it from @var{status}.  If
the process was stopped by a signal: the return value is @false{}.
@end defun


@defun wstatus-received-signal @var{status}
Return a symbol representing the signal that caused the termination of
the child process.  If no signal was received: return @false{}.
@end defun



@c page
@node ikaruslib posix signal
@subsection Delivering signals to processes


@cindex @code{SIGABRT}
@cindex @code{SIGALRM}
@cindex @code{SIGBUS}
@cindex @code{SIGCHLD}
@cindex @code{SIGCONT}
@cindex @code{SIGFPE}
@cindex @code{SIGHUP}
@cindex @code{SIGILL}
@cindex @code{SIGINT}
@cindex @code{SIGKILL}
@cindex @code{SIGPIPE}
@cindex @code{SIGQUIT}
@cindex @code{SIGSEGV}
@cindex @code{SIGSTOP}
@cindex @code{SIGTERM}
@cindex @code{SIGTSTP}
@cindex @code{SIGTTIN}
@cindex @code{SIGTTOU}
@cindex @code{SIGUSR1}
@cindex @code{SIGUSR2}
@cindex @code{SIGPOLL}
@cindex @code{SIGPROF}
@cindex @code{SIGSYS}
@cindex @code{SIGTRAP}
@cindex @code{SIGURG}
@cindex @code{SIGVTALRM}
@cindex @code{SIGXCPU}
@cindex @code{SIGXFSZ}


@unstable{1661}


@defun kill @var{pid} @var{signame}
Send the signal selected by @var{signame} to the process or group of
processes selected by @var{pid}.  Make use of the system @cfunc{kill}
function.  If an error occurs: an exception is raised.

Following is the meaning of @var{pid}:

@table @code
@item @var{pid} > 0
deliver the signal to the process having @var{pid} as identifier;

@item @var{pid} == 0
deliver the signal to all the process in the group of the sender;

@item @var{pid} == -1
deliver the signal to all the process having the same effective user
identifier of the sender; see the whole documentation in the system
library;

@item @var{pid} < -1
deliver the signal to all the process in the group having identifier
equal to the absolute value of @var{pid}.
@end table

@var{signame} must be a symbol specifying a signal.  Supported signal
names follow:

@example
SIGABRT         SIGALRM         SIGBUS
SIGCHLD         SIGCONT         SIGFPE
SIGHUP          SIGILL          SIGINT
SIGKILL         SIGPIPE         SIGQUIT
SIGSEGV         SIGSTOP         SIGTERM
SIGTSTP         SIGTTIN         SIGTTOU
SIGUSR1         SIGUSR2         SIGPOLL
SIGPROF         SIGSYS          SIGTRAP
SIGURG          SIGVTALRM       SIGXCPU
SIGXFSZ
@end example

@glibcref{Signaling Another Process}@*
@glibcref{Standard Signals}
@end defun



@c page
@node ikaruslib posix file
@subsection Interfacing with the file system


@unstable{1661}


@subsubheading Current working directory


@defun current-directory [@var{pathname}]
When invoked with an argument, change the current working directory to
the one selected by the string @var{pathname}.  Make use of the system
@cfunc{chdir} function.

When invoked without argument, return a string representing the current
working directory pathname.  Make use of the system @cfunc{getcwd}
function.

If an error occurs, an exception is raised.

@glibcref{Working Directory}
@end defun


@c ------------------------------------------------------------

@subsubheading Inspecting the file system


@defun directory-list @var{pathname}
Build and return the list of strings representing the entries in the
directory selected by the string @var{pathname}.  Make use of the
@cfunc{opendir}, @cfunc{readdir}, @cfunc{closedir} system functions.

If an error occurs, an exception is raised.

@glibcref{Opening a Directory}@*
@glibcref{Reading/Closing Directory}
@end defun


@defun file-ctime @var{pathname}
Return the time of the last modification to the attributes of the file;
makes use of the @cfunc{stat} system function, and return the
@code{st_ctime} field of the @code{stat} data structure.

The returned value is an exact integer, representing the number of
seconds elapsed since the Epoch (00:00:00 on January 1, 1970,
Coordinated Universal Time).

If an error occurs, an exception is raised.

@glibcref{Reading Attributes}
@end defun


@c ------------------------------------------------------------

@subsubheading Inspecting file types


@noindent
For the following functions: if @var{follow} is @true{}, the default,
make use of the @cfunc{stat} system function; if @var{follow} is
@false{}, make use of the @cfunc{lstat} system function.

@glibcref{Reading Attributes}


@defun file-exists? @var{pathname} [@var{follow}]
Return @true{} if @var{pathname} exists on the file system; otherwise
return @false{}.  If an error occurs, an exception is raised.
@end defun


@defun file-regular? @var{pathname} [@var{follow}]
Return @true{} if @var{pathname} exists on the file system and it is a
regular file; otherwise return @false{}.  If an error occurs, an
exception is raised.
@end defun


@defun file-directory? @var{pathname} [@var{follow}]
Return @true{} if @var{pathname} exists on the file system and it is a
directory; otherwise return @false{}.  If an error occurs, an exception
is raised.
@end defun


@defun file-symbolic-link? @var{pathname} [@var{follow}]
Return @true{} if @var{pathname} exists on the file system and it is a
symbolic link; otherwise return @false{}.  If an error occurs, an
exception is raised.
@end defun


@c ------------------------------------------------------------

@subsubheading Creation


@defun make-symbolic-link @var{to} @var{pathname}
Create a symbolic link whose pathname is the string @var{pathname}
referencing the @var{to} string pathname.  Make use of the
@cfunc{symlink} system function.  If an error occurs, an exception is
raised.

@glibcref{Symbolic Links}
@end defun


@defun make-directory @var{pathname} [@var{mode}]
Create a directory with name selected by the string @var{pathname}.
Make use of the @cfunc{mkdir} system function.  If an error occurs, an
exception is raised.

@var{mode} must be an exact integere selecting the access permissions
for the directory; it defaults to @code{#o755}.

@glibcref{Creating Directories}
@end defun

@c ------------------------------------------------------------

@subsubheading Deletion


@defun delete-file @var{pathname}
Remove from the system the file selected by the @var{pathname} string.
Make use of the @cfunc{unlink} system function.  If an error occurs, an
exception is raised.

@glibcref{Deleting Files}
@end defun


@defun delete-directory @var{pathname}
Remove from the system the directory selected by the @var{pathname}
string.  Make use of the @cfunc{rmdir} system function.  If an error
occurs, an exception is raised.

@glibcref{Deleting Files}
@end defun


@c ------------------------------------------------------------

@subsubheading Permissions


@defun change-mode @var{pathname} @var{mode}
Change the access permissions of the file or directory selected by the
@var{pathname} string.  Make use of the @cfunc{chmod} system function.
If an error occurs, an exception is raised.

@var{mode} must be an exact integer selecting the permissions.

@glibcref{Setting Permissions}
@end defun



@c page
@node ikaruslib posix env
@subsection Interfacing with the execution environment


@unstable{1661}


@defun getenv @var{varname}
Return the current value, as a string, of the system environment
variable selected by the string @var{varname}.  If the variable is not
set: @false{} is returned.

Example:

@example
(getenv "PATH")
=> "/usr/local/bin:/usr/bin:/bin"
@end example
@end defun


@c @defun env

@c @end defun


@c @defun environ

@c @end defun



@c page
@node ikaruslib posix misc
@subsection Miscellaneous functions


@unstable{1661}


@defun strerror @var{error-code}
Return a string describing the @code{errno} code @var{error-code}.
Makes use of the system function @cfunc{strerror}.  If @var{error-code}
is not a valid @code{errno} value: return a string telling it.

@glibcref{Error Messages}
@end defun


@defun nanosleep @var{seconds} @var{nanoseconds}
Suspend the process for the selected time; it makes use of the system
@cfunc{nanosleep} function.  @var{seconds} and @var{nanoseconds} must be
positive exact integers.  If an error occurs an exception is raised.

@glibcref{Sleeping}
@end defun



@c page
@node ikaruslib foreign
@section The @library{ikarus foreign} library


@noindent
This chapter describes the facilities through which Ikarus interfaces
with the host operating system and other external libraries.  The
facilities of the @library{ikarus foreign} library give the Scheme
program unrestricted access to the computer memory, allowing one to
allocate, access, modify, and free memory as needed.  The facilities
also allow the Scheme program to @emph{call out} to system procedures as
well as allow the native procedures to @emph{call back} into Scheme.

@ignore
An original paragraph giving an overview of this chapter contents was
omitted because with the menu above it is useless, and because it looked
outdated.
@end ignore

@quotation
@emph{Note:} Ikarus version @code{0.0.4} is the first version of Ikarus
to support the described foreign interfaces.
@end quotation

@quotation
@emph{Caveat emptor:} Preparing each call out and call back procedure
leaks a small amount of memory.  This is because the system cannot track
such pointers that go into native code (which may retain such pointers
indefinitely).  Use judiciously.
@end quotation


@menu
* ikaruslib foreign overview::  Overview of the foreign functions
                                interface.
* ikaruslib foreign memory::    Memory management.
* ikaruslib foreign memops::    Memory operations.
* ikaruslib foreign dl::        Accessing foreign objects from Scheme.
* ikaruslib foreign call out::  Calling out to foreign procedures.
* ikaruslib foreign call back:: Calling back to Scheme.
@end menu



@c page
@node ikaruslib foreign overview
@subsection Overview of the foreign functions interface


@noindent
In order to make full use of the computer, it is important for a
programming environment (e.g., Ikarus Scheme) to facilitate access to
the underlying architecture on which it runs.  The underlying
architecture includes the @api{} provided by the host operating system
kernel (e.g., Linux), the system libraries (e.g., @code{libc}), and
other site--installed libraries (e.g., @code{sqlite3}).

Providing direct access to such @api{} from within Scheme allows the
programmer to write Scheme libraries that have few or no dependencies on
external programs (such as @code{C} development toolchain).  When
dealing with system libraries, the programmer must have a thorough
understanding of many aspects of the targeted system.  This section
attempts to provide answers to many questions that are frequently
encountered when interfacing to external libraries.

@c ------------------------------------------------------------

@subsubheading Libffi


@noindent
Currently (Thu Oct 23, 2008) Ikarus implements the foreign functions
interface (@ffi{}) using an extenal library: Libffi, originally by
Anthony Green.  Libffi can be found at:

@center @url{http://sourceware.org/libffi/}

@noindent
and it is distributed under a liberal license (look for it at the site,
basically we can do everything but remove the original copyright
notice).

On Unix--like systems, we can install Libffi with the traditional
sequence:

@example
$ ./configure [options]
$ make
$ make install
@end example

@noindent
and the makefile supports the @env{DESTDIR} environment variable for
installation under a different directory prefix.

@quotation
@emph{Note:} Libffi version 3.0.6 installs its header files under:

@example
$@{prefix@}/lib/libffi-3.0.6/include
@end example

@noindent
and trying to use the @option{--includedir} option to
@command{configure} will @strong{not} work in changing this.  It means
that when configuring Ikarus for installation we have to specify where
the Libffi headers are to be found; @ref{overview install} for details.
@end quotation


@c page
@node ikaruslib foreign memory
@subsection Memory management


@noindent
Ikarus Scheme is a managed environment.  Like in many programming
environments, Ikarus manages its own memory.  Scheme objects are
allocated in a special memory region (the Scheme heap) and have
type--specific object layouts; this allows the run time system to
distinguish object types and the garbage collector to locate all
potentially live objects, and reclaim the memory of dead objects.
Scheme objects are also @emph{opaque} in the sense that the data
structures used to represent Scheme objects (e.g., pairs) are not
exposed to the programmer, who can only interact with objects through an
interface (e.g., @code{car}, @code{cdr}).

Unmanaged environments, such as the operating system on which Ikarus
runs, require that the programmer manages the allocation and
deallocation of system resources herself.  Memory regions, file handles,
external devices, the screen, etc., are all examples of resources whose
management must be coordinated among the different parts of the system,
and this becomes the responsibility of the programmer who is wiring the
different subsystems together.

Memory, from a system's point of view, is @emph{transparent}.  A pointer
is an integer denoting an address of memory.  This memory address may
contain a value that requires interpretation.  At the lowest--level,
each byte of memory contains eight bits, each of which may be toggled on
or off.  A level higher, contiguous sequences of bytes are grouped
together and are interpreted as integers, floating point numbers, or
pointers to other memory addresses.  These are the basic data types that
are often interpreted atomically.  Yet a level higher, groups of basic
types form data structures such as arrays, linked lists, trees, and so
on.  Objects, as found in object--oriented programming languages, are at
an even higher level of abstraction since they are treated as opaque
references that retain state and know how to respond to messages.

The procedures in the @library{ikarus foreign} library are meant to
provide a way to interface with the low level memory operations such as
setting and getting bytes from specific locations in memory.  Although
they do not provide high--level operations, the basic procedures make
implementing high--level operations (such as the Objective--C system)
possible.  Programmers are encouraged to define their own abstractions
that are most suitable for the specific target library rather than using
the low--level operations directly.  This results in writing more robust
and more easily maintainable libraries.  To put it more boldly:
@strong{Do not sprinkle your code with low--level memory operations}.



@c page
@node ikaruslib foreign memops
@subsection Memory operations


@menu
* ikaruslib foreign memops alloc::      Allocating and freeing memory.
* ikaruslib foreign memops pointer::    Handling pointer values.
* ikaruslib foreign memops poke::       Poking values.
* ikaruslib foreign memops peek::       Peeking values.
@end menu



@c page
@node ikaruslib foreign memops alloc
@subsubsection Allocating and freeing memory


@deffn Procedure malloc @var{number-of-bytes}
Allocate a block of memory and return a pointer to it.  The
@func{malloc} Scheme procedure is implemented using the host--provided
@cfunc{malloc} system procedure (often found in @code{libc}).  The
number of bytes must be a positive exact integer.

@example
> (malloc 10)
#<pointer #x00300320>
> (malloc 10000)
#<pointer #x01800400>
@end example

In case of failure allocating memory: the return value is @false{}.
@end deffn


@deffn Procedure free @var{pointer-to-memory-block}
Release the memory region at the given address.  The memory region must
have been allocated with @cfunc{malloc}, @cfunc{calloc}, or a similar
system procedure.  Once freed, memory operations on the given address
are invalid and may cause the system to crash at unpredictable times.
Ikarus cannot check for such errors since the memory may be freed by
procedures that are external to Ikarus.
@end deffn



@c page
@node ikaruslib foreign memops pointer
@subsubsection Handling pointer values


@noindent
The result of calling the procedures @func{eq?}, @func{eqv?} and
@func{equal?} on pointer values is unspecified.


@deffn Procedure pointer->integer @var{pointer}
Convert the value of @var{pointer} to an exact integer value.  The
result may be a fixnum or a bignum depending on the pointer.
@end deffn


@deffn Procedure integer->pointer @var{exact-integer}
Convert @var{exact-integer} to a pointer value.  The lower 32 bits (or
64 bits on 64-bit systems) of the argument are significant in computing
the pointer value.  It is guaranteed that @code{(integer->pointer
(pointer->integer p))} points to the same address as @var{p}.
@end deffn


@deffn Procedure pointer? @var{x}
Return @true{} if the value of @var{x} is a pointer, return @false{}
otherwise.
@end deffn


@deffn Procedure pointer-size
Return the number of bytes required to hold a pointer on the underlying
platform.
@end deffn



@c page
@node ikaruslib foreign memops poke
@subsubsection Poking values


@noindent
With all the following functions: the @var{pointer} argument must be a
valid pointer; the @var{offset} and @var{value} arguments must be exact
integers.  When adding an offset to a pointer: all the following
functions @strong{do not} scale the offset to the size of the poked
value.  Pointer arithmetics is performed with byte offsets.


@macro poker{BYTENUM,BITNUM}
Set to @var{value} the \BYTENUM\ of memory located at @var{offset} from
@var{pointer}.  Only the \BITNUM\ lowermost bits of @var{value} are used
in the operation and the remaining bits are ignored.
@end macro


@c ------------------------------------------------------------

@subsubheading Poking exact integers


@deffn Procedure pointer-set-c-char! @var{pointer} @var{offset} @var{value}
@poker{single byte,8}
@end deffn


@deffn Procedure pointer-set-c-short! @var{pointer} @var{offset} @var{value}
@poker{two bytes,16}
@end deffn


@deffn Procedure pointer-set-c-int! @var{pointer} @var{offset} @var{value}
@poker{four bytes,32}
@end deffn


@deffn Procedure pointer-set-c-long! @var{pointer} @var{offset} @var{value}
On 64-bit systems: @poker{eight bytes,64}

On 32-bit systems: perform the same task as @func{pointer-set-c-int!}.
@end deffn


@deffn Procedure pointer-set-c-long-long! @var{pointer} @var{offset} @var{value}
Set to @var{value} a number of bytes corresponding to the @code{long
long} type located at @var{offset} from @var{pointer}.
@end deffn


@c ------------------------------------------------------------

@subsubheading Poking floating point numbers


@deffn Procedure pointer-set-c-float! @var{pointer} @var{offset} @var{flonum}
Convert the Scheme floating point number @var{flonum} (represented in
Ikarus as an @ieee{} 754 double precision floating point number) to a
float (an @ieee{} 754 single precision floating point number) and store
the result in the four bytes at @var{offset} from @var{pointer}.
@end deffn


@deffn Procedure pointer-set-c-double! @var{pointer} @var{offset} @var{flonum}
Store the double precision @ieee{} 754 floating point value of the
Scheme @var{flonum} in the eight bytes at @var{offset} from
@var{pointer}.
@end deffn


@c ------------------------------------------------------------

@subsubheading Poking pointers


@deffn Procedure pointer-set-c-pointer! @var{pointer} @var{offset} @var{value}
On 64-bit systems: set the eight bytes at @var{offset} from
@var{pointer} to the 64-bit pointer @var{value}.

On 32-bit systems: set the four bytes at @var{offset} from @var{pointer}
to the 32-bit pointer @var{value}.
@end deffn


@c page
@node ikaruslib foreign memops peek
@subsubsection Peeking values


@noindent
With all the following functions: the @var{pointer} argument must be a
valid pointer; the @var{offset} argument must be an exact integer.  When
adding an offset to a pointer: all the following functions @strong{do
not} scale the offset to the size of the poked value.  Pointer
arithmetics is performed with byte offsets.


@c ------------------------------------------------------------

@subsubheading Peeking exact integers


@deffn Procedure pointer-ref-c-signed-char @var{pointer} @var{offset}
Peek the single byte located at @var{offset} from @var{pointer} and
return an exact integer representing the sign--extended integer value of
that byte. The resulting value is in the inclusive range @code{[-128,
127]}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-char @var{pointer} @var{offset}
Peek the single byte located at @var{offset} from @var{pointer} and
return an exact integer representing the unsigned integer value of that
byte.  The resulting value is in the inclusive range @code{[0, 255]}.
@end deffn


The following example shows the difference between the two functions
above:

@example
> (let ([p (malloc 3)])
    (pointer-set-c-char! p 0 #b01111111)
    (pointer-set-c-char! p 1 #b10000000)
    (pointer-set-c-char! p 2 #b11111111)
    (let ([result
           (list (pointer-ref-c-signed-char p 0)
                 (pointer-ref-c-signed-char p 1)
                 (pointer-ref-c-signed-char p 2)
                 (pointer-ref-c-unsigned-char p 0)
                 (pointer-ref-c-unsigned-char p 1)
                 (pointer-ref-c-unsigned-char p 2))])
      (free p)
      result))
(127 -128 -1 127 128 255)
@end example


@deffn Procedure pointer-ref-c-signed-short @var{pointer} @var{offset}
Peek two bytes at @var{offset} from @var{pointer} and return an exact
integer representing the sign--extended integer value of the sequence.
The resulting value is in the inclusive range @code{[-32768, 32767]}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-short @var{pointer} @var{offset}
Peek two bytes at @var{offset} from @var{pointer} and return an exact
integer representing the unsigned integer value of the sequence.  The
resulting value is in the inclusive range @code{[0, 65535]}.
@end deffn


@deffn Procedure pointer-ref-c-signed-int @var{pointer} @var{offset}
Peek four bytes at @var{offset} from @var{pointer} and return an exact
integer in the inclusive range @code{[-2^31, 2^31-1]}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-int @var{pointer} @var{offset}
Peek four bytes at @var{offset} from @var{pointer} and return an exact
integer in the inclusive range @code{[0, 2^32-1]}.
@end deffn


@deffn Procedure pointer-ref-c-signed-long @var{pointer} @var{offset}
On 64-bit systems: peek eight bytes at @var{offset} from @var{pointer}
and return an integer in the inclusive range @code{[-2^63, 2^63-1]}.

On 32-bit systems, perform the same task as
@func{pointer-ref-c-signed-int}.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-long @var{pointer} @var{offset}
On 64-bit systems: peek eight bytes at @var{offset} from @var{pointer}
and return an integer in the inclusive range @code{[0, 2^64-1]}.

On 32-bit systems: perform the same task as
@func{pointer-ref-c-unsigned-int}.
@end deffn


@deffn Procedure pointer-ref-c-signed-long-long @var{pointer} @var{offset}
Peek a number of bytes corresponding to the native @code{long long} type
at @var{offset} from @var{pointer} and return an integer.
@end deffn


@deffn Procedure pointer-ref-c-unsigned-long-long @var{pointer} @var{offset}
Peek a number of bytes corresponding to the native @code{unsigned long
long} type at @var{offset} from @var{pointer} and return an integer.
@end deffn

@c ------------------------------------------------------------

@subsubheading Peeking floating point numbers


@deffn Procedure pointer-ref-c-float @var{pointer} @var{offset}
Return the four--byte float (represented as @ieee{} 754 single precision
floating point number) stored at @var{offset} from @var{pointer}.  The
value is extended to an @ieee{} 754 double precision floating point
number that Ikarus uses to represent inexact numbers.
@end deffn


@deffn Procedure pointer-ref-c-double @var{pointer} @var{offset}
Return the eight--byte float (represented as @ieee{} 754 double
precision floating point number) stored at @var{offset} from
@var{pointer}.
@end deffn

@c ------------------------------------------------------------

@subsubheading Peeking pointers


@deffn Procedure pointer-ref-c-pointer @var{pointer} @var{offset}
Return the pointer stored at @var{offset} from @var{pointer}.  The size
of the pointer (also the number of bytes loaded) depends on the
architecture: it is 4 bytes on 32-bit systems and 8 bytes on 64-bit
systems.
@end deffn


@c page
@node ikaruslib foreign dl
@subsection Accessing foreign objects from Scheme


@deffn Procedure dlopen
@deffnx Procedure dlopen @var{library-name}
@deffnx Procedure dlopen @var{library-name} @var{lazy?} @var{global?}
Take the string @var{library-name} representing a system library and
call the system procedure @cfunc{dlopen} which dynamically loads the
given library into the running process.

The name of the library is system--dependent and must include the
appropriate suffix (e.g. @code{*.so} on Linux, @code{*.dylib} on Darwin
and @code{*.dll} on Cygwin).  @var{library-name} may include a full path
which identifies the location of the library, or it may just be the name
of the library in which case the system will lookup the library name
using the @env{LD_LIBRARY_PATH} environment variable.

The argument @var{lazy?} specifies how library dependencies are loaded.
If true, @func{dlopen} delays the resolution and loading of dependent
libraries until they are actually used.  If false, all library
dependencies are loaded before the call to @func{dlopen} returns.

The argument @func{global?} specifies the scope of the symbols exported
from the loaded library.  If true, all exported symbols become part of
the running image, and subsequent @func{dlsym} calls may not need to
specify the library from which the symbol is loaded.  If false, the
exported symbols are not global and the library pointer needs to be
specified for @func{dlsym}.

Calling @code{(dlopen library-name)} is equivalent to @code{(dlopen
library-name #f #f)}.  Calling @code{(dlopen)} without arguments returns
a pointer to the current process.

If succesful, @func{dlopen} returns a pointer to the external library
which can be used subsequently by @func{dlsym} and @func{dlclose}.  If
the library cannot be loaded, @func{dlopen} returns @false{} and the
procedure @func{dlerror} can be used to obtain the cause of the failure.

Consult the @code{dlopen(3)} page in your system manual for further
details.
@end deffn


@deffn Procedure dlclose @var{library-pointer}
A wrapper for the system procedure of the same name.  It receives a
library pointer (e.g. one obtained from @func{dlopen}) and releases the
resources loaded from that library.  Closing a library renders all
symbols and static data structures that the library exports invalid and
the program may crash or corrupt its memory if such symbols are used
after a library is closed.

Most system implementations of dynamic loading employ reference counting
for @func{dlopen} and @func{dlclose} in that library resources are not
freed until the number of calls to @func{dlclose} matches the number of
calls to @func{dlopen}.

The procedure @func{dlclose} returns a boolean value indicating whether
the success status of the operation.  If @func{dlclose} returns
@false{}, the procedure @func{dlerror} can be used to obtain the cause
of the error.

Consult the @code{dlclose(3)} page in your system manual for further
details.
@end deffn


@deffn Procedure dlsym @var{library-pointer} @var{string}
Take a library pointer (e.g. one obtained by a call to @func{dlopen})
and a string representing the name of a symbol that the library exports
and return a pointer to the location of that symbol in memory.  If
@func{dlsym} fails, it returns @false{} and the cause of the error can
be obtained using the procedure @code{dlerror}.

Consult the @code{dlsym(3)} page in your system manual for further
details.
@end deffn


@deffn Procedure dlerror
If any of the dynamic loading operations (i.e., @func{dlopen},
@func{dlclose}, @func{dlsym}) fails, the cause of the error can be
obtained by calling @func{dlerror} which returns a string describing the
error.  The procedure @func{dlerror} returns @false{} if there was no
dynamic loading error.

Consult the @code{dlerror(3)} page in your system manual for further
details.
@end deffn



@c page
@node ikaruslib foreign call out
@subsection Calling out to foreign procedures


@noindent
Ikarus provides the means to call out from Scheme to foreign procedures.
This allows the programmers to extend Ikarus to access system--specific
facilities that are available on the host machine.

@menu
* ikaruslib foreign call out api::      Interface to foreign functions.
* ikaruslib foreign call out types::    Type specifiers.
* ikaruslib foreign call out example::  C language call out example.
@end menu


@c page
@node ikaruslib foreign call out api
@subsubsection Interface to foreign functions


@noindent
In order to call out to a foreign procedure, one must provide two pieces
of information: the signature of the foreign procedure (e.g. its type
declaration if it is a C language procedure) and the address of the
procedure in memory.  The address of the procedure can be easily
obtained using @func{dlsym} if the name of the procedure and its
exporting library are known.  The signature of the procedure cannot, in
general, be obtained dynamically, and therefore must be hard coded into
the program.

The signature of the foreign procedure is required for proper linkage
between the Scheme system and the foreign system.  Using the signature,
Ikarus determines how Scheme values are converted into native values,
and where (e.g. in which registers and stack slots) to put these
arguments.  The signature also determines where the returned values are
placed and how they are converted from the system data types to the
corresponding Scheme data types.

A procedure's signature is composed of two parts: the return type and
the parameter types:

@itemize
@item
the return type is a symbol that can be any one of the type specifiers
listed in @ref{ikaruslib foreign call out types};

@item
the parameter types is a list of type specifier symbols; if the foreign
function takes no arguments: the parameter types must be the empty list;
@end itemize

@noindent
the symbol @code{void} can appear as a return type but cannot appear as
a parameter type.


@deffn Procedure make-c-callout @var{return-type} @var{parameter-types}
The procedure @func{make-c-callout} is the primary facility for making
foreign procedures callable from Scheme.  It works as follows:

@enumerate
@item
@func{make-c-callout} receives two arguments denoting the signature of
the procedure to be called; it prepares a bridge that converts from
Scheme's calling conventions and data structures to their foreign
counterparts; it returns a procedure @func{p1};

@item
the procedure @func{p1} accepts a pointer to a foreign procedure
(e.g. one obtained from @func{dlsym}) and returns a Scheme procedure
@func{p2} that encapsulates the foreign procedure;

@item
the final procedure @func{p2} can be called with as many arguments as
the ones specified in the @var{parameter-types}; the parameters supplied
to @func{p2} must match the types supplied as the @var{parameter-types}
according to the ``Valid Scheme types'' column in the table in
@ref{ikaruslib foreign call out types};

@item
the procedure @func{p2} converts the parameters from Scheme types to
native types, calls the foreign procedure, obtains the result, and
converts it to the appropriate Scheme value (depending on the
@var{return-type}).
@end enumerate

The interface of @func{make-c-callout} is broken down into three stages
in order to accomodate common usage patterns.  Often a function
signature can be used by many foreign procedures and therefore,
@func{make-c-callout} can be called once per signature and each
signature can be used multiple times.  Similarly, separating the foreign
procedure preparation from parameter passing allows for preparing the
foreign procedure once and calling it many times.

The list of types in the table in @ref{ikaruslib foreign call out types}
is restricted to basics and provides no automatic conversion from
composite Scheme data structures (such as strings, symbols, vectors, and
lists) to native types.  The restriction is intentional in order for
Ikarus to avoid making invalid assumptions about the memory management
of the target library.

@quotation
For example, while Ikarus @emph{can} convert a Scheme string to a native
byte array (e.g. use @func{string->bytevector} to decode the string,
then use @func{malloc} to allocate a temporary buffer, then copy the
bytes from the bytevector to the allocated memory), it cannot decide
when this allocated byte array is no longer needed and should be freed.
This knowledge is library--dependent and is often procedure--dependent.
Therefore, Ikarus leaves it to the programmer to manage all memory
related issues.
@end quotation

Outgoing parameters to foreign procedures are checked against the
declared types.  For example, if a callback is prepared to expect a
parameter of type @code{signed-int}, only exact integers are allowed to
be passed out.  For integer types, only a fixed number of bits is used
and the remaining bits are ignored.  For floating point types, the
argument is checked to be a Scheme flonum.  No implicit conversion
between exact and inexact numbers is performed.
@end deffn



@c page
@node ikaruslib foreign call out types
@subsubsection Type specifiers


@noindent
The following table lists valid type specifiers that can be used in
callout and callback signatures.  Specifiers with ``4/8 bytes'' have
size that depends on the system: it is 4 bytes on 32-bit systems and 8
bytes on 64-bit systems.  The @code{void} specifier can only be used as
a return value specifier to mean ``no useful value is returned''.


@multitable {Type specifier} {4/8 bytes} {Valid Scheme types} {Corresponding C types}
@headitem Type specifier @tab Size @tab Valid Scheme types @tab Corresponding C types
@item
@code{signed-char} @tab 1 byte @tab exact integer @tab @code{char}
@item
@code{unsigned-char} @tab 1 byte @tab exact integer @tab @code{unsigned char}
@item
@code{signed-short} @tab 2 bytes @tab exact integer @tab @code{short}
@item
@code{unsigned-short} @tab 2 bytes @tab exact integer @tab @code{unsigned short}
@item
@code{signed-int} @tab 4 bytes @tab exact integer @tab @code{int}
@item
@code{unsigned-int} @tab 4 bytes @tab exact integer @tab @code{unsigned int}
@item
@code{signed-long} @tab 4/8 bytes @tab exact integer @tab @code{long}
@item
@code{unsigned-long} @tab 4/8 bytes @tab exact integer @tab @code{unsigned long}
@item
@code{float} @tab 4 bytes @tab flonum @tab @code{float}
@item
@code{double} @tab 8 bytes @tab flonum @tab @code{double}
@item
@code{pointer} @tab 4/8 bytes @tab pointer @tab @code{void*}, @code{char*}, @code{int*}, @code{int**}, etc
@item
@code{void} @tab --- @tab --- @tab @code{void}
@end multitable



@c page
@node ikaruslib foreign call out example
@subsubsection C language call out example


@noindent
The following example illustrates the use of the @func{make-c-callout}
procedure in combination with @func{dlopen} and @func{dlsym}; the
session was run on a 32-bit Ikarus running under Mac OS X 10.4:

@enumerate
@item
the @file{libc.dylib} foreign library is loaded and is bound to the
variable @code{libc};

@item
we obtain a pointer to the @cfunc{atan} foreign procedure that is
defined in @code{libc}; the native procedure @cfunc{atan} takes a
@code{double} as an argument and returns a @code{double} and that's the
signature that we use for @func{make-c-callout};

@item
we call the foreign procedure interface with one argument, @code{1.0},
which is a flonum and thus matches the required parameter type; the
native procedure returns a @code{double} value which is converted to the
Scheme flonum with value @code{0.7853981633974483}.
@end enumerate

@example
> (import (ikarus foreign))
> (define libc (dlopen "libc.dylib"))
> libc
#<pointer #x00100770>
> (define libc-atan-ptr (dlsym libc "atan"))
> libc-atan-ptr
#<pointer #x9006CB1F>
> (define libc-atan
    ((make-c-callout 'double '(double)) libc-atan-ptr))
> libc-atan
#<procedure>
> (libc-atan 1.0)
0.7853981633974483
> (libc-atan 1)
Unhandled exception
 Condition components:
    1. &assertion
    2. &who: callout-procedure
    3. &message: "argument does not match type double"
    4. &irritants: (1)
@end example


@c page
@node ikaruslib foreign call back
@subsection Calling back to Scheme


@noindent
In order to provide full interoperability with native procedures, Ikarus
allows native procedures to call back into Scheme just as it allows
Scheme to call out to native procedures.  This is important for many
system libraries that provide graphical user interfaces with event
handling (e.g. Cocoa, GTK+, GLUT, etc.), database engines
(e.g. libsqlite, libmysql, etc.), among others.

The native calling site for the call back is compiled with a specific
callback signature encoding the expected parameter types and return
type.  Therefore, a Scheme procedure used for a call back must be
wrapped with a proper adapter that converts the incoming parameters from
native format to Scheme values as well as convert the value that the
Scheme procedure returns back to native format.  The signature format is
similar to the one used for call outs (@ref{ikaruslib foreign call out
types} for details).


@deffn Procedure make-c-callback @var{return-type} @var{parameter-types}
The procedure @func{make-c-callback} is similar to the procedure
@func{make-c-callout} except that it provides a bridge from native
procedures back into Scheme.  While the procedure @func{make-c-callout}
takes a native pointer and returns a Scheme procedure,
@func{make-c-callback} takes a Scheme procedure and returns a native
pointer.  The native pointer can be called by foreign procedures.  The
native parameters are converted to Scheme data (according to
@var{parameter-types}), the Scheme procedure is called with these
parameters, and the returned value is converted back into native format
(according to @var{return-type}) before control returns to the native
call site.

Note that the native procedure pointer obtained from
@func{make-c-callback} is indistinguishable from other native procedures
that are obtained using @func{dlsym} or similar means.  In particular,
such native pointers can be passed to @func{make-c-callout} resulting in
a Scheme procedure that calls out to the native procedure that in turn
calls back into Scheme.  The following segment illustrates a very
inefficient way of extracting the lowermost 32 bits from an exact
integer.

@example
> (format "~x"
    (((make-c-callout 'unsigned-int '(unsigned-int))
      ((make-c-callback 'unsigned-int '(unsigned-int))
       values))
     #xfedcba09876543210fedcba09876543210))
"76543210"
@end example
@end deffn



@c page
@node ikaruslib misc
@section Miscellaneous functions


@defun void
Return the void value.  It is the value returned by forms that do not
return a meaningful value.
@end defun



@c page
@node contrib libraries
@appendix Contributed libraries


@cindex Contributed libraries
@cindex Libraries, contributed


@noindent
Ikarus Scheme authors try to keep it small and manageable.  Libraries
that are not an essential part of Ikarus are not included in the Ikarus
proper, instead, they are distributed with Ikarus in source form.  Such
libraries may be written specifically for Ikarus, or they may be
portable libraries that can be used in Ikarus.  @acronym{SRFI} or other
libraries contributed by members of the Scheme community belong to this
section.

Using contributed libraries is no different from using any of the
built-in libraries---all one has to do is add the library name to the
@func{import} clause and the rest is done by the system.

Authors of useful @rnrs{6} libraries that wish for them to be available
for a wider audience, can contact Ikarus authors to include information
about them in the next release.

High quality @ansrfi{} with @rnrs{6} reference implementations will be
distributed with Ikarus as they become available.

@quotation
@emph{Note:} Contributed libraries may have bugs on their own or may
exhibit bugs in Ikarus itself.  If you have a problem using any of these
libraries, please try to resolve the issue by contacting the library
author first.  Do not hesitate to file a bug on Ikarus if you believe
that Ikarus is at fault.
@end quotation

@menu
* contrib gl::                  @code{(gl)} and @code{(glut)}.
* contrib number theory::       @code{(math number-theory)}
@end menu


@c page
@node contrib gl
@appendixsec @code{(gl)} and @code{(glut)}




@c page
@node contrib number theory
@appendixsec @code{(math number-theory)}


@center Provided by: Jens Axel Soegaard

@center @url{https://code.launchpad.net/~soegaard/ikarus-libraries/soegaard}


@noindent
This library contains number theory code that I have written over a long
period.  The code began as an experiment.  I grabbed a book on number
theory from the shelve (@emph{``Elementary Number Theory''} by Gareth
A. Jones and J. Mary Jones) and began illustrating each definition and
each theorem with Scheme code.  The first half of the surce code is thus
a well commented mix of definitions, theorems and code.

The second half contains more sophisticated algorithms mostly of from
the excellent book @emph{``Modern Computer Algebra''} by Joachim von zur
Gathen and Joergen Gerhard.  The algorithms for factorizing large
integers come from this book.

Finally there are some definitions of special functions, mostly inspired
by the problems of the Euler Project.


@c page
@node devel
@appendix Accessing development revisions


@noindent
Ikarus development is accessible at the site:

@center @url{https://launchpad.net/ikarus}

@noindent
where we can find the latest release tarball.  For the development
revisions, we can use the Bazaar revision control system:

@center @url{http://bazaar-vcs.org/}

@noindent
Bazaar is written in Python, so you have to install Python, too.

To checkout the latest revision we do:

@example
$ bzr checkout --lightweight \
      http://bazaar.launchpad.net/~aghuloum/ikarus/ikarus.dev
@end example

@noindent
or simply:

@example
$ bzr checkout --lightweight lp:ikarus
@end example

@noindent
this will put the source tree under the @file{ikarus.dev} local
directory.  To checkout a specific revison, say 1700:

@example
$ bzr checkout --lightweight --revision=1700 lp:ikarus
@end example

@noindent
and to check it out into the @file{ikarus-1700} local directory:

@example
$ bzr checkout --lightweight --revision=1700 lp:ikarus ikarus-1700
@end example

@noindent
the command @command{bzr help} shows a little help screen for Bazaar;
the command @command{bzr checkout --help} shows a little help screen for
the @code{checkout} Bazaar subcommand; the command @command{bzr log}
prints the revision logs, and we can use it to read the number of the
last checkin.

@quotation
Notice that it is not mandatory to actually install, or even build,
Bazaar on our system, it is enough to unpack its release archive in a
directory; with Bazaar (at least) version 1.1 after unpacking we have a
functional @command{bzr} executable in the top directory of the source
tree, which we can use by typing its pathname:

@example
$ cd /usr/local/src
$ tar xvzf bzr-1.1.tar.gz
$ ./bzr-1.1/bzr checkout ...
@end example
@end quotation


@c page
@node missing
@appendix Missing Features


@noindent
Ikarus does not fully conform to @rnrs{6} yet.  Although it implements
most of @rnrs{6}'s macros and procedures, some are still missing.  This
appendix summarizes the set of missing features and procedures.

@itemize
@item
The procedure @func{equal?} may not terminate on infinite (circular)
input, when the input is @func{equal?}.

@item
@func{number->string} does not accept the third argument (precision).
Similarly, @func{string->number} and the reader do not recognize the
@code{|p} notation.

@item
The following procedures are missing from @code{(rnrs arithmetic
bitwise)}:

@example
bitwise-reverse-bit-field               bitwise-rotate-bit-field
@end example

@item
The following procedures are missing from @code{(rnrs arithmetic
fixnum)}:

@example
fxreverse-bit-field                     fxrotate-bit-field
@end example

@item
The following procedures are missing from @code{(rnrs hashtables)}:

@example
make-eqv-hashtable                      equal-hash
@end example

@item
The following procedures are missing from @code{(rnrs io ports)}:

@example
port-has-port-position?                 port-position
port-has-set-port-position!?            set-port-position!
make-custom-binary-input/output-port
make-custom-textual-input/output-port
open-file-input/output-port
@end example
@end itemize


@c page
@node credits
@appendix Credits for this document


@subsubheading Skeleton

The skeleton of this document is the original ``Ikarus User's Guide'' in
XeLaTeX format, by Abdulaziz Ghulom.  That document is available in the
Ikarus distribution and is covered by the @gnu{} General Public License
version 3 as published by the Free Software Foundation.  It is available
at the following @aurl{}s:

@center @url{http://www.cs.indiana.edu/~aghuloum/ikarus/}
@center @url{https://launchpad.net/ikarus}

@c ------------------------------------------------------------

@subsubheading Language definition, base and standard library

The chapters describing the language (@ref{lang}), the Scheme base
library (@ref{baselib}) and the Scheme Standard Library (@ref{stdlib})
are derived from the original ``Revised^6 Report on the Algorithmic
Language Scheme'' document and the original ``Revised^6 Report on the
Algorithmic Language Scheme ---- Standard Libraries'', authored by the
following people:

@quotation
@noindent
MICHAEL SPERBER@*
R. KENT DYBVIG, MATTHEW FLATT, ANTON VAN STRAATEN@*
(Editors)

@noindent
RICHARD KELSEY, WILLIAM CLINGER, JONATHAN REES@*
(Editors, Revised^5 Report on the Algorithmic Language Scheme)

@noindent
ROBERT BRUCE FINDLER, JACOB MATTHEWS@*
(Authors, formal semantics)
@end quotation

@noindent
with various contributions by the following people:

@quotation
Hal Abelson, Norman Adams, David Bartley, Gary Brooks, William Clinger,
R. Kent Dybvig, Daniel Friedman, Robert Halstead, Chris Hanson,
Christopher Haynes, Eugene Kohlbecker, Don Oxley, Kent Pitman, Jonathan
Rees, Guillermo Rozas, Guy L. Steele Jr., Gerald Jay Sussman, and
Mitchell Wand.
@end quotation

@noindent
and a lot of discussions and debates by the Scheme community.  According
to the following quotation from the original document:

@quotation
We intend this report to belong to the entire Scheme community, and so
we grant permission to copy it in whole or in part without fee.  In
particular, we encourage implementors of Scheme to use this report as a
starting point for manuals and other documentation, modifying it as
necessary.
@end quotation

@noindent
the document is meant to be in the public domain.  It is available at:

@center @url{http://www.r6rs.org/}
@center @url{http://www.r6rs.org/r6rs-errata.html}



@c page
@node package license
@appendix @gnu{} General Public License

@c The GNU General Public License.
@center Version 3, 29 June 2007

@display
Copyright @copyright{} 2007 Free Software Foundation, Inc. @url{http://fsf.org/}

Everyone is permitted to copy and distribute verbatim copies of this
license document, but changing it is not allowed.
@end display

@heading Preamble

The GNU General Public License is a free, copyleft license for
software and other kinds of works.

The licenses for most software and other practical works are designed
to take away your freedom to share and change the works.  By contrast,
the GNU General Public License is intended to guarantee your freedom
to share and change all versions of a program---to make sure it remains
free software for all its users.  We, the Free Software Foundation,
use the GNU General Public License for most of our software; it
applies also to any other work released this way by its authors.  You
can apply it to your programs, too.

When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
them if you wish), that you receive source code or can get it if you
want it, that you can change the software or use pieces of it in new
free programs, and that you know you can do these things.

To protect your rights, we need to prevent others from denying you
these rights or asking you to surrender the rights.  Therefore, you
have certain responsibilities if you distribute copies of the
software, or if you modify it: responsibilities to respect the freedom
of others.

For example, if you distribute copies of such a program, whether
gratis or for a fee, you must pass on to the recipients the same
freedoms that you received.  You must make sure that they, too,
receive or can get the source code.  And you must show them these
terms so they know their rights.

Developers that use the GNU GPL protect your rights with two steps:
(1) assert copyright on the software, and (2) offer you this License
giving you legal permission to copy, distribute and/or modify it.

For the developers' and authors' protection, the GPL clearly explains
that there is no warranty for this free software.  For both users' and
authors' sake, the GPL requires that modified versions be marked as
changed, so that their problems will not be attributed erroneously to
authors of previous versions.

Some devices are designed to deny users access to install or run
modified versions of the software inside them, although the
manufacturer can do so.  This is fundamentally incompatible with the
aim of protecting users' freedom to change the software.  The
systematic pattern of such abuse occurs in the area of products for
individuals to use, which is precisely where it is most unacceptable.
Therefore, we have designed this version of the GPL to prohibit the
practice for those products.  If such problems arise substantially in
other domains, we stand ready to extend this provision to those
domains in future versions of the GPL, as needed to protect the
freedom of users.

Finally, every program is threatened constantly by software patents.
States should not allow patents to restrict development and use of
software on general-purpose computers, but in those that do, we wish
to avoid the special danger that patents applied to a free program
could make it effectively proprietary.  To prevent this, the GPL
assures that patents cannot be used to render the program non-free.

The precise terms and conditions for copying, distribution and
modification follow.

@heading TERMS AND CONDITIONS

@enumerate 0
@item
Definitions.

``This License'' refers to version 3 of the GNU General Public License.

``Copyright'' also means copyright-like laws that apply to other kinds
of works, such as semiconductor masks.

``The Program'' refers to any copyrightable work licensed under this
License.  Each licensee is addressed as ``you''.  ``Licensees'' and
``recipients'' may be individuals or organizations.

To ``modify'' a work means to copy from or adapt all or part of the work
in a fashion requiring copyright permission, other than the making of
an exact copy.  The resulting work is called a ``modified version'' of
the earlier work or a work ``based on'' the earlier work.

A ``covered work'' means either the unmodified Program or a work based
on the Program.

To ``propagate'' a work means to do anything with it that, without
permission, would make you directly or secondarily liable for
infringement under applicable copyright law, except executing it on a
computer or modifying a private copy.  Propagation includes copying,
distribution (with or without modification), making available to the
public, and in some countries other activities as well.

To ``convey'' a work means any kind of propagation that enables other
parties to make or receive copies.  Mere interaction with a user
through a computer network, with no transfer of a copy, is not
conveying.

An interactive user interface displays ``Appropriate Legal Notices'' to
the extent that it includes a convenient and prominently visible
feature that (1) displays an appropriate copyright notice, and (2)
tells the user that there is no warranty for the work (except to the
extent that warranties are provided), that licensees may convey the
work under this License, and how to view a copy of this License.  If
the interface presents a list of user commands or options, such as a
menu, a prominent @item
in the list meets this criterion.

@item
Source Code.

The ``source code'' for a work means the preferred form of the work for
making modifications to it.  ``Object code'' means any non-source form
of a work.

A ``Standard Interface'' means an interface that either is an official
standard defined by a recognized standards body, or, in the case of
interfaces specified for a particular programming language, one that
is widely used among developers working in that language.

The ``System Libraries'' of an executable work include anything, other
than the work as a whole, that (a) is included in the normal form of
packaging a Major Component, but which is not part of that Major
Component, and (b) serves only to enable use of the work with that
Major Component, or to implement a Standard Interface for which an
implementation is available to the public in source code form.  A
``Major Component'', in this context, means a major essential component
(kernel, window system, and so on) of the specific operating system
(if any) on which the executable work runs, or a compiler used to
produce the work, or an object code interpreter used to run it.

The ``Corresponding Source'' for a work in object code form means all
the source code needed to generate, install, and (for an executable
work) run the object code and to modify the work, including scripts to
control those activities.  However, it does not include the work's
System Libraries, or general-purpose tools or generally available free
programs which are used unmodified in performing those activities but
which are not part of the work.  For example, Corresponding Source
includes interface definition files associated with source files for
the work, and the source code for shared libraries and dynamically
linked subprograms that the work is specifically designed to require,
such as by intimate data communication or control flow between those
subprograms and other parts of the work.

The Corresponding Source need not include anything that users can
regenerate automatically from other parts of the Corresponding Source.

The Corresponding Source for a work in source code form is that same
work.

@item
Basic Permissions.

All rights granted under this License are granted for the term of
copyright on the Program, and are irrevocable provided the stated
conditions are met.  This License explicitly affirms your unlimited
permission to run the unmodified Program.  The output from running a
covered work is covered by this License only if the output, given its
content, constitutes a covered work.  This License acknowledges your
rights of fair use or other equivalent, as provided by copyright law.

You may make, run and propagate covered works that you do not convey,
without conditions so long as your license otherwise remains in force.
You may convey covered works to others for the sole purpose of having
them make modifications exclusively for you, or provide you with
facilities for running those works, provided that you comply with the
terms of this License in conveying all material for which you do not
control copyright.  Those thus making or running the covered works for
you must do so exclusively on your behalf, under your direction and
control, on terms that prohibit them from making any copies of your
copyrighted material outside their relationship with you.

Conveying under any other circumstances is permitted solely under the
conditions stated below.  Sublicensing is not allowed; section 10
makes it unnecessary.

@item
Protecting Users' Legal Rights From Anti-Circumvention Law.

No covered work shall be deemed part of an effective technological
measure under any applicable law fulfilling obligations under article
11 of the WIPO copyright treaty adopted on 20 December 1996, or
similar laws prohibiting or restricting circumvention of such
measures.

When you convey a covered work, you waive any legal power to forbid
circumvention of technological measures to the extent such
circumvention is effected by exercising rights under this License with
respect to the covered work, and you disclaim any intention to limit
operation or modification of the work as a means of enforcing, against
the work's users, your or third parties' legal rights to forbid
circumvention of technological measures.

@item
Conveying Verbatim Copies.

You may convey verbatim copies of the Program's source code as you
receive it, in any medium, provided that you conspicuously and
appropriately publish on each copy an appropriate copyright notice;
keep intact all notices stating that this License and any
non-permissive terms added in accord with section 7 apply to the code;
keep intact all notices of the absence of any warranty; and give all
recipients a copy of this License along with the Program.

You may charge any price or no price for each copy that you convey,
and you may offer support or warranty protection for a fee.

@item
Conveying Modified Source Versions.

You may convey a work based on the Program, or the modifications to
produce it from the Program, in the form of source code under the
terms of section 4, provided that you also meet all of these
conditions:

@enumerate a
@item

The work must carry prominent notices stating that you modified it,
and giving a relevant date.

@item

The work must carry prominent notices stating that it is released
under this License and any conditions added under section 7.  This
requirement modifies the requirement in section 4 to ``keep intact all
notices''.

@item

You must license the entire work, as a whole, under this License to
anyone who comes into possession of a copy.  This License will
therefore apply, along with any applicable section 7 additional terms,
to the whole of the work, and all its parts, regardless of how they
are packaged.  This License gives no permission to license the work in
any other way, but it does not invalidate such permission if you have
separately received it.

@item

If the work has interactive user interfaces, each must display
Appropriate Legal Notices; however, if the Program has interactive
interfaces that do not display Appropriate Legal Notices, your work
need not make them do so.
@end enumerate

A compilation of a covered work with other separate and independent
works, which are not by their nature extensions of the covered work,
and which are not combined with it such as to form a larger program,
in or on a volume of a storage or distribution medium, is called an
``aggregate'' if the compilation and its resulting copyright are not
used to limit the access or legal rights of the compilation's users
beyond what the individual works permit.  Inclusion of a covered work
in an aggregate does not cause this License to apply to the other
parts of the aggregate.

@item
 Conveying Non-Source Forms.

You may convey a covered work in object code form under the terms of
sections 4 and 5, provided that you also convey the machine-readable
Corresponding Source under the terms of this License, in one of these
ways:

@enumerate a
@item

Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by the
Corresponding Source fixed on a durable physical medium customarily
used for software interchange.

@item

Convey the object code in, or embodied in, a physical product
(including a physical distribution medium), accompanied by a written
offer, valid for at least three years and valid for as long as you
offer spare parts or customer support for that product model, to give
anyone who possesses the object code either (1) a copy of the
Corresponding Source for all the software in the product that is
covered by this License, on a durable physical medium customarily used
for software interchange, for a price no more than your reasonable
cost of physically performing this conveying of source, or (2) access
to copy the Corresponding Source from a network server at no charge.

@item

Convey individual copies of the object code with a copy of the written
offer to provide the Corresponding Source.  This alternative is
allowed only occasionally and noncommercially, and only if you
received the object code with such an offer, in accord with subsection
6b.

@item

Convey the object code by offering access from a designated place
(gratis or for a charge), and offer equivalent access to the
Corresponding Source in the same way through the same place at no
further charge.  You need not require recipients to copy the
Corresponding Source along with the object code.  If the place to copy
the object code is a network server, the Corresponding Source may be
on a different server (operated by you or a third party) that supports
equivalent copying facilities, provided you maintain clear directions
next to the object code saying where to find the Corresponding Source.
Regardless of what server hosts the Corresponding Source, you remain
obligated to ensure that it is available for as long as needed to
satisfy these requirements.

@item

Convey the object code using peer-to-peer transmission, provided you
inform other peers where the object code and Corresponding Source of
the work are being offered to the general public at no charge under
subsection 6d.

@end enumerate

A separable portion of the object code, whose source code is excluded
from the Corresponding Source as a System Library, need not be
included in conveying the object code work.

A ``User Product'' is either (1) a ``consumer product'', which means any
tangible personal property which is normally used for personal,
family, or household purposes, or (2) anything designed or sold for
incorporation into a dwelling.  In determining whether a product is a
consumer product, doubtful cases shall be resolved in favor of
coverage.  For a particular product received by a particular user,
``normally used'' refers to a typical or common use of that class of
product, regardless of the status of the particular user or of the way
in which the particular user actually uses, or expects or is expected
to use, the product.  A product is a consumer product regardless of
whether the product has substantial commercial, industrial or
non-consumer uses, unless such uses represent the only significant
mode of use of the product.

``Installation Information'' for a User Product means any methods,
procedures, authorization keys, or other information required to
install and execute modified versions of a covered work in that User
Product from a modified version of its Corresponding Source.  The
information must suffice to ensure that the continued functioning of
the modified object code is in no case prevented or interfered with
solely because modification has been made.

If you convey an object code work under this section in, or with, or
specifically for use in, a User Product, and the conveying occurs as
part of a transaction in which the right of possession and use of the
User Product is transferred to the recipient in perpetuity or for a
fixed term (regardless of how the transaction is characterized), the
Corresponding Source conveyed under this section must be accompanied
by the Installation Information.  But this requirement does not apply
if neither you nor any third party retains the ability to install
modified object code on the User Product (for example, the work has
been installed in ROM).

The requirement to provide Installation Information does not include a
requirement to continue to provide support service, warranty, or
updates for a work that has been modified or installed by the
recipient, or for the User Product in which it has been modified or
installed.  Access to a network may be denied when the modification
itself materially and adversely affects the operation of the network
or violates the rules and protocols for communication across the
network.

Corresponding Source conveyed, and Installation Information provided,
in accord with this section must be in a format that is publicly
documented (and with an implementation available to the public in
source code form), and must require no special password or key for
unpacking, reading or copying.

@item
Additional Terms.

``Additional permissions'' are terms that supplement the terms of this
License by making exceptions from one or more of its conditions.
Additional permissions that are applicable to the entire Program shall
be treated as though they were included in this License, to the extent
that they are valid under applicable law.  If additional permissions
apply only to part of the Program, that part may be used separately
under those permissions, but the entire Program remains governed by
this License without regard to the additional permissions.

When you convey a copy of a covered work, you may at your option
remove any additional permissions from that copy, or from any part of
it.  (Additional permissions may be written to require their own
removal in certain cases when you modify the work.)  You may place
additional permissions on material, added by you to a covered work,
for which you have or can give appropriate copyright permission.

Notwithstanding any other provision of this License, for material you
add to a covered work, you may (if authorized by the copyright holders
of that material) supplement the terms of this License with terms:

@enumerate a
@item

Disclaiming warranty or limiting liability differently from the terms
of sections 15 and 16 of this License; or

@item

Requiring preservation of specified reasonable legal notices or author
attributions in that material or in the Appropriate Legal Notices
displayed by works containing it; or

@item

Prohibiting misrepresentation of the origin of that material, or
requiring that modified versions of such material be marked in
reasonable ways as different from the original version; or

@item

Limiting the use for publicity purposes of names of licensors or
authors of the material; or

@item

Declining to grant rights under trademark law for use of some trade
names, trademarks, or service marks; or

@item

Requiring indemnification of licensors and authors of that material by
anyone who conveys the material (or modified versions of it) with
contractual assumptions of liability to the recipient, for any
liability that these contractual assumptions directly impose on those
licensors and authors.
@end enumerate

All other non-permissive additional terms are considered ``further
restrictions'' within the meaning of section 10.  If the Program as you
received it, or any part of it, contains a notice stating that it is
governed by this License along with a term that is a further
restriction, you may remove that term.  If a license document contains
a further restriction but permits relicensing or conveying under this
License, you may add to a covered work material governed by the terms
of that license document, provided that the further restriction does
not survive such relicensing or conveying.

If you add terms to a covered work in accord with this section, you
must place, in the relevant source files, a statement of the
additional terms that apply to those files, or a notice indicating
where to find the applicable terms.

Additional terms, permissive or non-permissive, may be stated in the
form of a separately written license, or stated as exceptions; the
above requirements apply either way.

@item
Termination.

You may not propagate or modify a covered work except as expressly
provided under this License.  Any attempt otherwise to propagate or
modify it is void, and will automatically terminate your rights under
this License (including any patent licenses granted under the third
paragraph of section 11).

However, if you cease all violation of this License, then your license
from a particular copyright holder is reinstated (a) provisionally,
unless and until the copyright holder explicitly and finally
terminates your license, and (b) permanently, if the copyright holder
fails to notify you of the violation by some reasonable means prior to
60 days after the cessation.

Moreover, your license from a particular copyright holder is
reinstated permanently if the copyright holder notifies you of the
violation by some reasonable means, this is the first time you have
received notice of violation of this License (for any work) from that
copyright holder, and you cure the violation prior to 30 days after
your receipt of the notice.

Termination of your rights under this section does not terminate the
licenses of parties who have received copies or rights from you under
this License.  If your rights have been terminated and not permanently
reinstated, you do not qualify to receive new licenses for the same
material under section 10.

@item
Acceptance Not Required for Having Copies.

You are not required to accept this License in order to receive or run
a copy of the Program.  Ancillary propagation of a covered work
occurring solely as a consequence of using peer-to-peer transmission
to receive a copy likewise does not require acceptance.  However,
nothing other than this License grants you permission to propagate or
modify any covered work.  These actions infringe copyright if you do
not accept this License.  Therefore, by modifying or propagating a
covered work, you indicate your acceptance of this License to do so.

@item
Automatic Licensing of Downstream Recipients.

Each time you convey a covered work, the recipient automatically
receives a license from the original licensors, to run, modify and
propagate that work, subject to this License.  You are not responsible
for enforcing compliance by third parties with this License.

An ``entity transaction'' is a transaction transferring control of an
organization, or substantially all assets of one, or subdividing an
organization, or merging organizations.  If propagation of a covered
work results from an entity transaction, each party to that
transaction who receives a copy of the work also receives whatever
licenses to the work the party's predecessor in interest had or could
give under the previous paragraph, plus a right to possession of the
Corresponding Source of the work from the predecessor in interest, if
the predecessor has it or can get it with reasonable efforts.

You may not impose any further restrictions on the exercise of the
rights granted or affirmed under this License.  For example, you may
not impose a license fee, royalty, or other charge for exercise of
rights granted under this License, and you may not initiate litigation
(including a cross-claim or counterclaim in a lawsuit) alleging that
any patent claim is infringed by making, using, selling, offering for
sale, or importing the Program or any portion of it.

@item
Patents.

A ``contributor'' is a copyright holder who authorizes use under this
License of the Program or a work on which the Program is based.  The
work thus licensed is called the contributor's ``contributor version''.

A contributor's ``essential patent claims'' are all patent claims owned
or controlled by the contributor, whether already acquired or
hereafter acquired, that would be infringed by some manner, permitted
by this License, of making, using, or selling its contributor version,
but do not include claims that would be infringed only as a
consequence of further modification of the contributor version.  For
purposes of this definition, ``control'' includes the right to grant
patent sublicenses in a manner consistent with the requirements of
this License.

Each contributor grants you a non-exclusive, worldwide, royalty-free
patent license under the contributor's essential patent claims, to
make, use, sell, offer for sale, import and otherwise run, modify and
propagate the contents of its contributor version.

In the following three paragraphs, a ``patent license'' is any express
agreement or commitment, however denominated, not to enforce a patent
(such as an express permission to practice a patent or covenant not to
sue for patent infringement).  To ``grant'' such a patent license to a
party means to make such an agreement or commitment not to enforce a
patent against the party.

If you convey a covered work, knowingly relying on a patent license,
and the Corresponding Source of the work is not available for anyone
to copy, free of charge and under the terms of this License, through a
publicly available network server or other readily accessible means,
then you must either (1) cause the Corresponding Source to be so
available, or (2) arrange to deprive yourself of the benefit of the
patent license for this particular work, or (3) arrange, in a manner
consistent with the requirements of this License, to extend the patent
license to downstream recipients.  ``Knowingly relying'' means you have
actual knowledge that, but for the patent license, your conveying the
covered work in a country, or your recipient's use of the covered work
in a country, would infringe one or more identifiable patents in that
country that you have reason to believe are valid.

If, pursuant to or in connection with a single transaction or
arrangement, you convey, or propagate by procuring conveyance of, a
covered work, and grant a patent license to some of the parties
receiving the covered work authorizing them to use, propagate, modify
or convey a specific copy of the covered work, then the patent license
you grant is automatically extended to all recipients of the covered
work and works based on it.

A patent license is ``discriminatory'' if it does not include within the
scope of its coverage, prohibits the exercise of, or is conditioned on
the non-exercise of one or more of the rights that are specifically
granted under this License.  You may not convey a covered work if you
are a party to an arrangement with a third party that is in the
business of distributing software, under which you make payment to the
third party based on the extent of your activity of conveying the
work, and under which the third party grants, to any of the parties
who would receive the covered work from you, a discriminatory patent
license (a) in connection with copies of the covered work conveyed by
you (or copies made from those copies), or (b) primarily for and in
connection with specific products or compilations that contain the
covered work, unless you entered into that arrangement, or that patent
license was granted, prior to 28 March 2007.

Nothing in this License shall be construed as excluding or limiting
any implied license or other defenses to infringement that may
otherwise be available to you under applicable patent law.

@item
No Surrender of Others' Freedom.

If conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot convey
a covered work so as to satisfy simultaneously your obligations under
this License and any other pertinent obligations, then as a
consequence you may not convey it at all.  For example, if you agree
to terms that obligate you to collect a royalty for further conveying
from those to whom you convey the Program, the only way you could
satisfy both those terms and this License would be to refrain entirely
from conveying the Program.

@item
Use with the GNU Affero General Public License.

Notwithstanding any other provision of this License, you have
permission to link or combine any covered work with a work licensed
under version 3 of the GNU Affero General Public License into a single
combined work, and to convey the resulting work.  The terms of this
License will continue to apply to the part which is the covered work,
but the special requirements of the GNU Affero General Public License,
section 13, concerning interaction through a network will apply to the
combination as such.

@item
Revised Versions of this License.

The Free Software Foundation may publish revised and/or new versions
of the GNU General Public License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Program
specifies that a certain numbered version of the GNU General Public
License ``or any later version'' applies to it, you have the option of
following the terms and conditions either of that numbered version or
of any later version published by the Free Software Foundation.  If
the Program does not specify a version number of the GNU General
Public License, you may choose any version ever published by the Free
Software Foundation.

If the Program specifies that a proxy can decide which future versions
of the GNU General Public License can be used, that proxy's public
statement of acceptance of a version permanently authorizes you to
choose that version for the Program.

Later license versions may give you additional or different
permissions.  However, no additional obligations are imposed on any
author or copyright holder as a result of your choosing to follow a
later version.

@item
Disclaimer of Warranty.

THERE IS NO WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY
APPLICABLE LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM ``AS IS'' WITHOUT
WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT
LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND
PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE PROGRAM PROVE
DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY SERVICING, REPAIR OR
CORRECTION.

@item
Limitation of Liability.

IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN WRITING
WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MODIFIES AND/OR
CONVEYS THE PROGRAM AS PERMITTED ABOVE, BE LIABLE TO YOU FOR DAMAGES,
INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR CONSEQUENTIAL DAMAGES
ARISING OUT OF THE USE OR INABILITY TO USE THE PROGRAM (INCLUDING BUT
NOT LIMITED TO LOSS OF DATA OR DATA BEING RENDERED INACCURATE OR
LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A FAILURE OF THE PROGRAM
TO OPERATE WITH ANY OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER
PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

@item
Interpretation of Sections 15 and 16.

If the disclaimer of warranty and limitation of liability provided
above cannot be given local legal effect according to their terms,
reviewing courts shall apply local law that most closely approximates
an absolute waiver of all civil liability in connection with the
Program, unless a warranty or assumption of liability accompanies a
copy of the Program in return for a fee.

@end enumerate

@heading END OF TERMS AND CONDITIONS

@heading How to Apply These Terms to Your New Programs

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
state the exclusion of warranty; and each file should have at least
the ``copyright'' line and a pointer to where the full notice is found.

@smallexample
@var{one line to give the program's name and a brief idea of what it does.}
Copyright (C) @var{year} @var{name of author}

This program is free software: you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation, either version 3 of the License, or (at
your option) any later version.

This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see @url{http://www.gnu.org/licenses/}.
@end smallexample

Also add information on how to contact you by electronic and paper mail.

If the program does terminal interaction, make it output a short
notice like this when it starts in an interactive mode:

@smallexample
@var{program} Copyright (C) @var{year} @var{name of author}
This program comes with ABSOLUTELY NO WARRANTY; for details type @samp{show w}.
This is free software, and you are welcome to redistribute it
under certain conditions; type @samp{show c} for details.
@end smallexample

The hypothetical commands @samp{show w} and @samp{show c} should show
the appropriate parts of the General Public License.  Of course, your
program's commands might be different; for a GUI interface, you would
use an ``about box''.

You should also get your employer (if you work as a programmer) or school,
if any, to sign a ``copyright disclaimer'' for the program, if necessary.
For more information on this, and how to apply and follow the GNU GPL, see
@url{http://www.gnu.org/licenses/}.

The GNU General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use
the GNU Lesser General Public License instead of this License.  But
first, please read @url{http://www.gnu.org/philosophy/why-not-lgpl.html}.


@c page
@node references
@appendix Bibliography and references


@noindent
@emph{Revised^6 Report on the Algorithmic Language Scheme.}  Michael
Sperber and R. Kent Dybvig and Matthew Flatt and Anton Van Straaten
(Editors).  2007.

@noindent
@emph{Revised^6 Report on the Algorithmic Language Scheme---Standard
Libraries.}  Michael Sperber and R. Kent Dybvig and Matthew Flatt and
Anton Van Straaten (Editors). 2007.

@noindent
@emph{Scheme Request for Implementation 41: Streams.}  Philip L. Bewig.
2007.  @url{http://srfi.schemers.org/srfi-41/srfi-41.html}

@noindent
@bibref{DYBGUA} @emph{Guardians in a generation--based garbage
collector}.  R. Kent Dybvig and Carl Bruggeman and David Eby.  PLDI '93,
pages 207--216, June 1993.  Introduces guardians and describes the
implementation of guardians and weak pairs in Chez Scheme.

@noindent
@emph{Don't stop the BiBOP: Flexible and efficient storage management
for dynamically--typed languages.}  R. Kent Dybvig and David Eby and
Carl Bruggeman.  Technical Report 400, Indiana University, March 1994.
Describes Chez Scheme's storage management system.

@noindent
@emph{Generation Friendly Eq Hash Tables.}  Abdulaziz Ghuloum and
R. Kent Dybvig. In @emph{Proceedings of the 2007 Workshop on Scheme and
Functional Programming}, pages 207--216.  Universite Laval Technical
Report DIUL-RT-0701, 2007.

@noindent
@emph{Extending the Scope of Syntactic Abstraction.}  Oscar Waddell.
PhD thesis, Indiana University Computer Science Department, August 1999.
@url{http://www.cs.indiana.edu/~owaddell/papers/thesis.ps.gz}

@noindent
@emph{Extending the Scope of Syntactic Abstraction.}  Oscar Waddell and
R. Kent Dybvig.  In @emph{Conference Record of POPL'99: The 26th ACM
SIGPLAN-SIGACT Symposium on Principles of Programming Languages}, pages
203--213, January 1999.
@url{http://www.cs.indiana.edu/~dyb/papers/popl99.ps.gz}

@noindent
@emph{Chez Scheme Version 7 User's Guide.}  R. Kent Dybvig.  Cadence
Research Systems, 2005.  User's guide and reference manual for Chez
Scheme Version 7.  @url{http://www.scheme.com/csug7/}

@noindent
@emph{Implicit phasing for R6RS libraries.}  Abdulaziz Ghuloum and
R. Kent Dybvig.  In @emph{ICFP '07: Proceedings of the 2007 ACM SIGPLAN
international conference on Functional programming}, pages 303--314.
New York, NY, USA, 2007.  ACM.



@c page
@node examples
@appendix Scheme programming examples


@menu
* examples macros::             Exploring macro mechanisms.
@end menu


@c page
@node examples macros
@appendixsec Exploring macro mechanisms


The examples in this section are meant neither to be useful nor to be
meaningful; their only purpose is to highlight how the
@func{define-syntax}, @func{syntax-case} and @func{syntax} mechanism
works.

When the examples are especially simple, or do not require particular
features of @func{syntax-case}, the @func{syntax-rules} transformer is
used.  This is the case of some of the pattern examples.


@menu
* examples macros phases::      Bits about phases.
* examples macros underscore::  About the underscore.
* examples macros patterns::    About writing patterns.
* examples macros literals::    About literal identifiers.
* examples macros syntax::      Syntax objects and you.
@end menu



@c page
@node examples macros phases
@appendixsubsec Bits about phases


@quotation
@strong{The following ramblings do not aim at being rigorous.}
@end quotation

@noindent
Let's look at this code:

@example
(import (rnrs))

(define (gasp arg)
  arg)

(define (gulp arg)
  (gasp arg))

(gulp 123)
@end example

@noindent
Oll Korrect: we define two functions, one of which invokes the other in
its body.  Now look at this:

@example
(import (rnrs))

(let ()
  (define (gasp arg)
    arg)
  #f)

(let ()
  (define (gulp arg)
    (gasp arg))
  (gulp 123))
@end example

@noindent
this will not work: when @func{gulp} is invoked @func{gasp} does not
exist anymore, because it is ``local'' to the first @func{let}.  The two
functions exist at different ``times'' (using correct jargon for this
case: they belong to distinct @emph{regions}).

Let's state this clearly: Scheme allows sets of functions to exist at
different times.  With more generality: Scheme allows sets of
identifier/value bindings to exist at different times.  Fine.  Now we
know that, technologically speaking, we have this option.

In the two--@func{let} example above the two ``times'', the two regions,
correspond to two distinct chunks of code: the @func{let} forms.  We ask
ourselves if it is possible to make two set of functions exist at
different times in the same chunk of code; with this feature, we could
use the first set to compute values and build code that are used by the
second set.  It would be similar to preprocessing C language files with
the C language preprocessor.  The answer is that: yes, it is possible.

Inhabitants of the Scheme Pantheon decided that, in the same way as
@func{let} ``times'' are called @emph{regions}, these other ``times''
are called @emph{phases}.

To do such a thing we have to mark, select, partition, discriminate,
paint with different colours the functions that are meant to belong to
different phases.  We can imagine that there are special versions of
@func{define} and @func{eval} that select a phase:

@example
;; Imaginary code.

(define-for-phase-1 (gasp arg1)
  (cons 1 arg1))

(define-for-phase-2 (gulp arg2)
  (cons 2 (gasp arg2)))

(evaluate-in-phase-2
  (gulp 9))
@end example

@noindent
so that after evaluation phase @code{1} is finished, we have code
equivalent to:

@example
;; Imaginary code.

(define-for-phase-2 (gulp arg)
  (cons 2 (cons 1 arg)))

(evaluate-in-phase-2
  (gulp 9))
@end example

@noindent
which is equivalent to:

@example
;; Imaginary code.

(define (gulp arg)
  (cons 2 (cons 1 arg)))

(gulp 9)
@end example

@noindent
which is ``ordinary'' Scheme code that computes the improper list
@code{(2 1 . 9)}.

It turns out that code like this is really ugly, and the Scheme Pantheon
decided that a chunk of code, by itself, should have only two phases
called @code{expand} and @code{run}.  The @code{run} phase is the normal
one: it is when the program should do whatever it is meant to do (talk
to the user, download web pages, etc).  The @code{expand} phase is the
special one: it is when the program does the precomputation of values
and code.

So it is enough to mark one set of functions, and the Pantheon decided
that it is the @code{expand} set that must be marked differently.  Let's
look at:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(define-syntax expand-time-func
  (lambda (syntax-object)        ;; this is the expand
    123))                        ;; phase function

(define (run-time-func arg)
  (expand-time-func arg))

(check
 (run-time-func 456)
 => 123)

(check-report)
@end example

@noindent
where we have marked @func{expand-time-func} to exist at @code{expand}
time using @func{define-syntax}.  After evaluation phase @code{expand}
is finished the code is equivalent to:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(define (run-time-func arg)
  123)

(check
 (run-time-func 456)
 => 123)

(check-report)
@end example

@noindent
and everything works as we expect.

The single argument that is handed to the @code{expand} time function is
a weird beast called ``syntax object''.  All this section about
@func{syntax-case} deals with using syntax objects.

In the example above, it looks like @func{expand-time-func} is applied
to the @code{arg} argument of @func{run-time-func}; but what is actually
handed to the function is a syntax object holding information about the
whole form @code{(expand-time-func arg)} and the context where it was
located.

There are functions to extract and use values in the syntax object.  For
example the following script evaluates successfully:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(define-syntax expand-time-func
  (lambda (syntax-object)
    (caddr (syntax->datum syntax-object))))

(define (run-time-func arg)
  (expand-time-func arg 123))

(check
 (run-time-func 456)
 => '123)

(check-report)
@end example



@c page
@node examples macros underscore
@appendixsubsec About the underscore


It is stated that:

@quotation
Underscores, @code{_}, also match arbitrary input subforms but are not
pattern variables and so cannot be used to refer to those elements.
Multiple underscores may appear in a @meta{pattern}.
@end quotation

@noindent
@xref{baselib transformers,syntax-rules}.  It means that the following
script will evaluate successfully:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(check
 (let ()
   (define-syntax doit
     (syntax-rules ()
       ((doit _) 1)))

   (list (doit '(a b c))
         (doit 2)
         (doit '(a (b (c)) d (e)))))
 => '(1 1 1))

(check
 (let ()
   (define-syntax doit
     (syntax-rules ()
       ((doit _ _) 1)))

   (list (doit '(a b c) '(d e f))
         (doit 1 2)))
 => '(1 1))

(check-report)
@end example

The use of @code{_} allows us not to invent pattern variable names for
subpatterns that we do not care about in a @meta{syntax rule}.  In the
following:

@example
(define-syntax doit
  (syntax-rules ()
    ((doit ?arg)
     1)))
@end example

@noindent
we do not care about the actual value of @code{?arg}, so why should we
be forced to invent a name for it?  Better to write:

@example
(define-syntax doit
  (syntax-rules ()
    ((doit _)
     1)))
@end example

It is customary to use @code{_} in the pattern of @meta{syntax rule}s as
a placeholder for the macro use name:

@example
(define-syntax doit
  (syntax-rules ()
    ((_ ?arg)
     (list ?arg))))
@end example

@noindent
but there is nothing special about this: it is convenient because one
has only one char to type.  Notice that when writing @func{syntax-case}
forms using @code{_} as first subpattern of patterns, while still
possible, may need to be avoided because there is the need to use the
macro use identifier, and it is not possible to do it with @code{_}.



@c page
@node examples macros patterns
@appendixsubsec About writing patterns


@subsubheading At least one element in a subpattern with ellipsis


When we want to specify a pattern or subpattern that matches at least
one element from the input form we have to use @code{?elm0 ?elm ...};
this is because the @code{?elm ...} subpattern matches @strong{zero} or
more elements.  So the following correctly returns @code{error} when
zero elements are used:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(define-syntax doit
  (syntax-rules ()
    ((_ ?elm0 ?elm ...)
     '(?elm0 ?elm ...))
    ((_ . ?rest)
     'error)))

(check (doit 1)         => '(1))
(check (doit 1 2 3)     => '(1 2 3))
(check (doit)           => 'error)

(check-report)
@end example

@noindent
while the following happily matches zero arguments to the macro:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(define-syntax doit
  (syntax-rules ()
    ((_ ?elm ...)
     '(?elm ...))
    ((_ . ?rest)
     'error)))

(check (doit 1)         => '(1))
(check (doit 1 2 3)     => '(1 2 3))
(check (doit)           => '())

(check-report)
@end example

@noindent
here the @code{(_ . ?rest)} is never matched.

@c ------------------------------------------------------------


@subsubheading Matching proper lists but not improper lists


When the @code{?arg ...} and @code{. ?args} subpatterns appear at the
end of a list, they both match all the other elements (the cdr), which
can be zero or more.  There is one difference: while @code{?arg ...}
matches only a proper list, @code{. ?args} matches both proper and
improper lists.  So the following works always:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(define-syntax doit
  (syntax-rules ()
    ((_ . ?args)
     '?args)))

(check (doit 1)         => '(1))
(check (doit 1 2 3)     => '(1 2 3))
(check (doit 1 . 2)     => '(1 . 2))

(check-report)
@end example

@noindent
but the following raises an ``invalid syntax'' error in the improper
list check:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

(define-syntax doit
  (syntax-rules ()
    ((_ ?arg ...)
     '(?arg ...))))

(check (doit 1)         => '(1))
(check (doit 1 2 3)     => '(1 2 3))
(check (doit 1 . 2)     => '(1 . 2))

(check-report)
@end example

Notice that the @meta{formals} argument of a @func{lambda} can be an
improper list when we use the @code{(arg1 arg2 . args)} form to bind the
rest arguments to @code{args}.  So to properly match @meta{formals} the
general @meta{formals} we have to use the @code{?arg . ?args}
subpattern.



@c page
@node examples macros literals
@appendixsubsec About literal identifiers


It is stated that:

@quotation
A @meta{literal} identifier matches an input subform if and only if the
input subform is an identifier and either both its occurrence in the
input expression and its occurrence in the list of literals have the
same lexical binding, or the two identifiers have the same name and both
have no lexical binding.
@end quotation

@noindent
@xref{baselib transformers,syntax-rules}.  Literal identifiers are
useful to ``mark'' subforms of the input form that have special meaning.
In a way, @meta{literal}s can act as comments.

The following script will evaluate successfully:

@example
(import (rnrs) (srfi lightweight-testing))
(check-set-mode! 'report-failed)

;;;In this  example 'alpha'  has NO lexical  binding in  both the
;;;literals list of SYNTAX-RULES and the input expression.
(check
 (let ()
   (define-syntax doit
     (syntax-rules (alpha)
       ((_ ?arg1 (alpha ?arg2))
        (list ?arg1 ?arg2))))

   (doit 1 (alpha 2)))
 => '(1 2))

;;;In this example  'alpha' has THE SAME lexical  binding in both
;;;the literals list of SYNTAX-RULES and the input expression.
(check
 (let ((alpha 123))
   (define-syntax doit
     (syntax-rules (alpha)
       ((_ ?arg1 (alpha ?arg2))
        (list ?arg1 ?arg2))))

   (doit 1 (alpha 2)))
 => '(1 2))

(check-report)
@end example

@noindent
while both the following examples will fail with a compile time error,
because @code{alpha} has @strong{different} lexical bindings in the
literals list of @func{syntax-rules} and the input expression:

@example
(check
 (let ()
   (define-syntax doit
     (syntax-rules (alpha)
       ((_ ?arg1 (alpha ?arg2))
        (list ?arg1 ?arg2))))

   (let ((alpha 123))
     (doit 1 (alpha 2))))
 => '(1 2))

(check
 (let ()
   (define-syntax doit
     (let ((alpha 123))
       (syntax-rules (alpha)
         ((_ ?arg1 (alpha ?arg2))
          (list ?arg1 ?arg2)))))

     (doit 1 (alpha 2)))
 => '(1 2))
@end example

@noindent
quoting the literal makes no difference:

@example
(check
 (let ()
   (define-syntax doit
     (syntax-rules (alpha)
       ((_ ?arg1 ((quote alpha) ?arg2))
        (list ?arg1 ?arg2))))

   (let ((alpha 123))
     (doit 1 ((quote alpha) 2))))
 => '(1 2))
@end example

@noindent
it is still a compile time error.


@c page
@node examples macros syntax
@appendixsubsec Syntax objects and you


Syntax objects are constructed with @func{syntax}.


@menu
* examples macros syntax not::   What we do not do.
@end menu


@c page
@node examples macros syntax not
@appendixsubsubsec What we do not do


We have to make clear that we cannot extract at will informations from a
syntax object; only in particular context we can do something with
them.  So the following is useless:

@example
(define (doit stx)
  ---)

(let ((alpha 1)
      (beta  2)
      (delta 3))
  (doit (syntax (alpha beta delta))))
@end example

@noindent
the expansion of @func{syntax} (which is a syntax, not a function)
creates a syntax object that is used as argument for @func{doit}; but we
can do nothing useful with it in the body of @func{doit}, neither for
actual solution of programming problems, nor to show how syntax objects
work.

The following checks will work, but they only demonstrate that we can
shoot the breeze with @func{syntax} and @func{syntax->datum}:

@example
(check
    (let ()
      (define (doit stx)
        (syntax-case stx ()
          ((use ?arg0 ?arg1)
           (syntax->datum (syntax ?arg0)))))
      (let ((alpha 1)
            (beta  2)
            (delta 3))
        (doit (syntax (alpha beta delta)))))
  => 'beta)

(check
    (let ()
      (define (doit stx)
        (syntax-case stx ()
          ((use ?arg0 ?arg1)
           (list (syntax->datum (syntax use))
                 (syntax->datum (syntax ?arg0))
                 (syntax->datum (syntax ?arg1))))))
      (let ((alpha 1)
            (beta  2)
            (delta 3))
        (doit (syntax (alpha beta delta)))))
  => '(alpha beta delta))

(check
    (let ()
      (define (doit stx)
        (syntax-case stx ()
          ((use ?arg0 ?arg1)
           (syntax->datum (syntax (use ?arg0 ?arg1))))))
      (let ((alpha 1)
            (beta  2)
            (delta 3))
        (doit (syntax (alpha beta delta)))))
  => '(alpha beta delta))
@end example


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c TeX-master: t
@c End:
