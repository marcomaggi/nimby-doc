\input texinfo.tex
@c %**start of header
@setfilename ypsilon.info
@settitle The Other Ypsilon User's Guide
@c %**end of header

@c page
@c ------------------------------------------------------------
@c Generic macros.
@c ------------------------------------------------------------

@macro version{}
285
@end macro

@macro texiversion{}
2008-12-01-13-54-06
@end macro


@c page
@c ------------------------------------------------------------
@c Special notes.
@c ------------------------------------------------------------

@macro forunix{}
@strong{Unix:}
@end macro

@macro fixme{TEXT}
@strong{FIXME: \TEXT\}
@end macro

@macro unstable{REVISION}
@quotation
@strong{Undocumented feature:} this feature is still undocumented in
Ypsilon revision \REVISION\, so it may change in the future.
@end quotation
@end macro


@c page
@c ------------------------------------------------------------
@c Scheme related macros.
@c ------------------------------------------------------------

@macro rsix{}
Revised^6 Report on the algorithmic language Scheme
@end macro

@macro rfive{}
@emph{Revised^5 Report on the Algorithmic Language Scheme}
@end macro

@macro repl{}
@acronym{REPL}
@end macro

@macro srfi{}
@acronym{SRFI}
@end macro

@c Separating the @srfi{} macro from the number with a '--' rather than
@c a '-'  makes the expansion look  ugly in menu entries  under the Info
@c reader.  IMHO  this should not happen,  but it does; so  we live with
@c this, because the main purpose of this document is to provide an Info
@c version.
@macro ansrfi{NUM}
@srfi{}-\NUM\
@end macro

@macro clos{}
@acronym{CLOS}
@end macro

@macro library{SPEC}
@code{(\SPEC\)}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro


@c page
@c ------------------------------------------------------------
@c Macros for references to external documents.
@c ------------------------------------------------------------

@macro glibcref{NODE, TITLE}
@ref{\NODE\,\TITLE\,\TITLE\,libc}
@end macro

@c @macro rsixref{NODE, TITLE}
@c @ref{\NODE\,\TITLE\,\TITLE\,r6rs}
@c @end macro

@macro bibref{TAG}
@code{[\TAG\]}
@end macro


@c page
@c ------------------------------------------------------------
@c RNRS document macros.
@c ------------------------------------------------------------

@macro rsixlibrary{THING}
@code{(rnrs \THING\ (6))}
@end macro

@macro arbno{THING}
\THING\*
@end macro

@macro atleastone{THING}
\THING\+
@end macro

@macro rnrs{NUMBER}
@acronym{R\NUMBER\RS}
@end macro

@c ------------------------------------------------------------

@macro meta{THING}
<\THING\>
@end macro

@macro metai{THING}
<\THING\1>
@end macro

@macro metaii{THING}
<\THING\2>
@end macro

@macro metaiii{THING}
<\THING\3>
@end macro

@c ------------------------------------------------------------

@macro hyper{THING}
<\THING\>
@end macro

@macro hyperi{THING}
<\THING\1>
@end macro

@macro hyperii{THING}
<\THING\2>
@end macro

@macro hyperiii{THING}
<\THING\3>
@end macro

@macro hypern{THING}
<\THING\n>
@end macro

@c ------------------------------------------------------------

@macro vari{THING}
@var{\THING\1}
@end macro

@macro varii{THING}
@var{\THING\2}
@end macro

@macro variii{THING}
@var{\THING\3}
@end macro

@macro variv{THING}
@var{\THING\4}
@end macro

@macro varn{THING}
@var{\THING\n}
@end macro

@macro vark{THING}
@var{\THING\k}
@end macro

@macro varj{THING}
@var{\THING\j}
@end macro

@c ------------------------------------------------------------

@c page
@c ------------------------------------------------------------
@c Miscellaneous acronyms.
@c ------------------------------------------------------------

@macro ansi{}
@acronym{ANSI}
@end macro

@macro api{}
@acronym{API}
@end macro

@c Remember that @url is already used by Texinfo.
@macro aurl{}
@acronym{URL}
@end macro

@macro ascii{}
@acronym{ASCII}
@end macro

@macro cpu{}
@acronym{CPU}
@end macro

@macro ieee{}
@acronym{IEEE}
@end macro

@macro iso{}
@acronym{ISO}
@end macro

@macro gnu{}
@acronym{GNU}
@end macro

@macro posix{}
@acronym{POSIX}
@end macro

@macro utf{}
@acronym{UTF}
@end macro


@c page
@c ------------------------------------------------------------
@c Scheme language macros.
@c ------------------------------------------------------------

@macro false{}
@code{#f}
@end macro

@macro true{}
@code{#t}
@end macro

@macro func{NAME}
@code{@sc{\NAME\}}
@end macro


@c page
@c ------------------------------------------------------------
@c C language macros.
@c ------------------------------------------------------------

@macro cfunc{NAME}
@code{\NAME\()}
@end macro


@c page
@c ------------------------------------------------------------
@c Values.
@c ------------------------------------------------------------

@set TITLE                      The Other Ypsilon User's Guide

@c To be used as @value{PACKAGE} whenever we need to include the full
@c name of this package.
@set PACKAGE                    Ypsilon

@c To be used as @value{PACKAGE_NICKNAME} whenever we need to include
@c the nickname of the project: the name that is used to compose the
@c distribution tarball or the web address.
@set PACKAGE_NICKNAME           ypsilon

@c To be used as @value{AUTHOR} whenever we need to include the list of
@c authors of this document.
@set AUTHOR                     Marco Maggi

@c To be used as @value{AUTHOR_EMAIL} whenever we need to include the
@c email of the *single* author of this document.
@set AUTHOR_EMAIL               @email{marcomaggi@@gna.org}

@c To be used as @value{COPYRIGHT_YEARS} whenever we need to include the
@c list of copyright years.
@set COPYRIGHT_YEARS            2004--2008



@c page
@c ------------------------------------------------------------
@c Copyright notice.
@c ------------------------------------------------------------

@copying
@noindent
This document describes version @version{} of @value{PACKAGE}, an
@rnrs{6} compliant implementation of the Scheme programming language.
The package is distributed under a @acronym{BSD} like license (see the
``License terms'' appendix) and can be downloaded from:

@center @url{http://code.google.com/p/ypsilon/}

@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Yoshikatsu Fujita.
All rights reserved.@*
Copyright @copyright{} @value{COPYRIGHT_YEARS} LittleWing Company
Limited.  All rights reserved.

This document is version @texiversion{} of an unofficial assemblage of
several documents reformatted in Texinfo; the reformatting author and
maintainer is @value{AUTHOR} @value{AUTHOR_EMAIL}.  See the appendix
``Credits'' for the list of original documents and their authors.
@end copying



@c page
@c ------------------------------------------------------------
@c Headers.
@c ------------------------------------------------------------

@titlepage
@title @value{TITLE}
@page
@vskip 0pt plus 1filll
@insertcopying
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Documentation
@direntry
* r6rs: (r6rs).                 Revised^6 Report on the Algorithmic
                                Language Scheme.
@end direntry
@end ifinfo

@c ------------------------------------------------------------

@ignore
@syncodeindex tp cp
@syncodeindex vr cp
@syncodeindex fn cp
@end ignore



@c page
@ifnottex
@node Top
@top @value{TITLE}

@insertcopying

@menu
* ffi::                         The foreign functions interface.

Appendices

* credits::                     Credits for this document.
* license::                     License terms.

Indexes

* concept index::               An entry for each concept.
* function index::              An entry for each function.
* variable index::              An entry for each variable.
* type index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

The foreign functions interface

* ffi load::                    Loading shared objects.
* ffi symbols::                 Retrieving symbols.
* ffi call out::                Calling foreign functions.
* ffi call back::               Callback functions.
* ffi errno::                   Accessing @code{errno}.
* ffi types::                   Handling of type conversions.
* ffi high::                    High level interface.

Handling of type conversions

* ffi types output::            Returned values.
* ffi types input::             Input arguments.

@end detailmenu
@end menu

@end ifnottex


@c page
@node ffi
@chapter The foreign functions interface


@quotation
What follows is an unofficial documentation of the foreign functions
interface implemented by Ypsilon revision 285.
@end quotation

@noindent
The high level interface is exported by the @library{ffi} library; the
low level interface is exported by the @library{core} library.  The
@library{ffi} library has everything we need for ``normal'' operations.


@menu
* ffi load::                    Loading shared objects.
* ffi symbols::                 Retrieving symbols.
* ffi call out::                Calling foreign functions.
* ffi call back::               Callback functions.
* ffi errno::                   Accessing @code{errno}.
* ffi types::                   Handling of type conversions.
* ffi high::                    High level interface.
@end menu


@c page
@node ffi load
@section Loading shared objects


@deffn Procedure load-shared-object @var{name}
Accept as single argument a string selecting the shared object file;
return a value referencing the loaded shared object.

The string can be the name of a library's file or a pathname of the
same, absolute or relative.  On Unix--like systems the following examples
will work:

@example
(import (rnrs)
  (ffi))
(define zlib   (load-shared-object "libz.so"))
(define bzlib2 (load-shared-object "/usr/lib/libbz2.so"))
@end example

@noindent
and assuming the current working directory is @file{/usr}:

@example
(import (rnrs)
  (ffi))
(define gtk (load-shared-object "./lib/libgtk.so"))
@end example

If @func{load-shared-object} is called with an empty string as argument:
the return value references the current process.  With this value we can
access symbols exported by the current program and the libraries that
have been already loaded (this may be platform specific, check out the
documentation of your operative system).  For example: the symbols from
the standard C library, like @cfunc{fwrite}, can be accessed this way.
@end deffn


@c page
@node ffi symbols
@section Retrieving symbols


@deffn Procedure lookup-shared-object @var{shared-object} @var{symbol}
Accept as first argument the value referencing an already loaded shared
object, and as second argument a symbol or string representing the name
of a function exported by the shared object.  Return a value referencing
the exported function.

On Unix-like systems the following example will work:

@example
(import (rnrs)
  (ffi))
(define zlib (load-shared-object "libz.so"))
(define deflateInit_f (lookup-shared-object zlib 'deflateInit_))
(define deflate_f     (lookup-shared-object zlib 'deflate))
(define deflateEnd_f  (lookup-shared-object zlib 'deflateEnd))
@end example

@noindent
as we see: we have to care about the true name of the exported symbols
(when coding in the C language: we call the init function as
@cfunc{deflateInit}, but the actual exported symbol is
@cfunc{deflateInit_}).

Another example for Unix like systems: to access the C standard
@cfunc{fwrite} we do:

@example
(import (rnrs)
  (ffi))
(define self (load-shared-object ""))
(define fwrite_f (lookup-shared-object self "fwrite"))
@end example
@end deffn


@c page
@node ffi call out
@section Calling foreign functions


It is done by calling a stub procedure, provided by Ypsilon, which is
specialised to return a type of value.


@deffn Procedure {stdcall-shared-object->void} @var{pointer} . @var{args}
@deffnx Procedure {stdcall-shared-object->int} @var{pointer} . @var{args}
@deffnx Procedure {stdcall-shared-object->double} @var{pointer} . @var{args}
@deffnx Procedure {stdcall-shared-object->intptr} @var{pointer} . @var{args}
@deffnx Procedure {stdcall-shared-object->char*} @var{pointer} . @var{args}
Invoke the foreign function identified by @var{pointer}, which must be a
value previously returned by @func{lookup-shared-object}.  The other
arguments are handed to the function as parameters.

The @code{void} variant is for functions that return no value.

The @code{int} variant is for functions that return an @code{int} value.

The @code{double} variant is for functions that return a @code{double} value.

The @code{intptr} variant is for functions that return a @code{void *}
value or any other pointers different from @code{char *}.

The @code{char*} variant is for functions that return a @code{char *}
value.

Ypsilon automatically figures out how to push the arguments on the stack
and how to convert returned values, as described in @ref{ffi types}.
@end deffn


Knowing that the C language prototype of @cfunc{deflateInit} is:

@example
int deflateInit (z_streamp strm, int level);
@end example

@noindent
in which @code{z_streamp} is a pointer to structure, to call the
function we can define a wrapper like this:

@example
(import (rnrs)
  (ffi))
(define zlib (load-shared-object "libz.so"))
(define deflateInit_f (lookup-shared-object zlib 'deflateInit_))

(define (deflateInit zstream level)
  (stdcall-shared-object->int deflateInit_f zstream level))
@end example


@c page
@node ffi call back
@section Callback functions





@c page
@node ffi errno
@section Accessing @code{errno}


@deffn Procedure shared-object-c-errno
Return the value of the @code{errno} variable just after the last call
to a foreign interface function.
@end deffn


@c page
@node ffi types
@section Handling of type conversions


Arguments and return values to the stub procedures described in @ref{ffi
call out} are all proper Scheme built in values.  Ypsilon does the
conversion between Scheme values and C language values automatically.
We have to understand the rules of the conversion.


@menu
* ffi types output::            Returned values.
* ffi types input::             Input arguments.
@end menu


@c page
@node ffi types output
@subsection Returned values


@subsubheading Void return type


The stub procedure @func{stdcall-shared-object->void} is meant to call a
foreign function that returns nothing.

No conversion problems here, but notice that, in truth, the function
call is equal to the one performed by @func{stdcall-shared-object->int}
(see below): the returned value is simply discarded.


@subsubheading Integer return type

The stub procedure @func{stdcall-shared-object->int} is meant to call a
foreign function that returns an integer value.

It is meant to handle return values that can be stored in a
@code{intptr_t} type, which is defined in the system header
@file{stdint.h}, and it is meant to be big enough to hold both a signed
integer and a pointer.  For example: on 64 bits platforms it could be
@code{long int}, while on 32 bits platforms it could be @code{int}.

The @code{intptr_t} value is converted to integer, a fixnum or bignum.


@subsubheading Double return type

The stub procedure @func{stdcall-shared-object->double} is meant to call
a foreign function that returns a double precision floating point value.
Single precision floating point values, @code{float}, are not supported.


@subsubheading Pointer return type

The stub function @func{stdcall-shared-object->intptr} is meant to call
a foreign function that returns a generic pointer value.  Nothing
prevents us from using this stub for foreign functions that return a
@code{char *} referencing a zero--terminated string; we have the option
of using the specialised @code{stdcall-shared-object->char*} stub.

The conversion is equal to the one performed by
@func{stdcall-shared-object->int} (see above).


@subsubheading Zstring pointer return type

The stub function @func{stdcall-shared-object->char*} is meant to invoke
a foreign function that returns a @code{char *} pointer value,
referencing a zero--terminated, @ascii{} coded string.

If the pointer value is @code{NULL}: the stub returns @false{}.

If the value is non--@code{NULL}: the pointer is interpreted as of type
@code{uint8_t *} and embedded in a special bytevector structure, that
allows bytevector Scheme procedures to be applied to the array of bytes.
Notice that:

@itemize
@item
even with the bytevector interface: the array of bytes @strong{must} be
terminated by a zero byte, else the behaviour is undefined (that is:
your machine will crash and burn, because there is no way to determine
the correct length of the array);

@item
the special wrapper bytevector structure is subject to garbage
collection, but the embedded array is not; the array has to be freed
using some foreign function, like the system @cfunc{free}; see the
protocol of pointer input arguments for details.
@end itemize

The @var{wrapper} bytevector can be converted to a Scheme string with
this form:

@example
(bytevector->string wrapper (make-transcoder (utf-8-codec)))
@end example


@c page
@node ffi types input
@subsection Input arguments


@subsubheading Integer and pointer arguments

Scheme integer arguments (both fixnums and bignums) have to be converted
to values of C language type integer.

If the value is positive: an attempt is made to convert it to a value
that can be stored in a variable of type @code{uintptr_t}, which is
defined in the system header @file{stdint.h}, and it is meant to be big
enough to hold both an unsigned integer and a pointer.  For example: on
64 bits platforms it could be @code{unsigned long int}, while on 32 bits
platforms it could be @code{unsigned int}.

If the value is negative: an attempt is made to convert it to a value
that can be stored in a variable of type @code{intptr_t}, which is
defined in the system header @file{stdint.h}, and it is meant to be big
enough to hold both a signed integer and a pointer.  For example: on 64
bits platforms it could be @code{long int}, while on 32 bits platforms
it could be @code{int}.

If the number is too big, an error is raised.

Notice that pointers are represented as unsigned integers: when we use
the stub @func{stdcall-shared-object->intptr} to call a foreign function
that returns a pointer value, the returned value will be converted to a
Scheme integer.  So when we use that pointer value as argument to
foreign functions, it will be pushed on the stack as unsigned integer
(that it @code{uintptr_t}).

Possible problems:

@itemize
@item
if the foreign function wants an @code{int}, but we use a positive value
that is big enough for @code{unsigned int} but not for an @code{int}:
Ypsilon will push an @code{unsigned int}, and the foreign function will
(probably) interpret it as a negative value;

it is our responsibility keep the argument in the correct range of
values, but there may be cases in which this is impossible;

@item
there is no way to push a @code{short int} or @code{long long} on the
stack as argument.
@end itemize


@subsubheading Floating point arguments

The low level interface accepts floating point numbers in two flavors:

@enumerate
@item
Scheme flonums that internally are implemented as @code{double}; they
are cloned from the Scheme values and pushed on the stack;

@item
32 bits Scheme fixnums that are pushed on the C stack and interpreted as
@code{float} numbers; we can convert Scheme flonums to these 32 bits
fixnums with the @func{flonum->float} procedure, which is exported by
@library{core}.
@end enumerate

Possible problems:

@itemize
@item
there is no way to push a @code{long double} to the stack.
@end itemize


@subsubheading Bytevector arguments

If the argument is a common Scheme bytevector: a pointer to the first
byte of its data area is pushed on the stack.  We can trust the garbage
collector @strong{not} to finalise the bytevector during the dynamic
extent of the foreign function call, but we @strong{cannot} use a
bytevector as argument to a foreign function that will store the pointer
in some data structure.

If the argument is a wrapper Scheme bytevector used as interface to a
@code{char *} array (@ref{ffi types output,Zstring pointer return
type}): the @code{char *} pointer is pushed on the stack.  We can trust
the garbage collector not to remove the bytevector during the dynamic
extent of the foreign function call, and we @strong{can} use this kind
of bytevector as argument to a foreign function that will store the
pointer in some data structure.  But we @strong{cannot} assume that the
bytevector will have consistent state if the foreign function may
release the array, with the system @cfunc{free} or some other mean to
``release'' the block of memory.


@subsubheading Vector arguments


Scheme vectors are accepted as foreign function arguments if they have a
special format.  @fixme{The interpretation of vector is misterious.}


@c page
@node ffi high
@section High level interface


@defun on-windows
@defunx on-darwin
@defunx on-linux
@defunx on-freebsd
@defunx on-posix
@defunx on-ia32
@defunx on-x64
Return @true{} if the underlying platform is the one in the function name.
@end defun


@deffn Syntax c-function @var{lib-handle} @var{lib-name} @var{ret-type} __stdcall @var{func-name} (@var{type} ...)
@deffnx Syntax c-function @var{lib-handle} @var{lib-name} @var{ret-type} @var{func-name} (@var{types} ...)
Build an return a new interface lambda to a foreign function.

@var{lib-handle} must be a value returned by @func{load-shared-object}.

@var{lib-name} must be a string describing the shared object from which
the foreign function is exported.  For example @code{Zlib}.

@var{ret-type} must be the symbol of a supported return type, one among:
@code{void}, @code{int}, @code{double}, @code{void*}, @code{bool},
@code{char*}.

@var{func-name} must be a symbol that must be handed to
@func{lookup-shared-object} to retrieve the foreign function identifier.

@var{type}s are input arguments specifications; they are handed to the
@func{c-argument} syntax (see below).
@end deffn


@deffn Syntax c-function/errno . @var{args}
@deffnx Syntax c-function/win32-last-error . @var{args}
Wrappers for @func{c-function}; the return value is an interface lambda
to the foreign function that returns two values: the return value from
the foreign function and an exact integer representing the value of
@code{errno} just after the foreign function call.

On Windows: when using @func{c-function/win32-last-error} the second
value is the return value of @cfunc{GetLastError}.
@end deffn


@deffn Syntax c-argument @var{name} @var{n} @var{type} @var{var}
Expands to a lambda that can be used to:

@enumerate
@item
assert that the Scheme value @var{var} used as @var{n}-th argument to a
function, whose name is @var{name}, is of the type specified by
@var{type};

@item
convert @var{var} from an ``external'' Scheme value to a Scheme value
that is usable by the low level @ffi{} interface; the kind of conversion
is specified by @var{type};
@end enumerate

@noindent
the lambda function is meant to be applied to three arguments matching
@var{name}, @var{n} and @var{var}; its return value will be the value to
be handed as argument to the stub functions described in @ref{ffi call
out,Calling foreign functions}.

@var{type} can be one among:

@itemize
@item
a symbol in the set: @code{void}, @code{int}, @code{bool},
@code{double}, @code{float}, @code{void*}, @code{char*}, @code{byte*};

@item
a subpattern in the set: @code{[int]}, @code{[char*]}, @code{(*
[char*])};

@item
a callback signature of the form:

@example
[c-callback void (args ...)]
[c-callback int (args ...)]
[c-callback void __stdcall (args ...)]
[c-callback int __stdcall (args ...)]
@end example
@end itemize
@end deffn


@c page
@node credits
@appendix Credits for this document


@c page
@node license
@appendix License terms


@noindent
Copyright @copyright{} @value{COPYRIGHT_YEARS} by Yoshikatsu Fujita.
All rights reserved.@*
Copyright @copyright{} @value{COPYRIGHT_YEARS} LittleWing Company
Limited.  All rights reserved.

Redistribution and use in source and binary forms, with or without
modification, are permitted provided that the following conditions are
met:

@enumerate
@item
Redistributions of source code must retain the above copyright notice,
this list of conditions and the following disclaimer.

@item
Redistributions in binary form must reproduce the above copyright
notice, this list of conditions and the following disclaimer in the
documentation and/or other materials provided with the distribution.

@item
Neither the name of the authors nor the names of its contributors may be
used to endorse or promote products derived from this software without
specific prior written permission.
@end enumerate

THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS ``AS
IS'' AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED
TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A
PARTICULAR PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL THE COPYRIGHT
OWNER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.


@c page
@node concept index
@appendix An entry for each concept

@printindex cp

@node function index
@appendix An entry for each function.

@printindex fn

@node variable index
@appendix An entry for each variable.

@printindex vr

@node type index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
