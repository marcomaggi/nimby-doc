\input texinfo.tex
@c %**start of header
@setfilename neko.info
@settitle NekoVM
@c %**end of header

@ignore
        TO DO LIST
        ==========

* Examples for the 'lib sys' node.
* Examples for the 'lib thread' node.
* Review the 'ffi' chapter.
* Review the 'embedding' chapter.

@end ignore

@c page
@c ------------------------------------------------------------
@c Macro definitions.
@c ------------------------------------------------------------

@macro version{}
1.7.1
@end macro

@macro authorname{}
Marco Maggi
@end macro

@macro copyrightyears{}
2008
@end macro

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@c ------------------------------------------------------------

@macro nvm{}
NekoVM
@end macro

@macro vm{}
@acronym{VM}
@end macro

@macro modneko{}
@code{mod_neko}
@end macro

@macro api{}
@acronym{API}
@end macro

@macro rtti{}
@acronym{RTTI}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro axml{}
@acronym{AXML}
@end macro

@macro utf8{}
@acronym{UTF8}
@end macro

@macro gui{}
@acronym{GUI}
@end macro

@macro urla{}
@acronym{URL}
@end macro

@macro uri{}
@acronym{URI}
@end macro

@macro nxml{}
@acronym{NXML}
@end macro

@c ------------------------------------------------------------

@macro cnull{}
@code{null}
@end macro

@macro true{}
@code{true}
@end macro

@macro false{}
@code{false}
@end macro

@macro cfunc{NAME}
@code{\NAME\()}
@end macro

@macro function{NAME}
@code{\NAME\()}
@end macro

@macro builtin{NAME}
@code{$\NAME\}
@end macro

@c ------------------------------------------------------------

@macro neko{}
@command{neko}
@end macro

@macro nekoc{}
@command{nekoc}
@end macro

@macro nekoml{}
@command{nekoml}
@end macro

@c page
@titlepage
@title NekoVM
@subtitle @version{}
@author @authorname{}
@page
@vskip 0pt plus 1filll
@noindent
Copyright @copyright{}  2005--2008  by Motion--Twin@*
Copyright @copyright{}  2005--2008  by Nicolas Cannasse@*
Copyright @copyright{}  @copyrightyears{}  by @authorname{}

This document gathers unofficial documentation describing version
@version{} of @nvm{}; this document is a Texinfo conversion of the
documentation available on the Internet, with some adjustment.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.3 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end titlepage

@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* neko: (neko).                 Unofficial documentation for NekoVM.
@end direntry
@end ifinfo

@c page
@ifnottex
@node Top
@top The Neko Programming Language


Neko is a high level dynamically typed programming language which can
also be used as an embedded scripting language.  This document gathers
unofficial documentation describing version @version{} of @nvm{}; this
document is a Texinfo conversion of the documentation available on the
Internet, with some adjustment.

@nvm{} is:

@noindent
Copyright @copyright{}  2005--2008  by Motion--Twin@*
Copyright @copyright{}  2005--2008  by Nicolas Cannasse

@noindent
and it is distributed under the terms of the @gnu{} Lesser General
Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
@ref{Package License} for details.

This document is:

@noindent
Copyright @copyright{}  2005--2008  by Motion--Twin@*
Copyright @copyright{}  2005--2008  by Nicolas Cannasse@*
Copyright @copyright{}  @copyrightyears{}  by @authorname{}

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.
@ref{Documentation License} a copy of the license is included in the
section entitled ``GNU Free Documentation License''.

@menu
* overview::                    Overview of @nvm{}.
* programs::                    Invoking Neko programs.
* specs::                       Neko language specification.
* ffi::                         Foreign functions interface.
* embedding::                   Embedding the virtual machine.
* nxml::                        Neko in @axml{} format.
* lib::                         Neko library.

Appendices

* faq::                         Frequently asked questions.
* mod_neko::                    An introduction to @modneko{}.
* nekoml::                      A quick guide to NekoML.
* examples::                    Neko code examples.
* Package License::             @gnu{} Lesser General Public License.
* Documentation License::       @gnu{} Free Documentation License.
* References::                  Bibliography and references.

Indexes

* Concept Index::               An entry for each concept.
* Function Index::              An entry for each function.
* Variable Index::              An entry for each variable.
* Type Index::                  An entry for each type.

@detailmenu
 --- The Detailed Node Listing ---

Invoking Neko programs

* nekoc::                       The language compiler.
* nekotools::                   Miscellaneous features.
* neko::                        The virtual machine boot program.

The Neko language compiler

* nekoc compile::               Compiling source files.
* nekoc release::               Cleaning bytecode for release.
* nekoc link::                  Linking together more bytecode files.
* nekoc dump::                  Dumping bytecode from a compiled file.
* nekoc normalise::             Source files normalisation.
* nekoc console::               Running the virtual machine interactively.

Miscellaneous features

* nekotools boot::              Building standalone executables.
* nekotools server::            Web server.

Neko language specification

* specs notation::              Notation for functions documentation.
* specs syntax::                Syntax of the language.
* specs values::                Values.
* specs flow::                  Execution flow.
* specs rtti::                  Runtime type information.
* specs funcs::                 Functions and function calls.
* specs objects::               Objects.
* specs array::                 Arrays.
* specs string::                Strings.
* specs exceptions::            Exceptions.
* specs hash tables::           Hash tables.
* specs goto::                  Labels and gotos.
* specs misc::                  Miscellaneous builtins.
* specs modules::               Modules.

Execution flow

* specs flow values::           Evaluation of values.
* specs flow exprs::            Evaluation of expressions.
* specs flow vars::             Handling of variables.
* specs flow ops::              Operations on basic types.

Operations on basic types

* specs flow ops arithmetic::   Arithmetic operations.
* specs flow ops bitwise::      Bitwise operations.
* specs flow ops boolean::      Boolean operations.
* specs flow ops logic::        Logic operations.
* specs flow ops comparison::   Equality and comparison.
* specs flow ops assignment::   Assignment.
* specs flow ops conversion::   Conversion.

Objects

* specs objects making::        Creating objects.
* specs objects access::        Setting and getting values.
* specs objects inspect::       Inspecting objects.
* specs objects methods::       Defining methods.
* specs objects overloading::   Operators overloading.
* specs objects protos::        Prototypes.
* specs objects misc::          Other functions.

Strings

* specs string make::           Creating strings.
* specs string access::         Accessing characters.
* specs string copy::           Copying strings.
* specs string inspect::        Inspecting strings.

Hash tables

* specs hash tables making::    Creating hash tables.
* specs hash tables access::    Accessing elements.
* specs hash tables inspect::   Inspecting tables.

Foreign functions interface

* ffi example::                 A small example.
* ffi values::                  Manipulating values.
* ffi objects::                 Working with objects.
* ffi callbacks::               Function callbacks.
* ffi abstracts::               Abstracts and kinds.
* ffi varargs::                 Variable arguments functions.
* ffi int32::                   Using 32 bits integers.
* ffi memory::                  Managing memory.
* ffi misc::                    Misc @api{} functions.

Manipulating values

* ffi values types::            Data types.
* ffi values const::            Constant values.
* ffi values predicates::       Type predicates.
* ffi values assert::           Asserting the types of values.
* ffi values access::           Access functions.
* ffi values alloc::            Allocation functions.
* ffi values print::            Printing values.
* ffi values buffers::          Buffers.

Data types

* ffi values types other::      Other data types.

Working with objects

* ffi objects api::             Objects @api{}.
* ffi objects methods::         Object methods.

Embedding the @vm{}

* embedding example::           Example of embedding the @vm{}.
* embedding threads::           Multithreading.

Neko library

* lib loading::                 Loading the standard library.

The standard library

* lib list::                    The list custom type.
* lib int32::                   Using 32 bits integers.
* lib buffer::                  Buffers.
* lib date::                    Date.
* lib file::                    File.
* lib math::                    Mathematical functions.
* lib md5::                     MD5.
* lib memory::                  Memory.
* lib module::                  Modules.
* lib process::                 Process.
* lib random::                  Pseudo--random numbers generation.
* lib serialise::               Serialisation.
* lib socket::                  @acronym{TCP} and @acronym{UDP} sockets.
* lib string::                  Additional string functions.
* lib sys::                     Interaction with the operating system.
* lib thread::                  Creating and managing system threads.
* lib utf8::                    Handling @acronym{UTF8} strings.
* lib xml::                     The standard event--driven @axml{} parser.
* lib misc::                    Miscellaneous functions.

Additionally libraries

* lib cgi::                     Apache access when running @modneko{}.
* lib mysql::                   Connecting to and using MySQL databases.
* lib sqlite::                  Connecting to and using Sqlite databases.
* lib regexp::                  Regular expressions using the @acronym{PCRE} engine.
* lib gui::                     Core native user interface support.
* lib zlib::                    Compression library.

Using 32 bits integers

* lib int32 make::              Constructors.
* lib int32 conversion::        Conversion.
* lib int32 comparison::        Comparison.
* lib int32 arithmetics::       Arithmetic operations.
* lib int32 bitwise::           Bitwise operations.
* lib int32 misc::              Miscellaneous operations.

File

* lib file open::               Opening and closing files.
* lib file io::                 Input/output upon files.
* lib file seek::               Setting the position.

@acronym{TCP} and @acronym{UDP} sockets

* lib socket creating::         Creating sockets.
* lib socket client::           Connecting as client.
* lib socket server::           Setting up a server.
* lib socket io::               Sending and receiving.
* lib socket select::           Selecting events on sockets.
* lib socket poll::             Polling events on sockets.
* lib socket resolver::         Resolving addresses.
* lib socket misc::             Miscellaneous functions.

Polling events on sockets

* lib socket poll events ex::   Example of polling for events.
* lib socket poll read ex::     Example of polling for available data.

Creating and managing system threads

* lib thread create::           Creating threads.
* lib thread message::          Sending and receiving messages.
* lib thread deque::            Handling deques.
* lib thread lock::             Handling locks.
* lib thread mux::              Handling mutexes.
* lib thread storage::          Handling thread local storage.

Neko code examples

* examples list::               A module that manipulates lists.
* examples o32::                An object interface to @code{'int32}
                                abstract numbers.

@end detailmenu
@end menu

@end ifnottex


@c page
@node overview
@chapter Overview of @nvm{}


Neko is a high level, dynamically typed, programming language which can
also be used as an embedded scripting language.  It is designed to
provide a common runtime for several different languages.  Neko is not
only very easy to learn and use, but can be extended with C language
libraries.  We can convert our high level language to the Neko language,
then use Neko's tools to compile and run the program, also accessing
existing libraries.

If we need to embed a scripting language into an application: Neko
provides one of the best trade off available between simplicity,
extensibility and speed.


@subsubheading The Neko Virtual Machine

Neko has a compiler and a virtual machine (@vm{}).  The @vm{} is both
lightweight and optimised so it offers fast code execution; it can be
easily embedded into any application and C language libraries are
directly accessible using the C language Foreign Function Interface
(@ffi{}).

The compiler converts a source file (conventionally with @code{.neko}
extension) into a bytecode file (conventionally with @code{.n}
extension) that can be executed with the @vm{}.  Although the compiler
is written in Neko itself, it is still very fast.  We can use the
compiler as standalone command line executable separated from the @vm{},
or as a Neko library to perform compile--and--run for interactive
languages.


@subsubheading @modneko{}

Neko comes with several libraries.  One of these is @modneko{},
which embeds the Neko Virtual Machine into the Apache web server, so we
can use Neko to generate web pages.


@subsubheading About Neko

Neko is developed as part of the Research and Development effort for
better languages at Motion--Twin.  The author of Neko is Nicolas
Cannasse and can be contacted at @email{ncannasse@@motion-twin.com}.

Neko is free software and the full source code is available under the
@gnu{} Lesser General Public License (@acronym{LGPL}).  Interested
people can join the mailing list:

@center @email{neko@@lists.motion-twin.com}
@center @url{http://www.nekovm.org/ml/}

@noindent
and visit Neko's web site:

@center @url{http://www.nekovm.org/}

@c page
@node programs
@chapter Invoking Neko programs


@menu
* nekoc::                       The language compiler.
* nekotools::                   Miscellaneous features.
* neko::                        The virtual machine boot program.
@end menu

@c page
@node nekoc
@section The Neko language compiler


@cindex @command{nekoc}, the language compiler

@menu
* nekoc compile::               Compiling source files.
* nekoc release::               Cleaning bytecode for release.
* nekoc link::                  Linking together more bytecode files.
* nekoc dump::                  Dumping bytecode from a compiled file.
* nekoc normalise::             Source files normalisation.
* nekoc console::               Running the virtual machine interactively.
@end menu

The program @command{nekoc} is the Neko language compiler: it produces
bytecode to be run under the @vm{}.  @ref{nekotools} for details on how
to produce standalone executables.

The synopsis of @command{nekoc} is:

@example
nekoc [options] file [file] ...
@end example

@noindent
the available options are:

@table @code
@item -d <BYTE_CODE_FILE>
dump bytecode for debugging; notice that when using @option{-d}: the
@option{-o} option is ignored;

@item -z <FILE>
make bytecode release; notice that when using @option{-z}: the
@option{-o} option is ignored;

@item -p <FILE>
parse and print Neko source; notice that when using @option{-p}: the
@option{-o} option is ignored;

@item -o <DIRECTORY>
select the output directory for compiled files;

@item -link <FILE>
link one or more bytecode files selected from the command line into the
unique file selected with @code{<FILE>}; notice that when using
@option{-link}: the @option{-o} option is ignored;

@item -console
run in console mode;

@item -v
turn on verbose mode;

@item --help
print the help screen and exit.
@end table

@c page
@node nekoc compile
@subsection Compiling source files


Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
we can compile it to produce the bytecode file @file{proof.n} with:

@example
$ nekoc proof.neko
@end example

@noindent
now we can run the code with:

@example
$ neko proof.n
@end example

More files can be compiled with a single run of @command{nekoc}:

@example
$ nekoc red.neko green.neko blue.neko
@end example

@noindent
to produce one bytecode file for each: @file{red.n}, @file{green.n},
@file{blue.n}.

@c page
@node nekoc release
@subsection Cleaning bytecode for release


Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
that we have compiled with:

@example
$ nekoc proof.neko
@end example

@noindent
to produce the bytecode file @file{proof.n}.  We can clean up the
bytecode removing stuff that is not expected to be included in
production code with:

@example
$ nekoc -z proof.n
@end example

@noindent
this command will modify @file{proof.n} itself.

@c page
@node nekoc link
@subsection Linking together more bytecode files


The @option{-link} option of @command{nekoc} allows us to append more
bytecode files into a single file so that the code is executed
sequentially.

Let's have the source file @file{red.neko}:

@example
// red.neko --

$print("this is a proof 01\n");

/// end of file
@end example

@noindent
and the source file @file{green.neko}:

@example
// green.neko --

$print("this is a proof 02\n");

/// end of file
@end example

@noindent
and we compile them with:

@example
$ nekoc red.neko green.neko
@end example

@noindent
to produce the two bytecode files @file{red.n} and @file{green.n}.  We
can produce a single bytecode file @file{proof} with:

@example
$ nekoc -link proof.n red green
@end example

@noindent
notice that the source bytecode files must be selected without
specifying the @code{.n} extension (damn!); now we can run the output
bytecode file:

@example
$ neko proof.n
@end example

Each source file has its own namespace: the variables declared in
@file{red.neko} are @strong{not} visible from the code in
@file{green.neko} and vice versa.  The only thing that linking does is
to append code to be executed in sequence.

@c page
@node nekoc dump
@subsection Dumping bytecode from a compiled file


Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
that we have compiled with:

@example
$ nekoc proof.neko
@end example

@noindent
to produce the bytecode file @file{proof.n}.  We can convert the
bytecode into a human readable format using the @option{-d} option:

@example
$ nekoc -d proof.n
@end example

@noindent
which produces a file @file{proof.dump} in the same directory of
@file{proof.n} with contents similar to:

@example
nglobals : 2
nfields : 1
codesize : 4 ops , 7 total
GLOBALS =
  global 0 : string "this is a proof\n"
  global 1 : debug 7 ops 20 bytes
FIELDS =
  print                   C88B582D
CODE =
000000      0    AccGlobal 0
000002      1    Push
000003      2    AccBuiltin print
000005      3    Call 1
END
@end example

This is useful for debugging the compiler and to compare the performance
of alternative chunks of high level language code.

@c page
@node nekoc normalise
@subsection Source files normalisation


The @option{-p} option of @command{nekoc} allows us to ``normalise'' the
source code and to detect errors without compiling; normalising means:
removing comments, properly indenting code, adding @code{;} characters
at the end of expressions.

To normalise a source file @file{proof.neko} we do:

@example
$ nekoc -p proof.neko
@end example

@noindent
which will produce a normalised file called @file{proof2.neko}.

@c page
@node nekoc console
@subsection Running the virtual machine interactively


The @option{-console} option of @command{nekoc} runs the virtual machine
in a read--eval--print loop; we type a command and end the line with a
@code{!} followed by a return:

@example
$ nekoc -console
> 123!
123
> 1 + 2 !
3
> $print(123 + "\n") !
123
#function:-1
@end example

@noindent
to exit send an end--of--file character (@key{Control-d} on Unix like
terminals).

@c page
@node nekotools
@section Miscellaneous features


@cindex @command{nekotools}, miscellaneous features


The program @command{nekotools} allows us to access a set of features
offered by the Neko programming environment.  The synopsis is:

@example
nekotools boot <BYTECODE_FILE>
nekotools server
@end example

@noindent
the available options are:

@table @code
@item --help
print the help screen and exit.
@end table

@menu
* nekotools boot::              Building standalone executables.
* nekotools server::            Web server.
@end menu

@c page
@node nekotools boot
@subsection Building standalone executables


@cindex Building standalone executables

When run with the @code{boot} subcommand: @command{nekotools} reads a
single bytecode file and produces a standalone executable by prepending
to it the Neko virtual machine boot program and linking the two
together.

Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
and we compile it to produce the bytecode file @file{proof.n}:

@example
$ nekoc proof.neko
@end example

@noindent
we can produce a standalone executable with:

@example
$ nekotools build proof.n
@end example

@noindent
now we can run the code with:

@example
$ ./proof
@end example

The executable will require the Neko shared library.

@c page
@node nekotools server
@subsection Web server


@cindex Using the web server


When run with the @code{server} subcommand: @command{nekotools} starts a
simple web server.  It is a very small web server that runs locally for
development purposes only; it mimics the same @api{} as @modneko{}.

In order to start the server we do:

@example
$ nekotools server
@end example

@noindent
by default it listens on port @code{2000} of localhost, so we can browse
the configuration page by visiting:

@center @url{http://localhost:2000/server:config}

From that page we can change the server base path to our website
directory and we can start browsing it.  If the site contains @code{.n}
Neko bytecode files, they will be loaded and executed just like Apache
@modneko{} does.

@c page
@node neko
@section The Neko virtual machine boot program


@cindex Shared libraries
@cindex @code{.ndll}, extension of shared libraries


The Neko virtual machine is one binary called @command{neko} included in
the @nvm{} distribution.  We can call it anytime using:

@example
$ neko file.n
@end example

@noindent
in order to execute the specified bytecode @code{file}.  Bytecode files
are precompiled Neko sources and have the @code{.n} extension; each
bytecode file is also called a @emph{module}.

@nvm{} can use platform specific shared libraries: @code{.so} on
Unix--like systems and @code{.dll} on Windows; these libraries must be
linked with Neko's library, @file{libneko.so} or @file{neko.lib}, and
use Neko's foreign functions interface and @api{}.  Each Neko library
can contain several primitives that can be used from a Neko program.
@ref{ffi} for how to define such primitives.

Shared libraries must be installed on the system with the @code{.ndll}
extension under a directory accessible by Neko.


@defvr {Environment Variable} NEKOPATH
Bytecode modules and shared libraries are searched in the local
directory but also using the @env{NEKOPATH} environment variable, which
can list several search paths separated by @code{:}.
@end defvr

@c page
@node specs
@chapter Neko language specification


@menu
* specs notation::              Notation for functions documentation.
* specs syntax::                Syntax of the language.
* specs values::                Values.
* specs flow::                  Execution flow.
* specs rtti::                  Runtime type information.
* specs funcs::                 Functions and function calls.
* specs objects::               Objects.
* specs array::                 Arrays.
* specs string::                Strings.
* specs exceptions::            Exceptions.
* specs hash tables::           Hash tables.
* specs goto::                  Labels and gotos.
* specs misc::                  Miscellaneous builtins.
* specs modules::               Modules.
@end menu

@c page
@node specs notation
@section Notation for functions documentation


Here's the notation of types for function arguments and return values
that is used in the following language specification, and that should be
used when documenting libraries, too:

@enumerate
@item
the basic types are indicated with: @cnull{}, @code{int}, @code{float},
@code{bool}, @code{string}, @code{array}, @code{object},
@code{function};

@item
the type @code{any} means that any value is accepted;

@item
the type @code{void} is used for arguments when the function accepts no
arguments, and for the return value if the function is not supposed to
return a meaningful value;

@item
the type @code{number} is used if both @code{int} and @code{float} are
accepted;

@item
the type @code{function:N}, where @code{N} is a number, is used if a
function with @code{N} parameters is accepted;

@item
abstracts are indicated by a name associated to their kind; that name is
used with a single quote as prefix; for example: @code{'file} is an
abstract of kind @code{file};

@item
for arrays that contain values of a specified type: we write the type
first, followed by @code{array}; for example: @code{int array} is an
@code{array} containing only integers and @code{'file array array} is a
two dimensions array that contains abstract files;

@item
for objects that must contain some fields, we can use Neko notation for
types: @code{@{ x => int, y => int @}} which means an object having at
least two fields @code{x} and @code{y} of type @code{int};

@item
if the @cnull{} value is accepted as well as some other type, we can
write, for example @code{int?}, which means @code{int} or @cnull{};

@item
if several types are accepted we can separate them with pipe characters
@code{|}; for example: @code{number} is actually a shortcut for
@code{int | float};

@item
we can introduce our own names, prefixed with a sharp, by defining and
describing them in the documentation using, for example:

@example
#point = @{ x => int, y => int @}
@end example

if we do not define a type, but we just introduce its @code{#}--name,
the user of the library should not rely on its actual implementation
since we can change it in the future.
@end enumerate

@c page
@node specs syntax
@section Syntax of the language


The syntax of the Neko language is designed to be easy to parse and easy
to generate.  It is not specifically designed to be written by a
programmer, but rather to be generated from a higher level language.
For example, one could easily write a @acronym{PHP}--to--Neko or a
Java--to--Neko converter that would generate equivalent code, but with
Neko syntax and semantics rather than those of @acronym{PHP} or Java.

In particular, there are no multiple levels of expressions as in C:
every statement is also an expression, thus enabling some constructs
that are not possible in other languages, for example:

@example
return if(x) @{ ... @} else @{ ... @}
@end example

@noindent
this simplifies the generation of Neko from functional languages.

The syntax is parsed using a left--to--right @acronym{LL(1)} parser:
after reading a token, we have enough information to know which
expression it will produce.  This allows for a very lightweight parser,
which is easy to improve without creating ambiguities.  Here's an
Abstract Syntax Tree (@acronym{AST}) description of the language syntax,
with the additional constraint that a program must be terminated by an
@acronym{EOF} (end of file):

@example
program :=
        | expr program
        | SEMICOLON program
        | _

ident :=
        | [a-zA-Z_@@] [a-zA-Z0-9_@@]*

binop :=
        | [!=*/<>&|^%+:-]+

value :=
        | [0-9]+
        | 0x[0-9A-Fa-f]+
        | [0-9]+ DOT [0-9]*
        | DOT [0-9]+
        | DOUBLEQUOTE characters DOUBLEQUOTE
        | DOLLAR ident
        | true
        | false
        | null
        | this
        | ident

expr :=
        | value
        | @{ program @}
        | @{ ident1 => expr1 , ident2 => expr2 ... @}
        | expr DOT ident
        | expr ( parameters )
        | expr [ expr ]
        | expr binop expr
        | ( expr )
        | var variables
        | while expr expr
        | do expr while expr
        | if expr expr [else expr]
        | try expr catch ident expr
        | function ( parameters-names ) expr
        | return [expr | SEMICOLON]
        | break [expr | SEMICOLON]
        | continue
        | ident :
        | switch expr @{ switch-case* @}
        | MINUS expr

variables :=
        | ident [= expr] variables
        | COMMA variables
        | _

parameters :=
        | expr parameters
        | COMMA parameters
        | _

parameters-names :=
        | ident parameters-names
        | COMMA parameters-names
        | _

switch-cases :=
        | default => expr
        | expr => expr
@end example

Random notes:

@itemize
@item
@code{_} represents an empty expression;

@item
@code{continue} and @code{break} are not allowed outside of a
@code{while} loop;

@item
there are a few ambiguous cases when two expressions follow each other
(as in @code{while} and @code{if}); if the second expression is inside
parenthesis, it will be parsed as a call of first expression, because
such a representation @code{e1 (e2)} exists in the @acronym{AST} (the
semicolons are optional);

@item
arithmetic operations have the following precedences (from least to
greatest):

@enumerate
@item
assignments;
@item
@code{++=} and @code{--=};
@item
@code{&&} and @code{||};
@item
comparisons;
@item
@code{+} and @code{-};
@item
@code{*} and @code{/};
@item
@code{|}, @code{&} and @code{^};
@item
@code{<<}, @code{>>}, @code{>>>} and @code{%}.
@end enumerate
@end itemize

@c page
@node specs values
@section Values.


A value in Neko can be one of the following:

@table @emph
@item Null
the special value @cnull{} is used for uninitialised variables as well as
programmer/language specific coding techniques;

@item Integer
integers can be represented in either decimal form (such as @code{12345}
or @code{-12}), or hexadecimal (such as @code{0x1A2B3C4D});

@item Floats
floating--point numbers are represented using a period (such as
@code{12.345} or @code{-0.123});

@item Boolean
the two booleans are represented by the lowercase identifiers @true{}
and @false{};

@item Strings
strings are surrounded by double quotes; examples:

@example
"foo"
"hello,\nworld!"
"My name is \"Bond\\James Bond\"."
@end example

@noindent
strings are mutable, which means that we can modify them;

@item Arrays
arrays are integer--indexed tables of values, with indices starting at
0; they provide fast random access to their elements;

@item Objects
an object is a table, which associates an identifier or a string to a
value;

@item Functions
a function is also a value in Neko, and thus can be stored in any
variable;

@item Abstract
an abstract value is some C language data that cannot be directly
accessed from a Neko program.
@end table

Some notes:

@itemize
@item
integers have 31 bits for virtual machine performance reasons; an @api{}
for full 32 bits integers is available through a standard library;

@item
floating--point numbers are 64 bits double--precision floating points
values;

@item
strings are sequences of 8 bits bytes; a string can contain @code{\0}
characters; the length of a string is determined by the number of bytes
in it, and not by the number of characters before the first @code{\0}.
@end itemize

@c page
@node specs flow
@section Execution flow


Here's some explanation on how each expression is evaluated.

@menu
* specs flow values::           Evaluation of values.
* specs flow exprs::            Evaluation of expressions.
* specs flow vars::             Handling of variables.
* specs flow ops::              Operations on basic types.
@end menu

@c page
@node specs flow values
@subsection Evaluation of values


@table @code
@item [0-9]+ | 0x[0-9A-Fa-f]+
evaluates to the corresponding integer value;

@item [0-9]+ DOT [0-9]* | DOT [0-9]+
evaluates to the corresponding floating--point number;

@item DOUBLEQUOTE characters DOUBLEQUOTE
evaluates to the corresponding string; escaped characters are similar to
the C language ones;

@item DOLLAR ident
identifiers prefixed with a dollar sign are built in opcodes; they
enable us to call some compiler constructors or do optimised function
calls;

@item true | false
evaluate to the corresponding boolean;

@item null
evaluates to the @emph{Null} value;

@item this
evaluates to the local ``object value'' (@ref{specs objects} for
details);

@item ident
evaluates to the value currently bound to this variable name.
@end table

@c page
@node specs flow exprs
@subsection Evaluation of expressions


Before evaluating any expression, all subexpressions are evaluated in an
unspecified order; @code{v} here represent the value obtained from
evaluation of subexpressions:

@table @code
@item @{ v1; v2; ...; vk @}
the evaluation order follows the order of the declarations; the value of
the last expression, @code{vk}, is returned as result, unless the
program does not contain any expressions, in which case it returns
@cnull{};

@item @{ i1 => v1 , i2 => v2 ... @}
this will create an object with fields @code{i1...ik} set to the values
@code{v1...vk}; it might be more optimised than setting the fields
one--by--one on an empty object;

@item v DOT ident
@code{v} is accessed as an object using @code{ident} as a key;

@item v ( v1, v2, ... vk )
the function @code{v} is called with the parameters @code{v1, v2... vk};

@item v [ v1 ]
@code{v} is accessed as an array using @code{v1} as the index;

@item v1 binop v2
calculates @code{v1 binop v2};

@item expr = v
this is a special case when the operation is an assignment;

@item ( v )
evaluates to @code{v};

@item var i1 = v1, i2 = v2, .... ik = vk
each variable @code{i} is set to the corresponding value @code{v}, or to
@cnull{} if no initialisation expression is provided;

@item while .... | do ... while ...
implements the classic @code{while} loop; its value is the one returned
by a @code{break} inside the @code{while}, or unspecified if the loop
ends without using @code{break};

@item if v1 e1
if @code{v1} is the boolean @true{}, then @code{e1} is evaluated and its
value returned; otherwise, its value is unspecified;

@item if v1 e1 else e2
if @code{v1} is the boolean @true{}, then @code{e1} is evaluated and its
value returned; otherwise @code{e2} is evaluated and its value returned;

@item try e1 catch i e2
evaluates e1 and returns its value; if an exception is raised while
evaluating @code{e1}, then @code{e2} is evaluated, with the local
variable @code{i} being set to the raised exception value; if an
exception is raised: the value of the @code{try...catch} block is the
result of evaluating @code{e2};

@item function ( parameters-names ) expr
evaluates to the corresponding function;

@item return ;
exits the current function with an unspecified return value;

@item return v
exits the current function and returns @code{v};

@item break ;
exits the current @code{while} loop with an unspecified return value;

@item break v
exits the current @code{while} loop and returns value @code{v};

@item continue
skips the rest of the loop body and jumps to the start of the loop,
reevaluating the loop condition;

@item ident :
a label;

@item switch e @{ e1a => e1b e2a => e2b .... default => edef @}
evaluates @code{e} and tests it against each @code{eia} sequentially
until it is found to be equal, then returns value of the corresponding
expression @code{eib}; if no value is found to be equal to @code{e}, the
value of the @code{edef} expression is returned; @cnull{} is returned if
@code{default} is not specified.
@end table

Please note that the conditions of @code{if} and @code{while} only
consider the boolean @true{} to be true.  We might need to add a
@builtin{istrue} opcode before each expression in order to convert the
expression result into a boolean.

@c page
@node specs flow vars
@subsection Handling of variables


When an identifier is found, it must be resolved to a scope containing
the variable's value.  The search starts in the local scope.


@subsubsection Local scope

The local scope contains all variables defined with the @code{var}
keyword in previous syntactical blocks.  In the following sample
@code{x} resolves to the value @code{3}:

@example
var x = 3;
$print(x);
@end example

A @code{var} declaration is local to the curly--braced block it has been
declared in; for example:

@example
var x = 3;
// x defined
if( ... ) @{
  // x defined
  var y;
  // x and y defined;
@}
// x defined
@end example

The same variable name can be reused in the same block or another block;
it will shadow or erase previous values:

@example
var x = 1;
$print(x); // print 1
var x = 3;
$print(x); // print 3
if( ... ) @{
  var x = "neko";
  $print(x); // print "neko"
@}
$print(x); // print 3
@end example

Function parameters are also local variables; they are defined within
the whole function:

@example
var x = 3;
f = function(x) @{
  $print(x);
@}
f("neko"); // print "neko"
@end example

Since scoping is resolved at a purely syntactic level, local variables
do not depend the on the current call stack, and we cannot access
variables defined outside the current local scope:

@example
f = function() @{
  $print(x);
@}
...
var x = 3;
f(); // will print "null"
@end example

@c ------------------------------------------------------------

@subsubsection Function scope

Local variables can be used inside functions if they're accessible at
the time the function is declared.  In this case, the value of the
variable is a copy of its value at the time the function was defined:

@example
var x = 3;
f = function() @{
  $print(x);
@}
x = 4;
f(); // print 3
@end example

Such variables are called ``environment variables'' because they're no
longer part of the local context but of the function's ``environment''
context.  A function can still modify an environment variable, but this
will not modify the original variable reference:

@example
var x = 3;
f = function() @{
  $print(x);
  x = x + 1;
@}
x = 50;
f(); // print 3
f(); // print 4
$print(x); // print 50
@end example

Please note also that each function instance has its own environment:

@example
gen = function() @{
  var i = 0;
  return function() @{ $print(i); i = i + 1; @};
@}
f1 = gen();
f2 = gen();
f1(); // print 0
f1(); // print 1
f2(); // print 0
f1(); // print 2
...
@end example

@c ------------------------------------------------------------

@subsubsection Global scope

When a variable is not found in the local scope or in the local function
environment, it is a global variable.  A global variable can be accessed
throughout the whole file, it is shared among all code.

@example
f = function() @{
  $print(x);
  x = x + 1;
@}
x = 0;
f(); // print 0
f(); // print 1
$print(x); // print 2
@end example

@c page
@node specs flow ops
@subsection Operations on basic types


Basic types are numbers (integer and float), booleans (bool), the
@cnull{} value, strings, objects, arrays and functions.  There are
several operations available for them.

In the following tables: on the row is the type of the first operand, on
the column is the type of the second operand; an @code{X} means that the
operation is invalid and will raise an exception.

@menu
* specs flow ops arithmetic::   Arithmetic operations.
* specs flow ops bitwise::      Bitwise operations.
* specs flow ops boolean::      Boolean operations.
* specs flow ops logic::        Logic operations.
* specs flow ops comparison::   Equality and comparison.
* specs flow ops assignment::   Assignment.
* specs flow ops conversion::   Conversion.
@end menu

@c page
@node specs flow ops arithmetic
@subsubsection Arithmetic operations


@findex @code{+}
@findex @code{-}
@findex @code{*}
@findex @code{/}
@findex @code{%}
@findex @code{__add}
@findex @code{__radd}

Operation addition (@code{+}): the result is either the type of the
returned value, or @code{concat} if we use string concatenation (in that
case, the two values are converted to strings and then concatenated
together).

@example
+        | null    int     float   string  bool    object  array   function
---------+-----------------------------------------------------------------
null     | X       X       X       concat  X       __radd  X       X
int      | X       int     float   concat  X       __radd  X       X
float    | X       float   float   concat  X       __radd  X       X
string   | concat  concat  concat  concat  concat  __radd  concat  concat
bool     | X       X       X       concat  X       __radd  X       X
object   | __add   __add   __add   __add   __add   __add   __add   __add
array    | X       X       X       concat  X       __radd  X       X
function | X       X       X       concat  X       __radd  X       X
@end example

Addition can be overridden for objects: @code{a + b} will call
@code{a.__add(b)} if @code{a} is an object, or @code{b.__radd(a)} if
@code{b} is an object.

Operations subtraction (@code{-}), division (@code{/}), multiplication
(@code{*}) and modulo (@code{%}):

@example
- / * % | int                  float
--------+---------------------------
int     | int (float for /)    float
float   | float                float
@end example

@noindent
note that unlike some languages: the division operation between two
integers returns a float; we can use the @builtin{idiv} built in to
perform integer division.

Dividing or taking the modulo of one integer by the integer or float 0
is hardware--dependent and usually returns the float @code{+infinity}
for division, and NaN (not a number) for modulo.  We can test this using
the @builtin{isnan} and @builtin{isinfinite} built in operations:

@example
$print($isinfinite(1/0));       // prints true
$print($isnan(0/0));            // prints true
@end example

Arithmetic operations are can be overridden by objects.

Note also that overflow on integer operations does not convert them to
floats, and does not throw an exception.  If we want to control
overflow, we can: define our own functions for operations, use floats
everywhere, or use an object with overridden operators.


@deftypefn {Neko Builtin} int $iadd (@var{a} : int, @var{b} : int)
@deftypefnx {Neko Builtin} int $isub (@var{a} : int, @var{b} : int)
@deftypefnx {Neko Builtin} int $imult (@var{a} : int, @var{b} : int)
@deftypefnx {Neko Builtin} int $idiv (@var{a} : int, @var{b} : int)
These operations on integers are optimised for speed; they all skip some
type checks, so they're faster.

Their results will always be a valid integer, but their value is
unspecified when one ore more of the two values is not an integer.
@builtin{idiv} raises an exception when division by @code{0} is
attempted:

@example
$print( $iadd(1,3) ); // 4
$print( $idiv(5,2) ); // 2
$print( $idiv(1,0) ); // exception
@end example
@end deftypefn


@deftypefn {Neko Builtin} bool $isnan (@var{n} : any)
Return @true{} if a value is the float NaN.
@end deftypefn


@deftypefn {Neko Builtin} bool $isinfinite (@var{n} : any)
Return if a value is the float @code{+Infinite}.
@end deftypefn

@c page
@node specs flow ops bitwise
@subsubsection Bitwise operations


The following operations are available for integers only.  For
performance reasons, Neko integers are signed and have 31 bits only, so
the ``unsigned'' part is of 30 bits only.


@deffn {Bitwise Binary Operation} <<
Left bit shift.
@end deffn

@deffn {Bitwise Binary Operation} >>
Right bit shift.
@end deffn

@deffn {Bitwise Binary Operation} >>>
Right unsigned bit shift.
@end deffn

@deffn {Bitwise Binary Operation} |
Or bits.
@end deffn

@deffn {Bitwise Binary Operation} &
And bits.
@end deffn

@deffn {Bitwise Binary Operation} ^
Xor bits.
@end deffn

Using these operations with one or more non--integer operands will raise
an exception.

@c page
@node specs flow ops boolean
@subsubsection Boolean operations


@findex @builtin{istrue}
@findex @builtin{not}

@deftypefn {Neko Builtin} bool $istrue (@var{v} : any)
Convert any value to a boolean.  The result of applying @builtin{istrue}
to a value depends on its type:

@table @asis
@item @cnull{}
yields @false{};

@item integer
yields @false{} if @code{0}, @true{} otherwise;

@item boolean
yields the boolean itself;

@item float
@itemx string
@itemx object
@itemx array
@itemx function
yields @true{};
@end table

@noindent
only the values @cnull{}, @false{}, and @code{0} (integer) evaluate to
@false{}.
@end deftypefn


@deftypefn {Neko Builtin} bool $not (@var{v} : any)
The inverse of @builtin{istrue}; return the opposite of the boolean that
would have been returned by @builtin{istrue}: @true{} if @var{v} is
@false{} or @cnull{} or @code{0}.
@end deftypefn

@c page
@node specs flow ops logic
@subsubsection Logic operations


@findex @code{&&}
@findex @code{||}

Logic boolean operations are short--circuited: if the first operand of
an @code{&&} is false or the first operand of an @code{||} is true, then
the second operand is not evaluated, and the first value is returned;
otherwise, the second value is returned.

Notice that no automatic conversion to boolean is done: @code{a && b} is
equivalent to @code{if (a == false) b else a} and @code{a || b} is
equivalent to @code{if (a == true) a else b} with @code{a} being
evaluated only once.  We might prefer to call @builtin{istrue} on each
argument before performing the operation.

@c page
@node specs flow ops comparison
@subsubsection Equality and comparison


Comparison occurs when the following operations are performed.

@deffn {Comparison Operation} ==
Equality: evaluate to @true{} if the operands are equal.
@end deffn

@deffn {Comparison Operation} !=
Inequality: evaluate to @true{} if the operands are @strong{not} equal.
@end deffn

@deffn {Comparison Operation} >
Greater than: evaluate to @true{} if the left side operand is greater
than the right side one.
@end deffn

@deffn {Comparison Operation} <
Greater than: evaluate to @true{} if the left side operand is less than
the right side one.
@end deffn

@deffn {Comparison Operation} >=
Greater than: evaluate to @true{} if the left side operand is greater
than or equal to the right side one.
@end deffn

@deffn {Comparison Operation} <
Greater than: evaluate to @true{} if the left side operand is less than
or equal to the right side one.
@end deffn

@deftypefn {Comparison Operation} int? $compare (@var{a}, @var{b})
The low level comparison function; it has the classic ternary result.
The following table shows the comparison method used depending on the
type of operands:

@example
$compare | null int    float  string bool   object array function
---------+-------------------------------------------------------
null     | 0    -      -      -      -      -      -     -
int      | -    icmp   fcmp   strcmp -      -      -     -
float    | -    fcmp   fcmp   strcmp -      -      -     -
string   | -    strcmp strcmp strcmp strcmp -      -     -
bool     | -    -      -      strcmp bcmp   -      -     -
object   | -    -      -      -      -      ocmp   -     -
array    | -    -      -      -      -      -      acmp  -
function | -    -      -      -      -      -      -     acmp
@end example

Here are the details of each comparison function:

@table @code
@item icmp
compares two integers @code{a} and @code{b}: it returns @code{0} if
they're equal, @code{-1} if @code{b < a}, and @code{+1} if @code{a > b};

@item fcmp
is the same as @code{icmp}, but compares floats instead of integers;

@item strcmp
compares strings; it can be seen as @code{icmp} applied to every byte of
the two strings;

@item acmp
compares the addresses of @code{a} and @code{b}; it returns @code{0} if
they're equal, @cnull{} otherwise;
@c @code{-1} if @code{a < b}, and @code{+1} if @code{a > b};

@item bcmp
returns @code{0} if @code{a} and @code{b} are both true or both false,
@code{+1} if @code{a} is true and @code{b} and false, and @code{-1} if
@code{a} is false and @code{b} is true;

@item ocmp
does ``object comparison''; if the two objects' addresses are equal,
then it returns @code{0}; otherwise it calls the method @code{__compare}
on the first object, with the second object as argument; if the returned
value is an integer, the integer is returned by @builtin{compare}, else
@cnull{} is returned;

@item -
means that the comparison is invalid, the returned value is @cnull{} when
using @builtin{compare} and @false{} when using an operator.
@end table
@end deftypefn


The following table shows how each operation is performed depending on
the result of @builtin{compare}:

@example
op  |   null    -1      0       1
----+--------------------------------
==  |   false   false   true    false
!=  |   true    true    false   true
<=  |   false   true    true    false
<   |   false   true    false   false
>=  |   false   false   true    true
>   |   false   false   true    true
@end example


@deftypefn {Comparison Operation} int? $pcompare (@var{a}, @var{b})
Compare two values physically; it will be the same result as
@builtin{compare} for integers, while other values will be compared
using their memory address.  We can use @builtin{pcompare} instead of
@builtin{compare} if we want to optimise our integer comparisons.
@end deftypefn

@c page
@node specs flow ops assignment
@subsubsection Assignment


@findex @code{=}
@findex @code{+=}
@findex @code{-=}
@findex @code{*=}
@findex @code{/=}
@findex @code{%=}
@findex @code{<<=}
@findex @code{>>=}
@findex @code{>>>=}
@findex @code{|=}
@findex @code{&=}
@findex @code{^= }
@findex @code{++=}
@findex @code{--=}

The following operations are available to modify the value of a
variable, object field, array slot@dots{}

The standard assignment operator is @code{=}; there are also the
following augmented assignment operators which perform an operation at
the same time; the return value is always the assigned value:

@example
+= -= *= /= %= <<= >>= >>>= |= &= ^=
@end example

There are two additional operators @code{++=} and @code{--=} which do
the same thing as @code{+=} and @code{-=}, except that the returned
value is the value of the variable before it was modified:

@example
a = 0;
$print(a ++= 1);        // 0
$print(a ++= 1);        // 1
$print(a);              // 2
@end example

@c page
@node specs flow ops conversion
@subsubsection Conversion


@findex @code{__string}
@cindex @code{#object}


@deftypefn {Neko Builtin} int $int (@var{value} : string|float)
Convert a string or a float to an integer; return @cnull{} if the
argument cannot be converted to an integer.  Examples:

@example
$int(45.67);     // 45
$int("67.87");   // 67
$int($array(4)); // null
@end example
@end deftypefn


@deftypefn {Neko Builtin} float $float (@var{value} : string|integer)
Convert a string or integer to a float; return @cnull{} if the argument
cannot be converted to an integer.  Examples:

@example
$float("1.345");   // 1.345
$float(12345);    // 12345.0000
$float($array()); // null
@end example
@end deftypefn


@deftypefn {Neko Builtin} string $string (@var{value} : any)
Convert a value to a string.  Any value can be converted to a string
using @builtin{string}, this operation is used in particular by the
@builtin{print} operation.  Examples:

@example
$string(null);          // "null"
$string(123);           // "123"
$string($array(1,2,3)); // "[1,2,3]"
@end example

On objects: @builtin{string} calls the @function{__string} method on the
object if it exists; if the returned value is a string, this string is
returned, else the string @code{#object} is returned.

On functions: @code{#function:<N>} is returned where @code{<N>} is the
number of arguments of the function (or @code{-1} if multiple
arguments).
@end deftypefn

@c page
@node specs rtti
@section Runtime type information


No matter if our language is statically or dynamically typed, we can
always access @rtti{} in Neko.  @rtti{} is powerful because we can
decide which behaviour to adopt depending on some value at runtime.  The
most common application of this is to print some debugging information.
Another one is introspection: the ability to look inside an object, read
its fields, and call its methods.


@deftypefn {Neko Builtin} int $typeof (@var{value} : any)
Return an integer specifying the type of a value according to the
following table:

@multitable {abstract} {Constant's symbolic name} {Constant's numeric value}
@headitem Type @tab Constant's symbolic name @tab Constant's numeric value
@item null @tab @code{$tnull} @tab 0
@item int @tab @code{$tint} @tab 1
@item float @tab @code{$tfloat} @tab 2
@item bool @tab @code{$tbool} @tab 3
@item string @tab @code{$tstring} @tab 4
@item object @tab @code{$tobject} @tab 5
@item array @tab @code{$tarray} @tab 6
@item function @tab @code{$tfunction} @tab 7
@item abstract @tab @code{$tabstract} @tab 8
@end multitable

@ignore
@example
Type     | Constant's symbolic name | Constant's numeric value
---------+--------------------------+-------------------------
null     | $tnull                   | 0
int      | $tint                    | 1
float    | $tfloat                  | 2
bool     | $tbool                   | 3
string   | $tstring                 | 4
object   | $tobject                 | 5
array    | $tarray                  | 6
function | $tfunction               | 7
abstract | $tabstract               | 8
@end example
@end ignore

Examples:

@example
$typeof(3);              // 1
$typeof($array(1,2));    // 6
$typeof(null) == $tnull; // true
@end example
@end deftypefn

We can use the builtins for objects, strings, functions and arrays to
manipulate them at runtime.

@defvr {Neko Variable} $tnull
@defvrx {Neko Variable} $tint
@defvrx {Neko Variable} $tfloat
@defvrx {Neko Variable} $tbool
@defvrx {Neko Variable} $tstring
@defvrx {Neko Variable} $tobject
@defvrx {Neko Variable} $tarray
@defvrx {Neko Variable} $tfunction
@defvrx {Neko Variable} $tabstract
Variables holding integer identifiers for Neko built in data types.
@end defvr

@c page
@node specs funcs
@section Functions and function calls


@findex @code{function}

Defining new functions is easy: since functions are values, we can
simply assign them to a local or a global variable:

@example
var foo = function() @{
  return 0;
@}
@end example

Functions are called by--value, which means that @code{foo(1)} calls the
function which is the value of the variable @code{foo}.  Calling a value
that is not a function or that does not accept the given number of
arguments will raise an exception.

We can retrieve the number of arguments needed by a function by using
the built in operation @builtin{nargs}; when @builtin{nargs} is applied
to a function that accepts a variable number of arguments: the return
value is @code{-1}.  Note note also that built in operations can be used
as values:

@example
$print($nargs(function(a,b) @{ return a + b; @});    // prints 2
$print($nargs($print));                            // prints -1
$print($nargs(0));                                 // exception
@end example

The built in operation @builtin{call} takes an array of arguments and a
object context as parameters; it can be useful for introspection:

@example
// call the foo function with null context
// and the two parameters 3 and 4
$call(foo,null,$array(3,4));
@end example

Functional languages require partial application (aka currying): the
ability to create closures by setting a fixed number of arguments of a
function, leaving the rest for later call.  The built in operation
@builtin{closure} enables us to create a closure:

@example
var add   = function(x,y) @{ return x + y @};
var plus5 = $closure(add,null,5); // null context and
                                  // 5 as first argument
$print(plus5(2)); // prints 7
@end example

@builtin{closure} can also be used to fix the @code{this} context of a
function:

@example
var f = function() @{ $print(this) @};
f = $closure(f,55);
f(); // prints 55
@end example

Some languages might want more security about the types of the arguments
that are passed to a function, or selecting at runtime different
implementations of a function depending on the type of the arguments.
There are many ways of doing that in Neko; for example, we might want to
add arguments checks at the beginning of the function body using @rtti{}
built in operations.

Another useful built in operation is @builtin{apply} which is identical
to a direct function call except that if the function requires extra
arguments then its call is delayed until further arguments are used:

@example
var f = function(x,y) @{ return x + y @};
f(1,2);
$apply(f,1)(2); // equivalent
$apply(f,1,2); // equivalent
@end example


@deftypefn {Neko Builtin} int $nargs (@var{f} : function)
Return the number of arguments of a function.  If the function has a
variable number of arguments: the return value is @code{-1}.
@end deftypefn


@deftypefn {Neko Builtin} any $call (@var{f} : function, @var{this} : any, @var{args} : array)
Call @var{f} with @var{this} context and @var{args} arguments.
@end deftypefn


@deftypefn {Neko Builtin} function $closure (@var{f} : function, ... : any)
Build a closure by applying a given number of arguments to a function.
@end deftypefn


@deftypefn {Neko Builtin} any $apply (@var{f} : function, ... : any)
Apply the function to several arguments.  Return a function asking for
more arguments or the function result if more arguments are needed.
@end deftypefn


@deftypefn {Neko Builtin} function $varargs (@var{f} : function:1)
Return a variable arguments function that, when called, will callback
@var{f} with the array of arguments.
@end deftypefn

@c page
@node specs objects
@section Objects


Objects are some kind of optimised hash tables.  All fields names are
hashed into an integer value that is used as the key into a look up
table.  Insertion of a new field is O(n), access to a field is O(log n).
If we're generating Neko code from a statically typed programming
language, we might prefer arrays for storing fields, since they provide
O(1) access.

@menu
* specs objects making::        Creating objects.
* specs objects access::        Setting and getting values.
* specs objects inspect::       Inspecting objects.
* specs objects methods::       Defining methods.
* specs objects overloading::   Operators overloading.
* specs objects protos::        Prototypes.
* specs objects misc::          Other functions.
@end menu

@c page
@node specs objects making
@subsection Creating objects


@deftypefn {Neko Builtin} object $new (@var{o} : object?)
Create and return an object.  The return value is a copy of the existing
object @var{o} or a new, empty, object if @var{o} is @cnull{}:

@example
o  = $new(null); // new empty object
o2 = $new(o);    // makes a copy of "o"
@end example

@noindent
if @var{o} is not an object or @cnull{}: throw an exception.
@end deftypefn


Access to object fields is done using the dot operator:

@example
var o   = $new(null);
o.field = value;
$print(o.field);
@end example

@noindent
but also with the built in operations @builtin{objset} and
@builtin{objget}.  @ref{specs objects access} for details.

To create a new object we can write a constructor function that
allocates an object and adds all the mandatory fields:

@example
var colour_constructor = function (red, green, blue) @{
  var o = $new(null);

  o.red   = red;
  o.green = green;
  o.blue  = blue;
  return o;
@};
@end example

@noindent
one other way to declare objects is to use the following notation, which
is more efficient when we want to initialise several fields at the same
time:

@example
var o = @{
  x   => 0,
  y   => -1,
  msg => "hello"
@}
@end example

@c page
@node specs objects access
@subsection Setting and getting values


@deftypefn {Neko Builtin} int $hash (@var{s} : string)
Return the hashed value of a field's name, or raise an exception in case
of collision.
@end deftypefn


@deftypefn {Neko Builtin} any $objset (@var{o} : object, @var{field_id} : int, @var{value} : any)
Set the field identified by @var{field_id} in @var{o} to @var{value} and
return @var{value} if @var{o} is an object or @cnull{} otherwise.
Example:

@example
var o = $new(null);
$objset(o, $hash("field"), "value");
@end example

@noindent
the field identifier is an integer that can be generated by the
@builtin{hash} built in operation.

If a field does not exist: it is added by @builtin{objset}; the same
happens when the field is set using the dot operator.
@end deftypefn


@deftypefn {Neko Builtin} any $objget (@var{o} : object, @var{field_id} : int)
Return the field identified by @var{field_id} in @var{o}, or @cnull{} if
the such field does not exist or @var{o} is not an object.  Example

@example
var o  = $new(null);
var id = $hash("field");
$objset(o, id, "value");
$print($objget(o, id));
@end example

If a field is not defined when accessed for reading: @cnull{} is
returned.
@end deftypefn


Field names are first hashed into integer values for faster access.
Notice that the second parameter of @builtin{objset} and
@builtin{objget} is hashed at runtime, while when using the dot operator
the field names are hashed by the compiler.  So using the explicit built
in operations is a bit less efficient than dot access, but it enables
introspection.

In order to avoid collisions among hashed values, they are stored in a
global table: Neko will use the table to make sure that @code{$hash(x)
== $hash(y)} implies @code{x == y}.  Another purpose of this feature is
to be able to reverse the hash function at runtime; this can be useful
to print the field names of an object, for debugging or other purposes.


@deftypefn {Neko Builtin} string $field (@var{n} : int)
Reverse the hashed value of a field's name.  Return @cnull{} if @var{n}
is not in the table of fields.
@end deftypefn

@c page
@node specs objects inspect
@subsection Inspecting objects


@deftypefn {Neko Builtin} bool $objfield (@var{o} : object, @var{field_id} : int)
Check for a field existence; return true if @var{o} is an object which
has a field identified by @var{field_id}.  This operation works even if
the field is set to @cnull{}.  Example:

@example
$objfield(o, $hash("field"));    // true if "o" has "field"
$objfield(null, 33);             // false
@end example
@end deftypefn


@deftypefn {Neko Builtin} {int array} $objfields (@var{o} : object)
Return an array containing all the field identifiers for the given
object:

@example
var a = $objfields(o);
var i = 0;
while( i < $asize(a) ) @{
  var fname = $field(a[i]);
  var fval  = $objget(o,a[i]);
  $print( fname + " = " + fval + "\n" );
  i = i + 1;
@}
@end example
@end deftypefn


@deftypefn {Neko Builtin} void $setresolver (@var{f} : function:2?)
Set a function to callback, with object and field id as arguments, when
an object field is not found.
@end deftypefn


The @builtin{setresolver} feature can be useful, for example, to
implement ``virtual'' fields.  The following is a raw example:

@example
math_pow   = $loader.loadprim("std@@math_pow",   2);
math_sqrt  = $loader.loadprim("std@@math_sqrt",  1);
math_atan2 = $loader.loadprim("std@@math_atan2", 2);

var slot_resolver = function (object, field_id) @{
  switch (object.class) @{
    $hkey("position") =>
      return switch (field_id) @{
        $hash("theta") =>
          math_atan2(object.y, object.x)
        $hash("rho") =>
          math_sqrt(math_pow(object.x, 2) +
                    math_pow(object.y, 2))
      @}
    default => $throw("unknown class")
  @}
@};

$setresolver(slot_resolver);

var s   = $new(null);
s.class = $hkey("position");
s.x     = 3;
s.y     = 4;

$print("rho = " + s.rho + " theta = " + s.theta "\n");
@end example

@c page
@node specs objects methods
@subsection Defining methods


@cindex @code{this}

A method is a function stored in an object field.  When a function is
called using the dot operator or the built in operation
@builtin{objcall}, the function can access a special variable named
@code{this} which is the ``object context'' (the object with which the
function was called):

@example
o     = $new(null);
o.x   = 1;
o.add = function(y) @{ return this.x + y; @}

$print(o.add(2));                              // prints 3
$print( $objcall(o,$hash("add"),$array(2)) );  // prints 3
@end example

The context is set when an object function is called and can be accessed
from any sub function:

@example
foo = function() @{
  $print(this.x);
@}
o     = $new(null);
o.x   = 3;
o.bar = function() @{ foo(); @};
o.bar(); // prints 3
@end example

We can modify the value of @code{this} at runtime by simply assigning
it to another value; it can be set to any value, not only objects.  When
returning from an object call, the context is restored, so any
modification is lost:

@example
this = 1;
o.foo = function() @{
  // here , we have this = o;
  this = 2; // modify
@};
o.foo();
$print(this); // 1
@end example


@deftypefn {Neko Builtin} any $objcall (@var{o} : any, @var{field_id} : int, @var{args} : array)
Call the function stored in the field identified by @var{field_id} in
@var{o} with arguments taken from the array @var{args}; return the
return value of the function or @cnull{} if @var{o} is not an object.
@end deftypefn

@c page
@node specs objects overloading
@subsection Operators overloading


Several operators can be overloaded: when they're applied to objects
they are actually calling methods.  If the overloaded method is not
defined when an operation occurs, an exception is raised.

The specified type of return values is the type that the method is
expected to return; when this type is @code{any}, it means that the type
of the return value is free: it can depend on the method implementation.


@deftypefn {Neko Method} string __string (void)
String conversion.  Call the method on the object with no arguments; a
string should be returned.
@end deftypefn


@deftypefn {Neko Method} int __compare (@var{b} : any)
Compare two different objects.  The method is called with the first
object stored in @code{this} and the second object as parameter.

Notice that, as per the specs of Neko: comparison between an object and
a non--object returns @cnull{} directly, without examining the fields of
the object itself.  This means that @function{__compare} is invoked only
whenever a comparison between two objects happens, and the invoked
@function{__compare} is the one of the objects to the left.  Neko does
not support the @function{__rcompare} method.
@end deftypefn


@deftypefn {Neko Method} any __add (@var{b} : any)
@deftypefnx {Neko Method} any __radd (@var{a} : any)
Add two objects.  In the case of @code{a + b}, if @code{a} is an object:
@code{a.__add(b)} is called; else if @code{b} is an object,
@code{b.__radd(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __sub (@var{b} : any)
@deftypefnx {Neko Method} any __rsub (@var{a} : any)
Subtract two objects.  In the case of @code{a - b}, if @code{a} is an
object: @code{a.__sub(b)} is called; else if @code{b} is an object,
@code{b.__rsub(a)} is called.

Notice that the unary negative operator is converted by Neko into the
subtraction: @code{0 - number}; so it is handled by the @function{__sub}
method.
@end deftypefn


@deftypefn {Neko Method} any __mult (@var{b} : any)
@deftypefnx {Neko Method} any __rmult (@var{a} : any)
Multiply two objects.  In the case of @code{a * b}, if @code{a} is an
object: @code{a.__mult(b)} is called; else if @code{b} is an object,
@code{b.__rmult(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __div (@var{b} : any)
@deftypefnx {Neko Method} any __rdiv (@var{a} : any)
Divide two objects.  In the case of @code{a / b}, if @code{a} is an
object: @code{a.__div(b)} is called; else if @code{b} is an object,
@code{b.__rdiv(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __mod (@var{b} : any)
@deftypefnx {Neko Method} any __rmod (@var{a} : any)
Compute the modulo of an object with respect to another.  In the case of
@code{a % b}, if @code{a} is an object: @code{a.__mod(b)} is called;
else if @code{b} is an object, @code{b.__rmod(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __get (@var{i} : int)
Called when an object is accessed as an array for reading, using
@code{a[i]} actually calls @code{a.__get(i)}.
@end deftypefn


@deftypefn {Neko Method} any __set (@var{i} : int)
Called when an object is accessed as an array for writing, using
@code{a[i] = v} actually calls @code{a.__set(i,v)}.
@end deftypefn

@c page
@node specs objects protos
@subsection Prototypes


@findex @builtin{objgetproto}
@findex @builtin{objsetproto}

Each object can have a ``prototype'' which is also an object.  When a
field is accessed for reading and is not found in an object, it is
searched in its prototype, then in the prototype of the prototype, and
so on recursively.

Prototypes can be accessed using @builtin{objgetproto} and
@builtin{objsetproto}:

@example
var proto = $new(null);
proto.foo = function() @{ $print(this.msg) @}

var o = $new(null);
o.msg = "hello";
$objsetproto(o,proto);
o.foo(); // print "hello"

$objsetproto(o,null); // remove proto
o.foo(); // exception
@end example


@deftypefn {Neko Builtin} void $objsetproto (@var{o} : object, @var{proto} : object?)
Set the prototype of the object.
@end deftypefn


@deftypefn {Neko Builtin} object? $objgetproto (@var{o} : object)
Get the prototype of the object.
@end deftypefn

@c page
@node specs objects misc
@subsection Other functions


@deftypefn {Neko Builtin} bool $objremove (@var{o} : object, @var{field_id} : int)
Remove the field identified by @var{field_id} from @var{o}; return
@true{} on success.  Example:

@example
$objremove(o, $hash("field"));
@end example
@end deftypefn

@c page
@node specs array
@section Arrays


Array is a Neko type, not an object.  If in our high level language
arrays are objects, then we can write an object wrapper using an array
value to store the data, and matching the @api{} of our language.

Array access is done using the C language--like brackets syntax, using
zero--based integer values as keys; every value of non--integer type,
used as key, will cause an exception to be raised.

When getting a value: if the integer key is in the range of the array
bounds (between @code{0} and @code{size - 1}), then the value returned
is the one stored at that index; else it's @cnull{}.  That is:
@strong{no} error is raised if the index is out of bounds.

When setting a value: if the integer key is out of bounds, then the
array is not modified and @strong{no} error is raised.


@deftypefn {Neko Builtin} array $array (any*)
@deftypefnx {Neko Builtin} array $amake (@var{number_of_slots} : int)
Build and return a new array: @builtin{array} will create an array
holding the given list of arguments, @builtin{amake} will create an
empty array with the given number of slots.  Examples:

@example
var a = $array(1,3,"test"); // array with three values
var b = $amake(0);          // empty array

$print(a[0]);   // prints 1
$print(a[2]);   // prints "test"
$print(a[3]);   // prints null
@end example

Arrays can contain a maximum of 2^29 - 1 elements; attempts to build a
larger array will raise an exception.  Arrays are @strong{not}
resizable.
@end deftypefn


@deftypefn {Neko Builtin} int $asize (@var{array})
Return the size of an array, which equals the number of allocated slots.
Example:

@example
a = $array(1,2,3);
$print($asize(a)); // prints 3
@end example
@end deftypefn


@deftypefn {Neko Builtin} array $acopy (@var{a} : array)
Create and return a copy of an array.  Example:

@example
a = $array(1,2,3,4);
$print( $acopy(a) );  // prints [1,2,3,4]
@end example

Modifying the copy of an array does not modify the original array
values.
@end deftypefn


@deftypefn {Neko Builtin} array $asub (@var{a} : array, @var{position} : int, @var{number_of_elements} : int)
Create and return a new array holding @var{number_of_elements} elements
from @var{a} starting at @var{position}.  An exception is raised if the
arguments select a range out of array bounds.  Examples:

@example
a = $array(1,2,3,4);
$print( $asub(a,1,2) );   // [2,3]
$print( $asub(a,3,3) );   // null
$print( $asub(a,-2,3) );  // null
@end example

Modifying the copy of an array does not modify the original array
values.
@end deftypefn


@deftypefn {Neko Builtin} array $ablit (@var{dst} : array, @var{dst_pos} : int, @var{src} : array, @var{src_pos} : int, @var{number_of_elements} : int)
Copy @var{number_of_elements} elements from @var{src} starting at
@var{src_pos} into @var{dst} starting at @var{dst_pos}.  An exception is
raised if the arguments select ranges out of arrays bounds.  Examples:

@example
a = $array(1,2,3,4);
b = $array(6,7,8);
$ablit(a,1,b,0,2); // copy 2 elements from b+0 to a+1
$print(a);         // prints [1,6,7,4]
@end example
@end deftypefn


@deftypefn {Neko Builtin} array $aconcat (@var{ell} : array)
Take @var{ell} to be an array in which each element is an array; build
and return a single array whose elements are taken from the subarrays of
@var{ell}.  Example:

@example
$print($aconcat($array($array(1,2,3),
                       $array(4,5),
                       $array(6)))); // prints [1,2,3,4,5,6]
@end example
@end deftypefn


The following is a possible comparison functions for array that compares
them element by element:

@example
var array_compare = function (a, b) @{
  var na = $asize(a);
  var nb = $asize(b);
  var n  = if (na < nb) na; else nb;
  var i  = 0;

  while (i < n)
    @{
      if (a[i] != b[i])
	return $compare(a[i], b[i]);
      i += 1;
    @}

  return if (na < nb) @{ -1 @}; else @{ if (na > nb) 1 ; else 0; @};
@};
@end example

@c page
@node specs string
@section Strings


Strings are a type and not objects.  They are arrays of bytes, so they
can be convenient to store a large quantity of small numbers or binary
data.

Notice that, unlike C language strings, the size of Neko strings is
stored in each string value so we can easily put binary data into it
without caring about the ending @code{\0} character.  For example
strings are used as input/output buffers when reading/writing to files
with Neko's standard library.  @ref{lib file} for details.

Neko strings are just buffers of bytes, so they are independent from any
encoding.  The encoding depends on the @api{} we're using to manipulate
strings.  We can use either the built in operations which manipulate
bytes (then suitable for @acronym{ISO}) or the @acronym{UTF8} @api{} (in the
standard library) which manipulates @acronym{UTF8} char codes.  @ref{lib utf8}
for details.

Literal strings can contain any character, including newlines and binary
data.  However double quotes and backslashes need to be escaped.  A
backslash is used for escaping some special characters, here's a list of
recognised escape sequences:

@table @code
@item \"
double quote;
@item \\
backslash;
@item \n
newline;
@item \r
carriage return;
@item \t
tab;
@item \xxx
@code{xxx} are three digits that represent a decimal binary code between
000 and 255.
@end table

@menu
* specs string make::           Creating strings.
* specs string access::         Accessing characters.
* specs string copy::           Copying strings.
* specs string inspect::        Inspecting strings.
@end menu

@c page
@node specs string make
@subsection Creating strings


@deftypefn {Neko Builtin} string $smake (@var{number_of_bytes} : int)
Build and return an uninitialised string of @var{number_of_bytes}; once
allocated, a string can't be resized.  Example:

@example
s = $smake(16);
s = "hello";
$print( $ssize(s) ); // prints 5
@end example

Strings can contain a maximum of 2 ^ 29 - 1 characters, or
@builtin{smake} will raise an exception.
@end deftypefn


@deftypefn {Neko Builtin} string $string (@var{value} : any)
Convert any value to a string.  This will make a copy of string.
@end deftypefn

@c page
@node specs string access
@subsection Accessing characters


@deftypefn {Neko Builtin} int? $sget (@var{s} : string, @var{position} : int)
Return the @var{position}th char of a string as integer in the range
@code{[0, 255]}, or @cnull{} if @var{position} is out of bounds.
@end deftypefn


@deftypefn {Neko Builtin} int? $sset (@var{s} : string, @var{position} : int, @var{c} : int)
Set the @var{position}th char of a string to @code{@var{c} % 255}.
Return @var{c} itself or @cnull{} if @var{position} is out of bounds.
@end deftypefn


Examples:

@example
$s = $smake(1);
$sset(s,0,3684);        // set byte 0 to 3624 mod 256
$print( $sget(s,0) );   // prints 40
@end example

@c page
@node specs string copy
@subsection Copying strings


Notice that assigning a constant string does not copy it, so the
constant content can be modified.  Also, equal constant strings can be
collapsed into the same string, so we have to be careful about
unexpected side effects when modifying a constant string.


@deftypefn {Neko Builtin} string $scopy (@var{s} : string)
Make a copy of a string.  Example:

@example
var s = "ciao";
var c = $scopy(s);
@end example
@end deftypefn


@deftypefn {Neko Builtin} string $ssub (@var{s} : string, @var{position} : int, @var{number_of_bytes} : int)
Return @var{number_of_bytes} chars starting at @var{position} in
@var{s}.  An exception is raised if @var{position} is out of string
bounds.  Example:

@example
var s = "hello";
$print( $ssub(s,1,3) ); // prints "ell"
@end example
@end deftypefn


@deftypefn {Neko Builtin} void $sblit (@var{dst} : string, @var{dst_pos} : int, @var{src} : string, @var{src_pos} : int, @var{len} : int)
Copy @var{len} chars from @var{src_pos} of @var{src} to @var{dst_pos} of
@var{dst}; return the number of bytes copied or @cnull{} if the copy
failed.  An exception is raised if the arguments select ranges that are
out of strings bounds.  Examples:

@example
s = "some string to blit from";
s2 = $smake(14);
$sblit(s2,0,s,5,14);
$print(s2); // prints "string to blit"
@end example
@end deftypefn

@c page
@node specs string inspect
@subsection Inspecting strings


@deftypefn {Neko Builtin} int $ssize (@var{s} : string)
Return the size of a string.
@end deftypefn


@deftypefn {Neko Builtin} int $sfind (@var{s} : string, @var{position} : int, @var{pattern} : string)
Return the index of the first occurrence of @var{pattern} in @var{s},
beginning the search at @var{position}.  Return @cnull{} if not found.
An exception is raised if @var{position} is out of bounds.  Example:

@example
s = "some string to search";
$print($sfind(s, 0,"to"));       // prints 12
$print($sfind(s,20,"to"));      // prints null
@end example
@end deftypefn

@c page
@node specs exceptions
@section Exceptions


@cindex @code{try}
@cindex @code{catch}
@findex @builtin{excstack}
@findex @builtin{callstack}

Exceptions are often referred to as ``non local jumps'' or ``non local
exits''.  They are a very good way to handle errors than can happen at
several calls between the function that yields an error and the handler
that will take care of it.  Raising an exception is done using
@builtin{throw}, and catching it is done using the @code{try...catch}
syntax.  Notice that any value can be an exception, it's up to us to
decide which structure we want to use:

@example
var foo = function() @{
  $throw("failure");
@}
try
  foo()
catch e @{
  $print(e); // prints "failure"
@}
@end example

@deftypefn {Neko Builtin} any $throw (@var{v} : any)
Throw any value as an exception.  Never return.
@end deftypefn


Every time an exception is catched, the call stack is saved and it can
be retrieved using @builtin{excstack()}.  It contains the file names and
positions of the different calls between the try and the place the
exception was raised:

@example
try
  foo()
catch e @{
  $print(e, " raised from : ", $excstack());
@}
@end example


@deftypefn {Neko Builtin} array $excstack (void)
Return the stack between the place the last exception was raised and the
place it was catched.  The stack is composed of the following items:

@itemize
@item
@cnull{} when it's a C function;

@item
a string when it's a module without debug informations;

@item
an array of two elements (usually file and line) if debug informations
where available.
@end itemize
@end deftypefn


In some cases, we may want to filter exceptions, that is: catch only
some of them.  To do this we catch all the exceptions, check if the
exception is filtered, and raise it again if not.  However, in order not
to loose the call stack by throwing a new exception, we can use
@builtin{rethrow} which will add the two stacks together (the current
one and the one to the next @code{catch}).

@example
try
  foo()
catch e @{
  if( $typeof(e) == $tint )
    $print("catched !")
  else
    $rethrow(e);
@}
@end example

Notice that we can rethrow another exception, so it's more easy to
rewrap some Neko libraries exceptions with our own format.


@deftypefn {Neko Builtin} any $rethrow (@var{v} : any)
Throw any value as an exception while keeping previous exception
stack.  Never returns.
@end deftypefn


@deftypefn {Neko Builtin} array $callstack ()
Return the current call stack.  Same format as @builtin{excstack}.
@end deftypefn

@c page
@node specs hash tables
@section Hash tables


Neko's hash tables are abstract types; they can only be manipulated
using the following operations.  A hash table stores the key/value
binding in one chained list per bucket; adding a new binding with the
same key will @strong{mask} the previous one.

@menu
* specs hash tables making::    Creating hash tables.
* specs hash tables access::    Accessing elements.
* specs hash tables inspect::   Inspecting tables.
@end menu

@c page
@node specs hash tables making
@subsection Creating hash tables


@deftypefn {Neko Builtin} 'hash $hnew (@var{size} : int)
Create and return a new table having, initially, @code{size} buckets.
@end deftypefn


@deftypefn {Neko Builtin} void $hresize (@var{table} : 'hash, @var{new_size} : int)
Resize the table to have @var{new_size} buckets; note that the size is
usually automatically handled.
@end deftypefn

@c page
@node specs hash tables access
@subsection Accessing elements


The hash function cannot be overridden, but the comparison function
between keys can be: we just have to provide a custom function as
argument to the built in operations @builtin{hget}, @builtin{hmem},
@builtin{hset}, @builtin{$hadd} and @builtin{hremove}.

In the following description: to compare the @var{key} argument to the
keys in the hash table, the built in operations will use the comparison
function selected with the @var{compar} argument, or @builtin{compare}
if @var{compar} is @cnull{}.

Remember that a comparison function must return a ternary result:
@code{0} for equality, @code{+1} or @code{-1} otherwise; from the point
of view of the hash table operations: the result of the comparison
function is zero or non--zero, it makes no difference if the non--zero
result is @code{+1} or @code{-1}.


@deftypefn {Neko Builtin} int $hkey (@var{value} : any)
The hash function used internally to compute the position of a hash
table element; @builtin{hkey} returns a positive integer for any Neko
value.  Examples:

@example
$print($hkey("ciao"));  // prints 798460
$print($hkey("hello")); // prints 15247414
@end example
@end deftypefn


@deftypefn {Neko Builtin} any $hget (@var{table} : 'hash, @var{key} : any, @var{compar} : function:2?)
Look for the values bound to @var{key} in @var{table}; return the first
value found or @cnull{} if no value is found.  Examples:

@example
var T = $hnew(10);
$hadd(T, 123, "ciao");
$print($hget(T, 123, null)); // prints "ciao"

$hadd(T, 123, "hello");
$print($hget(T, 123, null)); // prints "hello"

$hremove(T, 123, null);
$print($hget(T, 123, null)); // prints "ciao"
@end example
@end deftypefn


@deftypefn {Neko Builtin} bool $hmem (@var{table} : 'hash, @var{key} : any, @var{compar} : function:2?)
Look for the value bound to @var{key} in @var{table}; return @true{} if
the value was found, @false{} otherwise.
@end deftypefn


@deftypefn {Neko Builtin} bool $hset (@var{table} : 'hash, @var{key} : any, @var{value} : any, @var{compar} : function:2?)
Set the value bound to @var{key} to @var{value} or add it to @var{table}
if not found.  Return @true{} if a new @var{key}/@var{value} binding was
added to the table; return @false{} if @var{key} was already present and
so @var{value} replaced the old value.
@end deftypefn


@deftypefn {Neko Builtin} void $hadd (@var{table} : 'hash, @var{key} : any, @var{value} : any)
Bind @var{value} to @var{key} in @var{table}; the previous binding, if
any, is masked but not removed.  See the example given for
@builtin{hget}.
@end deftypefn


@deftypefn {Neko Builtin} bool $hremove (@var{table} : 'hash, @var{key} : any, @var{compar} : function:2?)
Look for the value bound to @var{key} in @var{table}; return @true{} if
such a value exists and remove it from the table, return @false{}
otherwise.
@end deftypefn

@c page
@node specs hash tables inspect
@subsection Inspecting tables


@deftypefn {Neko Builtin} void $hiter (@var{table} : 'hash, @var{func} : function:2)
Apply @var{func} to every key and value in @var{table}.  For example
calling:

@example
var h = $hnew(10);
$hadd(h, "a", 1);
$hadd(h, "b", 2);
$hadd(h, "c", 3);

var func = function (key, val) @{
  $print(key + " " + val + "\n");
@};

$hiter(h, func);
@end example

@noindent
is equivalent to evaluating:

@example
$print("a" + " " + 1 + "\n");
$print("b" + " " + 2 + "\n");
$print("c" + " " + 3 + "\n");
@end example
@end deftypefn


@deftypefn {Neko Builtin} int $hcount (@var{table} : 'hash)
Return the number of elements in @var{table}.
@end deftypefn


@deftypefn {Neko Builtin} int $hsize (@var{table} : 'hash)
Return the number of buckets in @var{table}.
@end deftypefn

@c page
@node specs goto
@section Labels and gotos


@findex @builtin{goto}

It is sometimes useful to be able to jump directly at some code
location; labels provide a way to mark a location in the code and the
builtin @builtin{goto} can jump to it:

@example
 $print("enter");
 $goto(next);
 $print("skipping");
next:
 $print("done");
@end example

Please note that label identifiers are global to the file, but cannot be
defined in all expressions.  The reason is to simplify the compiler
since labels normally require multiple passes for stack preservation
(see below).  In the case a label cannot be declared an error is printed
at compilation--time.


The builtin @builtin{goto} can only be used with a valid label identifier,
in that case only, the identifier is treated as a label and not as a
variable.

@c ------------------------------------------------------------

@subsection Gotos and stack preservation

In all cases, gotos to labels are preserving the stack.  For example in
the following case, the variable @code{x} is popped out of the stack
when the goto occurs:

@example
@{
  var x = 0;
  $goto(next);
@}
next:
@end example

If the goto is done inside a block having defined local variables, these
variables are also accessible but their values are unspecified:

@example
$goto(next);
@{
  var x = 0;
next:
  $print(x);  // nobody knows what this will print
@}
@end example

@c ------------------------------------------------------------

@subsection Gotos and exceptions

In the same way gotos are preserving the stack, they are also preserving
the exception handlers, so that the following program is correctly
compiled:

@example
try @{
  $goto(next);
@} catch e @{
  ...
@}
next:
@end example

In the case a goto is done inside a @code{try...catch} block, a
temporary exception handler will be set that will only reraise the
exception.  The exception is not handled by the catch block since the
@code{try} setup has been skipped:

@example
$goto(next);
try @{
 next:
  $throw("error");
@} catch e @{
  ...
@}
@end example

@c page
@node specs misc
@section Miscellaneous builtins


@deftypefn {Neko Builtin} void $print (... : any)
Can print any value.
@end deftypefn


@deftypefn {Neko Builtin} int $version (void)
Return the version of Neko: @code{135} means @code{1.3.5}.
@end deftypefn

@c page
@node specs modules
@section Modules


@cindex Loading primitives
@cindex Loading modules
@cindex Loading shared libraries

A Neko module is a set of constants and functions defined in a Neko file
that is compiled and installed in a location reachable by the Neko
virtual machine.  @ref{neko} for details about running the virtual
machine.


@defvr {Neko Variable} $exports
Each Neko module has an object bound to @builtin{exports} in the top
level scope.  The module can set fields into this object in order to
export some values that will be usable from other modules.  Example:

@example
$exports.log = function() @{ $print("log test") @};
@end example
@end defvr


@defvr {Neko Variable} $loader
Each Neko module has a loader which is an object that can be used to
load other Neko modules and C primitives.  The loader is bound to
@builtin{loader} in the top level scope of the module.
@end defvr


@deftypefn {Neko Method} object loadmodule (@var{module_name} : string, @var{loader} : object)
In order to load a module, we can simply call the @function{loadmodule}
method of @builtin{loader}.  @var{module_name} is the name of the file
with the extension stripped.  @var{loader} is the loader that the newly
loaded module will use: it will be bound to @builtin{loader} in its top
level scope.

If a module @code{@var{module_name}.n} is found: the file is loaded, its
code evaluated, then its @builtin{exports} table is returned; if not
found: an exception is thrown.

Example of loading the module @file{log.n}:

@example
var m = $loader.loadmodule("log",$loader);
m.log();
@end example

The only thing needed to implement a custom loader is to define the
methods @code{loadmodule} and @code{loadprim}.
@end deftypefn


@deftypefn {Neko Method} object loadprim (@var{prim_spec} : string, @var{arity} : int)
The loader can import C language primitives exported by platform
specific shared libraries.  A primitive is loaded with the
@function{loadprim} method of the @builtin{loader} object.
@var{prim_spec} is a string formed by concatenating: the library name,
the @code{@@} character, the primitive name.  @var{arity} is the number
of arguments accepted by the primitive.

If success, a Neko function is returned to be used to call the
primitive.  If not found, an exception is thrown.

Example of loading the C language primitive @cfunc{file_open} from
the Neko standard library, and binding it to the Neko symbol
@code{file_open}:

@example
var file_open = $loader.loadprim("std@@file_open", 2);
@end example

The Neko standard library is a file called @file{std.ndll}; the ``name''
of the library is the file name with the extension stripped.
@end deftypefn

@c page
@node ffi
@chapter Foreign functions interface


The @nvm{} itself has enough operations to compute any value.  However
it cannot do everything, like accessing files, connecting to network
servers, or display and manage a @gui{} window with menus and buttons.
All these features and much more are however accessible from C language
code that will use operating system libraries.  Since the @nvm{} cannot
directly call C functions, it is needed to write some glue C code that
will wrap the @acronym{OS} libraries in order to make them accessible.
These glue functions are called ``primitives''.

When we're writing primitives, we need to use the Neko C @ffi{}.  We
only need to include the @file{neko.h} file which is part of the Neko
distribution, and to link with the Neko library (@file{libneko.so} on
Unix, @file{libneko.dylib} on OSX, and @file{neko.lib} on Windows).

@menu
* ffi example::                 A small example.
* ffi values::                  Manipulating values.
* ffi objects::                 Working with objects.
* ffi callbacks::               Function callbacks.
* ffi abstracts::               Abstracts and kinds.
* ffi varargs::                 Variable arguments functions.
* ffi int32::                   Using 32 bits integers.
* ffi memory::                  Managing memory.
* ffi misc::                    Misc @api{} functions.
@end menu

@c page
@node ffi example
@section A small example


Here's an ``Hello World'' sample on how to write a Neko primitive in C:

@example
#include <neko.h>

value test()
@{
  return alloc_string("Hello world");
@}

DEFINE_PRIM(test,0); // function 'test' with 0 arguments
@end example

Now all we have to do is to compile this C file into a shared library
named @file{hello.ndll}.  In order to test our primitive, we simply call
the @builtin{loader.loadprim} method and request the primitive with the
declared number of arguments:

@example
var p = $loader.loadprim("hello@@test",0);
$print( p() );
@end example

The format of primitive name is:

@example
name_of_the_library@@name_of_the_function
@end example

@noindent
we can then define several primitives in the same library.

@c page
@node ffi values
@section Manipulating values


There are several kind of @api{} functions:

@table @code
@item val_is_*
they work on any value and return @code{1} if the value is of the given
type, or @code{0} otherwise;

@item val_*
they enable us to retrieve the content of a value; please note that we
must first @strong{ensure} that the value is of the given type before
using such a function or the program might crash or have unpredictable
behaviour;

@item alloc_*
functions enable us to convert a C value to a Neko value;
@end table

@noindent
notice that most (almost all) of these functions are actually C macros.

@menu
* ffi values types::            Data types.
* ffi values const::            Constant values.
* ffi values predicates::       Type predicates.
* ffi values assert::           Asserting the types of values.
* ffi values access::           Access functions.
* ffi values alloc::            Allocation functions.
* ffi values print::            Printing values.
* ffi values buffers::          Buffers.
@end menu

@c page
@node ffi values types
@subsection Data types


The following types of values are available:

@example
null
integer
float
boolean
string
array
object
abstract
@end example

@noindent
every value given as argument to a primitive or returned by a primitive
must be of the C type @code{value}.

@deftp {C Language Type} value
The type of Neko values.  Instances of this type are garbage
collected.
@end deftp


@deftp {C Language Enum} val_type
The type of constants that identify types.  Defined values follow.
@end deftp

@c ------------------------------------------------------------

@deffn {C Language Type Constant} VAL_INT
The identifier of integers.
@end deffn


@deffn {C Language Type Constant} VAL_NULL
The identifier of @cnull{}.
@end deffn


@deffn {C Language Type Constant} VAL_FLOAT
The identifier of floating point numbers.
@end deffn


@deffn {C Language Type Constant} VAL_BOOL
The identifier of boolean values.
@end deffn


@deffn {C Language Type Constant} VAL_STRING
The identifier of strings.
@end deffn


@deffn {C Language Type Constant} VAL_OBJECT
The identifier of objects.
@end deffn


@deffn {C Language Type Constant} VAL_ARRAY
The identifier of arrays.
@end deffn


@deffn {C Language Type Constant} VAL_FUNCTION
The identifier of functions.
@end deffn


@deffn {C Language Type Constant} VAL_ABSTRACT
The identifier of abstracts.
@end deffn


@deffn {C Language Type Constant} VAL_PRIMITIVE
The identifier of primitive functions.
@end deffn


@c @deffn {C Language Type Constant} VAL_JITFUN
@c The identifier of integers.
@c @end deffn


@deffn {C Language Type Constant} VAL_32_BITS
The identifier of 32-bits integers.
@end deffn

@menu
* ffi values types other::      Other data types.
@end menu

@c page
@node ffi values types other
@subsubsection Other data types


@deftp {C Language Type} tfloat
An alias for a C language floating point number type; defined to be
@code{double}.
@end deftp


@deftp {C Language Type} field
The type of an object's field.
@end deftp

@c page
@node ffi values const
@subsection Constant values


@deftypevr {C Language Variable} value val_null
The @cnull{} value.
@end deftypevr


@deftypevr {C Language Variable} value val_true
@deftypevrx {C Language Variable} value val_false
The @true{} and @false{} values.
@end deftypevr

@c page
@node ffi values predicates
@subsection Type predicates


@deftypefn {C Macro} int val_is_null (value @var{v})
Check if a value is @cnull{}.
@end deftypefn


@deftypefn {C Macro} int val_is_int (value @var{v})
Check if a value is an integer.
@end deftypefn


@deftypefn {C Macro} int val_is_float (value @var{v})
Check if a value is a float.
@end deftypefn


@deftypefn {C Macro} int val_is_string (value @var{v})
Check if a value is a string.
@end deftypefn


@deftypefn {C Macro} int val_is_bool (value @var{v})
Check if a value is a boolean.
@end deftypefn


@deftypefn {C Macro} int val_is_array (value @var{v})
Check if a value is an array.
@end deftypefn


@deftypefn {C Macro} int val_is_object (value @var{v})
Check if a value is an object.
@end deftypefn


@deftypefn {C Macro} int val_is_function (value @var{v})
Check if a value is a function.
@end deftypefn


@deftypefn {C Macro} int val_is_abstract (value @var{v})
Check if a value is an abstract.
@end deftypefn


@deftypefn {C Macro} int val_is_kind (value @var{v}, value k)
Check if a value is an abstract of the kind @var{k}.
@end deftypefn


@deftypefn {C Macro} int val_is_number (value @var{v})
Check if a value is either an integer or a float.
@end deftypefn

@c page
@node ffi values assert
@subsection Asserting the types of values


Often, when we're writing primitives, we expect the arguments to be of
one given type.  So the first thing done in primitives is to check that
the types are correct and have an exception raised if not.  Neko
provides several functions for that.


@deftypefn {C Macro} void val_check (value @var{v}, @var{type})
If @var{v} is not of type @var{type}: call @cfunc{neko_error}.
@var{type} is used by the C preprocessor to compose the type check
function like this: @code{val_is_##@var{type}}.  Usage example:

@example
value v;

val_check(v, int);
@end example
@end deftypefn


@deftypefn {C Macro} void val_check_kind (value @var{v}, vkind @var{t})
If @var{v} is not an abstract value of kind @var{t}: call
@cfunc{neko_error}.
@end deftypefn


@deftypefn {C Macro} void val_check_function (value @var{v}, int @var{arity})
If @var{v} is not a function or the number of arguments it accepts is
not @var{arity}: call @cfunc{neko_error}.
@end deftypefn


@deftypefn {C Macro} val_type val_type (value @var{v})
Return the type identifier of the value.
@end deftypefn


@deftypefn {C Macro} {void *} neko_error (void)
Simply @code{return} the C @code{NULL} value.  This special value will
be catched by the virtual machine that will raise an exception.
@end deftypefn

@c page
@node ffi values access
@subsection Access functions


In order to use the following functions, we must be sure first that the
type of the value is correct by using the functions described in
@ref{ffi values assert}.  If we do not the behaviour is undefined.


@deftypefn {C Macro} int val_int (value @var{v})
Retrieve the integer stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_bool (value @var{v})
Retrieve the boolean stored into a value.
@end deftypefn


@deftypefn {C Macro} double val_float (value @var{v})
Retrieve the float stored into a value.
@end deftypefn


@deftypefn {C Macro} {char *} val_string (value @var{v})
Retrieve the string stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_strlen (value @var{v})
Retrieve the length of the string stored into a value.
@end deftypefn


@deffn {C Macro} val_number (value @var{v})
Retrieve the float or the integer stored into a value.
@end deffn


@deftypefn {C Macro} {value *} val_array_ptr (value @var{v})
Retrieve the array stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_array_size (value @var{v})
Retrieve the size of the array stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_fun_nargs (value @var{v})
Retrieve the arity (number of accepted arguments) of the function stored
into a value.
@end deftypefn


@deftypefn {C Macro} {void *} val_data (value @var{v})
Retrieve the data stored into an abstract value.
@end deftypefn


@deftypefn {C Macro} vkind val_kind (value @var{v})
Retrieve the kind of an abstract value.
@end deftypefn


@c page
@node ffi values alloc
@subsection Allocation functions


@deftypefn {C Macro} value alloc_int (int @var{i})
Return a value from a C @code{int}.
@end deftypefn


@deftypefn {C Macro} value alloc_bool (@var{b})
Return a value from a C boolean which can be anything; notice that
@code{0} is false and Neko @true{} either.
@end deftypefn


@deftypefn {C Function} value alloc_float (tfloat @var{f})
@deftypefnx {C Function} value neko_alloc_float (tfloat @var{f})
Return a value from a C float.
@end deftypefn


@deftypefn {C Function} value alloc_array (unsigned int @var{size})
@deftypefnx {C Function} value neko_alloc_array (unsigned int @var{size})
Create a Neko array of the given size.
@end deftypefn


@deftypefn {C Function} value alloc_string (const char * @var{str})
@deftypefnx {C Function} value neko_alloc_string (const char * @var{str})
Return a value from a C string; this function makes a copy of the memory
block referenced by @var{str}.
@end deftypefn


@deftypefn {C Function} value alloc_empty_string (unsigned int @var{size})
@deftypefnx {C Function} value neko_alloc_empty_string (unsigned int @var{size})
Return an uninitialised string value that can hold @var{size} bytes
@strong{without} the terminating @code{\0} byte.

Neko string values have the number of bytes stored in the data
structure, so there is no need to include a terminating @code{\0} byte.
@end deftypefn


@deftypefn {C Function} value copy_string (value @var{str}, unsigned int @var{size})
@deftypefnx {C Function} value neko_copy_string (value @var{str}, unsigned int @var{size})
Return a copy of the @var{size} first bytes of the string @var{str} as a
value.
@end deftypefn

@c page
@node ffi values print
@subsection Printing values


Using what we have learned from the Neko @api{}, we can now write a
function that prints any value:

@example
#include <stdio.h>
#include <neko.h>

value
print (value v)
@{
  if (val_is_null(v))
    printf("null");

  else if (val_is_int(v))
    printf("int : %d",val_int(v));

  else if (val_is_float(v))
    printf("float : %f",val_float(v));

  else if (val_is_bool(v))
    printf("bool : %s",val_bool(v)?"true":"false");

  else if (val_is_array(v))
    printf("array : size %d",val_array_size(v));

  else if (val_is_function(v))
    printf("function : %d args",val_fun_nargs(v));

  else if (val_is_string(v))
    printf("string : %s (%d bytes)",val_string(v),val_strlen(v));

  else if (val_is_object(v))
    printf("object");

  else if (val_is_abstract(v))
    printf("abstract of kind %X",val_kind(v));

  else
    printf("?????");

  return val_null;
@}

DEFINE_PRIM(print,1);
@end example

Please note that it's pretty inefficient since we are are doing a test
for each type, while we could simply dispatch using @code{val_type}:

@example
#include <stdio.h>
#include <neko.h>

value
print (value v)
@{
  switch (val_type(v))
  @{
    case VAL_NULL:
      printf("null");
      break;
    case VAL_INT:
      printf("int : %d",val_int(v));
      break;
    case VAL_FLOAT:
      printf("float : %f",val_float(v));
      break;
    case VAL_BOOL:
      printf("bool : %s",val_bool(v)?"true":"false");
      break;
    case VAL_ARRAY:
      printf("array : size %d",val_array_size(v));
      break;
    case VAL_FUNCTION:
      printf("function : %d args",val_fun_nargs(v));
      break;
    case VAL_STRING:
      printf("string : %s (%d bytes)",val_string(v),val_strlen(v));
      break;
    case VAL_OBJECT:
      printf("object");
      break;
    case VAL_ABSTRACT:
      printf("abstract of kind %X",val_kind(v));
      break;
    default:
      printf("?????");
      break;
  @}
  return val_null;
@}

DEFINE_PRIM(print,1);
@end example

The default case is not supposed to happen unless there is some bug into
a C code function that doesn't return a correct value (or memory
corruption).  Since the @nvm{} is safe in regard to memory manipulation,
such problem can only arise from a buggy C primitive.

@strong{*FIXME*} This is not true because not all the @code{VAL_} values
are in this function.

@c page
@node ffi values buffers
@subsection Buffers


The printing of a value is a little more complex than what is described
in @ref{ffi values print}.  In particular, in case of objects we must
call the @code{__string} method to retrieve a representation of the
object if available.

In order to easily construct strings of mixed constant C strings and
values converted to strings, the Neko @api{} has buffers.  A buffer is
@strong{not} a @code{value}, so we cannot return it from C primitives,
but it is garbage collected so we don't have to free them after usage.


@deftypefn {C Function} buffer alloc_buffer (const char * @var{str})
@deftypefnx {C Function} buffer neko_alloc_buffer (const char * @var{str})
Allocate a fresh buffer with a string @var{str} or no data if @var{str}
is @code{NULL}.
@end deftypefn


@deftypefn {C Function} void val_buffer (buffer @var{b}, value @var{v})
@deftypefnx {C Function} void neko_val_buffer (buffer @var{b}, value @var{v})
Add a string representation of the value @var{v} to the buffer @var{b}.

@strong{Warning} Be careful with this function: its name has the format
@code{val_*} but it does @strong{not} retrieve a buffer from a
@code{value}.
@end deftypefn


@deftypefn {C Function} void buffer_append (buffer @var{b}, const char * @var{str})
@deftypefnx {C Function} void neko_buffer_append (buffer @var{b}, const char * @var{str})
Append the C string @var{str} at the end of the buffer @var{b}.
@end deftypefn


@deftypefn {C Function} void buffer_append_sub (buffer @var{b}, const char * @var{str}, int_val @var{n})
@deftypefnx {C Function} void neko_buffer_append_sub (buffer @var{b}, const char * @var{str}, int_val @var{n})
Append the @var{n} first bytes of the C string @var{str} at the end of
the buffer @var{b}.@footnote{Neko type @code{int_val} is here to mean
a 64bit integer on 64--bits system.  The reason is that at several
places we might want to use a difference between two @code{char *} in
order to measure the length:

@example
char * begin = "aaaaxbbb";
char * end   = strstr(begin,"x");

buffer_append_sub(b, begin, end - begin);
@end example

@noindent
the problem is that differences between pointers are not of type
@code{int}; same for @cfunc{strlen}.

Neko type @code{int_val} is defined to be @code{intptr_t}, which for
the @gnu{} C Library is defined to be @code{long int}; see the file
@file{stdint.h}.}
@end deftypefn


@deftypefn {C Function} value buffer_to_string (buffer @var{b})
@deftypefnx {C Function} value neko_buffer_to_string (buffer @var{b})
Allocate and return a string @code{value} holding the content of a
buffer.
@end deftypefn


Example of buffer usage:

@example
value
print2 (value @var{v1}, value @var{v2})
@{
  buffer b = alloc_buffer("Values");

  buffer_append(b," = ");
  val_buffer(b,v1);
  buffer_append_sub(b,",xxx",1); // only first byte, so ','
  val_buffer(b,v2);
  return buffer_to_string(b);
@}
@end example

@c page
@node ffi objects
@section Working with objects


Objects in Neko are also values, and there are several functions in the
Neko @api{} to access and modify object's fields.

@menu
* ffi objects api::             Objects @api{}.
* ffi objects methods::         Object methods.
@end menu

@c page
@node ffi objects api
@subsection Objects @api{}


@deftypefn {C Function} value alloc_object (value @var{o})
@deftypefnx {C Function} value neko_alloc_object (value @var{o})
Return a copy of the object @var{o}, or an empty object if @var{o} is
@code{NULL} or @code{val_null}.
@end deftypefn


@deftypefn {C Macro} int val_is_object (value @var{v})
Check that the value is an object.
@end deftypefn


@deftypefn {C Function} field val_id (const char * @var{field_name})
@deftypefnx {C Function} field neko_val_id (const char * @var{field_name})
In the Neko specification, it is told that object tables do not directly
contain field names but hashed identifiers of the field names.  This
function returns a field identifier from a field name.
@end deftypefn


@deftypefn {C Function} value val_field (value @var{o}, field @var{f})
@deftypefnx {C Function} value neko_val_field (value @var{o}, field @var{f})
Access an object field for reading; return @code{val_null} if the field
is not found in @var{o}.  @var{f} is the field identifier returned by
@cfunc{val_id}.
@end deftypefn


@deftypefn {C Function} value val_field_name (field @var{f})
@deftypefnx {C Function} value neko_val_field_name (field @var{f})
Return the field name as value from its identifier; return
@code{val_null} if the field is not found.
@end deftypefn


@deftypefn {C Function} void alloc_field (value @var{o}, field @var{f}, value @var{v})
@deftypefnx {C Function} void neko_alloc_field (value @var{o}, field @var{f}, value @var{v})
Set or replace the value of the field @var{f}, in the object @var{o},
with the value @var{v}.
@end deftypefn


@deftypefn {C Function} value val_this (void)
@deftypefnx {C Function} value neko_val_this (void)
Return the value of @code{this} in the current context.
@end deftypefn


@deftypefn {C Function} void val_iter_fields (value @var{o}, void * @var{f} (value, field, void *), void * @var{p})
@deftypefnx {C Function} void neko_val_iter_fields (value @var{o}, void * @var{f} (value, field, void *), void * @var{p})
Iterate over the fields of @var{o} invoking the function @var{f} for
each of them; the arguments to @var{f} are: the object @var{o} itself,
the field's identifier and the custom data pointer @var{p} which can
reference anything we want.
@end deftypefn


Here's a small example that allocates an object with two fields @code{x}
and @code{y} from two values:

@example
#include <neko.h>

value
make_point (value x, value y)
@{
  value         o;

  val_check(x,number);
  val_check(y,number);

  o = alloc_object(NULL);
  alloc_field(o,val_id("x"),x);
  alloc_field(o,val_id("y"),y);
  return o;
@}

DEFINE_PRIM(make_point, 2);
@end example

@c page
@node ffi objects methods
@subsection Object methods


If we want to add a method @code{__string} to the object in order to
display its content when printed, we can do the following:

@example
#include <neko.h>

value
point_to_string (void)
@{
  value  o = neko_val_this();
  value  x, y;
  buffer b;

  val_check(o,object);

  x = neko_val_field(o, neko_val_id("x"));
  y = neko_val_field(o, neko_val_id("y"))

  b = neko_alloc_buffer("Point : ");
  neko_val_buffer(b, x);
  neko_buffer_append(b, " , ");
  neko_val_buffer(b, y);
  return neko_buffer_to_string(b);
@}

value
make_point (value x, value y)
@{
  value f = neko_alloc_function(point_to_string, 0,
                                "point_to_string");
  value o;

  ...
  neko_alloc_field(o, neko_val_id("%%__string%%"), f);
  return o;
@}
@end example

Let's see what is done here:

@itemize
@item
in @cfunc{make_point} we are setting the field @code{__string} of
the object @code{o} to a function value allocated with
@cfunc{alloc_function}, which takes 3 parameters: the address of the
C function, the number of arguments, and a name for the function that
will help for debugging and errors location;
@item
in @cfunc{point_to_string} we are first retrieving
@cfunc{neko_val_this} which is the current @code{this} value; since
it might not be an object, we test it first before accessing its fields
@code{x} and @code{y}; then we want to construct, as object's
representation, the string @code{Point : x , y} with the values of
@code{x} and @code{y}, we're using a buffer for this.
@end itemize

@c page
@node ffi callbacks
@section Function callbacks


At some point, we might need to call back a value function or an object
method.


@deftypefn {C Function} void val_callEx (value @var{vthis}, value @var{f}, value * @var{args}, int @var{nargs}, value * @var{exc})
@deftypefnx {C Function} void neko_val_callEx (value @var{vthis}, value @var{f}, value * @var{args}, int @var{nargs}, value * @var{exc})
This is the most general callback function; all the other callback
functions are only some easier ways of making calls to
@cfunc{val_callEx}.  Arguments' descriptions follows:

@table @var
@item vthis
a value specifying which will be the @code{this} value inside the call;

@item f
the function we want to call;

@item args
a C array of values storing the arguments, in left--to--right order;

@item nargs
the number of arguments stored into @var{args};

@item exc
a value pointer to store an exception if it is raised in a subcall; if
@code{NULL}, exceptions will not be catched and they will go through the
function calling @cfunc{val_callEx}.
@end table

The function @var{f} must have either a variable number of arguments
(@code{VAR_ARGS}) or the exact @var{nargs} number of arguments, or an
exception will be raised.

If the call is successful, the value returned by @var{f} is returned by
@cfunc{val_callEx}.
@end deftypefn


@deftypefn {C Function} value val_call0 (value @var{f})
@deftypefnx {C Function} value val_call1 (value @var{f}, value @var{arg1})
@deftypefnx {C Function} value val_call2 (value @var{f}, value @var{arg1}, value @var{arg2})
@deftypefnx {C Function} value val_call3 (value @var{f}, value @var{arg1}, value @var{arg2}, value @var{arg3})
Call the function @var{f} with 0, 1, 2 or 3 arguments.
@end deftypefn


@deftypefn {C Function} value val_callN (value @var{f}, value * @var{args}, int @var{nargs})
Call the function @var{f} with the arguments in the array @var{args}.
@end deftypefn


In the following functions, @var{f} is a field, so it's not the value of
the method but the hash of the field name.  The method is fetched from
the object table before the call is performed.


@deftypefn {C Function} value val_ocall0 (value @var{o}, field @var{f})
@deftypefnx {C Function} value val_ocall1 (value @var{o}, field @var{f}, value @var{arg1})
@deftypefnx {C Function} value val_ocall2 (value @var{o}, field @var{f}, value @var{arg1}, value @var{arg2})
Call the method @var{f} from the object @var{o} with 0, 1, 2 arguments.
@end deftypefn


@deftypefn {C Function} value val_ocallN (value @var{o}, field @var{f}, value * @var{args}, int @var{nargs})
Call the method @var{f} from the object @var{o} with the arguments in
@var{args}.
@end deftypefn


This is a small example that enable the C code to callback a Neko
function.  First we define a primitive so that we can register our
callback:

@example
#include <neko.h>

value * function_storage = NULL;

static value
set_handler (value f)
@{
  val_check_function(f,1); // checks that f has 1 argument

  if( function_storage == NULL )
    function_storage = alloc_root(1);
  *function_storage = f;
  return val_null;
@}

DEFINE_PRIM(set_handler,1);
@end example

Since the function is a value, we have to store it into a place that can
be accessed by the garbage collector; this is why we allocate a
@code{function_storage} with @cfunc{alloc_root}.  The
@cfunc{alloc_root} parameter is the number of values that can be
stored in the allocated pointer.

Once the callback is set, we can call it from C by using the following
code:

@example
// call the function with the Neko string "Hello"
value ret = val_call1(*function_storage, alloc_string("Hello"));
// ... handle the ret value
@end example


@c page
@node ffi abstracts
@section Abstracts and kinds


Most of the time, when we have to write an interface from Neko to a C
library, we get some pointer to some mallocated memory.  We can't safely
return this value to the Neko program for the following reasons:

@itemize
@item
it is not a value so it does not match the NekoVM memory model;

@item
it might then crash the program when accessed inappropriately;

@item
even it if was a value, it would have to be free explicitly;

@item
we cannot distinguish the types between two C pointers.
@end itemize

For all of these reasons, we need to be able to store a C pointer into
an abstract Neko value and mark it with some type information called
``kind''.  The kind of an abstract value is its type, and the data of an
abstract value is the corresponding C pointer.

Please note that the @vm{} itself cannot access either the kind or the
data of an abstract value; for the @vm{}, an abstract is an opaque value
without any structure.  It's up to our C primitives to manipulate the
abstract.  This ensures also that if we don't make any mistake in our C
primitives, the whole program will be kept memory--safe.

First, we need to define a kind somewhere in our C file, using the macro
@code{DEFINE_KIND} from the Neko @api{}.  By convention, we often prefix
the kind with @code{k_} but it's not mandatory:

@example
#include <neko.h>

DEFINE_KIND(k_mykind);
@end example

Now that we have a kind, we can create an abstract value of this kind
using the @cfunc{alloc_abstract} Neko @api{} function:

@example
value
create (void)
@{
  void *ptr = ...

  return alloc_abstract(k_mykind,ptr);
@}
@end example

It is possible to store another value in the data part of an abstract,
since it will still be checked by the garbage collector.

When we get back a value into one of our primitives, we can check if
it's an abstract value using @cfunc{val_is_abstract} then check its
kind using the @cfunc{val_is_kind} @api{} function and then access
its data using the @cfunc{val_data} @api{} function:

@example
value
dosomething (value v)
@{
  if((! val_is_abstract(v)) || (! val_is_kind(v,k_mykind)))
    neko_error();

  do_something_in_C(val_data(v));
  return val_true;
@}
@end example

Instead of writing these checks all the time, we can use the
@cfunc{val_check_kind} macro which is more convenient:

@example
value
dosomething( value v )
@{
  val_check_kind(v,k_mykind);

  do_something_in_C(val_data(v));
  return val_true;
@}
@end example

In some cases, we might want the user to free the pointer stored into an
abstract explicitly.  At this time, we can set its kind to @code{NULL}
so it is not accessible anymore:

@example
value
destroy (value v)
@{
  val_check_kind(v,k_mykind);

  free_data(val_data(v));
  val_kind(v) = NULL;
  return val_true;
@}
@end example

In other cases, we might want the pointer data to be free when the
abstract value becomes garbage--collected.  In that case we have to bind
a finalise function on it.  Please note that it might take some time
between the value becomes unreachable and the finalise function is called.

@example
void
finalize (value v)
@{
  free_data(val_data(v));
@}

value
create (void)
@{
  void *ptr = ....
  value v   = alloc_abstract(k_mykind, ptr);

  val_gc(v,finalize);
  return v;
@}
@end example

We can remove the finalise function from an abstract value by calling
@code{val_gc(v,NULL)}.


@c page
@node ffi varargs
@section Variable arguments functions


If we want to pass more than five arguments, or a variable number of
arguments, in a single Neko--to--C function call, we can use the
@cfunc{DEFINE_PRIM_MULT} macro:

@example
value
myprim (value *args, int nargs)
@{
  ...
@}

DEFINE_PRIM_MULT(myprim);
@end example

@noindent
then, pass @code{-1} as the number of arguments to @builtin{loadprim}.

@c page
@node ffi int32
@section Using 32 bits integers


As explained before, Neko integers are only signed 31 bits.  While this
is enough for most of the cases, there are times where we want to use
the full 32 bits.  It was then added a common @code{int32} abstract
type.

We can use @cfunc{val_is_int32} to check that the value is either an
integer or an @code{int32}.  And @cfunc{val_int32} will return the
corresponding integer.  If we want to check that the value is exactly an
@code{int32}, then we can use @code{val_is_kind(i,k_in32)}.

To create an @code{int32} value, we can use @cfunc{alloc_int32}.
Please note that unlike @cfunc{alloc_int}a which is a fast macro,
@cfunc{alloc_int32} allocate some memory to store the integer so it
is slower.

In the case most of our integers are using only 31 bits but we still
want to be able to use the full 32 bits, we can use the
@cfunc{alloc_best_int} macro that will use either
@cfunc{alloc_int} or @cfunc{alloc_int32} depending on the needed
bits.  Use then the @code{val_check(i,int32)} and @code{val_is_int32(v)}
macros in order to accept both kind of integers.

@c page
@node ffi memory
@section Managing memory


When we're working with abstracts, we might want to allocate
garbage--collected memory so we don't have to add finalise functions for our
data (finalise functions are more expensive than garbage--collected memory).


@deftypefn {C Function} {char *} alloc (unsigned int @var{nbytes})
@deftypefnx {C Function} {char *} neko_alloc (unsigned int @var{nbytes})
Return a pointer capable of storing up to @var{nbytes}.  So it's
equivalent to @code{malloc(nbytes)} but the memory will be automatically
collected when unreachable from the @vm{}.  Please note that C static
values are not reachable by the @vm{}.

The memory allocated with @cfunc{alloc} will be scanned by the
garbage collector so we can store values and other allocated pointers
into it.  As long as our pointer is reachable these values will also be
reachable so they will not be collected.
@end deftypefn


@deftypefn {C Function} {char *} alloc_private (unsigned int @var{nbytes})
@deftypefnx {C Function} {char *} neko_alloc_private (unsigned int @var{nbytes})
If we want to allocate big chunks of memory and we're sure they will
not contain any value (strings for example) we can this function that
will return @var{nbytes} of memory but that will not be scanned by the
garbage collector.
@end deftypefn


In some cases, we might need to store some value into a static variable.
First, we have to be sure of what we're doing: since the Neko @vm{} can
run in several threads, we need to protect the accesses to this value to
ensure that our library will work when used simultaneously by multiple
threads.  Second, since the statics are not reachable by the garbage
collector, we have to allocate a root value.

A root value is a pointer that can store several values and that will
always be scanned by the garbage collector.  Since it will never be
garbage--collected we can store it anywhere.  However we'll have to free
it explicitly.


@deftypefn {C Function} {value *} alloc_root (unsigned int @var{nvals})
@deftypefnx {C Function} {value *} neko_alloc_root (unsigned int @var{nvals})
Allocate a root value array, capable of storing up to @var{nvals}
values.
@end deftypefn


@deftypefn {C Function} void free_root (value * @var{root})
Free a previously allocated root value array.
@end deftypefn


Try to avoid the use of roots and static values as much as possible.
Always store data into abstract values if possible.

@c page
@node ffi misc
@section Misc @api{} functions


@deftypefn {C Function} int val_compare (value @var{a}, value @var{b})
@deftypefnx {C Function} int neko_val_compare (value @var{a}, value @var{b})
Compare two values according to Neko specification.  Return an integer
that will be @code{0} if @code{a = b}, @code{-1} if @code{a < b},
@code{1} if @code{a > b} or @code{invalid_comparison} if @var{a} and
@var{b} can't be compared.
@end deftypefn


@defmac invalid_comparison
A constant value returned by @cfunc{val_compare} when the two
operands of a comparison cannot be compared.
@end defmac


@deftypefn {C Function} value val_print (value @var{v})
@deftypefnx {C Function} value neko_val_print (value @var{v})
Print the value to the defined output of the virtual machine.
@end deftypefn


@deftypefn {C Function} int val_hash (value @var{v})
@deftypefnx {C Function} int neko_val_hash (value @var{v})
Hash any value into a positive integer.
@end deftypefn


@deftypefn {C Function} void val_throw (value @var{v})
@deftypefnx {C Function} void val_rethrow (value @var{v})
Throw the value @var{v} as an exception.
@end deftypefn


@deftypefn {C Function} void failure (value @var{msg})
@deftypefnx {C Function} void bfailure (buffer @var{msg})
Throw a failure exception using a constant C string as error message.
This is a convenient way of handling errors in our primitives, since the
exception will contain our error message as well as the C file name and
the line where the error occurred.
@end deftypefn


@c page
@node embedding
@chapter Embedding the @vm{}


The Neko Virtual Machine and its C @ffi{} are packaged into a single
shared library (@file{libneko.so} on Unix systems and @code{neko.dll} on
Windows).  Along with the garbage collector library (@file{libgc} on
Unix and @file{gc.dll} on Windows) it is all we need to add to our
application in order to be able to run a Neko program.

@menu
* embedding example::           Example of embedding the @vm{}.
* embedding threads::           Multithreading.
@end menu

@c page
@node embedding example
@section Example of embedding the @vm{}


Here's a code snippet that initialises a @vm{} and runs a Neko module
inside it, then it accesses some data:

@example
#include <stdio.h>
#include <neko_vm.h>

value
load (char * file)
@{
  value loader;
  value args[2];
  value exc = NULL;
  value ret;

  loader  = neko_default_loader(NULL, 0);
  args[0] = alloc_string(file);
  args[1] = loader;
  ret     = val_callEx(loader,
                       val_field(loader, val_id("loadmodule")),
                       args, 2, &exc);

  if (NULL != exc)
    @{
      buffer b = alloc_buffer(NULL);

      val_buffer(b,exc);
      printf("Uncaught exception - %s\n", val_string(buffer_to_string(b)));
      return NULL;
    @}
  return ret;
@}

void
execute (value module)
@{
  value x = val_field(module, val_id("x"));
  value f = val_field(module, val_id("f"));
  value ret;

  if (! val_is_int(x))
    return;
  printf("x = %d\n",val_int(x));
  if (! val_is_function(f,1))
    return;
  ret = val_call1(f,x);
  if (! val_is_int(ret))
    return;
  printf("f(x) = %d\n",val_int(ret));
@}

int
main (int argc, char *argv[])
@{
  neko_vm *     vm;
  value         module;

  neko_global_init(NULL);
  vm = neko_vm_alloc(NULL);
  neko_vm_select(vm);

  module = load("mymodule.n");
  if (NULL == module)
    @{
      printf("Failed to load module !\n");
      return -1;
    @}
  execute(module);

  neko_global_free();
  return 0;
@}
@end example

We can use it to load the following @file{mymodule.neko} file after
compilation:

@example
$exports.x = 33;
$exports.f = function(x) @{ return x * 2 + 1; @}
@end example

@c page
@node embedding threads
@section Multithreading


@nvm{} supports multithreading and multiple @vm{} instances; it means
that we can run some Neko code into a multithreaded program, as long as
we respect the following guidelines:

@enumerate
@item
we can allocate a @vm{} with @cfunc{neko_vm_alloc}; the @vm{} holds
the Neko stack and registers;

@item
a given thread can allocate several @vm{};

@item
only one @vm{} is ``active'' for a thread at a given time; we can choose
the local thread current @vm{} by calling @code{neko_vm_select(neko_vm
*vm)};

@item
we can retrieve the selected @vm{} for the current thread by calling
@cfunc{neko_vm_current};

@item
a single @vm{} should not be used to execute code on several threads at
the same time;

@item
a Neko Module can be used by several @vm{}/Threads at the same time.
@end enumerate

Using some non--basic data structures such as loaders, hash tables or
abstracts values (files, regular expressions@dots{}) from multiple
threads can results in crashes.  Try to always keep these data
structures in the thread that allocated them in the first place.

@c page
@node nxml
@chapter Neko in @axml{} format


Neko sources syntax is easy to read but can sometimes be difficult to
generate; also, it does not permit embedding file and line numbers
informations.  For example: if we convert a file in our language,
@file{MyFile.mylang}, into a file in Neko language, @file{myfile.neko},
we would like to get error traces in terms of position in the original
@file{MyFile.mylang} file.

For these reasons, an extension of the neko syntax is proposed: it is
called @nxml{}.  This is not a different format: we can easily mix
@nxml{} and Neko sources together.  We can put some @nxml{} expressions
in Neko sources and some Neko sources into an @nxml{} document.  @nxml{}
is based on @axml{} and it represents a Neko Abstract Syntax Tree
(@acronym{AST}).

@c ------------------------------------------------------------

@subsubheading @nxml{} nodes

In order to use the @nxml{} syntax we start with @code{<nxml>} and
finish with @code{</nxml>}; all @nxml{} nodes inside are Neko
expressions.  @nxml{} blocks are like Neko blocks; for example:
@code{<nxml></nxml>} is the equivalent of the empty Neko block @code{@{
@}}.

Examples of other nodes follow:

@table @code
@item <i v="3"/>
the literal integer 3;

@item <f v="1.5"/>
the literal float @code{1.5};

@item <s v="a string"/>
the literal string @code{a string};

@item <v v="id"/>
the identifier @code{id} (includes special identifiers such as @cnull{},
@true{}, @false{} and @code{this});

@item <b>e1 e2 e3...</b>
a block having several subexpressions;

@item <p>e</p>
parentheses around a subexpression;

@item <g v="field">e</g>
field access of a subexpression @code{(e).field};

@item <c>e0 e1 e2 e3...</c>
call of @code{e0(e1,e2,e3...)};

@item <a>e1 e2</a>
array access @code{e1[e2]};

@item <var><v v="x">e</v><v v="y"/></var>
local variable declaration, equivalent to @code{var x = e, y};

@item <while>e1 e2</while>
@code{while} loop: @code{while e1 e2};

@item <do>e1 e2</do>
@code{do...while} loop: @code{do e1 while e2};

@item <if>e0 e1</if>
equivalent of @code{if e0 e1};

@item <if>e0 e1 e2</if>
equivalent of @code{if e0 e1 else e2};

@item <o v="*">e1 e2</o>
a binary operation such as @code{e1 * e2};

@item <try v="exc">e1 e2</try>
a @code{try..catch} block: @code{try e1 catch exc e2};

@item <function v="x:y:z">e</function>
a function declaration such as @code{function(x,y,z) e};

@item <return/>
the @code{return} statement without expression;

@item <return>e</return>
@code{return} of an expression value;

@item <break/>
the @code{break} statement without expression;

@item <break>e</break>
@code{break} with an expression value;

@item <continue/>
the @code{continue} statement;

@item <next>e1 e2</next>
a way to tie two expressions together, such as @code{e1;e2};

@item <label v="here"/>
the @code{goto} label @code{here:};

@item <switch>e0 <case>e1 e2</case> <case>e1 e2</case> <default>edef</default></switch>
a @code{switch} with several cases and an optional default;

@item <object><v v="f0"><i v="42"/></v><v v="f1"><s v="foo"/></v></object>
an object literal, equivalent to the neko code @code{@{ f0 => 42, f1 =>
"foo" @}};

@item <neko>....</neko>
some neko source, can be embedded into a @code{<!CDATA[[...]]>} section.
@end table

For example, if we want to represent the Fibonacci function in @nxml{}:

@example
fib = function(n) @{
    if( n <= 1 ) 1 else fib(n-1)+fib(n-2)
@}

<o v="=">
  <v v="fib"/>
  <function v="n">
    <if>
      <o v="<="><v v="n"/><i v="1"/></o>
      <i v="1"/>
      <o v="+">
        <c><v v="fib"/><o v="-"><v v="n"/><i v="1"/></o></c>
        <c><v v="fib"/><o v="-"><v v="n"/><i v="2"/></o></c>
      </o>
    </if>
  </function>
</o>
@end example

@c ------------------------------------------------------------

@subsubheading File position

The additional attribute @code{p} can be placed on every @nxml{} node in
order to specify from which original file and line the expression is
generated.  For example @code{<i v="33" p="myfile.l:478"/>} is the
integer @code{33} referenced in @code{myfile.l} at line @code{478}.

When encountered, such position is stored and remains valid for all @nxml{}
nodes.  For example:

@example
<nxml>
  <i v="33" p="myfile.l:478"/>
  <i v="34"/>
</nxml>
@end example

@noindent
is listing two integers from @code{myfile.l}, both at line @code{478}.

If we do not specify the file name in the @code{p} attribute, it's
considered to be a number of lines skipped since the last @code{p}
information.  For example:

@example
<nxml>
  <i v="33" p="myfile.l:478"/>
  <i v="34" p="2"/>
</nxml>
@end example

@noindent
is listing two integers from @code{myfile.l}, the first is @code{33} at
line @code{478} and the second is @code{34} at line @code{480} (478 +
2).

@c ------------------------------------------------------------

@subsubheading @nxml{} to Neko

There is a @nxml{} to Neko generator which is available using the
@command{nekoc} compiler.  Simply run @code{nekoc myfile.neko}
containing Neko/@nxml{} syntax, it will create a @file{myfile2.neko}
that will only contain Neko source code.

There is no Neko to @nxml{} generator right now, although it should be
possible to write one very easily.

@c page
@node lib
@chapter Neko library


@menu
* lib loading::                 Loading the standard library.

The standard library

* lib list::                    The list custom type.
* lib int32::                   Using 32 bits integers.
* lib buffer::                  Buffers.
* lib date::                    Date.
* lib file::                    File.
* lib math::                    Mathematical functions.
* lib md5::                     MD5.
* lib memory::                  Memory.
* lib module::                  Modules.
* lib process::                 Process.
* lib random::                  Pseudo--random numbers generation.
* lib serialise::               Serialisation.
* lib socket::                  @acronym{TCP} and @acronym{UDP} sockets.
* lib string::                  Additional string functions.
* lib sys::                     Interaction with the operating system.
* lib thread::                  Creating and managing system threads.
* lib utf8::                    Handling @acronym{UTF8} strings.
* lib xml::                     The standard event--driven @axml{} parser.
* lib misc::                    Miscellaneous functions.

Additionally libraries

* lib cgi::                     Apache access when running @modneko{}.
* lib mysql::                   Connecting to and using MySQL databases.
* lib sqlite::                  Connecting to and using Sqlite databases.
* lib regexp::                  Regular expressions using the @acronym{PCRE} engine.
* lib gui::                     Core native user interface support.
* lib zlib::                    Compression library.
@end menu

@c page
@node lib loading
@section Loading the standard library


The following is an example module that can be used to load the Neko
standard library.  The module must be compiled and installed in a
reachable directory, for example, under the name @file{stdlib.n}.

The suggested way to use it is to adopt @code{std} as name of the table
of imported functions; so we should do:

@example
var std = $loader.loadmodule("stdlib", $loader);
@end example

@noindent
and then call the library functions like this:

@example
var current_data = std.date_now();
@end example

@noindent
using the @code{std.} prefix.

@c ------------------------------------------------------------

@example
// stdlib.neko --
//
// Load the Neko standard library.

var stdload = function (name, arity) @{
  return $loader.loadprim("std" + "@@" + name, arity);
@}

$exports.buffer_new             = stdload("buffer_new",         0);
$exports.buffer_add             = stdload("buffer_add",         2);
$exports.buffer_add_char        = stdload("buffer_add_char",    2);
$exports.buffer_add_sub         = stdload("buffer_add_sub",     4);
$exports.buffer_string          = stdload("buffer_string",      1);
$exports.buffer_reset           = stdload("buffer_reset",       1);

$exports.date_now               = stdload("date_now",           0);
$exports.date_new               = stdload("date_new",           1);
$exports.date_format            = stdload("date_format",        2);
$exports.date_set_hour          = stdload("date_set_hour",      4);
$exports.date_set_day           = stdload("date_set_day",       4);
$exports.date_get_day           = stdload("date_get_day",       1);
$exports.date_get_hour          = stdload("date_get_hour",      1);
$exports.date_get_tz            = stdload("date_get_tz",        0);

$exports.file_open              = stdload("file_open",          2);
$exports.file_close             = stdload("file_close",         1);
$exports.file_name              = stdload("file_name",          1);
$exports.file_write             = stdload("file_write",         4);
$exports.file_read              = stdload("file_read",          4);
$exports.file_write_char        = stdload("file_write_char",    2);
$exports.file_read_char         = stdload("file_read_char",     1);
$exports.file_seek              = stdload("file_seek",          3);
$exports.file_tell              = stdload("file_tell",          1);
$exports.file_eof               = stdload("file_eof",           1);
$exports.file_flush             = stdload("file_flush",         1);
$exports.file_contents          = stdload("file_contents",      1);
$exports.file_stdin             = stdload("file_stdin",         0);
$exports.file_stdout            = stdload("file_stdout",        0);
$exports.file_stderr            = stdload("file_stderr",        0);

$exports.math_atan2             = stdload("math_atan2",         2);
$exports.math_pow               = stdload("math_pow",           2);
$exports.math_abs               = stdload("math_abs",           1);
$exports.math_ceil              = stdload("math_ceil",          1);
$exports.math_floor             = stdload("math_floor",         1);
$exports.math_round             = stdload("math_round",         1);
$exports.math_pi                = stdload("math_pi",            0);
$exports.math_sqrt              = stdload("math_sqrt",          1);
$exports.math_atan              = stdload("math_atan",          1);
$exports.math_cos               = stdload("math_cos",           1);
$exports.math_sin               = stdload("math_sin",           1);
$exports.math_tan               = stdload("math_tan",           1);
$exports.math_log               = stdload("math_log",           1);
$exports.math_exp               = stdload("math_exp",           1);
$exports.math_acos              = stdload("math_acos",          1);
$exports.math_asin              = stdload("math_asin",          1);

$exports.make_md5               = stdload("make_md5",           1);

$exports.mem_size               = stdload("mem_size",           1);

$exports.module_read            = stdload("module_read",        2);
$exports.module_read_path       = stdload("module_read_path",   3);
$exports.module_exec            = stdload("module_exec",        1);
$exports.module_name            = stdload("module_name",        1);
$exports.module_exports         = stdload("module_exports",     1);
$exports.module_loader          = stdload("module_loader",      1);
$exports.module_nglobals        = stdload("module_nglobals",    1);
$exports.module_global_get      = stdload("module_global_get",  2);
$exports.module_global_set      = stdload("module_global_set",  3);
$exports.module_code_size       = stdload("module_code_size",   1);

$exports.process_run            = stdload("process_run",         2);
$exports.process_stdout_read    = stdload("process_stdout_read", 4);
$exports.process_stderr_read    = stdload("process_stderr_read", 4);
$exports.process_stdin_write    = stdload("process_stdin_write", 4);
$exports.process_stdin_close    = stdload("process_stdin_close", 1);
$exports.process_exit           = stdload("process_exit",        1);
$exports.process_pid            = stdload("process_pid",         1);
$exports.process_close          = stdload("process_close",       1);

$exports.random_new             = stdload("random_new",         0);
$exports.random_set_seed        = stdload("random_set_seed",    2);
$exports.random_int             = stdload("random_int",         2);
$exports.random_float           = stdload("random_float",       1);

$exports.serialize              = stdload("serialize",          1);
$exports.unserialize            = stdload("unserialize",        2);

$exports.socket_init            = stdload("socket_init",        0);
$exports.socket_new             = stdload("socket_new",         1);
$exports.socket_close           = stdload("socket_close",       1);
$exports.socket_send_char       = stdload("socket_send_char",   2);
$exports.socket_send            = stdload("socket_send",        4);
$exports.socket_recv            = stdload("socket_recv",        4);
$exports.socket_recv_char       = stdload("socket_recv_char",   1);
$exports.socket_write           = stdload("socket_write",       2);
$exports.socket_read            = stdload("socket_read",        1);
$exports.host_resolve           = stdload("host_resolve",       1);
$exports.host_to_string         = stdload("host_to_string",     1);
$exports.host_reverse           = stdload("host_reverse",       1);
$exports.host_local             = stdload("host_local",         0);
$exports.socket_connect         = stdload("socket_connect",     3);
$exports.socket_listen          = stdload("socket_listen",      2);
$exports.socket_select          = stdload("socket_select",      4);
$exports.socket_bind            = stdload("socket_bind",        3);
$exports.socket_accept          = stdload("socket_accept",      1);
$exports.socket_peer            = stdload("socket_peer",        1);
$exports.socket_host            = stdload("socket_host",        1);
$exports.socket_set_timeout     = stdload("socket_set_timeout", 2);
$exports.socket_shutdown        = stdload("socket_shutdown",    3);
$exports.socket_set_blocking    = stdload("socket_set_blocking",2);
$exports.socket_poll_alloc      = stdload("socket_poll_alloc",  1);
$exports.socket_poll_prepare    = stdload("socket_poll_prepare",3);
$exports.socket_poll_events     = stdload("socket_poll_events", 2);
$exports.socket_poll            = stdload("socket_poll",        3);

$exports.string_split           = stdload("string_split",       2);
$exports.sprintf                = stdload("sprintf",            2);
$exports.url_encode             = stdload("url_encode",         1);
$exports.url_decode             = stdload("url_decode",         1);
$exports.base_encode            = stdload("base_encode",        2);
$exports.base_decode            = stdload("base_decode",        2);

$exports.get_env                = stdload("get_env",            1);
$exports.put_env                = stdload("put_env",            2);
$exports.sys_env                = stdload("sys_env",            0);
$exports.sys_sleep              = stdload("sys_sleep",          1);
$exports.set_time_locale        = stdload("set_time_locale",    1);
$exports.sys_time               = stdload("sys_time",           0);
$exports.sys_cpu_time           = stdload("sys_cpu_time",       0);
$exports.get_cwd                = stdload("get_cwd",            0);
$exports.set_cwd                = stdload("set_cwd",            1);
$exports.sys_string             = stdload("sys_string",         0);
$exports.sys_is64               = stdload("sys_is64",           0);
$exports.sys_command            = stdload("sys_command",        1);
$exports.sys_exit               = stdload("sys_exit",           1);
$exports.sys_exists             = stdload("sys_exists",         1);
$exports.file_exists            = stdload("file_exists",        1);
$exports.file_delete            = stdload("file_delete",        1);
$exports.sys_rename             = stdload("sys_rename",         2);
$exports.sys_stat               = stdload("sys_stat",           1);
$exports.sys_file_type          = stdload("sys_file_type",      1);
$exports.sys_create_dir         = stdload("sys_create_dir",     2);
$exports.sys_remove_dir         = stdload("sys_remove_dir",     1);
$exports.sys_read_dir           = stdload("sys_read_dir",       1);
$exports.file_full_path         = stdload("file_full_path",     1);
$exports.sys_exe_path           = stdload("sys_exe_path",       0);
$exports.sys_getch              = stdload("sys_getch",          1);
$exports.sys_get_pid            = stdload("sys_get_pid",        0);

$exports.thread_create          = stdload("thread_create",      2);
$exports.thread_current         = stdload("thread_current",     0);
$exports.thread_send            = stdload("thread_send",        2);
$exports.thread_read_message    = stdload("thread_read_message",1);
$exports.lock_create            = stdload("lock_create",        0);
$exports.lock_release           = stdload("lock_release",       1);
$exports.lock_wait              = stdload("lock_wait",          2);
$exports.tls_create             = stdload("tls_create",         0);
$exports.tls_set                = stdload("tls_set",            2);
$exports.tls_get                = stdload("tls_get",            1);
$exports.mutex_create           = stdload("mutex_create",       0);
$exports.mutex_acquire          = stdload("mutex_acquire",      1);
$exports.mutex_try              = stdload("mutex_try",          1);
$exports.mutex_release          = stdload("mutex_release",      1);
$exports.deque_create           = stdload("deque_create",       0);
$exports.deque_add              = stdload("deque_add",          2);
$exports.deque_push             = stdload("deque_push",         2);
$exports.deque_pop              = stdload("deque_pop",          2);

$exports.utf8_buf_alloc         = stdload("utf8_buf_alloc",     1);
$exports.utf8_buf_add           = stdload("utf8_buf_add",       2);
$exports.utf8_buf_content       = stdload("utf8_buf_content",   1);
$exports.utf8_buf_length        = stdload("utf8_buf_length",    1);
$exports.utf8_buf_size          = stdload("utf8_buf_size",      1);
$exports.utf8_validate          = stdload("utf8_validate",      1);
$exports.utf8_length            = stdload("utf8_length",        1);
$exports.utf8_sub               = stdload("utf8_sub",           3);
$exports.utf8_get               = stdload("utf8_get",           2);
$exports.utf8_iter              = stdload("utf8_iter",          2);
$exports.utf8_compare           = stdload("utf8_compare",       2);

$exports.parse_xml              = stdload("parse_xml",          2);

$exports.float_bytes            = stdload("float_bytes",        2);
$exports.double_bytes           = stdload("double_bytes",       2);
$exports.float_of_bytes         = stdload("float_of_bytes",     2);
$exports.double_of_bytes        = stdload("double_of_bytes",    2);
$exports.run_gc                 = stdload("run_gc",             1);
$exports.gc_stats               = stdload("gc_stats",           0);
$exports.enable_jit             = stdload("enable_jit",         1);
$exports.test                   = stdload("test",               0);
$exports.print_redirect         = stdload("print_redirect",     1);

$exports.int32_new              = stdload("int32_new",          1);
$exports.int32_to_int           = stdload("int32_to_int",       1);
$exports.int32_to_float         = stdload("int32_to_float",     1);
$exports.int32_compare          = stdload("int32_compare",      2);
$exports.int32_add              = stdload("int32_add",          2);
$exports.int32_sub              = stdload("int32_sub",          2);
$exports.int32_mul              = stdload("int32_mul",          2);
$exports.int32_div              = stdload("int32_div",          2);
$exports.int32_neg              = stdload("int32_neg",          1);
$exports.int32_ushr             = stdload("int32_ushr",         2);
$exports.int32_shl              = stdload("int32_shl",          2);
$exports.int32_shr              = stdload("int32_shr",          2);
$exports.int32_mod              = stdload("int32_mod",          2);
$exports.int32_complement       = stdload("int32_complement",   1);
$exports.int32_or               = stdload("int32_or",           2);
$exports.int32_and              = stdload("int32_and",          2);
$exports.int32_xor              = stdload("int32_xor",          2);
$exports.int32_address          = stdload("int32_address",      1);

/// end of file
@end example

@c page
@node lib list
@section The list custom type


@cindex @code{#list} custom type

Sometimes the Neko library makes use of a custom list type to organise a
sequence of values; a @code{#list} is a tree of nested arrays organised
like a Lisp list:

@example
  -------     -------     -------
 | 0 | 1 |-->| 0 | 1 |-->| 0 | 1 |--> [null]
  -------     -------     -------
   |           |           |
   v           v           v
[value]     [value]     [value]
@end example

@noindent
to build such a tree of arrays we can use code like this:

@example
var the_list = $array("one",
                      $array("two",
                             $array("three", null)));
@end example

@noindent
and to extract values we do:

@example
the_list[0];            // evaluate to: "one"
the_list[1][0];         // evaluate to: "two"
the_list[1][1][0];      // evaluate to: "three"
the_list[1][1][1];      // evaluate to: null
@end example

@noindent
and to iterate over the values:

@example
var ell = the_list;

while (null != ell)
  @{
    $print("the value is: " + ell[0] + "\n");
    ell = ell[1];
  @}
@end example

@ref{examples list} for a Neko module that manipulates lists.

@c page
@node lib int32
@section Using 32 bits integers


Int32 is an abstract type that can be used to store the full 32 bits of
an integer.  The type @code{'int32} means that the value is a real
int32.  The type @code{#int32} means @code{(int | 'int32)}.

@menu
* lib int32 make::              Constructors.
* lib int32 conversion::        Conversion.
* lib int32 comparison::        Comparison.
* lib int32 arithmetics::       Arithmetic operations.
* lib int32 bitwise::           Bitwise operations.
* lib int32 misc::              Miscellaneous operations.
@end menu


@c page
@node lib int32 make
@subsection Constructors


@deftypefn {Neko Function} 'int32 int32_new (@var{value} : #int32 | float)
Allocate an int32 from any integer or float.
@end deftypefn

@c page
@node lib int32 conversion
@subsection Conversion


@deftypefn {Neko Function} int int32_to_int (@var{value} : #int32)
Return the integer value if it can be represented using 31 bits.
Otherwise an error is raised.
@end deftypefn


@deftypefn {Neko Function} float int32_to_float (@var{value} : #int32)
Return a float representing the integer.
@end deftypefn

@c page
@node lib int32 comparison
@subsection Comparison


@deftypefn {Neko Function} int int32_compare (@var{a} : #int32, @var{b} : #int32)
Compare two integers.
@end deftypefn

@c page
@node lib int32 arithmetics
@subsection Arithmetic operations


@deftypefn {Neko Function} #int32 int32_add (@var{a} : #int32, @var{b} : #int32)
Add two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_sub (@var{a} : #int32, @var{b} : #int32)
Subtract two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_mul (@var{a} : #int32, @var{b} : #int32)
Multiply two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_div (@var{a} : #int32, @var{b} : #int32)
Divide two integers.  An error is raised on division by zero.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_neg (@var{value} : #int32)
Return the negative value of an integer.
@end deftypefn

@c page
@node lib int32 bitwise
@subsection Bitwise operations


@deftypefn {Neko Function} #int32 int32_ushr (@var{value} : #int32, @var{amount} : #int32)
Perform unsigned bits right shifting upon @var{value}.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_shl (@var{value} : #int32, @var{amount} : #int32)
Perform bit left shifting.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_shr (@var{value} : #int32, @var{amound} : #int32)
Perform bit right shifting.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_mod (@var{value} : #int32, @var{base} : #int32)
Return the modulo of one integer by the other.  An error is raised if
@var{base} is zero.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_complement (@var{value} : #int32)
Return the bitwise one--complement integer of @var{value}.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_or (@var{a} : #int32, @var{b} : #int32)
Return the bitwise OR between two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_and (@var{a} : #int32, @var{b} : #int32)
Return the bitwise AND between two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_xor (@var{a} : #int32, @var{b} : #int32)
Return the bitwise XOR of two integers.
@end deftypefn

@c page
@node lib int32 misc
@subsection Miscellaneous operations


@deftypefn {Neko Function} #int32 int32_address (@var{value} : any)
Return the address of the value.  The address should not be considered
constant.  It is not unique either unless we are sure we are running on
a 32 bits platform.
@end deftypefn

@c page
@node lib buffer
@section Buffers


A buffer can store any value as a string and will only allocate the
total needed space when requested.  It makes a copy of each value when
stored so modifying them later is not a problem.


@deftypefn {Neko Function} 'buffer buffer_new (void)
Allocate a new empty buffer.
@end deftypefn


@deftypefn {Neko Function} void buffer_add (@var{b} : 'buffer, @var{value} : any)
Convert @var{value} to a string then append the string to @var{b}.
@end deftypefn


@deftypefn {Neko Function} void buffer_add_char (@var{b} : 'buffer, @var{c} : int)
Add a single char to a buffer; it is an error if @var{c} is not in the
@code{[0, 255]} range.
@end deftypefn


@deftypefn {Neko Function} void buffer_add_sub (@var{b} : 'buffer, @var{string} : string, @var{position} : int, @var{number_of_chars} : int)
Append to the buffer @var{number_of_chars} from @var{string}, starting
at @var{position}.  An error occurs if out of string bounds.
@end deftypefn


@deftypefn {Neko Function} string buffer_string (@var{b} : 'buffer)
Build and return a string holding the buffer contents.
@end deftypefn


@deftypefn {Neko Function} void buffer_reset (@var{b} : 'buffer)
Clean the buffer contents, leaving it empty.
@end deftypefn

@c page
@node lib date
@section Date


The date module uses standard C functions in order to manipulate 32 bits
integers.  Dates are represented as the number of seconds elapsed since
1st January 1970.


@deftypefn {Neko Function} 'int32 date_now (void)
Return current date and time.
@end deftypefn


@deftypefn {Neko Function} 'int32 date_new (@var{s} : string?)
Parse a date formatted string.  The following formats are accepted:

@table @code
@item null
return current date and time;

@item YYYY-MM-DD HH:MM:SS
full date and time;

@item YYYY-MM-DD
date only (time will be set to midnight);

@item HH:MM:SS
this represents an elapsed time; it will be corrected with timezone so
we can subtract it from a date.
@end table
@end deftypefn


@deftypefn {Neko Function} string date_format (@var{date} : 'int32, @var{fmt} : string?)
Format a date using the C language function @cfunc{strftime}.  If
@var{fmt} is @cnull{} then the default format is used.
@end deftypefn


@deftypefn {Neko Function} 'int32 date_set_hour (@var{date} : 'int32, @var{hours} : int, @var{minutes} : int, @var{seconds} : int)
Change the time of a date.  Return the modified date.
@end deftypefn


@deftypefn {Neko Function} 'int32 date_set_day (@var{date} 'int32, @var{year} : int, @var{month} : int, @var{day} : int)
Change the day of a date.  Return the modified date.
@end deftypefn


@deftypefn {Neko Function} {@{ y => int, m => int, d => int@}} date_get_day (@var{date} : 'int32)
Return the year month and day of a date stored in an object.  Object
fields are: @code{y} holds the year as string, @code{m} holds the month
as string, @code{d} holds the day as string.
@end deftypefn


@deftypefn {Neko Function} {@{ h => int, m => int, s => int@}} date_get_hour (@var{date} : 'int32)
Return the hour minutes and seconds of a date stored in an object.
Object fields are: @code{h} holds the hour as string, @code{m} holds the
minutes as string, @code{s} holds the seconds as string.
@end deftypefn


@deftypefn {Neko Function} int date_get_tz (void)
Return the local Timezone (in seconds).
@end deftypefn

@c page
@node lib file
@section File


The file @api{} can be used for different kind of file I/O; it is mostly
based upon the standard C language functions.


@deftypefn {Neko Function} 'file file_stdin (void)
@deftypefnx {Neko Function} 'file file_stdout (void)
@deftypefnx {Neko Function} 'file file_stderr (void)
Return a standard channel.
@end deftypefn


@menu
* lib file open::               Opening and closing files.
* lib file io::                 Input/output upon files.
* lib file seek::               Setting the position.
@end menu

@c page
@node lib file open
@subsection Opening and closing files


@deftypefn {Neko Function} 'file file_open (@var{pathname} : string, @var{access} : string)
Call @cfunc{fopen} with the given @var{pathname} and access rights.
Return the opened file or throw an exception if an error occurs.
@end deftypefn


@deftypefn {Neko Function} void file_close (@var{f} : 'file)
Close a file.  Any operation on @var{f} file will fail after
@function{file_close} has been applied to it.
@end deftypefn


@deftypefn {Neko Function} string file_name (@var{f} : 'file)
Return the name of the file associated to @var{f}.
@end deftypefn


@deftypefn {Neko Function} int file_write (@var{f} : 'file, @var{s} : string, @var{p} : int, @var{l} : int)
Write up to @var{l} chars from the string @var{s} starting at position
@var{p}.  Return the number of chars written, which will be zero or a
positive number.
@end deftypefn

@c page
@node lib file io
@subsection Input/output upon files


@deftypefn {Neko Function} int file_read (@var{f} : 'file, @var{s} : string, @var{p} : int, @var{l} : int)
Read up to @var{l} chars into the string @var{s} starting at position
@var{p}.  Return the number of chars read, which will be a positive
number or @code{0} if @code{@var{l} == 0}.
@end deftypefn


@deftypefn {Neko Function} void file_write_char (@var{f} : 'file, @var{c} : int)
Write the char @var{c}.  It is an error if @var{c} is outside of the
range @code{[0, 255]}.
@end deftypefn


@deftypefn {Neko Function} int file_read_char (@var{f} : 'file)
Read a char from the file.  Throw an exception if an error occurs.
@end deftypefn


@deftypefn {Neko Function} void file_flush (@var{f} : 'file)
Flush the file buffer.
@end deftypefn


@deftypefn {Neko Function} string file_contents (@var{pathname} : string)
Read the content of the file and return it.
@end deftypefn

@c page
@node lib file seek
@subsection Setting the position


@deftypefn {Neko Function} void file_seek (@var{f} : 'file, @var{pos} : int, @var{mode} : int)
Use @cfunc{fseek} to move the file position.
@end deftypefn


@deftypefn {Neko Function} int file_tell (@var{f} : 'file)
Return the current position in the file.
@end deftypefn


@deftypefn {Neko Function} bool file_eof (@var{f} : 'file)
Tell if we have reached the end of the file.
@end deftypefn

@c page
@node lib math
@section Mathematical functions


@deftypefn {Neko Function} float math_atan2 (@var{y} : number, @var{x} : number)
Return the @cfunc{atan2} calculus.
@end deftypefn


@deftypefn {Neko Function} float math_pow (@var{n} : number, @var{exp} : number)
Return power calculus.
@end deftypefn


@deftypefn {Neko Function} number math_abs (@var{n} : number)
Return absolute value of a number.
@end deftypefn


@deftypefn {Neko Function} int math_ceil (@var{n} : number)
Return rounded--up integer.
@end deftypefn


@deftypefn {Neko Function} int math_floor (@var{n} : number)
Return rounded--down integer.
@end deftypefn


@deftypefn {Neko Function} int math_round (@var{n} : number)
Return nearest integer.
@end deftypefn


@deftypefn {Neko Function} float math_pi (void)
Return the value of PI.
@end deftypefn


@deftypefn {Neko Function} float math_sqrt (@var{n} : number)
Return the square root.
@end deftypefn


@deftypefn {Neko Function} float math_atan (@var{n} : number)
Return the arctangent.
@end deftypefn


@deftypefn {Neko Function} float math_cos (@var{n} : number)
Return the cosine.
@end deftypefn


@deftypefn {Neko Function} float math_sin (@var{n} : number)
Return the sine.
@end deftypefn


@deftypefn {Neko Function} float math_tan (@var{n} : number)
Return the tangent.
@end deftypefn


@deftypefn {Neko Function} float math_log (@var{n} : number)
Return the logarithm.
@end deftypefn


@deftypefn {Neko Function} float math_exp (@var{n} : number)
Return the exponent.
@end deftypefn


@deftypefn {Neko Function} float math_acos (@var{n} : number)
Return the arccosine.
@end deftypefn


@deftypefn {Neko Function} float math_asin (@var{n} : number)
Return the arcsine.
@end deftypefn

@c page
@node lib md5
@section MD5


@deftypefn {Neko Function} string make_md5 (@var{value} : any)
Build a MD5 digest (16 bytes binary string) from any value.
@end deftypefn

@c page
@node lib memory
@section Memory


An @api{} for memory manipulation and statistics.


@deftypefn {Neko Function} int mem_size (@var{value} : any)
Calculate the quite precise amount of @vm{} memory reachable from this
value.
@end deftypefn

@c page
@node lib module
@section Modules


An @api{} for reflexion of Neko bytecode modules.


@deftypefn {C Language Function} 'module module_read (@var{fread} : function:3, @var{loader} : object)
Read a module using the selected read function and the specified loader.
The reader function has Neko signature:

@example
int @var{fread} (@var{b} : string, @var{position} : int, @var{number_of_bytes} : int)
@end example

@noindent
where: @var{b} is a string in which to store loaded code, @var{position}
is the offset from the start of the string to which append the code,
@var{number_of_bytes} is the maximum size of code to append.

The return value of @var{fread} must be the number of bytes appended to
the string or @code{-1} if an error occurred; it is an error to return a
value equal to or grater than @var{number_of_bytes}.

@var{fread} can be invoked any number of times to load chunk after chunk
of bytecode; when all the available bytecode has been read: @var{fread}
should just return @code{0} to signal the end of code event.
@end deftypefn


@deftypefn {Neko Function} 'module module_read_path (@var{path} : string #list, @var{module_name} : string, @var{loader} : object)
Read a module using the specified search path and loader.
@var{module_name} can be a platform specific file pathname or the file
name with or without the @code{.n} extension.

If the attempt to open @var{module_name} directly fails: @var{path} is
used to build a set of alternative file pathnames.  @var{path} must be a
list of strings representing file pathname prefixes: they will be
prepended to @var{module_name} as is; this means that if the elements of
@var{path} are directory pathnames, they must end with a separator
(@code{/} on Unix) or the prepending operation will build an invalid
pathname.  Example:

@example
var the_path = $array("/usr/lib/neko/",
                      $array("/usr/local/lib/neko/", null);
var mod = module_read_path(the_path, "the_module", $loader);
@end example

@noindent
will search the file @file{the_module.n} in the following locations:

@example
./the_module.n
/usr/lib/neko/the_module.n
/usr/local/lib/neko/the_module.n
@end example

@ref{lib list} for an explanation of what a @code{#list} is.
@end deftypefn


@deftypefn {Neko Function} any module_exec (@var{m} : 'module)
Execute the module in the current @vm{}; return the calculated value,
that is the result of evaluating the last expression in the module.

If the module just defines functions to be exported: the return value
will be the last defined function, which, usually, is useless.
@end deftypefn


@deftypefn {Neko Function} string module_name (@var{m} : 'module)
Return the module name: actually this is the file pathname that was used
to load the file (directory part included).
@end deftypefn


@deftypefn {Neko Function} object module_exports (@var{m} : 'module)
Return the module export table: the value bound to @builtin{exports} in
the module top level scope.
@end deftypefn


@deftypefn {Neko Function} object module_loader (@var{m} : 'module)
Return the module loader: the value bound to @builtin{$loader} in the
module top level scope, which was selected when loading the module.
@end deftypefn


@deftypefn {Neko Function} int module_nglobals (@var{m} : 'module)
Return the number of globals for this module.
@end deftypefn


@deftypefn {Neko Function} any module_global_get (@var{m} : 'module, @var{n} : int)
Get the nth global.
@end deftypefn


@deftypefn {Neko Function} void module_global_set (@var{m} : 'module, @var{n} : int, @var{value} : any)
Set the nth global.
@end deftypefn


@deftypefn {Neko Function} int module_code_size (@var{m} : 'module)
Return the code size of the module.
@end deftypefn

@c page
@node lib process
@section Process


An @api{} for starting and communication with sub processes.


@deftypefn {Neko Function} 'process process_run (@var{cmd} : string, @var{args} : string array)
Start a process using a command and the specified arguments.  Example:

@example
var p = process_run("ls", $amake("-l", "-R"));
@end example

@var{cmd} must be the pathname of the executable file or the name of the
executable file; in the latter case the environment is examined to find
the executable on the system.  On Unix like systems the C functions
@cfunc{fork} and @cfunc{execvp} are used, on Windows systems
@cfunc{CreateProcess} is used.

If there are no arguments we have to use @code{$amake(0)} as value of
@var{args}.
@end deftypefn


@deftypefn {Neko Function} int process_stdout_read (@var{p} : 'process, @var{buf} : string, @var{position} : int, @var{number_of_bytes} : int)
Read up to @var{number_of_bytes} from the standard output channel of
@var{p} and append them to @var{buf} starting at @var{position}.  Return
the number of bytes read this way.  Raise an exception if this process'
@code{stdout} is closed and no more data is available for reading.
@end deftypefn


@deftypefn {Neko Function} int process_stderr_read (@var{p} : 'process, @var{buf} : string, @var{position} : int, @var{number_of_bytes} : int)
Read up to @var{number_of_bytes} from the standard error channel of
@var{p} and append them to @var{buf} starting at @var{position}.  Return
the number of bytes read this way.  Raise an exception if this process'
@code{stderr} is closed and no more data is available for reading.
@end deftypefn


@deftypefn {Neko Function} int process_stdin_write (@var{p} : 'process, @var{buf} : string, @var{position} : int, @var{number_of_bytes} : int)
Write up to @var{number_of_bytes} bytes from @var{buf} starting at
@var{position} to the process' @code{stdin}.  Return the number of bytes
written this way.  Raise an exception if this process' @code{stdin} is
closed.
@end deftypefn


@deftypefn {Neko Function} void process_stdin_close (@var{p} : 'process)
Close the process standard input.
@end deftypefn


@deftypefn {Neko Function} int process_exit (@var{p} : 'process)
Wait until the process terminates, then returns its exit code.
@end deftypefn


@deftypefn {Neko Function} int process_pid (@var{p} : 'process)
Returns the process' id.
@end deftypefn


@deftypefn {Neko Function} void process_close (@var{p} : 'process)
Close the process' input/output channels and terminate the process.
@end deftypefn

@c page
@node lib random
@section Pseudo--random numbers generation


@deftypefn {Neko Function} 'random random_new (void)
Create a new random with random seed.
@end deftypefn


@deftypefn {Neko Function} void random_set_seed (@var{r} : 'random, @var{seed} : int)
Set the generator seed.
@end deftypefn


@deftypefn {Neko Function} int random_int (@var{r} : 'random, @var{max} : int)
Return a random integer modulo @var{max}.
@end deftypefn


@deftypefn {Neko Function} float random_float (@var{r} : 'random)
Return a random float.
@end deftypefn

@c page
@node lib serialise
@section Serialisation


@findex __serialize

Serialisation can be used in order to store permanently some runtime
value.  Serialisation of all values is possible, except @emph{abstracts}
with the special cases of @code{'int32} and @code{'hash} which are
handled by Neko.

Serialisation of bytecode functions is possible, but it will result in a
runtime exception when deserialising if the function offset in the
bytecode has changed.

We can define the @function{__serialize} method of an object.  When this
method is found, while serialising the object, it is called with no
arguments and its return value will be serialised.  The name of the
module the method is declared in will also be serialised.  When
deserialising, the module is loaded and its @function{__unserialize}
exported function is called with the value that was returned by
@function{__serialize}.


@deftypefn {Neko Function} string serialize (@var{value} : any)
Serialise any value recursively.
@end deftypefn


@deftypefn {Neko Function} any unserialize (@var{s} : string, @var{loader} : object)
Deserialise a stored value.  Need a loader to look for modules if some
bytecode functions have been serialised.
@end deftypefn

@c page
@node lib socket
@section @acronym{TCP} and @acronym{UDP} sockets


@menu
* lib socket creating::         Creating sockets.
* lib socket client::           Connecting as client.
* lib socket server::           Setting up a server.
* lib socket io::               Sending and receiving.
* lib socket select::           Selecting events on sockets.
* lib socket poll::             Polling events on sockets.
* lib socket resolver::         Resolving addresses.
* lib socket misc::             Miscellaneous functions.
@end menu

@c page
@node lib socket creating
@subsection Creating sockets


@deftypefn {Neko Function} void socket_init (void)
Initialise the socket @api{}.  Must be called at least once per process
before using any socket or host function.
@end deftypefn


@deftypefn {Neko Function} 'socket socket_new (@var{udp} : bool)
Create a new socket, @acronym{TCP} or @acronym{UDP}.  @acronym{UDP} is
selected if @var{udp} is @true{}.
@end deftypefn


@deftypefn {Neko Function} void socket_close (@var{sock} : 'socket)
Close a socket.  Any subsequent operation on this socket will fail.
@end deftypefn


@deftypefn {Neko Function} void socket_shutdown (@var{sock} : 'socket, @var{read} : bool, @var{write} : bool)
Prevent the socket from further reading or writing or both.
@end deftypefn

@c page
@node lib socket client
@subsection Connecting as client


@deftypefn {Neko Function} void socket_connect (@var{sock} : 'socket, @var{host} : 'int32, @var{port} : int)
Connect the socket the given @var{host} and @var{port}.
@end deftypefn


Example of @acronym{TCP} connection to @code{localhost:8080}:

@example
socket_init();

var sock = socket_new(false);
var ip   = host_resolve("localhost");
var port = 8080;

socket_connect(client, ip, port);

... // read/write data using 'sock'

socket_close(sock);
@end example

@c page
@node lib socket server
@subsection Setting up a server


@deftypefn {Neko Function} void socket_bind (@var{sock} : 'socket, @var{host} : 'int32, @var{port} : int)
Bind the socket for server usage on the given host and port.
@end deftypefn


@deftypefn {Neko Function} void socket_listen (@var{sock} : 'socket, @var{n} : int)
Listen for a number of connections.
@end deftypefn


@deftypefn {Neko Function} 'socket socket_accept (@var{sock} : 'socket)
Accept an incoming connection request.
@end deftypefn


Example of @acronym{TCP} listening and accepting on @code{localhost:8080}:

@example
socket_init();

var server = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);

var sock = socket_accept(server);

socket_set_timeout(client, 1);

... // read/write data using 'sock'

socket_close(sock);
socket_close(server);
@end example

@c page
@node lib socket io
@subsection Sending and receiving


@subsubsection Characters


@deftypefn {Neko Function} void socket_send_char (@var{sock} : 'socket, @var{c} : int)
Send a character over a connected socket; return @true{} is success.
@var{c} must be in the range @code{[0, 255]}.
@end deftypefn


@deftypefn {Neko Function} int socket_recv_char (@var{sock} : 'socket)
Read and return a single char from a connected socket.
@end deftypefn


Example of exchanging a character through @code{localhost:8080}:

@example
socket_init();
var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

socket_send_char(sock, 65);
socket_recv_char(client);   // return 65

socket_close(sock);
socket_close(server);
socket_close(client);
@end example


@c ------------------------------------------------------------

@subsubsection Data using buffers


@noindent
The following functions send and receive data from strings used as
buffers.


@deftypefn {Neko Function} int socket_send (@var{sock} : 'socket, @var{buf} : string, @var{pos} : int, @var{len} : int)
Send up to @var{len} bytes from @var{buf} starting at @var{pos} over a
connected socket.  Return the number of sent bytes.
@end deftypefn


@deftypefn {Neko Function} int socket_recv (@var{sock} 'socket, @var{buf} : string, @var{pos} : int, @var{len} : int)
Read up to @var{len} bytes from @var{buf} starting at @var{pos} from a
connected socket.  Return the number of received bytes.
@end deftypefn


Example of exchanging a data through @code{localhost:8080}:

@example
socket_init();
var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var out = "ciao";
var in  = $smake(4);
socket_send(sock,   out, 0, 4);  // return 4
socket_recv(client, in,  0, 4);  // return 4

// here 'in' holds "ciao"

socket_close(sock);
socket_close(server);
socket_close(client);
@end example


@c ------------------------------------------------------------

@subsubsection Whole strings


@deftypefn {Neko Function} void socket_write (@var{sock} : 'socket, @var{s} : string)
Send the whole content of a string over a connected socket.  Return
@true{} if success.
@end deftypefn


@deftypefn {Neko Function} string socket_read (@var{sock} : 'socket)
Read and return the whole content of a the data available from a socket
until the connection is closed by the foreign host.  If the socket
hasn't been closed by the other side, the function might block.
@end deftypefn


Example of exchanging a string through @code{localhost:8080}:

@example
socket_init();
var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

socket_write(sock, "hello");
socket_close(sock);
socket_read(client);  // return "hello"

socket_close(server);
socket_close(client);
@end example

@c ------------------------------------------------------------

@subsubsection Configuration


@deftypefn {Neko Function} void socket_set_blocking (@var{sock} : 'socket, @var{b} : bool)
Turn on/off the socket blocking mode.
@end deftypefn


@deftypefn {Neko Function} void socket_set_timeout (@var{sock} : 'socket, @var{timeout} : number?)
Set the socket send and recv timeout in seconds to the given value (or
@cnull{} for blocking).
@end deftypefn

@c page
@node lib socket select
@subsection Selecting events on sockets


@deftypefn {Neko Function} {'socket array? array} socket_select (@var{read} : 'socket array?, @var{write} : 'socket array?, @var{others} : 'socket array?, @var{timeout} : number?)
Perform the @cfunc{select} operation.  Arguments description:

@table @var
@item read
must be an array of sockets for which we want to know if data is
available for reading;

@item write
must be an array of sockets for which we want to know if they are ready
to send data; usually a socket @strong{is} ready to send data;

@item others
must be an array of sockets for which we want to know if an exception
was detected;

@item timeout
is in seconds or @cnull{} if infinite.
@end table

If we are not interested in events of a kind: we must set @var{read},
@var{write} or @var{others} to @cnull{}, @strong{not} to the empty array.

The return value is an array of 3 elements, one for each kind of event:
the element with index @code{0} for read--ready sockets; the element
with index @code{1} for write--ready sockets; the element with index
@code{2} or sockets under exception condition.

The elements of the returned array can be:

@table @asis
@item @cnull{}
if @cnull{} was used as parameter for a kind, then @cnull{} is stored in
the returned array for that kind;

@item @code{'socket array}
the array of sockets that are ready for an event; this array can be
empty if no sockets are ready.
@end table
@end deftypefn


Example of exchanging a character through @code{localhost:8080}:

@example
socket_init();

var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var them = socket_select($array(sock, client), $array(sock, client), null, 1);

// Result of select:
//
// no read-ready sockets:               0 == $asize(them[0])
// 2 write-ready sockets:               2 == $asize(them[1])
// the first write-ready is 'sock':     sock   == them[1][0]
// the second write-ready is 'client':  client == them[1][1]
// no exception sockets:                null == them[2]

socket_send_char(sock, 65);

var them = socket_select($array(sock, client), $array(sock, client), null, 1);

// Result of select:
//
// 1 read-ready socket:                 1 == $asize(them[0])
// the read-ready socket is 'client':   client == them[0][0]
// 2 write-ready sockets:               2 == $asize(them[1])
// the first write-ready is 'sock':     sock   == them[1][0]
// the second write-ready is 'client':  client == them[1][1]
// no exception sockets:                null == them[2]

socket_recv_char(client);

var them = socket_select($array(sock, client), $array(sock, client), null, 1);

// Result of select:
//
// no read-ready sockets:               0 == $asize(them[0])
// 2 write-ready sockets:               2 == $asize(them[1])
// the first write-ready is 'sock':     sock   == them[1][0]
// the second write-ready is 'client':  client == them[1][1]
// no exception sockets:                null == them[2]

socket_close(sock);
socket_close(server);
socket_close(client);
@end example

@c page
@node lib socket poll
@subsection Polling events on sockets


@menu
* lib socket poll events ex::   Example of polling for events.
* lib socket poll read ex::     Example of polling for available data.
@end menu


@deftypefn {Neko Function} 'poll socket_poll_alloc (@var{n} : int)
Allocate memory to perform polling on a given number of sockets.
@end deftypefn


@deftypefn {Neko Function} {int array array} socket_poll_prepare (@var{p} : 'poll, @var{read} : 'socket array, @var{write} : 'socket array)
Prepare a @code{'poll} for scanning events on sets of sockets.  Return
an array of two elements: the first will hold informations about sockets
that have data available for reading; the second will hold informations
about sockets that are ready to accept data for writing.

Both the elements of the returned array are arrays of integers in which,
initially, all the elements are set to @code{-1}.  These arrays are
logically linked to the @var{p} object and the @var{read} and
@var{write} arrays.  See @function{socket_poll_events} for more.
@end deftypefn


@deftypefn {Neko Function} void socket_poll_events (@var{p} : 'poll, @var{timeout} : float)
Poll for read/write events the sockets previously registered into
@var{p} by @function{socket_poll_prepare}, then update the array
previously returned by the same function.

Sockets that are read or write ready are selected by this function by
storing the associated indexes in the @var{read} and @var{write}
arguments to @function{socket_poll_prepare} in the arrays returned by
the same function, and terminating the sequence with a @code{-1}.

Example of polling 4 sockets for both reading and writing:

@example
socket_init();

var socks = $array(socket_new(false), socket_new(false),
                   socket_new(false), socket_new(false));

var ip   = host_resolve("localhost");
var port = 8080;
socket_connect(socks[0], ip, port);
socket_connect(socks[1], ip, port);
socket_connect(socks[2], ip, port);
socket_connect(socks[2], ip, port);

var poll = socket_poll_alloc(4 + 4);
var them = socket_poll_prepare(poll, socks, socks);

socket_poll_events(poll, 0.1);

// Ready for reading:
var i = 0;
while (-1 != them[0][i]) @{
  var readable = socks[them[0][i]];
  ... // read data from 'readable'
@}

// Ready for writing:
var i = 0;
while (-1 != them[1][i]) @{
  var writable = socks[them[1][i]];
  ... // write data into 'writable'
@}
@end example
@end deftypefn


@deftypefn {Neko Function} {'socket array} socket_poll (@var{sock} : 'socket array, @var{p} : 'poll, @var{timeout} : float)
Poll the sockets in @var{sock} for data available for reading; return an
array holding the read ready sockets.  @var{timeout} selects an upper
limit on the time for which @function{socket_poll} will block; the limit
is given in seconds and can be less than zero.  @strong{Warning} Beware
of not setting @var{timeout} to a negative value.

This is similar to @function{socket_select} except that
@function{socket_select} is limited to a given number of simultaneous
sockets to check.
@end deftypefn

@c page
@node lib socket poll events ex
@subsubsection Example of polling for events


Example of exchanging a character through @code{localhost:8080} using
the complex @function{socket_poll_events} interface:

@example
socket_init();

var count_number_of_ready_sockets = function (flags, idx) @{
  var i = 0;
  while (-1 != flags[idx][i]) i += 1;
  return i;
@};
var count_number_of_read_ready_sockets = function (flags) @{
  return count_number_of_ready_sockets(flags, 0);
@}
var count_number_of_write_ready_sockets = function (flags) @{
  return count_number_of_ready_sockets(flags, 1);
@}

var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var sockets = $array(sock, client);
var poll    = socket_poll_alloc(2 * $asize(sockets));
var flags   = socket_poll_prepare(poll, sockets, sockets);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      0 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// end of readable sequence:     -1     == flags[0][0]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_send_char(sock, 65);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      1 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// client socket is read-ready:  client == sockets[flags[0][0]]
// end of readable sequence:     -1     == flags[0][1]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_recv_char(client);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      0 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// end of readable sequence:     -1     == flags[0][0]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_send_char(client, 65);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      1 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// server socket is read-ready:  sock   == sockets[flags[0][0]]
// end of readable sequence:     -1     == flags[0][1]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

dotest.test("server socket recv char", 65, socket_recv_char(sock));

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      0 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// end of readable sequence:     -1     == flags[0][0]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_close(sock);
socket_close(server);
socket_close(client);
@end example

@c page
@node lib socket poll read ex
@subsubsection Example of polling for available data


Example of exchanging a character through @code{localhost:8080} using
the simple @function{socket_poll} interface:

@example
socket_init();

var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var poll = socket_poll_alloc(2);
var them = socket_poll($array(sock, client), poll, 0.1);

// Polling result:
//
// no sockets read ready:       0 == $asize(them)

socket_send_char(sock, 65));

var them = socket_poll($array(sock, client), poll, 0.1);

// Polling result:
//
// 1 socket read ready:         1 == $asize(them)
// read ready socket is client: client == them[0]

socket_recv_char(client);

var them = socket_poll($array(sock, client), poll, 0.1);

// Polling result:
//
// no sockets read ready:       0 == $asize(them)

socket_close(sock);
socket_close(server);
socket_close(client);
@end example


@c page
@node lib socket resolver
@subsection Resolving addresses


@deftypefn {Neko Function} 'int32 host_resolve (@var{url} : string)
Resolve the given host string into an @acronym{IP} address.
@end deftypefn


@deftypefn {Neko Function} string host_to_string (@var{address} : 'int32)
Return a string representation of an @acronym{IP} address.  Example:

@example
$print(host_to_string(host_resolve("localhost")));
  // prints "127.0.0.1"
@end example
@end deftypefn


@deftypefn {Neko Function} string host_reverse (@var{address} : 'int32)
Reverse the @acronym{DNS} of the given @acronym{IP} address.  Example:

@example
$print(host_reverse(host_resolve("localhost")));
  // prints "localhost"
@end example
@end deftypefn


@deftypefn {Neko Function} string host_local (void)
Return the local host name.
@end deftypefn

@c page
@node lib socket misc
@subsection Miscellaneous functions


@deftypefn {Neko Function} #address socket_host (@var{sock} : 'socket)
Return the socket local address composed of an (host,port) array.
Example:

@example
var sock = ...;
var host = socket_host(sock);

$print("hostname: " + host_to_string(host[0])
       + ", port: " + host[1] + "\n");
@end example
@end deftypefn


@deftypefn {Neko Function} #address socket_peer (@var{sock} : 'socket)
Return the socket connected peer @code{#address} composed of an
(host,port) array.  Example:

@example
var sock = ...;
var host = socket_peer(sock);

$print("hostname: " + host_to_string(host[0])
       + ", port: " + host[1] + "\n");
@end example
@end deftypefn

@c page
@node lib string
@section Additional string functions


@deftypefn {Neko Function} {string #list} string_split (@var{s} : string, @var{sep} : string)
Split the string s using separator @var{sep}.

@ref{lib list} to understand what a @code{#list} is.
@end deftypefn


@deftypefn {Neko Function} string sprintf (@var{fmt} : string, @var{params} : (any | array))
Format a string.  If only one parameter is needed then it can be
directly passed, either the parameters need to be stored in an array.
The following formats are accepted (with corresponding types):

@table @code
@item %s
string;

@item %d %x %X
@code{int};

@item %c
@code{int} in the @code{[0, 255]} range;

@item %b
@code{bool};

@item %f
@code{float}.
@end table

Examples:

@example
sprintf("alpha %s %d", $array("beta", 123));
  // return: "alpha beta 123"

sprintf("float %f", 1.2);
  // return: "float 1.2"
@end example
@end deftypefn


@deftypefn {Neko Function} string url_decode (@var{s} : string)
Decode an @urla{} using escaped format.
@end deftypefn


@deftypefn {Neko Function} string url_encode (@var{s} : string)
Encode an @urla{} using escaped format.
@end deftypefn


@deftypefn {Neko Function} string base_encode (@var{s} : string, @var{charset} : string)
Encode a string using the specified @var{charset}; the length of the
string @var{charset} must be a power of two (2, 4, 8, 16, @dots{}).
This encoding has nothing to do with hexadecimal, base64, basE91,
@dots{} rather it is a lossless encoding that converts @var{s} to
another string using only bytes from the set @var{charset}.
@end deftypefn


@deftypefn {Neko Function} string base_decode (@var{s} : string, @var{charset} : string)
Decode a string encoded using characters from the specified
@var{charset}.  This is the inverse of @function{base_encode}.
@end deftypefn

Example:

@example
var base = "hello123"; // the length is 8
var s    = "the quick fox jumps over the lazy dog";

var enc  = base_encode(s, base);
// enc == "l1h2oeo1ehh3h121lll2e11lehh2le13l2hlhe1ll1l2212hlo2lhe13l1o2l12lehh3le1hlellhe1olhl31e3eehh2le13le2"
var dec  = base_decode(enc, base);
// dec == "the quick fox jumps over the lazy dog"
@end example

@c page
@node lib sys
@section Interaction with the operating system


@subsubheading Environment variables


@deftypefn {Neko Function} string? get_env (@var{s} : string)
Get some environment variable if exists.
@end deftypefn


@deftypefn {Neko Function} void put_env (@var{var} : string, @var{val} : string)
Set some environment variable value.
@end deftypefn


@deftypefn {Neko Function} #list sys_env (void)
Return all the (key,value) pairs in the environment as a chained list.
@ref{lib list} to understand what a @code{#list} is.
@end deftypefn


@subsubheading Time related functions


@deftypefn {Neko Function} void sys_sleep (@var{n} : number)
Sleep a given number of seconds.
@end deftypefn


@deftypefn {Neko Function} bool set_time_locale (@var{s} : string)
Set the locale for @env{LC_TIME}, returns true on success.
@end deftypefn


@deftypefn {Neko Function} float sys_time (void)
Return an accurate local time stamp in seconds since Jan 1 1970.
@end deftypefn


@deftypefn {Neko Function} float sys_cpu_time (void)
Return the most accurate @acronym{CPU} time spent since the process
started (in seconds).
@end deftypefn


@subsubheading Current working directory


@deftypefn {Neko Function} string get_cwd (void)
Return current working directory.
@end deftypefn


@deftypefn {Neko Function} void set_cwd (@var{s} : string)
Set current working directory.
@end deftypefn


@subsubheading System properties


@deftypefn {Neko Function} string sys_string (void)
Return the local system string.  Currently the following values are possible:
@code{Windows}, @code{Linux}, @code{BSD}, @code{Mac}.
@end deftypefn


@deftypefn {Neko Function} bool sys_is64 (void)
Return @true{} if we are on a 64 bits system.
@end deftypefn


@subsubheading Shell commands


@deftypefn {Neko Function} int sys_command (@var{s} : string)
Run a shell command and return its exit code.
@end deftypefn


@subsubheading Process termination


@deftypefn {Neko Function} void sys_exit (@var{code} : int)
Exit with the given error code.  Never return.
@end deftypefn


@subsubheading File system


@deftypefn {Neko Function} bool sys_exists (@var{pathname} : string)
Returns true if the file or directory exists.
@end deftypefn


@deftypefn {Neko Function} bool file_exists (@var{pathname} : string)
Deprecated: use @function{sys_exists} instead.
@end deftypefn


@deftypefn {Neko Function} void file_delete (@var{pathname} : string)
Delete the file.  Exception on error.
@end deftypefn


@deftypefn {Neko Function} void sys_rename (@var{from} : string, @var{to} : string)
Rename the file or directory.  Exception on error.
@end deftypefn


@deftypefn {Neko Function} {@{ gid => int, uid => int, atime => 'int32, mtime => 'int32, ctime => 'int32, dev => int, ino => int, nlink => int, rdev => int, size => int, mode => int @}} sys_stat (@var{pathname} : string)
Apply the @cfunc{stat} function to the given file or directory.
@end deftypefn


@deftypefn {Neko Function} string sys_file_type (@var{pathname} : string)
Return the type of the file.  Currently the following return values are
possible: @code{file}, @code{dir}, @code{symlink}, @code{sock},
@code{char}, @code{block}, @code{fifo}.
@end deftypefn


@deftypefn {Neko Function} void sys_create_dir (@var{pathname} : string, @var{mode} : int)
Create a directory with the specified rights.
@end deftypefn


@deftypefn {Neko Function} void sys_remove_dir (@var{pathname} : string)
Remove a directory.  Exception on error.
@end deftypefn


@deftypefn {Neko Function} {string #list} sys_read_dir (@var{pathname} : string)
Return the content of a directory. @ref{lib list} to understand what a
@code{#list} is.
@end deftypefn


@deftypefn {Neko Function} string file_full_path (@var{pathname} : string)
Return an absolute path from a relative one.  The file or directory must
exists.
@end deftypefn


@deftypefn {Neko Function} string sys_exe_path (void)
Return the path of the executable.
@end deftypefn


@subsubheading Miscellaneous functions


@deftypefn {Neko Function} int sys_getch (@var{b} : bool)
Read a character from @code{stdin} with or without echo.
@end deftypefn


@deftypefn {Neko Function} int sys_get_pid (void)
Returns the current process identifier.
@end deftypefn

@c page
@node lib thread
@section Creating and managing system threads


@menu
* lib thread create::           Creating threads.
* lib thread message::          Sending and receiving messages.
* lib thread deque::            Handling deques.
* lib thread lock::             Handling locks.
* lib thread mux::              Handling mutexes.
* lib thread storage::          Handling thread local storage.
@end menu

@c page
@node lib thread create
@subsection Creating threads


@deftypefn {Neko Function} 'thread thread_create (@var{f} : function:1, @var{p} : any)
Create a thread that will be running the function
@code{@var{f}(@var{p})}.
@end deftypefn


@deftypefn {Neko Function} 'thread thread_current (void)
Return the current thread.
@end deftypefn

@c page
@node lib thread message
@subsection Sending and receiving messages


@deftypefn {Neko Function} void thread_send (@var{thd} : 'thread, @var{msg} : any)
Send a message into the target thread message queue.
@end deftypefn


@deftypefn {Neko Function} any thread_read_message (@var{block} : bool)
Read a message from the message queue.  If @var{block} is @true{}, the
function only returns when a message is available.  If @var{block} is
@false{} and no message is available in the queue, the function will
immediately return @cnull{}.
@end deftypefn

@c page
@node lib thread deque
@subsection Handling deques


@deftypefn {Neko Function} 'deque deque_create (void)
Create a message queue for multithread access.
@end deftypefn


@deftypefn {Neko Function} void deque_add (@var{d} : 'deque, @var{value} : any)
Add a message at the @strong{end} of the queue.
@end deftypefn


@deftypefn {Neko Function} void deque_push (@var{d} : 'deque, @var{value} : any)
Add a message at the @strong{head} of the queue.
@end deftypefn


@deftypefn {Neko Function} any? deque_pop (@var{d} : 'deque, @var{block} : bool)
Pop a message from the @strong{head} of the queue.  If @var{block} is
true: block until a message is available; else return @cnull{}
immediately.
@end deftypefn

@c page
@node lib thread lock
@subsection Handling locks


@deftypefn {Neko Function} 'lock lock_create (void)
Create a lock which is initially locked.
@end deftypefn


@deftypefn {Neko Function} void lock_release (@var{lock} : 'lock)
Release a lock.  The thread does not need to own the lock to be able to
release it.  If a lock is released several times, it can be acquired as
many times.
@end deftypefn


@deftypefn {Neko Function} bool lock_wait (@var{lock} : 'lock, @var{timeout} : number?)
Waits for a lock to be released, then acquire it.  If @var{timeout} (in
seconds) is not @cnull{} and expires then the returned value is @false{}.
@end deftypefn

@c page
@node lib thread mux
@subsection Handling mutexes


@deftypefn {Neko Function} 'mutex mutex_create (void)
Create a mutex, which can be used to acquire a temporary lock to access
some resource.  The main difference with a lock is that a mutex must
always be released by the owner thread.
@end deftypefn


@deftypefn {Neko Function} void mutex_acquire (@var{mux} : 'mutex)
Make the current thread acquire the mutex or wait if not available.  The
same thread can acquire several times the same mutex, but it must
release it as many times it has been acquired.
@end deftypefn


@deftypefn {Neko Function} bool mutex_try (@var{mux} : 'mutex)
Try to acquire the mutex, return @true{} if success or @false{} if
@var{mux} is already locked by another thread.
@end deftypefn


@deftypefn {Neko Function} void mutex_release (@var{mux} : 'mutex)
Release a mutex that has been acquired by the current thread.  The
behavior is undefined if the current thread does not own the mutex.
@end deftypefn

@c page
@node lib thread storage
@subsection Handling thread local storage


@deftypefn {Neko Function} 'tls tls_create (void)
Creates thread local storage.  A thread local storage area can hold a
value that will be different depending on the local thread.

@strong{Warning} We must set the @acronym{TLS} value to @cnull{} before
exiting the thread or the memory will never be collected.
@end deftypefn


@deftypefn {Neko Function} void tls_set (@var{r} : 'tls, @var{value} : any)
Set the value of the @acronym{TLS} for the local thread.
@end deftypefn


@deftypefn {Neko Function} any tls_get (@var{t} : 'tls)
Return the value set by @function{tls_set} for the local thread.
@end deftypefn

@c page
@node lib utf8
@section Handling @acronym{UTF8} strings


Most of the operations are optimised for speed; they might still succeed
on some malformed @acronym{UTF8} string.  The only function that completely
checks the @acronym{UTF8} format is @function{utf8_validate}.  Other functions
might raise exceptions or not depending on the malformed data.


@deftypefn {Neko Function} 'ubuf utf8_buf_alloc (@var{size} : int)
Create a new buffer with an initial @var{size} in bytes.
@end deftypefn


@deftypefn {Neko Function} void utf8_buf_add (@var{b} : 'buf, @var{c} : int)
Add a valid @acronym{UTF8} char (in the range @code{[0, 0x10FFFF]}) to
the buffer.
@end deftypefn


@deftypefn {Neko Function} string utf8_buf_content (@var{b} : 'buf)
Return the current content of the buffer.  This is not a copy of the
buffer but the shared content.  Retrieving content and then continuing
to add chars is possible but not very efficient.
@end deftypefn


@deftypefn {Neko Function} int utf8_buf_length (@var{b} : 'buf)
Return the number of @acronym{UTF8} chars stored in the buffer.
@end deftypefn


@deftypefn {Neko Function} int utf8_buf_size (@var{b} : 'buf)
Return the current size of the buffer in bytes.
@end deftypefn


@deftypefn {Neko Function} bool utf8_validate (@var{s} : string)
Validate if a string is encoded using the @acronym{UTF8} format.
@end deftypefn


@deftypefn {Neko Function} int utf8_length (@var{s} : string)
Return the number of @acronym{UTF8} chars in the string.
@end deftypefn


@deftypefn {Neko Function} string utf8_sub (@var{s} : string, @var{pos} : int, @var{len} : int)
Return a part of an @acronym{UTF8} string.
@end deftypefn


@deftypefn {Neko Function} int utf8_get (@var{s} : string, @var{n} : int)
Return the nth char in an @acronym{UTF8} string.  This might be
inefficient if @var{n} is big.
@end deftypefn


@deftypefn {Neko Function} void utf8_iter (@var{s} : string, @var{f} : ((int -> void)))
Call @var{f} with each of @acronym{UTF8} char of the string.
@end deftypefn


@deftypefn {Neko Function} int utf8_compare (@var{s1} : string, @var{s2} : string)
Compare two @acronym{UTF8} strings according to @acronym{UTF8} char codes.
@end deftypefn

@c page
@node lib xml
@section The standard event--driven @axml{} parser.


@deftypefn {Neko Function} void parse_xml (@var{xml} : string, @var{events} : object)
Parse a string and, for each parsed element, call the corresponding
object method in events:

@table @code
@item void xml (name : string, attribs : object)
when an @axml{} node is found;

@item void done (void)
when an @axml{} node is closed;

@item void pcdata (s : string)
when @code{PCData} are chars found;

@item void cdata (s : string)
when a @code{CData} session is found;

@item void comment (s : string)
when some comment or special header is found.
@end table

We can implement the events so they build the appropriate @axml{} data
structure needed by our language.
@end deftypefn

@c page
@node lib misc
@section Miscellaneous functions


@deftypefn {Neko Function} string float_bytes (@var{n} : number, @var{bigendian} : bool)
Return the 4 bytes representation of the number as an @acronym{IEEE} 32
bits float.
@end deftypefn


@deftypefn {Neko Function} string double_bytes (@var{n} number, @var{bigendian} : bool)
Return the 8 bytes representation of the number as an @acronym{IEEE} 64
bits float.
@end deftypefn


@deftypefn {Neko Function} float float_of_bytes (@var{s} : string, @var{bigendian} : bool)
Return a float from a 4 bytes @acronym{IEEE} 32 bits representation.
@end deftypefn


@deftypefn {Neko Function} float double_of_bytes (@var{s} : string, @var{bigendian} : bool)
Returns a float from a 8 bytes @acronym{IEEE} 64 bits representation.
@end deftypefn


@deftypefn {Neko Function} void run_gc (@var{major} : bool)
Run the Neko garbage collector.
@end deftypefn


@deftypefn {Neko Function} {@{ heap => int, free => int@}} gc_stats (void)
Return the size of the GC heap and the among of free space, in bytes.
@end deftypefn


@deftypefn {Neko Function} void enable_jit (@var{b} : bool)
Enable or disable the @acronym{JIT}.
@end deftypefn


@deftypefn {Neko Function} void test (void)
The test function, to check that library is reachable and correctly
linked.
@end deftypefn


@deftypefn {Neko Function} void print_redirect (@var{f} : function:1?)
Set a redirection function for all printed values.  Setting it to
@cnull{} will cancel the redirection and restore previous printer.
@end deftypefn

@c page
@node lib cgi
@section Apache access when running @modneko{}


The following functions are defined only when running @modneko{}, they
are @strong{not} in the standard library.


@deftypefn {Neko Function} 'list get_cookies (void)
Return a cookie list as a (name,value) chained list.
@end deftypefn


@deftypefn {Neko Function} void set_cookie (@var{name} : string, @var{val} : string)
Set a cookie.
@end deftypefn


@deftypefn {Neko Function} string get_host_name (void)
Get the local host @acronym{IP}.
@end deftypefn


@deftypefn {Neko Function} string get_client_ip (void)
Get the connected client @acronym{IP}.
@end deftypefn


@deftypefn {Neko Function} string get_uri (void)
Get the original @acronym{URI} requested by the client (before any
internal redirection).
@end deftypefn


@deftypefn {Neko Function} void redirect (@var{uri} : string)
Redirect the client to another page (Location header).
@end deftypefn


@deftypefn {Neko Function} void set_return_code (@var{code} : int)
Set the @acronym{HTTP} return code.
@end deftypefn


@deftypefn {Neko Function} void set_header (@var{name} : string, @var{val} : string)
Set a @acronym{HTTP} header value.
@end deftypefn


@deftypefn {Neko Function} string? get_client_header (@var{name} : string)
Get a @acronym{HTTP} header sent by the client.
@end deftypefn


@deftypefn {Neko Function} {string list} get_client_headers (void)
Get all the @acronym{HTTP} client headers.
@end deftypefn


@deftypefn {Neko Function} string get_params_string (void)
Return the whole parameters string.
@end deftypefn


@deftypefn {Neko Function} string get_post_data (void)
Return the whole unparsed @code{POST} string.
@end deftypefn


@deftypefn {Neko Function} void parse_multipart_data (@var{onpart} : function:2, @var{ondata} : function:3)
Incrementally parse the multipart data.  Call
@code{onpart(name,filename)} for each part found and
@code{ondata(buf,pos,len)} when some data is available.
@end deftypefn


@deftypefn {Neko Function} #list get_params (void)
Parse all @code{GET} and @code{POST} params and return them into a
chained list.
@end deftypefn


@deftypefn {Neko Function} string cgi_get_cwd (void)
Return current bytecode file working directory.
@end deftypefn


@deftypefn {Neko Function} void cgi_set_main (@var{f} : function:0)
Set the main entry point function.
@end deftypefn


@deftypefn {Neko Function} void cgi_flush (void)
Flush the data written so it's immediately sent to the client.
@end deftypefn


@deftypefn {Neko Function} object cgi_get_config (void)
Return the current configuration.
@end deftypefn


@deftypefn {Neko Function} void cgi_set_config (@var{o} : object)
Set the current configuration.
@end deftypefn


@deftypefn {Neko Function} any cgi_command (@var{value} : any)
Perform a configuration--specific command:

@table @code
@item stats
returns the statistics;

@item cache
returns the current cache.
@end table
@end deftypefn

@c page
@node lib mysql
@section Connecting and using MySQL databases


The following functions are available only if the interface library has
been built and installed; the library is called @file{mysql.ndll} and
can be loaded using the following Neko module:

@example
// mysql.neko --
//
// Load the Neko interface library to MySQL.

var stdload = function (name, arity) @{
  return $loader.loadprim("mysql" + "@@" + name, arity);
@}


$exports.connect                = stdload("connect",    1);
$exports.close                  = stdload("close",      1);
$exports.select_db              = stdload("select_db",  2);
$exports.request                = stdload("request",    2);
$exports.escape                 = stdload("escape",     1);
$exports.result_set_conv_date   = stdload("result_set_conv_date", 2);
$exports.result_get_length      = stdload("result_get_length",    1);
$exports.result_get_nfields     = stdload("result_get_nfields",   1);
$exports.result_next            = stdload("result_next",          1);
$exports.result_get             = stdload("result_get",           2);
$exports.result_get_int         = stdload("result_get_int",       2);
$exports.result_get_float       = stdload("result_get_float",     2);

/// end of file
@end example


@subsection Connecting


@deftypefn {Neko Function} 'connection connect (@var{o} : @{ host => string, port => int, user => string, pass => string, socket => string?@})
Connect to a database using the connection informations.
@end deftypefn


@deftypefn {Neko Function} void close (@var{c} : 'connection)
Close the connection.  Any subsequent operation on @var{c} will fail.
@end deftypefn


@deftypefn {Neko Function} void select_db (@var{c} : 'connection, @var{s} : string)
Select the database.
@end deftypefn


@deftypefn {Neko Function} 'result request (@var{c} : 'connection, @var{query} : string)
Execute a @acronym{SQL} request.  An exception is raised on error.
@end deftypefn


@deftypefn {Neko Function} string escape (@var{s} : string)
Escape the string for inserting into a @acronym{SQL} request.
@end deftypefn


@subsection Handling the result


@deftypefn {Neko Function} void result_set_conv_date (@var{r} : 'result, @var{f} : function:1)
Set the function that will convert a @code{Date} or @code{DateTime}
string to the corresponding value.
@end deftypefn


@deftypefn {Neko Function} int result_get_length (@var{r} : 'result)
Return the number of rows returned or affected.
@end deftypefn


@deftypefn {Neko Function} int result_get_nfields (@var{r} : 'result)
Return the number of fields in a result row.
@end deftypefn


@deftypefn {Neko Function} object? result_next (@var{r} : 'result)
Return the next row if available.

A row is represented as an object, which fields have been converted to
the corresponding Neko value (@code{int}, @code{float} or
@code{string}).

For @code{Date} and @code{DateTime} we can specify our own conversion
function using @function{result_set_conv_date}.  By default they're
returned as plain strings.

Additionally, the @code{TINYINT(1)} will be converted to either @true{}
or @false{} if equal to @code{0}.
@end deftypefn


@deftypefn {Neko Function} string result_get (@var{r} : 'result, @var{n} : int)
Return the nth field of the current row.
@end deftypefn


@deftypefn {Neko Function} int result_get_int (@var{r} : 'result, @var{n} : int)
Return the nth field of the current row as an integer (or 0).
@end deftypefn


@deftypefn {Neko Function} float result_get_float (@var{r} : 'result, @var{n} : int)
Return the nth field of the current row as a float (or 0).
@end deftypefn

@c page
@node lib sqlite
@section Connecting to and using Sqlite databases


Sqlite is a small embeddable @acronym{SQL} database that stores all its
data into a single file.  See @url{http://sqlite.org} for more details.

The following functions are available only if the interface library has
been built and installed; the library is called @file{sqlite.ndll} and
can be loaded using the following Neko module:

@example
// sqlite.neko --
//
// Load the Neko interface library to Sqlite.

var stdload = function (name, arity) @{
  return $loader.loadprim("sqlite" + "@@" + name, arity);
@}


$exports.connect                = stdload("connect",            1);
$exports.last_insert_id         = stdload("last_insert_id",     1);
$exports.request                = stdload("request",            2);
$exports.result_get_length      = stdload("result_get_length",  1);
$exports.result_get_nfields     = stdload("result_get_nfields", 1);
$exports.result_next            = stdload("result_next",        1);
$exports.result_get             = stdload("result_get",         2);
$exports.result_get_int         = stdload("result_get_int",     2);
$exports.result_get_float       = stdload("result_get_float",   2);

/// end of file
@end example


@subsection Connecting


@deftypefn {Neko Function} 'db connect (@var{filename} : string)
Open or create the database stored in the specified file.
@end deftypefn


@deftypefn {Neko Function} void close (@var{db} : 'db)
Close the database.
@end deftypefn


@deftypefn {Neko Function} int last_insert_id (@var{db} : 'db)
Return the last inserted @code{auto_increment} id.
@end deftypefn


@subsection Handling the result


@deftypefn {Neko Function} 'result request (@var{db} : 'db, @var{query} : string)
Executes the @acronym{SQL} request and returns its result.
@end deftypefn


@deftypefn {Neko Function} int result_get_length (@var{r} : 'result)
Return the number of rows in the result or the number of rows changed by
the request.
@end deftypefn


@deftypefn {Neko Function} int result_get_nfields (@var{r} : 'result)
Return the number of fields in the result.
@end deftypefn


@deftypefn {Neko Function} object? result_next (@var{r} : 'result)
Return the next row in the result or @cnull{} if no more result.
@end deftypefn


@deftypefn {Neko Function} string result_get (@var{r} : 'result, @var{n} : int)
Return the nth field of the current result row.
@end deftypefn


@deftypefn {Neko Function} int result_get_int (@var{r} : 'result, @var{n} : int)
Return the nth field of the current result row as an integer.
@end deftypefn


@deftypefn {Neko Function} float result_get_float (@var{r} : 'result, @var{n} : int)
Return the nth field of the current result row as a float.
@end deftypefn

@c page
@node lib regexp
@section Regular expressions using the @acronym{PCRE} engine


The following functions are available only if the regexp library has
been built and installed; the library file name is @file{regexp.ndll}.
To access the functions we can load the following module:

@example
// regexp.neko --
//
// Load the Neko regexp library.

var stdload = function (name, arity) @{
  return $loader.loadprim("regexp" + "@@" + name, arity);
@}

$exports.regexp_new_options     = stdload("regexp_new_options", 2);
$exports.regexp_new             = stdload("regexp_new",         1);
$exports.regexp_match           = stdload("regexp_match",       4);
$exports.regexp_replace         = stdload("regexp_replace",     3);
$exports.regexp_replace_all     = stdload("regexp_replace_all", 3);
$exports.regexp_replace_fun     = stdload("regexp_replace_fun", 3);
$exports.regexp_matched         = stdload("regexp_matched",     2);
$exports.regexp_matched_pos     = stdload("regexp_matched_pos", 2);

/// end of file
@end example


@deftypefn {Neko Function} 'regexp regexp_new_options (@var{pattern} : string, @var{options} : string)
Build a new regexp with the following options:

@table @code
@item i
case insensitive matching;

@item s
@code{.} matches anything including newlines;

@item m
treat the input as a multiline string;

@item u
run in @acronym{UTF8} mode;

@item g
turn off greedy behaviour.
@end table
@end deftypefn


@deftypefn {Neko Function} 'regexp regexp_new (@var{pattern} : string)
Build a new regexp.
@end deftypefn


@deftypefn {Neko Function} bool regexp_match (@var{rex} : 'regexp, @var{s} : string, @var{pos} : int, @var{len} : int)
Match @var{len} chars of a string starting at @var{pos} using @var{rex}.
Return @true{} if a match is found.
@end deftypefn


@deftypefn {Neko Function} string regexp_replace (@var{rex} : 'regexp, @var{from} : string, @var{by} : string)
Perform a replacement using a regexp.
@end deftypefn


@deftypefn {Neko Function} string regexp_replace_all (@var{rex} : 'regexp, @var{from} : string, @var{by} : string)
Perform a replacement of all matched substrings using a regexp.
@end deftypefn


@deftypefn {Neko Function} string regexp_replace_fun (@var{rex} : 'regexp, @var{from} : string, @var{f} : (('regexp -> any)))
Perform a replacement of all matched substrings by calling @var{f} for
every match.
@end deftypefn


@deftypefn {Neko Function} string regexp_matched (@var{rex} : 'regexp, @var{n} : int)
Return the nth matched block by the regexp.  If @var{n} is @code{0} then
return the whole matched substring.
@end deftypefn


@deftypefn {Neko Function} {@{ pos => int, len => int@}} regexp_matched_pos (@var{rex} : 'regexp, @var{n} : int)
Return the position of the nth block matched by the regexp.  If @var{n}
is @code{0} then return the whole matched substring position.
@end deftypefn

@c page
@node lib gui
@section Core native user interface support


This @api{} uses native Win32 @api{} on Windows, Carbon @api{} on
@acronym{OSX}, and @acronym{GTK2} on Linux.  The following functions are
available only if the @gui{} library has been built and installed; the
library file name is @file{ui.ndll}.  To access the functions we can
load the following module:

@example
// ui.neko --
//
// Load the Neko interface library to GUI.

var stdload = function (name, arity) @{
  // The library is called "ui.ndll".
  return $loader.loadprim("ui" + "@@" + name, arity);
@}

$exports.ui_is_main     = stdload("ui_is_main",         0);
$exports.ui_loop        = stdload("ui_loop",            0);
$exports.ui_stop_loop   = stdload("ui_stop_loop",       0);
$exports.ui_sync        = stdload("ui_sync",            1);

/// end of file
@end example


@deftypefn {Neko Function} bool ui_is_main (void)
Tell if the current thread is the main loop thread or not.  The main
loop thread is the one in which the first @gui{} library primitive has
been loaded.
@end deftypefn


@deftypefn {Neko Function} void ui_loop (void)
Start the native @gui{} event loop.  This method can only be called from
the main thread.
@end deftypefn


@deftypefn {Neko Function} void ui_stop_loop (void)
Stop the native @gui{} event loop.  This method can only be called from
the main thread.
@end deftypefn


@deftypefn {Neko Function} void ui_sync (@var{callb} : ((void -> void)))
Queue a method call to @var{callb} to be executed by the main thread
while running the @gui{} event loop.  This can be used to perform @gui{}
updates in the @gui{} thread using results processed by another thread.
@end deftypefn

@c page
@node lib zlib
@section Compression library


The following @api{} gives access to the popular ZLib compression
library, used in several file formats such as @acronym{ZIP} and
@acronym{PNG}.

The following functions are available only if the interface library has
been built and installed; the library file name is @file{zlib.ndll}.  To
access the functions we can load the following module:

@example
// zlib.neko --
//
// Load the Neko interface library to Zlib.

var stdload = function (name, arity) @{
  return $loader.loadprim("zlib" + "@@" + name, arity);
@}

$exports.set_flush_mode = stdload("set_flush_mode",     2);
$exports.deflate_bound  = stdload("deflate_bound",      2);
$exports.deflate_init   = stdload("deflate_init",       1);
$exports.deflate_buffer = stdload("deflate_buffer",     5);
$exports.deflate_end    = stdload("deflate_end",        1);
$exports.inflate_init   = stdload("inflate_init",       1);
$exports.inflate_buffer = stdload("inflate_buffer",     5);
$exports.inflate_end    = stdload("inflate_end",        1);
$exports.get_adler32    = stdload("get_adler32",        1);
$exports.update_adler32 = stdload("update_adler32",     4);
$exports.update_crc32   = stdload("update_crc32",       4);

/// end of file
@end example


@subsection Stream configuration


@deftypefn {Neko Function} void set_flush_mode (@var{s} : 'stream, @var{mode} : string)
Change the flush mode of a stream; supported modes are: @code{NO},
@code{SYNC}, @code{FULL}, @code{FINISH}, @code{BLOCK}.
@end deftypefn


@subsection Stream compression


@deftypefn {Neko Function} int deflate_bound (@var{d} : 'dstream, @var{n} : int)
Return the maximum buffer size needed to write @var{n} bytes.
@end deftypefn


@deftypefn {Neko Function} 'dstream deflate_init (@var{level} : int)
Open a compression stream with the given level of compression.
@end deftypefn


@deftypefn {Neko Function} {@{ done => bool, read => int, write => int@}} deflate_buffer (@var{d} : 'dstream, @var{src} : string, @var{srcpos} : int, @var{dst} : string, @var{dstpos} : int)
Compresses a string and store the output into a string.
@end deftypefn


@deftypefn {Neko Function} void deflate_end (@var{d} : 'dstream)
Close a compression stream.
@end deftypefn


@subsection Stream decompression


@deftypefn {Neko Function} 'istream inflate_init (@var{window_size} : int?)
Open a decompression stream.
@end deftypefn


@deftypefn {Neko Function} {@{ done => bool, read => int, write => int@}} inflate_buffer (@var{i} : 'istream, @var{src} : string, @var{srcpos} : int, @var{dst} : string, @var{dstpos} : int)
Decompresses a string and store the output into a string.
@end deftypefn


@deftypefn {Neko Function} void inflate_end (@var{i} : 'istream)
Close a decompression stream.
@end deftypefn


@subsection Sums


@deftypefn {Neko Function} 'int32 get_adler32 (@var{s} : 'stream)
Return the adler32 value of the stream.
@end deftypefn


@deftypefn {Neko Function} 'int32 update_adler32 (@var{adler} : 'int32, @var{s} : string, @var{pos} : int, @var{len} : int)
Update an adler32 value with a substring.
@end deftypefn


@deftypefn {Neko Function} 'int32 update_crc32 (@var{crc} : 'int32, @var{s} : string, @var{pos} : int, @var{len} : int)
Update a @acronym{CRC32} value with a substring.
@end deftypefn

@c page
@node faq
@appendix Frequently asked questions


@appendixsec How is Neko different from .Net's @acronym{CLR} or the Java's @acronym{JVM}?

The .Net's @acronym{CLR} and the Java Virtual Machine are both defined
by a bytecode language with a static type system based on classes.  As a
result, you can easily run languages that have a type system compatible
with Java or C# on these virtual machines.  But if you have a
dynamically typed language or no class system, you'll have to trick the
virtual machine and find a type mapping from your type system to the
@acronym{JVM} or .Net one.

Neko is a lot more simple.  First it is not a bytecode language but a
high--level programming language.  You don't have then to write a
compiler for it, a simple generator that translates your program into
the corresponding Neko program is enough.  You still have to find a
mapping from your values to Neko data structures but Neko gives you a
dynamically typed language with no fixed class system.  You have then to
find a runtime mapping so that your program executes correctly on Neko,
and not a type mapping so that your program types correctly like with
.Net/@acronym{JVM}.

As a result, it is easier to write a new or existing language on the
NekoVM than it is for the @acronym{CLR}/@acronym{JVM}, since you don't
have to deal with a high level type system.  Also, this means that
languages can interoperate more easily since they only need to share the
same data structures and not always the same types.


@appendixsec How is Neko different from @acronym{LLVM} or C-- ?


@noindent
These are compiler frameworks with low--level abstract processor
instructions and a static type system with low--level memory
manipulation functions.  For example, it would be possible to use these
frameworks to compile Neko, which stands as a higher--level language,
although Neko is powered by its own runtime.

As a result, Neko is perhaps less suitable to optimisations than these
abstract processors but is a lot easier to target for language designers
that want to reuse a runtime.  Since Neko is not a framework, it is very
lightweight.  For example, you only need @file{libneko.so}, which is
only 68 kB, in order to embed and run Neko programs in your application.


@appendixsec How is Neko different from @acronym{PHP}/Perl/Python/Ruby/Javascript?


@noindent
These languages are meant to be used by people.  They contain powerful
but sometimes complex features.  Often their runtimes are written
entirely in C and can thus be difficult to maintain and their
interpreters can be rather slow.  Neko runtime could be used to run
these languages more efficiently, and help them interact together and
share the same libraries.

Actually, it is one of the goals of Neko to be able to run these
languages on the same runtime.  Since current implementations are either
interpreted or running in a not--so--fast virtual machine using an
intermediate compilable representation such as Neko should be a good
improvement, especially when @acronym{JIT} is added.


@appendixsec How is Neko different from Lua?


@noindent
A complete comparison is available on the website.  Neko has better
@acronym{OO} support and a more easy--to--use C @ffi{}.  Neko is faster
for data structures manipulation but slower for floating--point
arithmetics.


@appendixsec How is Neko different from Parrot?


@noindent
Targeting Parrot is quite complex, with different languages at different
levels (low level @acronym{PASM} and medium level @acronym{PIR}).  In
particular, it is difficult to differentiate between the language and
the libraries.  Also, it gives access to more low level bytecode which
make it difficult to change it later without breaking backward
compatibility.  The Neko compiler is handling the low level and the Neko
language is as much abstract as possible.

Parrot is written in C while Neko compiler is written... in Neko.  The
language is fully bootstrapped right now.  Also, Neko is lightweight and
the Virtual Machine is only 68 kB on Linux and 40 kB on Windows, while
still offering a very good speed.


@appendixsec What garbage collector is Neko using?


@noindent
Neko is using the Boehm GC which is a conservative multithreaded mark
and sweep collector.  However since all calls to the GC are wrapper by
the Neko @api{} in @file{vm/alloc.c} it might be possible in the future
to switch easily to another garbage collector.


@appendixsec On which architecture can Neko run?


@noindent
Neko is known to run on Windows x86, Linux, @acronym{BSD},
@acronym{OSX}, and Linux @acronym{AMD64} architectures.  A lot more
architectures should be easily targeted since the @nvm{} is written in
pure @acronym{ANSI} C with only some differences for specific things
such as some standard library functions for system @api{} and dynamic
loading.

@c page
@node mod_neko
@appendix An introduction to @modneko{}


@modneko{} is an Apache module for Neko: it makes possible to run Neko
programs on the server side, in order to serve web pages using Apache.
Here's a step--by--step tutorial on how to configure and use @modneko{}.

@c ------------------------------------------------------------

@appendixsec Quick configuration

If we don't have @modneko{} compiled or we don't want to setup
Apache, we can use a @modneko{} emulator by using the Neko Web
Server.  It is a very small web server running locally for development
purposes only.  It mimics the same @api{} as @modneko{} so we can
use it instead.

In order to start the server, simply run the following command:

@example
$ nekotools server
@end example

@noindent
it should start the local server, by default on @code{localhost}, port
@code{2000}, so we can browse the configuration page by visiting:

@center @url{http://localhost:2000/server:config}

From the displayed page we can change the server's base path to our
website directory and we can start browsing it.  If it contains Neko
bytecode files, extension @code{.n}, they will be loaded and executed
just like Apache @modneko{} does.

@c ------------------------------------------------------------

@appendixsec Apache configuration

To use Apache with @modneko{}, once Neko is correctly configured,
we can edit the Apache configuration file, @file{httpd.conf}, in order
to add @modneko{}.  Each statement must be added on a single line
at the proper place in the Apache configuration file:

@enumerate
@item
add:

@example
LoadModule neko_module
@end example

@noindent
our path to @file{mod_neko.ndll};

@item
add:

@example
AddModule mod_neko.c
@end example

@item
add:

@example
AddHandler neko-handler .n
@end example

@item
add @code{index.n} to the list of @code{DirectoryIndex};
@end enumerate

@noindent
now we can restart Apache to check that @modneko{} is correctly
loaded.

@c ------------------------------------------------------------

@appendixsec Some tests

We can simply edit a Neko file and print a welcome message:

@example
$print("Hello Mod_neko !");
@end example

@noindent
compile it, then install the bytecode file in the web directory so that
it can be accessed by Apache; browsing it should display the message.

Now let's try to print the @acronym{HTTP} parameters that are passed to
the script, using the @modneko{} @api{}:

@example
get_params = $loader.loadprim("mod_neko@@get_params",0);

// or:
//   $loader.loadprim("mod_neko2@@get_params",0)
// for the 'mod_neko2.ndll' module

$print("PARAMS = " + get_params());
@end example

We can now set @acronym{HTTP} parameters @code{<THE-URL>?p1=v1;p2=v2...}
and see them displayed on the web page.

@c ------------------------------------------------------------

@appendixsec Script versus application

Usage of Neko is separated into two different phases: compile and run.
We cannot directly see the modifications we are making to the script
since we need to compile it first: this is a disadvantage.  However,
this approach has also several advantages:

@itemize
@item
the code it runs faster;

@item
the source code is checked at compile--time, before we attempt to browse
the page;

@item
we don't need to have sources on the server, only binaries are required;

@item
we can run our module in application mode (see below).
@end itemize

Every time a request is made by the browser, @modneko{} loads the
Neko bytecode files and executes them.  If we have a very big script it
might take some time (although it's already faster than other web
scripting languages).

The idea of running in Application Mode is to have first an
initialisation phase for our script that will create objects, load
libraries, initialise global data, and then setup an entry point which
will be the function called for every request.  Here's an example:

@example
$print("Initializing...");

// this is the entry point
entry = function() @{
  $print("Main...");
@}

// setup the entry point
set_main = $loader.loadprim("mod_neko@@cgi_set_main",1);
set_main(entry);

// call it the first time as well
entry();
@end example

Now, after compiling, if we browse this page it should display
@code{Initializing... Main...} the first time and then @code{Main...}
for every refresh.  It means that we can initialise a lot of things at
loading time and store values into globals that will be persistent
between calls.

If we recompile, this will change the time stamp of the @code{.n} file so
it will reload and initialise it again.  That means we should be able to
reload everything we need at loading time.

@c page
@node nekoml
@appendix A quick guide to NekoML


NekoML is a high--order functional language with type inference.  It can
be seen as Neko with a powerful static type system.  It is very suitable
for complex data structure manipulations, such as the ones performed by
compilers.  NekoML is inspired by OCaml, but walks different ways for
some points.

@c ------------------------------------------------------------

@appendixsec Types

NekoML comes with several builtin types, and we can define our own types
quite easily:

@itemize
@item
core types:

@example
1234    : int
1.234   : float
"hello" : string
true    : bool
'\n'    : char
()      : void
@end example

@item
tuples:

@example
(1,true) : (int, bool)
("a",(),1.23) : (string, void, float)
@end example

@item
union types:

@example
type t @{
  A;
  B;
  C : int;
  D : (int , string);
@}

A : t;
B : t;
C(0) : t;
D(1,"") : t;
D : int -> string -> t;
@end example

@item
records:

@example
type t @{
  x : int;
  y : int;
@}

@{ x = 1; y = 2 @} : t
@end example

@item
mutable record fields:

@example
type t @{
	mutable counter : int;
@}

var x = @{ counter = 0 @};
x.counter := 1;
@end example

@item
abstract types:

@example
type t
@end example

@item
recursive types:

@example
type t1 // declare as abstract

type t2 @{
  A : t1;
  B : t2;
@}

type t1 @{ // declare
  C : t1;
  D : t2;
@}
@end example

@item
parametrised types:

@example
type ('a,'b) pair @{
  fst : 'a;
  snd : 'b;
@}
@end example

@item
function types:

@example
function() @{ @} : void -> void;
function(x,y) @{ x + y @} : int -> int -> int
@end example

@item
lists:

@example
[1; 2; 3] : int list
@end example

@item
lists constructors:

@example
[] : 'a list;
0 :: [] : int list;
"a" :: "" :: [] : string list
@end example
@end itemize

@c ------------------------------------------------------------

@appendixsec Syntax

The syntax of NekoML if similar to the syntax of Neko, but with some
additional constructs:

@itemize
@item
blocks:

@example
@{ f(); g(); h() @}
@end example

@item
variables declaration:

@example
var x = (expr);
@end example

@item
conditions:

@example
if (expr) then (expr) [else (expr)]
@end example

@item
calls using parenthesis:

@example
f(1,2,3);
g();
h((1,2)); // call with a tuple
@end example

@item
calls using spaces:

@example
f 1 2 3;
g ();
h (1,2); // call with a tuple
@end example

@item
mixed calls:

@example
f (1,2) g() h (1,2);
// means
f((1,2),g(),h,(1,2));
@end example

@item
function declarations, we can declare a function anonymously or with a
name to add it to the local scope:

@example
var f = function() @{ ... @};
// equivalent to
function f() @{
  ...
@}
@end example

@item
recursive functions, when several following functions are declared
recursive (using rec), they're mutually recursive so they can call each
other:

@example
function rec f() @{
  g()
@}

function rec g() @{
  f()
@}
@end example
@end itemize

@c page
@node examples
@appendix Neko code examples


@menu
* examples list::               A module that manipulates lists.
* examples o32::                An object interface to @code{'int32}
                                abstract numbers.
@end menu

@c page
@node examples list
@appendixsec A module that manipulates lists


@example
// Part of: Marco's Test modules
// Contents: Lisp like lists using arrays
// Date: Sun Aug 17, 2008
//
// Abstract
//
// This module exports a  set of function to manipulate Neko
// '#list' values.  Sometimes the  Neko library makes use of
// a custom  list type to  organise a sequence of  values; a
// '#list' is a tree of  nested arrays organised like a Lisp
// list:
//
//      -------     -------     -------
//     | 0 | 1 |-->| 0 | 1 |-->| 0 | 1 |--> [null]
//      -------     -------     -------
//       |           |           |
//       v           |           |
//  [first value]    |           |
//                   v           |
//             [second value]    |
//                               |
//                         [third value]
//
// each array has two values and the end of the list must be
// marked with 'null'.
//
//   The interpretation protocol  for '#list' values defined
// by this module is:
//
// 1. a '#list' is a  chain of 2-values arrays terminated by
//    'null';
//
// 2. 'null' itself is interpreted as the empty list;
//
// 3. an array of two  values is called "pair"; so a '#list'
//    is made up of pairs;
//
// 4. each pair in a list can hold a value;
//
// 5. the length of the  list is the number of values, which
//    equals the number of pairs.
//
//   Most  of  the  functions  in this  module  assume  that
// arguments are of the  correct type; calling them with bad
// values  will cause  undefined behaviour.   Predicates and
// assertion  functions are provided  to validate  lists and
// pairs.
//
// Copyright (c) 2008 Marco Maggi <marcomaggi@@gna.org>
//
// What follows is a list of contributors to this module:
//
// Copyright (c) 2008 Vitali Falileev <insideable@@gmail.com>
//
// This  is free  software; you  can redistribute  it and/or
// modify  it under  the  terms of  the  GNU Lesser  General
// Public  License   as  published  by   the  Free  Software
// Foundation;  either version  2.1 of  the License,  or (at
// your option) any later version.
//
// This library is  distributed in the hope that  it will be
// useful,  but  WITHOUT  ANY  WARRANTY;  without  even  the
// implied  warranty  of MERCHANTABILITY  or  FITNESS FOR  A
// PARTICULAR  PURPOSE.  See the  GNU Lesser  General Public
// License for more details.
//
// You should have received a copy of the GNU Lesser General
// Public License along with  this library; if not, write to
// the  Free  Software Foundation,  Inc.,  59 Temple  Place,
// Suite 330, Boston, MA 02111-1307 USA.
//

//page
// ------------------------------------------------------------
// Constructors.
// ------------------------------------------------------------

// Synopsis: #list cons (car : any, cdr : any)
//
// Build and return a pair.
$exports.cons = function (car, cdr) @{
  $array(car, cdr);
@};

// Synopsis: #list copy (ell : #list)
//
// Build and return a new  list holding the same elements of
// ELL.
$exports.copy = function (ell) @{
  var result, last_pair;

  if (null != ell)
    @{
      result    = $array(ell[0], null);
      last_pair = result;
      ell       = ell[1];
    @}
  while (null != ell)
    @{
      last_pair[1] = $array(ell[0], null);
      last_pair    = last_pair[1];
      ell          = ell[1];
    @}
  result;
@};

// '$exports.list' is defined in the "Conversion" section.

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Type predicates.
// ------------------------------------------------------------

// Synopsis: bool pairp (value : any)
//
// Return  'true' if  VALUE  is a  pair, 'false'  otherwise.
// Notice that 'null' is NOT a valid pair.
$exports.pairp = function (value) @{
  (($tarray == $typeof(value)) && (2 == $asize(value)));
@};

// Synopsis: bool listp (value : any)
//
// Return  'true' if  VALUE  is a  list, 'false'  otherwise.
// Notice that 'null' is a valid list: the empty list.
$exports.listp = function (value) @{
  if (null == value)
    true;
  else
    @{
      var last_pair;

      while (null != value)
        @{
          if ($exports.pairp(value))
            @{
              last_pair = value;
              value     = value[1];
            @}
          else
            return false;
        @}
      return (null == last_pair[1]);
    @}
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Type assertions.
// ------------------------------------------------------------

// Synopsis: void assert_pair (value : any)
//
// Raise an exception if VALUE is not a pair.
$exports.assert_pair = function (value) @{
  if ($tarray != $typeof(value))
    $throw("expected array got: " + value);
  if (2 != $asize(value))
    $throw("expected array of 2 elements got size: " + $asize(value));
@};

// Synopsis: void assert_list (value : any)
//
// Raise an exception if VALUE is not a list.
$exports.assert_list = function (value) @{
  while (null != value)
    @{
      $exports.assert_pair(value);
      value = value[1];
    @}
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Comparison.
// ------------------------------------------------------------

var list_comparison = function (compar, a, b) @{
  var v;

  while ((null != a) && (null != b))
    @{
      v = compar(a[0], b[0]);
      if (0 != v)
        return v;
      else
        @{
          a = a[1];
          b = b[1];
        @}
    @}

  if ((null == a) && (null != b))
    @{ -1 @}
  else
    if ((null != a) && (null == b)) @{ 1 @} else 0;
@};

// Synopsis: bool compare (a : #list, b : #list)
//
// Compare two lists element by element using '$compare' and
// return a ternary result:
//
// 0: if the  lists have equal length and  equal elements in
// the same position;
//
// -1:  if the  lists have  equal length  and for  the first
// different element the one of A is lesser;
//
// 1:  if the  lists have  equal  length and  for the  first
// different element the one of A is greater;
//
// -1:  if  the  lists   have  different  length  and  equal
// elements, but A is shorter;
//
// 1: if the lists have different length and equal elements,
// but A is longer.
$exports.compare = function (a, b) @{
  list_comparison($compare, a, b);
@};

// Synopsis: bool equalp (a : #list, b : #list)
//
// Compare two  lists element by element and  return true if
// the elements are equal according to '$compare'.
$exports.equalp = function (a, b) @{
  return (0 == list_comparison($compare, a, b));
@};

// Synopsis: bool eqp (a : #list, b : #list)
//
// Compare two  lists element by element and  return true if
// the elements are equal according to '$pcompare'.
$exports.eqp = function (a, b) @{
  return (0 == list_comparison($pcompare, a, b));
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Inspection.
// ------------------------------------------------------------

// Synopsis: int length (ell : #list)
//
// Return the length of a list.
$exports.length = function (ell) @{
  var len = 0;

  if ($istrue(ell))
    @{
      while (null != ell)
        @{
          len += 1;
          ell = ell[1];
        @}
    @}
  len;
@};

var member_sub = function (compar, x, ell) @{
  while (null != ell)
    @{
      if (0 == compar(x, ell[0]))
        return ell;
      else
        ell = ell[1];
    @}
  null;
@};

// Synopsis: #list memq (x : any, ell : #list)
//
// Return the first  sublist of ELL whose car  is equal to X
// according  to '$pcompare';  if X  does not  occur  in ELL
// return 'null'.
$exports.memq = function (x, ell) @{
  member_sub($pcompare, x, ell);
@};

// Synopsis: #list member (x : any, ell : #list)
//
// Return the first  sublist of ELL whose car  is equal to X
// according  to '$compare';  if  X does  not  occur in  ELL
// return 'null'.
$exports.member = function (x, ell) @{
  member_sub($compare, x, ell);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Common getters.
// ------------------------------------------------------------

// Synopsis: any car (pair : #pair)
//
// Return the first element in a pair.
$exports.car = function (pair) @{
  if ($tarray == $typeof(pair))
    pair[0];
  else
    $throw("cannot take the car of: " + pair);
@};

// Synopsis: any cdr (pair : #pair)
//
// Return the second element in a pair.
$exports.cdr = function (pair) @{
  if ($tarray == $typeof(pair))
    pair[1];
  else
    $throw("cannot take the cdr of: " + pair);
@};

// ------------------------------------------------------------

// Synopsis: any caar (ell : #list)
//
// Apply 'car' twice.
//
// It is an equivalent of 'ell[0][0]'.
$exports.caar = function (ell) @{
  $exports.car($exports.car(ell));
@};

// Synopsis: any cddr (ell : #list)
//
// Apply 'cdr' twice.
//
// It is an equivalent of 'ell[1][1]'.
$exports.cddr = function (ell) @{
  $exports.cdr($exports.cdr(ell));
@};

// Synopsis: any cadr (ell : #list)
//
// Apply 'cdr' then 'car'.
//
// It is an equivalent of 'ell[1][0]'.
$exports.cadr = function (ell) @{
  $exports.car($exports.cdr(ell));
@};

// Synopsis: any cdar (ell : #list)
//
// Apply 'car' then 'cdr'.
//
// It is an equivalent of 'ell[1][0]'.
$exports.cdar = function (ell) @{
  $exports.cdr($exports.car(ell));
@};

// ------------------------------------------------------------

// Synopsis: any caaar (ell : #list)
//
// Apply 'car' three times.
//
// It is an equivalent of 'ell[0][0][0]'.
$exports.caaar = function (ell) @{
  $exports.car($exports.caar(ell));
@};

// Synopsis: any cdddr (ell : #list)
//
// Apply 'cdr' three times.
//
// It is an equivalent of 'ell[1][1][1]'.
$exports.cdddr = function (ell) @{
  $exports.cdr($exports.cddr(ell));
@};

// ------------------------------------------------------------
// Two 'cdr' and one 'car'.

// Synopsis: any caddr (ell : #list)
//
// Apply 'cdr' then 'cdr' then 'car'.
//
// It is an equivalent of 'ell[1][1][0]'.
$exports.caddr = function (ell) @{
  $exports.car($exports.cddr(ell));
@};

// Synopsis: any cdadr (ell : #list)
//
// Apply 'cdr' then 'car' then 'cdr'.
//
// It is an equivalent of 'ell[1][0][1]'.
$exports.cdadr = function (ell) @{
  $exports.cdr($exports.cadr(ell));
@};

// Synopsis: any cddar (ell : #list)
//
// Apply 'car' then 'cdr' then 'cdr'.
//
// It is an equivalent of 'ell[0][1][1]'.
$exports.cddar = function (ell) @{
  $exports.cdr($exports.cdar(ell));
@};

// ------------------------------------------------------------
// Two 'car' and one 'cdr'.

// Synopsis: any caadr (ell : #list)
//
// Apply 'cdr' then 'car' then 'car'.
//
// It is an equivalent of 'ell[1][0][0]'.
$exports.caadr = function (ell) @{
  $exports.car($exports.cadr(ell));
@};

// Synopsis: any cadar (ell : #list)
//
// Apply 'car' then 'cdr' then 'car'.
//
// It is an equivalent of 'ell[0][1][0]'.
$exports.cadar = function (ell) @{
  $exports.car($exports.cdar(ell));
@};

// Synopsis: any cdaar (ell : #list)
//
// Apply 'cdr' then 'car' then 'car'.
//
// It is an equivalent of 'ell[1][0][0]'.
$exports.cdaar = function (ell) @{
  $exports.cdr($exports.caar(ell));
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Other getters.
// ------------------------------------------------------------

// Synopsis: #pair last_pair (ell : #list)
//
// Return the last pair of ELL or 'null' if ELL is the empty
// string.
$exports.last_pair = function (ell) @{
  if (null != ell)
    while(null != ell[1])
      ell = ell[1];
  ell;
@};

// Synopsis: any list_ref (ell : #list, i : int)
//
// Return the I-th element from ELL.
$exports.list_ref = function (ell, i) @{
  var count = 0;

  while (null != ell)
    @{
      if (count == i)
        return ell[0];
      else
        @{
          count += 1;
          ell    = ell[1];
        @}
    @}
  $throw("attempting to get element " + i
         + " from list, got list of length " + count);
@};

// Synopsis: #list head (ell : #list, count : integer)
//
// Build  and return  an new  list holding  the  first COUNT
// elements from ELL.
$exports.head = function (ell, count) @{
  if (0 == count)
    null;
  else if (null == ell)
    $throw("expected non-empty list");
  else
    @{
      var result = null;
      var i = 0;


      while (null != ell)
        @{
          result = $array(ell[0], result);
          ell    = ell[1];
          i += 1;

          if (i == count)
            return $exports.reverse(result);
        @}
      $throw("attempting to get " + count
             + "elements from list got list of length " + i);
    @}
@};

// Synopsis: #list tail (ell : #list, count : integer)
//
// Build  and return  an  new list  holding  the last  COUNT
// elements from ELL.
$exports.tail = function (ell, count) @{
  $exports.reverse($exports.head($exports.reverse(ell), count));
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Function application.
// ------------------------------------------------------------

// Synopsis: void for_each (func : function:1, ell : #list)
//
// Map a function to each element of ELL.
$exports.for_each = function (func, ell) @{
  while (null != ell)
    @{
      func(ell[0]);
      ell = ell[1];
    @}
@};

// Synopsis: #list map (func : function:1, ell : #list)
//
// Map  a function  to each  element of  ELL, return  a list
// holding the return values.
$exports.map = function (func, ell) @{
  var result = null;

  while (null != ell)
    @{
      result = $array(func(ell[0]), result);
      ell = ell[1];
    @}
  $exports.reverse(result);
@};

// Synopsis: any fold (proc : function:2, init : any, ell : #list)
//
// Apply PROC to the elements of ELL to build a result; then
// return that result.  Each call is 'PROC(E,PREV)', where E
// is the  next element  from ELL and  PREV is  the previous
// result.  The result is initialised with INIT.
//
// If ELL is 'null': the return value is INIT.
$exports.fold = function (proc, accumulator, ell) @{
  while (null != ell)
    @{
      accumulator = proc(ell[0], accumulator);
      ell = ell[1];
    @}
  accumulator;
@};

// Synopsis: any reduce (proc : function:2, DEFVALUE : any, ell : #list)
//
// It is a  variant of FOLD where the first  call to PROC is
// on 2 elements of ELL.
//
// If ELL is 'null': the  return value is DEFVALUE.  This is
// the only use of DEFVALUE.
$exports.reduce = function (proc, default_value, ell) @{
  if (null == ell)
    default_value;
  else
    @{
      var accumulator = ell[0];

      ell = ell[1];
      while (null != ell)
        @{
          accumulator = proc(ell[0], accumulator);
          ell = ell[1];
        @}
      accumulator;
    @}
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Operations.
// ------------------------------------------------------------

// Synopsis: #list reverse (ell : #list)
//
// Build and return a new  list holding the values of ELL in
// reversed order.
$exports.reverse = function (ell) @{
  var result = null;

  while (null != ell)
    @{
      result = $array(ell[0], result);
      ell    = ell[1];
    @}
  result;
@};

// Synopsis: #list do_append (args : array)
//
// Interpret all the elements  in ARGS as lists, concatenate
// them and return the result.
var do_append = function (args) @{
  var i = 0;
  var result = null;

  while (i < $asize(args))
    @{
      var ell = args[i];

      while (null != ell)
        @{
          result = $array(ell[0], result);
          ell    = ell[1];
        @}
      i += 1;
    @}
  $exports.reverse(result);
@};

// Synopsis: #list append (ell1 : #list, ...)
//
// Interpret  all the arguments  as lists,  concatenate them
// and return the result.
$exports.append = $varargs(do_append);

// Synopsis: #list filter (pred : function:1, ell : #list)
//
// Build and return  a new list holding all  the elements in
// ELL which satisfy the predicate PRED.
$exports.filter = function (pred, ell) @{
  var result = null;

  while (null != ell)
    @{
      if (pred(ell[0]))
        result = $array(ell[0], result);
      ell = ell[1];
    @}
  $exports.reverse(result);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Array conversion.
// ------------------------------------------------------------

// Synopsis: #list list_from_array (args : array)
//
// Build  and return a  list holding  the elements  from the
// array.   If  the array  is  empty:  the  return value  is
// 'null'.
$exports.list_from_array = function (args) @{
  var i   = $asize(args) - 1;
  var ell = null;

  while (0 <= i)
    @{
      ell = $array(args[i], ell);
      i -= 1;
    @}
  ell;
@};

// Synopsis: #list list (v1 : any, v2 : any, ...)
//
// Build and return a  list holding the given arguments.  If
// called with no arguments: the return value is 'null'.
$exports.list = $varargs($exports.list_from_array);

// Synopsis: array list_to_array (ell : #list)
//
// Build and  return a new  array holding the  elements from
// ELL.  If applied to 'null': the return value is the empty
// array.
$exports.list_to_array = function (ell) @{
  var result = $amake($exports.length(ell));
  var i = 0;

  while (null != ell)
    @{
      result[i] = ell[0];
      ell       = ell[1];
      i        += 1;
    @}
  result;
@};

// ------------------------------------------------------------


/// end of file
// Local Variables:
// fill-column: 60
// End:
@end example



@c page
@node examples o32
@appendixsec An object interface to @code{'int32} abstract numbers


@example
// Part of: Marco's Test modules
// Contents: object interface to #int32
// Date: Wed Aug 20, 2008
//
// Abstract
//
// This module  exports an  object interface to  handle Neko
// 'int32  values.   This  module  defines  a  protocol  for
// handling objects wrapping  'int32 through the object type
// #o32.
//
//   An  object value is  of type  #o32 if:  it has  a field
// named "n" holding an  abstract Neko value of 'int32 kind;
// its  prototype  is the  value  of  "o32_proto" from  this
// module.
//
// Copyright (c) 2008 Marco Maggi <marcomaggi@@gna.org>
//
// This  is free  software; you  can redistribute  it and/or
// modify  it under  the  terms of  the  GNU Lesser  General
// Public  License   as  published  by   the  Free  Software
// Foundation;  either version  2.1 of  the License,  or (at
// your option) any later version.
//
// This library is  distributed in the hope that  it will be
// useful,  but  WITHOUT  ANY  WARRANTY;  without  even  the
// implied  warranty  of MERCHANTABILITY  or  FITNESS FOR  A
// PARTICULAR  PURPOSE.  See the  GNU Lesser  General Public
// License for more details.
//
// You should have received a copy of the GNU Lesser General
// Public License along with  this library; if not, write to
// the  Free  Software Foundation,  Inc.,  59 Temple  Place,
// Suite 330, Boston, MA 02111-1307 USA.
//

//page
// ------------------------------------------------------------
// Setup.
// ------------------------------------------------------------

var stdload = function (name, arity) @{
  $loader.loadprim("std" + "@@" + name, arity);
@}

var std = $new(null);

std.int32_new           = stdload("int32_new",          1);
std.int32_to_int        = stdload("int32_to_int",       1);
std.int32_to_float      = stdload("int32_to_float",     1);
std.int32_compare       = stdload("int32_compare",      2);
std.int32_add           = stdload("int32_add",          2);
std.int32_sub           = stdload("int32_sub",          2);
std.int32_mul           = stdload("int32_mul",          2);
std.int32_div           = stdload("int32_div",          2);
std.int32_mod           = stdload("int32_mod",          2);

// This  is not  used because  when acting  on  objects Neko
// converts  the unary  negative operator  to  a subtraction
// from zero.
//
//std.int32_neg = stdload("int32_neg", 1);

/* The following are not used.
std.int32_ushr          = stdload("int32_ushr",         2);
std.int32_shl           = stdload("int32_shl",          2);
std.int32_shr           = stdload("int32_shr",          2);
std.int32_complement    = stdload("int32_complement",   1);
std.int32_or            = stdload("int32_or",           2);
std.int32_and           = stdload("int32_and",          2);
std.int32_xor           = stdload("int32_xor",          2);
std.int32_address       = stdload("int32_address",      1);
*/

// ------------------------------------------------------------

// This is  to solve the  chicken and egg problem  of object
// prototype  definition.  Notice  that the  "make" variable
// has to be  defined WITHOUT the "var" keyword,  so that it
// is global to this file and not captured by functions.
make = null;
$exports.o32_proto = null;

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Type predicates and assertions.
// ------------------------------------------------------------

// Synopsis: bool o32p (o : any)
//
// Return true if O is a Neko object value of type #o32.
//
// *FIXME* This function does not verify if the value in the
// *"n" field is an abstract of 'int32 kind.
$exports.o32p = function (o) @{
  (($tobject == $typeof(o)) &&
   ($objfield(o,$hash("n"))) &&
   ($exports.o32_proto == $objgetproto(o)));
@};

// Synopsis: void o32_assert (o : any)
//
// Raise an  error if O is  not an #o32  object according to
// "o32p()".
$exports.o32_assert = function (o) @{
  if ($not($exports.o32p(o)))
    $throw("expected #o32 object, got: " + o);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Comparison.
// ------------------------------------------------------------

// Synopsis: int o32_compare (o : any)
//
// Return a comparison ternary  result between "this" and O;
// this function  assumes that both "this" and  O hold valid
// #o32 objects.
//
// Notice that, as per the specs of Neko: comparison between
// an  object  and  a  non-object returns  "null"  directly,
// without examining the fields  of the object itself.  This
// means  that  "__compare"   is  invoked  only  whenever  a
// comparison between  two objects happens,  and the invoked
// "__compare" is the one of  the objects to the left.  Neko
// does not support the "__rcompare" method.

var o32_compare = function (num) @{
  if ($exports.o32p(num))
    std.int32_compare(this.n, num.n);
  else
    null;
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Arithmetics.
// ------------------------------------------------------------

// Synopsis: #o32 o32_add  (num : #o32|string|number)
// Synopsis: #o32 o32_radd (num : #o32|string|number)
//
// Return the sum between "this" and NUM.
//
// When dealing with numbers:  left and right adding are the
// same; when dealing with strings: left and right adding is
// different.  This is why we have two add functions.

var o32_add = function (num) @{
  switch ($typeof(num)) @{
    $tint       => make(std.int32_add(this.n, std.int32_new(num)))
    $tfloat     => make(std.int32_add(this.n, std.int32_new(num)))
    $tstring    => this.n + num
  default       => if ($exports.o32p(num))
      make(std.int32_add(this.n, num.n));
    else
      $throw("expected value summable to an #o32, got: " + num)
        @}
@};
var o32_radd = function (num) @{
  switch ($typeof(num)) @{
    $tint       => make(std.int32_add(this.n, std.int32_new(num)))
    $tfloat     => make(std.int32_add(this.n, std.int32_new(num)))
    $tstring    => num + this.n
  default       => if ($exports.o32p(num))
      make(std.int32_add(this.n, num.n));
    else
      $throw("expected value summable to an #o32, got: " + num)
        @}
@};

// ------------------------------------------------------------

var number_dispatcher = function (num) @{
  switch ($typeof(num)) @{
    $tint       => std.int32_new(num)
    $tfloat     => std.int32_new(num)
  default       => if ($exports.o32p(num))
      num.n;
    else
      $throw("expected number got: '" + num + "'")
        @}
@};

// ------------------------------------------------------------

// Synopsis: #o32 o32_sub  (num : #o32|number)
// Synopsis: #o32 o32_rsub (num : #o32|number)
//
// Return the subtraction between  "this" and NUM, right and
// left order.
//
// Notice that  the unary negative operator  is converted by
// Neko into the  subtraction: 0 - number; so  it is handled
// by the "__sub" method.

var o32_sub = function (num) @{
  make(std.int32_sub(this.n, number_dispatcher(num)));
@};
var o32_rsub = function (num) @{
  make(std.int32_sub(number_dispatcher(num), this.n));
@};

// Synopsis: #o32 o32_mul  (num : #o32|number)
//
// Return the  multiplication between "this"  and NUM; right
// and left order does not matter.
var o32_mul = function (num) @{
  make(std.int32_mul(this.n, number_dispatcher(num)));
@};

// Synopsis: #o32 o32_div  (num : #o32|number)
// Synopsis: #o32 o32_rdiv (num : #o32|number)
//
// Return  the division  between "this"  and NUM,  right and
// left order.
var o32_div = function (num) @{
  make(std.int32_div(this.n, number_dispatcher(num)));
@};
var o32_rdiv = function (num) @{
  make(std.int32_div(number_dispatcher(num), this.n));
@};

// Synopsis: #o32 o32_mod  (num : #o32|number)
// Synopsis: #o32 o32_rmod (num : #o32|number)
//
// Return the modulo between  "this" and NUM, right and
// left order.
var o32_mod = function (num) @{
  make(std.int32_mod(this.n, number_dispatcher(num)));
@};
var o32_rmod = function (num) @{
  make(std.int32_mod(number_dispatcher(num), this.n));
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Conversion.
// ------------------------------------------------------------

// Synopsis: string o32_to_string (void)
//
// Interpret "this" as an  #o32 object and return its string
// representation.
var o32_to_string = function () @{
  $string(this.n);
@};

// Synopsis: string o32_to_int (void)
//
// Interpret "this" as an #o32 object and return its integer
// representation.
var o32_to_int = function () @{
  std.int32_to_int(this.n);
@};

// Synopsis: string o32_to_float (void)
//
// Interpret "this"  as an #o32 object and  return its float
// representation.
var o32_to_float = function () @{
  std.int32_to_float(this.n);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Constructors.
// ------------------------------------------------------------

$exports.o32_proto = @{
  __string      => o32_to_string
  __compare     => o32_compare
  __add         => o32_add
  __radd        => o32_radd
  __sub         => o32_sub
  __rsub        => o32_rsub
  __mult        => o32_mul
  __rmult       => o32_mul
  __div         => o32_div
  __rdiv        => o32_rdiv
  __mod         => o32_mod
  __rmod        => o32_rmod

  int           => o32_to_int
  float         => o32_to_float
@};

var basic_new = function (number) @{
  var o = $new(null);

  o.n = number;
  $objsetproto(o, $exports.o32_proto);
  o;
@};

// Synopsis: #o32 o32 (n : int|float|string)
//
// Build  and return  a new  #o32 value;  N must  be  a Neko
// number or  string integer  representation and it  will be
// used to initialise the object.
$exports.o32 = function (value) @{
  basic_new(switch ($typeof(value))
    @{
      $tint     => std.int32_new(value)
      $tfloat   => std.int32_new(value)
      $tstring  => std.int32_new($int(value))
      default   => $throw("expected number got: " + value)
    @});
@};

// This is  to solve the  chicken and egg problem  of object
// prototype definition.
make = basic_new;


/// end of file
// Local Variables:
// fill-column: 60
// End:
@end example

@c page
@c appendices

@include lgpl-2.1.texi
@include fdl-1.3.texi

@c page
@node References
@appendix Bibliography and references


@nvm{} Home Page:

@center @url{http://www.nekovm.org/}

@c page
@node Concept Index
@appendix An entry for each concept

@printindex cp

@node Function Index
@appendix An entry for each function.

@printindex fn

@node Variable Index
@appendix An entry for each variable.

@printindex vr

@node Type Index
@appendix An entry for each type.

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c End:
