\input texinfo.tex
@c %**start of header
@setfilename neko.info
@settitle NekoVM
@c %**end of header

@ignore
        TO DO LIST
        ==========

* Examples for the 'lib sys' node.
* Examples for the 'lib thread' node.
* Review the 'ffi' chapter.
* Review the 'embedding' chapter.

@end ignore


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------

@macro version{}
1.7.1
@end macro

@macro authorname{}
Marco Maggi
@end macro

@macro copyrightyears{}
2008
@end macro

@macro gnu{}
@acronym{GNU}
@end macro

@macro gpl{}
@acronym{GPL}
@end macro

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@macro nvm{}
NekoVM
@end macro

@macro vm{}
@acronym{VM}
@end macro

@macro modneko{}
@code{mod_neko}
@end macro

@macro api{}
@acronym{API}
@end macro

@macro rtti{}
@acronym{RTTI}
@end macro

@macro ffi{}
@acronym{FFI}
@end macro

@macro xml{}
@acronym{XML}
@end macro

@macro utf8{}
@acronym{UTF8}
@end macro

@macro gui{}
@acronym{GUI}
@end macro

@macro urla{}
@acronym{URL}
@end macro

@macro uri{}
@acronym{URI}
@end macro

@macro nxml{}
@acronym{NXML}
@end macro

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@macro null{}
@code{null}
@end macro

@macro true{}
@code{true}
@end macro

@macro false{}
@code{false}
@end macro

@macro cfunction{NAME}
@code{\NAME\()}
@end macro

@macro function{NAME}
@code{\NAME\()}
@end macro

@macro builtin{NAME}
@code{$\NAME\}
@end macro

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@macro neko{}
@command{neko}
@end macro

@macro nekoc{}
@command{nekoc}
@end macro

@macro nekoml{}
@command{nekoml}
@end macro

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@titlepage
@title NekoVM
@subtitle @version{}
@author @authorname{}
@page
@vskip 0pt plus 1filll
@noindent
Copyright @copyright{}  2005--2008  by Motion--Twin@*
Copyright @copyright{}  2005--2008  by Nicolas Cannasse@*
Copyright @copyright{}  @copyrightyears{}  by @authorname{}

This document gathers unofficial documentation describing version
@version{} of @nvm{}; this document is a Texinfo conversion of the
documentation available on the Internet, with some adjustment.

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.  A
copy of the license is included in the section entitled ``GNU Free
Documentation License''.
@end titlepage


@c ------------------------------------------------------------

@ifinfo
@dircategory Development
@direntry
* neko: (neko).                 Unofficial documentation for NekoVM. 
@end direntry
@end ifinfo

@c ------------------------------------------------------------
@ifnottex
@node Top
@top The Neko Programming Language


@noindent
Neko is a high level dynamically typed programming language which can
also be used as an embedded scripting language.  This document gathers
unofficial documentation describing version @version{} of @nvm{}; this
document is a Texinfo conversion of the documentation available on the
Internet, with some adjustment.

@nvm{} is:

@noindent
Copyright @copyright{}  2005--2008  by Motion--Twin@*
Copyright @copyright{}  2005--2008  by Nicolas Cannasse

@noindent
and it is distributed under the terms of the @gnu{} Lesser General
Public License as published by the Free Software Foundation; either
version 2.1 of the License, or (at your option) any later version.
@ref{Software License} for details.

This document is:

@noindent
Copyright @copyright{}  2005--2008  by Motion--Twin@*
Copyright @copyright{}  2005--2008  by Nicolas Cannasse@*
Copyright @copyright{}  @copyrightyears{}  by @authorname{}

Permission is granted to copy, distribute and/or modify this document
under the terms of the GNU Free Documentation License, Version 1.2 or
any later version published by the Free Software Foundation; with no
Invariant Sections, no Front--Cover Texts, and no Back--Cover Texts.
@ref{Documentation License} a copy of the license is included in the
section entitled ``GNU Free Documentation License''.

@menu
* overview::                    Overview of @nvm{}. 
* programs::                    Invoking Neko programs.
* specs::                       Neko language specification.
* ffi::                         Foreign functions interface.
* embedding::                   Embedding the virtual machine.
* nxml::                        Neko in @xml{} format.
* lib::                         Neko library.

Appendices

* faq::                         Frequently asked questions.
* mod_neko::                    An introduction to @modneko{}.
* nekoml::                      A quick guide to NekoML.
* examples::                    Neko code examples.
* Software License::            @gnu{} Lesser General Public License.
* Documentation License::       @gnu{} Free Documentation License.
* References::                  Bibliography and references.

Indexes

* Concept Index::               An entry for each concept. 
* Function Index::              An entry for each function. 
* Variable Index::              An entry for each variable. 
* Type Index::                  An entry for each type. 

@detailmenu
 --- The Detailed Node Listing ---

Invoking Neko programs

* nekoc::                       The language compiler.
* nekotools::                   Miscellaneous features.
* neko::                        The virtual machine boot program.

The Neko language compiler

* nekoc compile::               Compiling source files.
* nekoc release::               Cleaning bytecode for release.
* nekoc link::                  Linking together more bytecode files.
* nekoc dump::                  Dumping bytecode from a compiled file.
* nekoc normalise::             Source files normalisation.
* nekoc console::               Running the virtual machine interactively.

Miscellaneous features

* nekotools boot::              Building standalone executables.
* nekotools server::            Web server.

Neko language specification

* specs notation::              Notation for functions documentation.
* specs syntax::                Syntax of the language.
* specs values::                Values.
* specs flow::                  Execution flow.
* specs rtti::                  Runtime type information.
* specs funcs::                 Functions and function calls.
* specs objects::               Objects.
* specs array::                 Arrays.
* specs string::                Strings.
* specs exceptions::            Exceptions.
* specs hash tables::           Hash tables.
* specs goto::                  Labels and gotos.
* specs misc::                  Miscellaneous builtins.
* specs modules::               Modules.

Execution flow

* specs flow values::           Evaluation of values.
* specs flow exprs::            Evaluation of expressions.
* specs flow vars::             Handling of variables.
* specs flow ops::              Operations on basic types.

Operations on basic types

* specs flow ops arithmetic::   Arithmetic operations.
* specs flow ops bitwise::      Bitwise operations.
* specs flow ops boolean::      Boolean operations.
* specs flow ops logic::        Logic operations.
* specs flow ops comparison::   Equality and comparison.
* specs flow ops assignment::   Assignment.
* specs flow ops conversion::   Conversion.

Objects

* specs objects making::        Creating objects.
* specs objects access::        Setting and getting values.
* specs objects inspect::       Inspecting objects.
* specs objects methods::       Defining methods.
* specs objects overloading::   Operators overloading.
* specs objects protos::        Prototypes.
* specs objects misc::          Other functions.

Strings

* specs string make::           Creating strings.
* specs string access::         Accessing characters.
* specs string copy::           Copying strings.
* specs string inspect::        Inspecting strings.

Hash tables

* specs hash tables making::    Creating hash tables.
* specs hash tables access::    Accessing elements.
* specs hash tables inspect::   Inspecting tables.

Foreign functions interface

* ffi example::                 A small example.
* ffi values::                  Manipulating values.
* ffi objects::                 Working with objects.
* ffi callbacks::               Function callbacks.
* ffi abstracts::               Abstracts and kinds.
* ffi varargs::                 Variable arguments functions.
* ffi int32::                   Using 32 bits integers.
* ffi memory::                  Managing memory.
* ffi misc::                    Misc @api{} functions.

Manipulating values

* ffi values types::            Data types.
* ffi values const::            Constant values.
* ffi values predicates::       Type predicates.
* ffi values assert::           Asserting the types of values.
* ffi values access::           Access functions.
* ffi values alloc::            Allocation functions.
* ffi values print::            Printing values.
* ffi values buffers::          Buffers.

Data types

* ffi values types other::      Other data types.

Working with objects

* ffi objects api::             Objects @api{}.
* ffi objects methods::         Object methods.

Embedding the @vm{}

* embedding example::           Example of embedding the @vm{}.
* embedding threads::           Multithreading.

Neko library

* lib loading::                 Loading the standard library.

The standard library

* lib list::                    The list custom type.
* lib int32::                   Using 32 bits integers.
* lib buffer::                  Buffers.
* lib date::                    Date.
* lib file::                    File.
* lib math::                    Mathematical functions.
* lib md5::                     MD5.
* lib memory::                  Memory.
* lib module::                  Modules.
* lib process::                 Process.
* lib random::                  Pseudo--random numbers generation.
* lib serialise::               Serialisation.
* lib socket::                  @acronym{TCP} and @acronym{UDP} sockets.
* lib string::                  Additional string functions.
* lib sys::                     Interaction with the operating system.
* lib thread::                  Creating and managing system threads.
* lib utf8::                    Handling @utf8{} strings.
* lib xml::                     The standard event--driven @xml{} parser. 
* lib misc::                    Miscellaneous functions.

Additionally libraries

* lib cgi::                     Apache access when running @modneko{}.
* lib mysql::                   Connecting to and using MySQL databases.
* lib sqlite::                  Connecting to and using Sqlite databases.
* lib regexp::                  Regular expressions using the @acronym{PCRE} engine.
* lib gui::                     Core native user interface support.
* lib zlib::                    Compression library.

Using 32 bits integers

* lib int32 make::              Constructors.
* lib int32 conversion::        Conversion.
* lib int32 comparison::        Comparison.
* lib int32 arithmetics::       Arithmetic operations.
* lib int32 bitwise::           Bitwise operations.
* lib int32 misc::              Miscellaneous operations.

File

* lib file open::               Opening and closing files.
* lib file io::                 Input/output upon files.
* lib file seek::               Setting the position.

@acronym{TCP} and @acronym{UDP} sockets

* lib socket creating::         Creating sockets.
* lib socket client::           Connecting as client.
* lib socket server::           Setting up a server.
* lib socket io::               Sending and receiving.
* lib socket select::           Selecting events on sockets.
* lib socket poll::             Polling events on sockets.
* lib socket resolver::         Resolving addresses.
* lib socket misc::             Miscellaneous functions.

Polling events on sockets

* lib socket poll events ex::   Example of polling for events.
* lib socket poll read ex::     Example of polling for available data.

Creating and managing system threads

* lib thread create::           Creating threads.
* lib thread message::          Sending and receiving messages.
* lib thread deque::            Handling deques.
* lib thread lock::             Handling locks.
* lib thread mux::              Handling mutexes.
* lib thread storage::          Handling thread local storage.

Neko code examples

* examples list::               A module that manipulates lists.
* examples o32::                An object interface to @code{'int32}
                                abstract numbers.

@end detailmenu
@end menu

@end ifnottex

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node overview
@chapter Overview of @nvm{}


@noindent
Neko is a high level, dynamically typed, programming language which can
also be used as an embedded scripting language.  It is designed to
provide a common runtime for several different languages.  Neko is not
only very easy to learn and use, but can be extended with C language
libraries.  We can convert our high level language to the Neko language,
then use Neko's tools to compile and run the program, also accessing
existing libraries.

If we need to embed a scripting language into an application: Neko
provides one of the best trade off available between simplicity,
extensibility and speed.


@section The Neko Virtual Machine


@noindent
Neko has a compiler and a virtual machine (@vm{}).  The @vm{} is both
lightweight and optimised so it offers fast code execution; it can be
easily embedded into any application and C language libraries are
directly accessible using the C language Foreign Function Interface
(@ffi{}).

The compiler converts a source file (conventionally with @code{.neko}
extension) into a bytecode file (conventionally with @code{.n}
extension) that can be executed with the @vm{}.  Although the compiler
is written in Neko itself, it is still very fast.  We can use the
compiler as standalone command line executable separated from the @vm{},
or as a Neko library to perform compile--and--run for interactive
languages.


@section @modneko{}


@noindent
Neko comes with several libraries.  One of these is @modneko{},
which embeds the Neko Virtual Machine into the Apache web server, so we
can use Neko to generate web pages.


@section About Neko


@noindent
Neko is developed as part of the Research and Development effort for
better languages at Motion--Twin.  The author of Neko is Nicolas
Cannasse and can be contacted at @email{ncannasse@@motion-twin.com}.

Neko is free software and the full source code is available under the
@gnu{} Lesser General Public License (@acronym{LGPL}).  Interested
people can join the mailing list:

@center @email{neko@@lists.motion-twin.com}
@center @url{http://www.nekovm.org/ml/}

@noindent
and visit Neko's web site:

@center @url{http://www.nekovm.org/}


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node programs
@chapter Invoking Neko programs


@menu
* nekoc::                       The language compiler.
* nekotools::                   Miscellaneous features.
* neko::                        The virtual machine boot program.
@end menu


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoc
@section The Neko language compiler


@cindex @command{nekoc}, the language compiler

@menu
* nekoc compile::               Compiling source files.
* nekoc release::               Cleaning bytecode for release.
* nekoc link::                  Linking together more bytecode files.
* nekoc dump::                  Dumping bytecode from a compiled file.
* nekoc normalise::             Source files normalisation.
* nekoc console::               Running the virtual machine interactively.
@end menu


@noindent
The program @command{nekoc} is the Neko language compiler: it produces
bytecode to be run under the @vm{}.  @ref{nekotools} for details on how
to produce standalone executables.

The synopsis of @command{nekoc} is:

@example
nekoc [options] file [file] ...
@end example

@noindent
the available options are:

@table @code
@item -d <BYTE_CODE_FILE>
dump bytecode for debugging; notice that when using @option{-d}: the
@option{-o} option is ignored;

@item -z <FILE>
make bytecode release; notice that when using @option{-z}: the
@option{-o} option is ignored;

@item -p <FILE>
parse and print Neko source; notice that when using @option{-p}: the
@option{-o} option is ignored;

@item -o <DIRECTORY>
select the output directory for compiled files;

@item -link <FILE>
link one or more bytecode files selected from the command line into the
unique file selected with @code{<FILE>}; notice that when using
@option{-link}: the @option{-o} option is ignored;

@item -console
run in console mode;

@item -v
turn on verbose mode;

@item --help
print the help screen and exit.
@end table

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoc compile
@subsection Compiling source files


@noindent
Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
we can compile it to produce the bytecode file @file{proof.n} with:

@example
$ nekoc proof.neko
@end example

@noindent
now we can run the code with:

@example
$ neko proof.n
@end example

More files can be compiled with a single run of @command{nekoc}:

@example
$ nekoc red.neko green.neko blue.neko
@end example

@noindent
to produce one bytecode file for each: @file{red.n}, @file{green.n},
@file{blue.n}.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoc release
@subsection Cleaning bytecode for release


@noindent
Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
that we have compiled with:

@example
$ nekoc proof.neko
@end example

@noindent
to produce the bytecode file @file{proof.n}.  We can clean up the
bytecode removing stuff that is not expected to be included in
production code with:

@example
$ nekoc -z proof.n
@end example

@noindent
this command will modify @file{proof.n} itself.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoc link
@subsection Linking together more bytecode files


@noindent
The @option{-link} option of @command{nekoc} allows us to append more
bytecode files into a single file so that the code is executed
sequentially.

Let's have the source file @file{red.neko}:

@example
// red.neko --

$print("this is a proof 01\n");

/// end of file
@end example

@noindent
and the source file @file{green.neko}:

@example
// green.neko --

$print("this is a proof 02\n");

/// end of file
@end example

@noindent
and we compile them with:

@example
$ nekoc red.neko green.neko
@end example

@noindent
to produce the two bytecode files @file{red.n} and @file{green.n}.  We
can produce a single bytecode file @file{proof} with:

@example
$ nekoc -link proof.n red green
@end example

@noindent
notice that the source bytecode files must be selected without
specifying the @code{.n} extension (damn!); now we can run the output
bytecode file:

@example
$ neko proof.n
@end example

Each source file has its own namespace: the variables declared in
@file{red.neko} are @strong{not} visible from the code in
@file{green.neko} and vice versa.  The only thing that linking does is
to append code to be executed in sequence.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoc dump
@subsection Dumping bytecode from a compiled file


@noindent
Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
that we have compiled with:

@example
$ nekoc proof.neko
@end example

@noindent
to produce the bytecode file @file{proof.n}.  We can convert the
bytecode into a human readable format using the @option{-d} option:

@example
$ nekoc -d proof.n
@end example

@noindent
which produces a file @file{proof.dump} in the same directory of
@file{proof.n} with contents similar to:

@example
nglobals : 2
nfields : 1
codesize : 4 ops , 7 total
GLOBALS =
  global 0 : string "this is a proof\n"
  global 1 : debug 7 ops 20 bytes
FIELDS =
  print                   C88B582D
CODE =
000000      0    AccGlobal 0
000002      1    Push
000003      2    AccBuiltin print
000005      3    Call 1
END
@end example

This is useful for debugging the compiler and to compare the performance
of alternative chunks of high level language code.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoc normalise
@subsection Source files normalisation


@noindent
The @option{-p} option of @command{nekoc} allows us to ``normalise'' the
source code and to detect errors without compiling; normalising means:
removing comments, properly indenting code, adding @code{;} characters
at the end of expressions.

To normalise a source file @file{proof.neko} we do:

@example
$ nekoc -p proof.neko
@end example

@noindent
which will produce a normalised file called @file{proof2.neko}.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoc console
@subsection Running the virtual machine interactively


@noindent
The @option{-console} option of @command{nekoc} runs the virtual machine
in a read--eval--print loop; we type a command and end the line with a
@code{!} followed by a return:

@example
$ nekoc -console
> 123!
123
> 1 + 2 !
3
> $print(123 + "\n") !
123
#function:-1
@end example

@noindent
to exit send an end--of--file character (@key{Control-d} on Unix like
terminals).


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekotools
@section Miscellaneous features


@cindex @command{nekotools}, miscellaneous features

@menu
* nekotools boot::              Building standalone executables.
* nekotools server::            Web server.
@end menu

@noindent
The program @command{nekotools} allows us to access a set of features
offered by the Neko programming environment.  The synopsis is:

@example
nekotools boot <BYTECODE_FILE>
nekotools server
@end example

@noindent
the available options are:

@table @code
@item --help
print the help screen and exit.
@end table

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekotools boot
@subsection Building standalone executables


@cindex Building standalone executables

@noindent
When run with the @code{boot} subcommand: @command{nekotools} reads a
single bytecode file and produces a standalone executable by prepending
to it the Neko virtual machine boot program and linking the two
together.

Let's have a source file @file{proof.neko} like this:

@example
// proof.neko --

$print("this is a proof\n");

/// end of file
@end example

@noindent
and we compile it to produce the bytecode file @file{proof.n}:

@example
$ nekoc proof.neko
@end example

@noindent
we can produce a standalone executable with:

@example
$ nekotools build proof.n
@end example

@noindent
now we can run the code with:

@example
$ ./proof
@end example

The executable will require the Neko shared library.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekotools server
@subsection Web server


@cindex Using the web server

@noindent
When run with the @code{server} subcommand: @command{nekotools} starts a
simple web server.  It is a very small web server that runs locally for
development purposes only; it mimics the same @api{} as @modneko{}.

In order to start the server we do:

@example
$ nekotools server
@end example

@noindent
by default it listens on port @code{2000} of localhost, so we can browse
the configuration page by visiting:

@center @url{http://localhost:2000/server:config}

From that page we can change the server base path to our website
directory and we can start browsing it.  If the site contains @code{.n}
Neko bytecode files, they will be loaded and executed just like Apache
@modneko{} does.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node neko
@section The Neko virtual machine boot program


@cindex Shared libraries
@cindex @code{.ndll}, extension of shared libraries

@noindent
The Neko virtual machine is one binary called @command{neko} included in
the @nvm{} distribution.  We can call it anytime using:

@example
$ neko file.n
@end example

@noindent
in order to execute the specified bytecode @code{file}.  Bytecode files
are precompiled Neko sources and have the @code{.n} extension; each
bytecode file is also called a @emph{module}.

@nvm{} can use platform specific shared libraries: @code{.so} on
Unix--like systems and @code{.dll} on Windows; these libraries must be
linked with Neko's library, @file{libneko.so} or @file{neko.lib}, and
use Neko's foreign functions interface and @api{}.  Each Neko library
can contain several primitives that can be used from a Neko program.
@ref{ffi} for how to define such primitives.

Shared libraries must be installed on the system with the @code{.ndll}
extension under a directory accessible by Neko.


@defvr {Environment Variable} NEKOPATH
Bytecode modules and shared libraries are searched in the local
directory but also using the @env{NEKOPATH} environment variable, which
can list several search paths separated by @code{:}.
@end defvr


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs
@chapter Neko language specification


@menu
* specs notation::              Notation for functions documentation.
* specs syntax::                Syntax of the language.
* specs values::                Values.
* specs flow::                  Execution flow.
* specs rtti::                  Runtime type information.
* specs funcs::                 Functions and function calls.
* specs objects::               Objects.
* specs array::                 Arrays.
* specs string::                Strings.
* specs exceptions::            Exceptions.
* specs hash tables::           Hash tables.
* specs goto::                  Labels and gotos.
* specs misc::                  Miscellaneous builtins.
* specs modules::               Modules.
@end menu


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs notation
@section Notation for functions documentation


@noindent
Here's the notation of types for function arguments and return values
that is used in the following language specification, and that should be
used when documenting libraries, too:

@enumerate
@item
the basic types are indicated with: @null{}, @code{int}, @code{float},
@code{bool}, @code{string}, @code{array}, @code{object},
@code{function};

@item
the type @code{any} means that any value is accepted;

@item
the type @code{void} is used for arguments when the function accepts no
arguments, and for the return value if the function is not supposed to
return a meaningful value;

@item
the type @code{number} is used if both @code{int} and @code{float} are
accepted;

@item
the type @code{function:N}, where @code{N} is a number, is used if a
function with @code{N} parameters is accepted;

@item
abstracts are indicated by a name associated to their kind; that name is
used with a single quote as prefix; for example: @code{'file} is an
abstract of kind @code{file};

@item
for arrays that contain values of a specified type: we write the type
first, followed by @code{array}; for example: @code{int array} is an
@code{array} containing only integers and @code{'file array array} is a
two dimensions array that contains abstract files;

@item
for objects that must contain some fields, we can use Neko notation for
types: @code{@{ x => int, y => int @}} which means an object having at
least two fields @code{x} and @code{y} of type @code{int};

@item
if the @null{} value is accepted as well as some other type, we can
write, for example @code{int?}, which means @code{int} or @null{};

@item
if several types are accepted we can separate them with pipe characters
@code{|}; for example: @code{number} is actually a shortcut for
@code{int | float};

@item
we can introduce our own names, prefixed with a sharp, by defining and
describing them in the documentation using, for example:

@example
#point = @{ x => int, y => int @}
@end example

if we do not define a type, but we just introduce its @code{#}--name,
the user of the library should not rely on its actual implementation
since we can change it in the future.
@end enumerate


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs syntax
@section Syntax of the language


@noindent
The syntax of the Neko language is designed to be easy to parse and easy
to generate.  It is not specifically designed to be written by a
programmer, but rather to be generated from a higher level language.
For example, one could easily write a @acronym{PHP}--to--Neko or a
Java--to--Neko converter that would generate equivalent code, but with
Neko syntax and semantics rather than those of @acronym{PHP} or Java.

In particular, there are no multiple levels of expressions as in C:
every statement is also an expression, thus enabling some constructs
that are not possible in other languages, for example:

@example
return if(x) @{ ... @} else @{ ... @}
@end example

@noindent
this simplifies the generation of Neko from functional languages.

The syntax is parsed using a left--to--right @acronym{LL(1)} parser:
after reading a token, we have enough information to know which
expression it will produce.  This allows for a very lightweight parser,
which is easy to improve without creating ambiguities.  Here's an
Abstract Syntax Tree (@acronym{AST}) description of the language syntax,
with the additional constraint that a program must be terminated by an
@acronym{EOF} (end of file):

@example
program :=
        | expr program
        | SEMICOLON program
        | _

ident :=
        | [a-zA-Z_@@] [a-zA-Z0-9_@@]*

binop :=
        | [!=*/<>&|^%+:-]+

value :=
        | [0-9]+
        | 0x[0-9A-Fa-f]+
        | [0-9]+ DOT [0-9]*
        | DOT [0-9]+
        | DOUBLEQUOTE characters DOUBLEQUOTE
        | DOLLAR ident
        | true
        | false
        | null
        | this
        | ident

expr :=
        | value
        | @{ program @}
        | @{ ident1 => expr1 , ident2 => expr2 ... @}
        | expr DOT ident
        | expr ( parameters )
        | expr [ expr ]
        | expr binop expr
        | ( expr )
        | var variables
        | while expr expr
        | do expr while expr
        | if expr expr [else expr]
        | try expr catch ident expr
        | function ( parameters-names ) expr
        | return [expr | SEMICOLON]
        | break [expr | SEMICOLON]
        | continue
        | ident :
        | switch expr @{ switch-case* @}
        | MINUS expr

variables :=
        | ident [= expr] variables
        | COMMA variables
        | _

parameters :=
        | expr parameters
        | COMMA parameters
        | _

parameters-names :=
        | ident parameters-names
        | COMMA parameters-names
        | _

switch-cases :=
        | default => expr
        | expr => expr
@end example

Random notes:

@itemize
@item
@code{_} represents an empty expression;

@item
@code{continue} and @code{break} are not allowed outside of a
@code{while} loop;

@item
there are a few ambiguous cases when two expressions follow each other
(as in @code{while} and @code{if}); if the second expression is inside
parenthesis, it will be parsed as a call of first expression, because
such a representation @code{e1 (e2)} exists in the @acronym{AST} (the
semicolons are optional);

@item
arithmetic operations have the following precedences (from least to
greatest):

@enumerate
@item
assignments;
@item
@code{++=} and @code{--=};
@item
@code{&&} and @code{||};
@item
comparisons;
@item
@code{+} and @code{-};
@item
@code{*} and @code{/};
@item
@code{|}, @code{&} and @code{^};
@item
@code{<<}, @code{>>}, @code{>>>} and @code{%}.
@end enumerate
@end itemize

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs values
@section Values.


@noindent
A value in Neko can be one of the following:

@table @emph
@item Null
the special value @null{} is used for uninitialised variables as well as
programmer/language specific coding techniques;

@item Integer
integers can be represented in either decimal form (such as @code{12345}
or @code{-12}), or hexadecimal (such as @code{0x1A2B3C4D});

@item Floats
floating--point numbers are represented using a period (such as
@code{12.345} or @code{-0.123});

@item Boolean
the two booleans are represented by the lowercase identifiers @true{}
and @false{};

@item Strings
strings are surrounded by double quotes; examples:

@example
"foo"
"hello,\nworld!"
"My name is \"Bond\\James Bond\"."
@end example

@noindent
strings are mutable, which means that we can modify them;

@item Arrays
arrays are integer--indexed tables of values, with indices starting at
0; they provide fast random access to their elements;

@item Objects
an object is a table, which associates an identifier or a string to a
value;

@item Functions
a function is also a value in Neko, and thus can be stored in any
variable;

@item Abstract
an abstract value is some C language data that cannot be directly
accessed from a Neko program.
@end table

Some notes:

@itemize
@item
integers have 31 bits for virtual machine performance reasons; an @api{}
for full 32 bits integers is available through a standard library;

@item
floating--point numbers are 64 bits double--precision floating points
values;

@item
strings are sequences of 8 bits bytes; a string can contain @code{\0}
characters; the length of a string is determined by the number of bytes
in it, and not by the number of characters before the first @code{\0}.
@end itemize


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow
@section Execution flow


@noindent
Here's some explanation on how each expression is evaluated.

@menu
* specs flow values::           Evaluation of values.
* specs flow exprs::            Evaluation of expressions.
* specs flow vars::             Handling of variables.
* specs flow ops::              Operations on basic types.
@end menu


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow values
@subsection Evaluation of values


@table @code
@item [0-9]+ | 0x[0-9A-Fa-f]+
evaluates to the corresponding integer value;

@item [0-9]+ DOT [0-9]* | DOT [0-9]+
evaluates to the corresponding floating--point number;

@item DOUBLEQUOTE characters DOUBLEQUOTE
evaluates to the corresponding string; escaped characters are similar to
the C language ones;

@item DOLLAR ident
identifiers prefixed with a dollar sign are built in opcodes; they
enable us to call some compiler constructors or do optimised function
calls;

@item true | false
evaluate to the corresponding boolean;

@item null
evaluates to the @emph{Null} value;

@item this
evaluates to the local ``object value'' (@ref{specs objects} for
details);

@item ident
evaluates to the value currently bound to this variable name.
@end table

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow exprs
@subsection Evaluation of expressions


@noindent
Before evaluating any expression, all subexpressions are evaluated in an
unspecified order; @code{v} here represent the value obtained from
evaluation of subexpressions:

@table @code
@item @{ v1; v2; ...; vk @}
the evaluation order follows the order of the declarations; the value of
the last expression, @code{vk}, is returned as result, unless the
program does not contain any expressions, in which case it returns
@null{};

@item @{ i1 => v1 , i2 => v2 ... @}
this will create an object with fields @code{i1...ik} set to the values
@code{v1...vk}; it might be more optimised than setting the fields
one--by--one on an empty object;

@item v DOT ident
@code{v} is accessed as an object using @code{ident} as a key;

@item v ( v1, v2, ... vk )
the function @code{v} is called with the parameters @code{v1, v2... vk};

@item v [ v1 ]
@code{v} is accessed as an array using @code{v1} as the index;

@item v1 binop v2
calculates @code{v1 binop v2};

@item expr = v
this is a special case when the operation is an assignment;

@item ( v )
evaluates to @code{v};

@item var i1 = v1, i2 = v2, .... ik = vk
each variable @code{i} is set to the corresponding value @code{v}, or to
@null{} if no initialisation expression is provided;

@item while .... | do ... while ...
implements the classic @code{while} loop; its value is the one returned
by a @code{break} inside the @code{while}, or unspecified if the loop
ends without using @code{break};

@item if v1 e1
if @code{v1} is the boolean @true{}, then @code{e1} is evaluated and its
value returned; otherwise, its value is unspecified;

@item if v1 e1 else e2
if @code{v1} is the boolean @true{}, then @code{e1} is evaluated and its
value returned; otherwise @code{e2} is evaluated and its value returned;

@item try e1 catch i e2
evaluates e1 and returns its value; if an exception is raised while
evaluating @code{e1}, then @code{e2} is evaluated, with the local
variable @code{i} being set to the raised exception value; if an
exception is raised: the value of the @code{try...catch} block is the
result of evaluating @code{e2};

@item function ( parameters-names ) expr
evaluates to the corresponding function;

@item return ;
exits the current function with an unspecified return value;

@item return v
exits the current function and returns @code{v};

@item break ;
exits the current @code{while} loop with an unspecified return value;

@item break v
exits the current @code{while} loop and returns value @code{v};

@item continue
skips the rest of the loop body and jumps to the start of the loop,
reevaluating the loop condition;

@item ident :
a label;

@item switch e @{ e1a => e1b e2a => e2b .... default => edef @}
evaluates @code{e} and tests it against each @code{eia} sequentially
until it is found to be equal, then returns value of the corresponding
expression @code{eib}; if no value is found to be equal to @code{e}, the
value of the @code{edef} expression is returned; @null{} is returned if
@code{default} is not specified.
@end table

Please note that the conditions of @code{if} and @code{while} only
consider the boolean @true{} to be true.  We might need to add a
@builtin{istrue} opcode before each expression in order to convert the
expression result into a boolean.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow vars
@subsection Handling of variables


@noindent
When an identifier is found, it must be resolved to a scope containing
the variable's value.  The search starts in the local scope.


@subsubsection Local scope


@noindent
The local scope contains all variables defined with the @code{var}
keyword in previous syntactical blocks.  In the following sample
@code{x} resolves to the value @code{3}:

@example
var x = 3;
$print(x);
@end example

A @code{var} declaration is local to the curly--braced block it has been
declared in; for example:

@example
var x = 3;
// x defined
if( ... ) @{
  // x defined
  var y;
  // x and y defined;
@}
// x defined
@end example

The same variable name can be reused in the same block or another block;
it will shadow or erase previous values:

@example
var x = 1;
$print(x); // print 1
var x = 3;
$print(x); // print 3
if( ... ) @{
  var x = "neko";
  $print(x); // print "neko"
@}
$print(x); // print 3
@end example

Function parameters are also local variables; they are defined within
the whole function:

@example
var x = 3;
f = function(x) @{
  $print(x);
@}
f("neko"); // print "neko"
@end example

Since scoping is resolved at a purely syntactic level, local variables
do not depend the on the current call stack, and we cannot access
variables defined outside the current local scope:

@example
f = function() @{
  $print(x);
@}
...
var x = 3;
f(); // will print "null"
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@subsubsection Function scope


@noindent
Local variables can be used inside functions if they're accessible at
the time the function is declared.  In this case, the value of the
variable is a copy of its value at the time the function was defined:

@example
var x = 3;
f = function() @{
  $print(x);
@}
x = 4;
f(); // print 3
@end example

Such variables are called ``environment variables'' because they're no
longer part of the local context but of the function's ``environment''
context.  A function can still modify an environment variable, but this
will not modify the original variable reference:

@example
var x = 3;
f = function() @{
  $print(x);
  x = x + 1;
@}
x = 50;
f(); // print 3
f(); // print 4
$print(x); // print 50
@end example

Please note also that each function instance has its own environment:

@example
gen = function() @{
  var i = 0;
  return function() @{ $print(i); i = i + 1; @};
@}
f1 = gen();
f2 = gen();
f1(); // print 0
f1(); // print 1
f2(); // print 0
f1(); // print 2
...
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@subsubsection Global scope


@noindent
When a variable is not found in the local scope or in the local function
environment, it is a global variable.  A global variable can be accessed
throughout the whole file, it is shared among all code.

@example
f = function() @{
  $print(x);
  x = x + 1;
@}
x = 0;
f(); // print 0
f(); // print 1
$print(x); // print 2
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops
@subsection Operations on basic types


@menu
* specs flow ops arithmetic::   Arithmetic operations.
* specs flow ops bitwise::      Bitwise operations.
* specs flow ops boolean::      Boolean operations.
* specs flow ops logic::        Logic operations.
* specs flow ops comparison::   Equality and comparison.
* specs flow ops assignment::   Assignment.
* specs flow ops conversion::   Conversion.
@end menu


@noindent
Basic types are numbers (integer and float), booleans (bool), the
@null{} value, strings, objects, arrays and functions.  There are
several operations available for them.

In the following tables: on the row is the type of the first operand, on
the column is the type of the second operand; an @code{X} means that the
operation is invalid and will raise an exception.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops arithmetic
@subsubsection Arithmetic operations


@findex @code{+}
@findex @code{-}
@findex @code{*}
@findex @code{/}
@findex @code{%}
@findex @code{__add}
@findex @code{__radd}

@noindent
Operation addition (@code{+}): the result is either the type of the
returned value, or @code{concat} if we use string concatenation (in that
case, the two values are converted to strings and then concatenated
together).

@example
+        | null    int     float   string  bool    object  array   function
---------+-----------------------------------------------------------------
null     | X       X       X       concat  X       __radd  X       X
int      | X       int     float   concat  X       __radd  X       X
float    | X       float   float   concat  X       __radd  X       X
string   | concat  concat  concat  concat  concat  __radd  concat  concat
bool     | X       X       X       concat  X       __radd  X       X
object   | __add   __add   __add   __add   __add   __add   __add   __add
array    | X       X       X       concat  X       __radd  X       X
function | X       X       X       concat  X       __radd  X       X
@end example

Addition can be overridden for objects: @code{a + b} will call
@code{a.__add(b)} if @code{a} is an object, or @code{b.__radd(a)} if
@code{b} is an object.

Operations subtraction (@code{-}), division (@code{/}), multiplication
(@code{*}) and modulo (@code{%}):

@example
- / * % | int                  float
--------+---------------------------
int     | int (float for /)    float
float   | float                float
@end example

@noindent
note that unlike some languages: the division operation between two
integers returns a float; we can use the @builtin{idiv} built in to
perform integer division.

Dividing or taking the modulo of one integer by the integer or float 0
is hardware--dependent and usually returns the float @code{+infinity}
for division, and NaN (not a number) for modulo.  We can test this using
the @builtin{isnan} and @builtin{isinfinite} built in operations:

@example
$print($isinfinite(1/0));       // prints true
$print($isnan(0/0));            // prints true
@end example

Arithmetic operations are can be overridden by objects.

Note also that overflow on integer operations does not convert them to
floats, and does not throw an exception.  If we want to control
overflow, we can: define our own functions for operations, use floats
everywhere, or use an object with overridden operators.


@deftypefn {Neko Builtin} int $iadd (@var{a} : int, @var{b} : int)
@deftypefnx {Neko Builtin} int $isub (@var{a} : int, @var{b} : int)
@deftypefnx {Neko Builtin} int $imult (@var{a} : int, @var{b} : int)
@deftypefnx {Neko Builtin} int $idiv (@var{a} : int, @var{b} : int)
These operations on integers are optimised for speed; they all skip some
type checks, so they're faster.

Their results will always be a valid integer, but their value is
unspecified when one ore more of the two values is not an integer.
@builtin{idiv} raises an exception when division by @code{0} is
attempted:

@example
$print( $iadd(1,3) ); // 4
$print( $idiv(5,2) ); // 2
$print( $idiv(1,0) ); // exception
@end example
@end deftypefn


@deftypefn {Neko Builtin} bool $isnan (@var{n} : any)
Return @true{} if a value is the float NaN.
@end deftypefn


@deftypefn {Neko Builtin} bool $isinfinite (@var{n} : any)
Return if a value is the float @code{+Infinite}.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops bitwise
@subsubsection Bitwise operations


@noindent
The following operations are available for integers only.  For
performance reasons, Neko integers are signed and have 31 bits only, so
the ``unsigned'' part is of 30 bits only.


@deffn {Bitwise Binary Operation} <<
Left bit shift.
@end deffn

@deffn {Bitwise Binary Operation} >>
Right bit shift.
@end deffn

@deffn {Bitwise Binary Operation}>>>
Right unsigned bit shift.
@end deffn

@deffn {Bitwise Binary Operation} |
Or bits.
@end deffn

@deffn {Bitwise Binary Operation} &
And bits.
@end deffn

@deffn {Bitwise Binary Operation} ^
Xor bits.
@end deffn

Using these operations with one or more non--integer operands will raise
an exception.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops boolean
@subsubsection Boolean operations


@findex @builtin{istrue}
@findex @builtin{not}

@deftypefn {Neko Builtin} bool $istrue (@var{v} : any)
Convert any value to a boolean.  The result of applying @builtin{istrue}
to a value depends on its type:

@table @asis
@item @null{}
yields @false{};

@item integer
yields @false{} if @code{0}, @true{} otherwise;

@item boolean
yields the boolean itself;

@item float
@itemx string
@itemx object
@itemx array
@itemx function
yields @true{};
@end table

@noindent
only the values @null{}, @false{}, and @code{0} (integer) evaluate to
@false{}.
@end deftypefn


@deftypefn {Neko Builtin} bool $not (@var{v} : any)
The inverse of @builtin{istrue}; return the opposite of the boolean that
would have been returned by @builtin{istrue}: @true{} if @var{v} is
@false{} or @null{} or @code{0}.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops logic
@subsubsection Logic operations


@findex @code{&&}
@findex @code{||}

@noindent
Logic boolean operations are short--circuited: if the first operand of
an @code{&&} is false or the first operand of an @code{||} is true, then
the second operand is not evaluated, and the first value is returned;
otherwise, the second value is returned.

Notice that no automatic conversion to boolean is done: @code{a && b} is
equivalent to @code{if (a == false) b else a} and @code{a || b} is
equivalent to @code{if (a == true) a else b} with @code{a} being
evaluated only once.  We might prefer to call @builtin{istrue} on each
argument before performing the operation.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops comparison
@subsubsection Equality and comparison


@noindent
Comparison occurs when the following operations are performed.

@deffn {Comparison Operation} ==
Equality: evaluate to @true{} if the operands are equal.
@end deffn

@deffn {Comparison Operation} !=
Inequality: evaluate to @true{} if the operands are @strong{not} equal.
@end deffn

@deffn {Comparison Operation} >
Greater than: evaluate to @true{} if the left side operand is greater
than the right side one.
@end deffn

@deffn {Comparison Operation} <
Greater than: evaluate to @true{} if the left side operand is less than
the right side one.
@end deffn

@deffn {Comparison Operation} >=
Greater than: evaluate to @true{} if the left side operand is greater
than or equal to the right side one.
@end deffn

@deffn {Comparison Operation} <
Greater than: evaluate to @true{} if the left side operand is less than
or equal to the right side one.
@end deffn

@deftypefn {Comparison Operation} int? $compare (@var{a}, @var{b})
The low level comparison function; it has the classic ternary result.
The following table shows the comparison method used depending on the
type of operands:

@example
$compare | null int    float  string bool   object array function
---------+-------------------------------------------------------
null     | 0    -      -      -      -      -      -     -
int      | -    icmp   fcmp   strcmp -      -      -     -
float    | -    fcmp   fcmp   strcmp -      -      -     -
string   | -    strcmp strcmp strcmp strcmp -      -     -
bool     | -    -      -      strcmp bcmp   -      -     -
object   | -    -      -      -      -      ocmp   -     -
array    | -    -      -      -      -      -      acmp  -
function | -    -      -      -      -      -      -     acmp
@end example

Here are the details of each comparison function:

@table @code
@item icmp
compares two integers @code{a} and @code{b}: it returns @code{0} if
they're equal, @code{-1} if @code{b < a}, and @code{+1} if @code{a > b};

@item fcmp
is the same as @code{icmp}, but compares floats instead of integers;

@item strcmp
compares strings; it can be seen as @code{icmp} applied to every byte of
the two strings;

@item acmp
compares the addresses of @code{a} and @code{b}; it returns @code{0} if
they're equal, @null{} otherwise;
@c @code{-1} if @code{a < b}, and @code{+1} if @code{a > b};

@item bcmp
returns @code{0} if @code{a} and @code{b} are both true or both false,
@code{+1} if @code{a} is true and @code{b} and false, and @code{-1} if
@code{a} is false and @code{b} is true;

@item ocmp
does ``object comparison''; if the two objects' addresses are equal,
then it returns @code{0}; otherwise it calls the method @code{__compare}
on the first object, with the second object as argument; if the returned
value is an integer, the integer is returned by @builtin{compare}, else
@null{} is returned;

@item -
means that the comparison is invalid, the returned value is @null{} when
using @builtin{compare} and @false{} when using an operator.
@end table
@end deftypefn


The following table shows how each operation is performed depending on
the result of @builtin{compare}:

@example
op  |   null    -1      0       1
----+--------------------------------
==  |   false   false   true    false
!=  |   true    true    false   true
<=  |   false   true    true    false
<   |   false   true    false   false
>=  |   false   false   true    true
>   |   false   false   true    true
@end example


@deftypefn {Comparison Operation} int? $pcompare (@var{a}, @var{b})
Compare two values physically; it will be the same result as
@builtin{compare} for integers, while other values will be compared
using their memory address.  We can use @builtin{pcompare} instead of
@builtin{compare} if we want to optimise our integer comparisons.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops assignment
@subsubsection Assignment


@findex @code{=}
@findex @code{+=}
@findex @code{-=}
@findex @code{*=}
@findex @code{/=}
@findex @code{%=}
@findex @code{<<=}
@findex @code{>>=}
@findex @code{>>>=}
@findex @code{|=}
@findex @code{&=}
@findex @code{^= }
@findex @code{++=}
@findex @code{--=}

@noindent
The following operations are available to modify the value of a
variable, object field, array slot@dots{}

The standard assignment operator is @code{=}; there are also the
following augmented assignment operators which perform an operation at
the same time; the return value is always the assigned value:

@example
+= -= *= /= %= <<= >>= >>>= |= &= ^=
@end example

There are two additional operators @code{++=} and @code{--=} which do
the same thing as @code{+=} and @code{-=}, except that the returned
value is the value of the variable before it was modified:

@example
a = 0;
$print(a ++= 1);        // 0
$print(a ++= 1);        // 1
$print(a);              // 2
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs flow ops conversion
@subsubsection Conversion


@findex @code{__string}
@cindex @code{#object}


@deftypefn {Neko Builtin} int $int (@var{value} : string|float)
Convert a string or a float to an integer; return @null{} if the
argument cannot be converted to an integer.  Examples:

@example
$int(45.67);     // 45
$int("67.87");   // 67
$int($array(4)); // null
@end example
@end deftypefn


@deftypefn {Neko Builtin} float $float (@var{value} : string|integer)
Convert a string or integer to a float; return @null{} if the argument
cannot be converted to an integer.  Examples:

@example
$float("1.345");   // 1.345
$float(12345);    // 12345.0000
$float($array()); // null
@end example
@end deftypefn


@deftypefn {Neko Builtin} string $string (@var{value} : any)
Convert a value to a string.  Any value can be converted to a string
using @builtin{string}, this operation is used in particular by the
@builtin{print} operation.  Examples:

@example
$string(null);          // "null"
$string(123);           // "123"
$string($array(1,2,3)); // "[1,2,3]"
@end example

On objects: @builtin{string} calls the @function{__string} method on the
object if it exists; if the returned value is a string, this string is
returned, else the string @code{#object} is returned.

On functions: @code{#function:<N>} is returned where @code{<N>} is the
number of arguments of the function (or @code{-1} if multiple
arguments).
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs rtti
@section Runtime type information


@noindent
No matter if our language is statically or dynamically typed, we can
always access @rtti{} in Neko.  @rtti{} is powerful because we can
decide which behaviour to adopt depending on some value at runtime.  The
most common application of this is to print some debugging information.
Another one is introspection: the ability to look inside an object, read
its fields, and call its methods.


@deftypefn {Neko Builtin} int $typeof (@var{value} : any)
Return an integer specifying the type of a value according to the
following table:

@multitable {abstract} {Constant's symbolic name} {Constant's numeric value}
@headitem Type @tab Constant's symbolic name @tab Constant's numeric value
@item null @tab @code{$tnull} @tab 0
@item int @tab @code{$tint} @tab 1
@item float @tab @code{$tfloat} @tab 2
@item bool @tab @code{$tbool} @tab 3
@item string @tab @code{$tstring} @tab 4
@item object @tab @code{$tobject} @tab 5
@item array @tab @code{$tarray} @tab 6
@item function @tab @code{$tfunction} @tab 7
@item abstract @tab @code{$tabstract} @tab 8
@end multitable

@ignore
@example
Type     | Constant's symbolic name | Constant's numeric value
---------+--------------------------+-------------------------
null     | $tnull                   | 0
int      | $tint                    | 1
float    | $tfloat                  | 2
bool     | $tbool                   | 3
string   | $tstring                 | 4
object   | $tobject                 | 5
array    | $tarray                  | 6
function | $tfunction               | 7
abstract | $tabstract               | 8
@end example
@end ignore

Examples:

@example
$typeof(3);              // 1
$typeof($array(1,2));    // 6
$typeof(null) == $tnull; // true
@end example
@end deftypefn

We can use the builtins for objects, strings, functions and arrays to
manipulate them at runtime.

@defvr {Neko Variable} $tnull
@defvrx {Neko Variable} $tint
@defvrx {Neko Variable} $tfloat
@defvrx {Neko Variable} $tbool
@defvrx {Neko Variable} $tstring
@defvrx {Neko Variable} $tobject
@defvrx {Neko Variable} $tarray
@defvrx {Neko Variable} $tfunction
@defvrx {Neko Variable} $tabstract
Variables holding integer identifiers for Neko built in data types.
@end defvr


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs funcs
@section Functions and function calls


@findex @code{function}

@noindent
Defining new functions is easy: since functions are values, we can
simply assign them to a local or a global variable:

@example
var foo = function() @{
  return 0;
@}
@end example

Functions are called by--value, which means that @code{foo(1)} calls the
function which is the value of the variable @code{foo}.  Calling a value
that is not a function or that does not accept the given number of
arguments will raise an exception.

We can retrieve the number of arguments needed by a function by using
the built in operation @builtin{nargs}; when @builtin{nargs} is applied
to a function that accepts a variable number of arguments: the return
value is @code{-1}.  Note note also that built in operations can be used
as values:

@example
$print($nargs(function(a,b) @{ return a + b; @});    // prints 2
$print($nargs($print));                            // prints -1
$print($nargs(0));                                 // exception
@end example

The built in operation @builtin{call} takes an array of arguments and a
object context as parameters; it can be useful for introspection:

@example
// call the foo function with null context
// and the two parameters 3 and 4
$call(foo,null,$array(3,4));
@end example

Functional languages require partial application (aka currying): the
ability to create closures by setting a fixed number of arguments of a
function, leaving the rest for later call.  The built in operation
@builtin{closure} enables us to create a closure:

@example
var add   = function(x,y) @{ return x + y @};
var plus5 = $closure(add,null,5); // null context and
                                  // 5 as first argument
$print(plus5(2)); // prints 7
@end example

@builtin{closure} can also be used to fix the @code{this} context of a
function:

@example
var f = function() @{ $print(this) @};
f = $closure(f,55);
f(); // prints 55
@end example

Some languages might want more security about the types of the arguments
that are passed to a function, or selecting at runtime different
implementations of a function depending on the type of the arguments.
There are many ways of doing that in Neko; for example, we might want to
add arguments checks at the beginning of the function body using @rtti{}
built in operations.

Another useful built in operation is @builtin{apply} which is identical
to a direct function call except that if the function requires extra
arguments then its call is delayed until further arguments are used:

@example
var f = function(x,y) @{ return x + y @};
f(1,2);
$apply(f,1)(2); // equivalent
$apply(f,1,2); // equivalent
@end example


@deftypefn {Neko Builtin} int $nargs (@var{f} : function)
Return the number of arguments of a function.  If the function has a
variable number of arguments: the return value is @code{-1}.
@end deftypefn


@deftypefn {Neko Builtin} any $call (@var{f} : function, @var{this} : any, @var{args} : array)
Call @var{f} with @var{this} context and @var{args} arguments.
@end deftypefn


@deftypefn {Neko Builtin} function $closure (@var{f} : function, ... : any)
Build a closure by applying a given number of arguments to a function.
@end deftypefn


@deftypefn {Neko Builtin} any $apply (@var{f} : function, ... : any)
Apply the function to several arguments.  Return a function asking for
more arguments or the function result if more arguments are needed.
@end deftypefn


@deftypefn {Neko Builtin} function $varargs (@var{f} : function:1)
Return a variable arguments function that, when called, will callback
@var{f} with the array of arguments.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects
@section Objects


@menu
* specs objects making::        Creating objects.
* specs objects access::        Setting and getting values.
* specs objects inspect::       Inspecting objects.
* specs objects methods::       Defining methods.
* specs objects overloading::   Operators overloading.
* specs objects protos::        Prototypes.
* specs objects misc::          Other functions.
@end menu


@noindent
Objects are some kind of optimised hash tables.  All fields names are
hashed into an integer value that is used as the key into a look up
table.  Insertion of a new field is O(n), access to a field is O(log n).
If we're generating Neko code from a statically typed programming
language, we might prefer arrays for storing fields, since they provide
O(1) access.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects making
@subsection Creating objects


@deftypefn {Neko Builtin} object $new (@var{o} : object?)
Create and return an object.  The return value is a copy of the existing
object @var{o} or a new, empty, object if @var{o} is @null{}:

@example
o  = $new(null); // new empty object
o2 = $new(o);    // makes a copy of "o"
@end example

@noindent
if @var{o} is not an object or @null{}: throw an exception.
@end deftypefn


Access to object fields is done using the dot operator:

@example
var o   = $new(null);
o.field = value;
$print(o.field);
@end example

@noindent
but also with the built in operations @builtin{objset} and
@builtin{objget}.  @ref{specs objects access} for details.

To create a new object we can write a constructor function that
allocates an object and adds all the mandatory fields:

@example
var colour_constructor = function (red, green, blue) @{
  var o = $new(null);

  o.red   = red;
  o.green = green;
  o.blue  = blue;
  return o;
@};
@end example

@noindent
one other way to declare objects is to use the following notation, which
is more efficient when we want to initialise several fields at the same
time:

@example
var o = @{
  x   => 0,
  y   => -1,
  msg => "hello"
@}
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects access
@subsection Setting and getting values


@deftypefn {Neko Builtin} int $hash (@var{s} : string)
Return the hashed value of a field's name, or raise an exception in case
of collision.
@end deftypefn


@deftypefn {Neko Builtin} any $objset (@var{o} : object, @var{field_id} : int, @var{value} : any)
Set the field identified by @var{field_id} in @var{o} to @var{value} and
return @var{value} if @var{o} is an object or @null{} otherwise.
Example:

@example
var o = $new(null);
$objset(o, $hash("field"), "value");
@end example

@noindent
the field identifier is an integer that can be generated by the
@builtin{hash} built in operation.

If a field does not exist: it is added by @builtin{objset}; the same
happens when the field is set using the dot operator.
@end deftypefn


@deftypefn {Neko Builtin} any $objget (@var{o} : object, @var{field_id} : int)
Return the field identified by @var{field_id} in @var{o}, or @null{} if
the such field does not exist or @var{o} is not an object.  Example

@example
var o  = $new(null);
var id = $hash("field");
$objset(o, id, "value");
$print($objget(o, id));
@end example

If a field is not defined when accessed for reading: @null{} is
returned.
@end deftypefn


Field names are first hashed into integer values for faster access.
Notice that the second parameter of @builtin{objset} and
@builtin{objget} is hashed at runtime, while when using the dot operator
the field names are hashed by the compiler.  So using the explicit built
in operations is a bit less efficient than dot access, but it enables
introspection.

In order to avoid collisions among hashed values, they are stored in a
global table: Neko will use the table to make sure that @code{$hash(x)
== $hash(y)} implies @code{x == y}.  Another purpose of this feature is
to be able to reverse the hash function at runtime; this can be useful
to print the field names of an object, for debugging or other purposes.


@deftypefn {Neko Builtin} string $field (@var{n} : int)
Reverse the hashed value of a field's name.  Return @null{} if @var{n}
is not in the table of fields.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects inspect
@subsection Inspecting objects


@deftypefn {Neko Builtin} bool $objfield (@var{o} : object, @var{field_id} : int)
Check for a field existence; return true if @var{o} is an object which
has a field identified by @var{field_id}.  This operation works even if
the field is set to @null{}.  Example:

@example
$objfield(o, $hash("field"));    // true if "o" has "field"
$objfield(null, 33);             // false
@end example
@end deftypefn


@deftypefn {Neko Builtin} {int array} $objfields (@var{o} : object)
Return an array containing all the field identifiers for the given
object:

@example
var a = $objfields(o);
var i = 0;
while( i < $asize(a) ) @{
  var fname = $field(a[i]);
  var fval  = $objget(o,a[i]);
  $print( fname + " = " + fval + "\n" );
  i = i + 1;
@}
@end example
@end deftypefn


@deftypefn {Neko Builtin} void $setresolver (@var{f} : function:2?)
Set a function to callback, with object and field id as arguments, when
an object field is not found.
@end deftypefn


The @builtin{setresolver} feature can be useful, for example, to
implement ``virtual'' fields.  The following is a raw example:

@example
math_pow   = $loader.loadprim("std@@math_pow",   2);
math_sqrt  = $loader.loadprim("std@@math_sqrt",  1);
math_atan2 = $loader.loadprim("std@@math_atan2", 2);

var slot_resolver = function (object, field_id) @{
  switch (object.class) @{
    $hkey("position") =>
      return switch (field_id) @{
        $hash("theta") =>
          math_atan2(object.y, object.x)
        $hash("rho") =>
          math_sqrt(math_pow(object.x, 2) +
                    math_pow(object.y, 2))
      @}
    default => $throw("unknown class")
  @}
@};

$setresolver(slot_resolver);

var s   = $new(null);
s.class = $hkey("position");
s.x     = 3;
s.y     = 4;

$print("rho = " + s.rho + " theta = " + s.theta "\n");
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects methods
@subsection Defining methods


@cindex @code{this}

@noindent
A method is a function stored in an object field.  When a function is
called using the dot operator or the built in operation
@builtin{objcall}, the function can access a special variable named
@code{this} which is the ``object context'' (the object with which the
function was called):

@example
o     = $new(null);
o.x   = 1;
o.add = function(y) @{ return this.x + y; @}

$print(o.add(2));                              // prints 3
$print( $objcall(o,$hash("add"),$array(2)) );  // prints 3
@end example

The context is set when an object function is called and can be accessed
from any sub function:

@example
foo = function() @{
  $print(this.x);
@}
o     = $new(null);
o.x   = 3;
o.bar = function() @{ foo(); @};
o.bar(); // prints 3
@end example

We can modify the value of @code{this} at runtime by simply assigning
it to another value; it can be set to any value, not only objects.  When
returning from an object call, the context is restored, so any
modification is lost:

@example
this = 1;
o.foo = function() @{
  // here , we have this = o;
  this = 2; // modify
@};
o.foo();
$print(this); // 1
@end example


@deftypefn {Neko Builtin} any $objcall (@var{o} : any, @var{field_id} : int, @var{args} : array)
Call the function stored in the field identified by @var{field_id} in
@var{o} with arguments taken from the array @var{args}; return the
return value of the function or @null{} if @var{o} is not an object.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects overloading
@subsection Operators overloading


@noindent
Several operators can be overloaded: when they're applied to objects
they are actually calling methods.  If the overloaded method is not
defined when an operation occurs, an exception is raised.

The specified type of return values is the type that the method is
expected to return; when this type is @code{any}, it means that the type
of the return value is free: it can depend on the method implementation.


@deftypefn {Neko Method} string __string (void)
String conversion.  Call the method on the object with no arguments; a
string should be returned.
@end deftypefn


@deftypefn {Neko Method} int __compare (@var{b} : any)
Compare two different objects.  The method is called with the first
object stored in @code{this} and the second object as parameter.

Notice that, as per the specs of Neko: comparison between an object and
a non--object returns @null{} directly, without examining the fields of
the object itself.  This means that @function{__compare} is invoked only
whenever a comparison between two objects happens, and the invoked
@function{__compare} is the one of the objects to the left.  Neko does
not support the @function{__rcompare} method.
@end deftypefn


@deftypefn {Neko Method} any __add (@var{b} : any)
@deftypefnx {Neko Method} any __radd (@var{a} : any)
Add two objects.  In the case of @code{a + b}, if @code{a} is an object:
@code{a.__add(b)} is called; else if @code{b} is an object,
@code{b.__radd(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __sub (@var{b} : any)
@deftypefnx {Neko Method} any __rsub (@var{a} : any)
Subtract two objects.  In the case of @code{a - b}, if @code{a} is an
object: @code{a.__sub(b)} is called; else if @code{b} is an object,
@code{b.__rsub(a)} is called.

Notice that the unary negative operator is converted by Neko into the
subtraction: @code{0 - number}; so it is handled by the @function{__sub}
method.
@end deftypefn


@deftypefn {Neko Method} any __mult (@var{b} : any)
@deftypefnx {Neko Method} any __rmult (@var{a} : any)
Multiply two objects.  In the case of @code{a * b}, if @code{a} is an
object: @code{a.__mult(b)} is called; else if @code{b} is an object,
@code{b.__rmult(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __div (@var{b} : any)
@deftypefnx {Neko Method} any __rdiv (@var{a} : any)
Divide two objects.  In the case of @code{a / b}, if @code{a} is an
object: @code{a.__div(b)} is called; else if @code{b} is an object,
@code{b.__rdiv(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __mod (@var{b} : any)
@deftypefnx {Neko Method} any __rmod (@var{a} : any)
Compute the modulo of an object with respect to another.  In the case of
@code{a % b}, if @code{a} is an object: @code{a.__mod(b)} is called;
else if @code{b} is an object, @code{b.__rmod(a)} is called.
@end deftypefn


@deftypefn {Neko Method} any __get (@var{i} : int)
Called when an object is accessed as an array for reading, using
@code{a[i]} actually calls @code{a.__get(i)}.
@end deftypefn


@deftypefn {Neko Method} any __set (@var{i} : int)
Called when an object is accessed as an array for writing, using
@code{a[i] = v} actually calls @code{a.__set(i,v)}.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects protos
@subsection Prototypes


@findex @builtin{objgetproto}
@findex @builtin{objsetproto}

@noindent
Each object can have a ``prototype'' which is also an object.  When a
field is accessed for reading and is not found in an object, it is
searched in its prototype, then in the prototype of the prototype, and
so on recursively.

Prototypes can be accessed using @builtin{objgetproto} and
@builtin{objsetproto}:

@example
var proto = $new(null);
proto.foo = function() @{ $print(this.msg) @}
 
var o = $new(null);
o.msg = "hello";
$objsetproto(o,proto);
o.foo(); // print "hello"
 
$objsetproto(o,null); // remove proto
o.foo(); // exception
@end example


@deftypefn {Neko Builtin} void $objsetproto (@var{o} : object, @var{proto} : object?)
Set the prototype of the object.
@end deftypefn


@deftypefn {Neko Builtin} object? $objgetproto (@var{o} : object)
Get the prototype of the object.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs objects misc
@subsection Other functions


@deftypefn {Neko Builtin} bool $objremove (@var{o} : object, @var{field_id} : int)
Remove the field identified by @var{field_id} from @var{o}; return
@true{} on success.  Example:

@example
$objremove(o, $hash("field"));
@end example
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs array
@section Arrays


@noindent
Array is a Neko type, not an object.  If in our high level language
arrays are objects, then we can write an object wrapper using an array
value to store the data, and matching the @api{} of our language.

Array access is done using the C language--like brackets syntax, using
zero--based integer values as keys; every value of non--integer type,
used as key, will cause an exception to be raised.

When getting a value: if the integer key is in the range of the array
bounds (between @code{0} and @code{size - 1}), then the value returned
is the one stored at that index; else it's @null{}.  That is:
@strong{no} error is raised if the index is out of bounds.

When setting a value: if the integer key is out of bounds, then the
array is not modified and @strong{no} error is raised.


@deftypefn {Neko Builtin} array $array (any*)
@deftypefnx {Neko Builtin} array $amake (@var{number_of_slots} : int)
Build and return a new array: @builtin{array} will create an array
holding the given list of arguments, @builtin{amake} will create an
empty array with the given number of slots.  Examples:

@example
var a = $array(1,3,"test"); // array with three values
var b = $amake(0);          // empty array
 
$print(a[0]);   // prints 1
$print(a[2]);   // prints "test"
$print(a[3]);   // prints null
@end example

Arrays can contain a maximum of 2^29 - 1 elements; attempts to build a
larger array will raise an exception.  Arrays are @strong{not}
resizable.
@end deftypefn


@deftypefn {Neko Builtin} int $asize (@var{array})
Return the size of an array, which equals the number of allocated slots.
Example:

@example
a = $array(1,2,3);
$print($asize(a)); // prints 3
@end example
@end deftypefn


@deftypefn {Neko Builtin} array $acopy (@var{a} : array)
Create and return a copy of an array.  Example:

@example
a = $array(1,2,3,4);
$print( $acopy(a) );  // prints [1,2,3,4]
@end example

Modifying the copy of an array does not modify the original array
values.
@end deftypefn


@deftypefn {Neko Builtin} array $asub (@var{a} : array, @var{position} : int, @var{number_of_elements} : int)
Create and return a new array holding @var{number_of_elements} elements
from @var{a} starting at @var{position}.  An exception is raised if the
arguments select a range out of array bounds.  Examples:

@example
a = $array(1,2,3,4);
$print( $asub(a,1,2) );   // [2,3]
$print( $asub(a,3,3) );   // null
$print( $asub(a,-2,3) );  // null
@end example

Modifying the copy of an array does not modify the original array
values.
@end deftypefn


@deftypefn {Neko Builtin} array $ablit (@var{dst} : array, @var{dst_pos} : int, @var{src} : array, @var{src_pos} : int, @var{number_of_elements} : int)
Copy @var{number_of_elements} elements from @var{src} starting at
@var{src_pos} into @var{dst} starting at @var{dst_pos}.  An exception is
raised if the arguments select ranges out of arrays bounds.  Examples:

@example
a = $array(1,2,3,4);
b = $array(6,7,8);
$ablit(a,1,b,0,2); // copy 2 elements from b+0 to a+1
$print(a);         // prints [1,6,7,4]
@end example
@end deftypefn


@deftypefn {Neko Builtin} array $aconcat (@var{ell} : array)
Take @var{ell} to be an array in which each element is an array; build
and return a single array whose elements are taken from the subarrays of
@var{ell}.  Example:

@example
$print($aconcat($array($array(1,2,3),
                       $array(4,5),
                       $array(6)))); // prints [1,2,3,4,5,6]
@end example
@end deftypefn


The following is a possible comparison functions for array that compares
them element by element:

@example
var array_compare = function (a, b) @{
  var na = $asize(a);
  var nb = $asize(b);
  var n  = if (na < nb) na; else nb;
  var i  = 0;

  while (i < n)
    @{
      if (a[i] != b[i])
	return $compare(a[i], b[i]);
      i += 1;
    @}

  return if (na < nb) @{ -1 @}; else @{ if (na > nb) 1 ; else 0; @};
@};
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs string
@section Strings


@menu
* specs string make::           Creating strings.
* specs string access::         Accessing characters.
* specs string copy::           Copying strings.
* specs string inspect::        Inspecting strings.
@end menu


@noindent
Strings are a type and not objects.  They are arrays of bytes, so they
can be convenient to store a large quantity of small numbers or binary
data.

Notice that, unlike C language strings, the size of Neko strings is
stored in each string value so we can easily put binary data into it
without caring about the ending @code{\0} character.  For example
strings are used as input/output buffers when reading/writing to files
with Neko's standard library.  @ref{lib file} for details.

Neko strings are just buffers of bytes, so they are independent from any
encoding.  The encoding depends on the @api{} we're using to manipulate
strings.  We can use either the built in operations which manipulate
bytes (then suitable for @acronym{ISO}) or the @utf8{} @api{} (in the
standard library) which manipulates @utf8{} char codes.  @ref{lib utf8}
for details.

Literal strings can contain any character, including newlines and binary
data.  However double quotes and backslashes need to be escaped.  A
backslash is used for escaping some special characters, here's a list of
recognised escape sequences:

@table @code
@item \"
double quote;
@item \\
backslash;
@item \n
newline;
@item \r
carriage return;
@item \t
tab;
@item \xxx
@code{xxx} are three digits that represent a decimal binary code between
000 and 255.
@end table


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs string make
@subsection Creating strings


@deftypefn {Neko Builtin} string $smake (@var{number_of_bytes} : int)
Build and return an uninitialised string of @var{number_of_bytes}; once
allocated, a string can't be resized.  Example:

@example
s = $smake(16);
s = "hello";
$print( $ssize(s) ); // prints 5
@end example

Strings can contain a maximum of 2 ^ 29 - 1 characters, or
@builtin{smake} will raise an exception.
@end deftypefn


@deftypefn {Neko Builtin} string $string (@var{value} : any)
Convert any value to a string.  This will make a copy of string.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs string access
@subsection Accessing characters


@deftypefn {Neko Builtin} int? $sget (@var{s} : string, @var{position} : int)
Return the @var{position}th char of a string as integer in the range
@code{[0, 255]}, or @null{} if @var{position} is out of bounds.
@end deftypefn


@deftypefn {Neko Builtin} int? $sset (@var{s} : string, @var{position} : int, @var{c} : int)
Set the @var{position}th char of a string to @code{@var{c} % 255}.
Return @var{c} itself or @null{} if @var{position} is out of bounds.
@end deftypefn


Examples:

@example
$s = $smake(1);
$sset(s,0,3684);        // set byte 0 to 3624 mod 256
$print( $sget(s,0) );   // prints 40
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs string copy
@subsection Copying strings


@noindent
Notice that assigning a constant string does not copy it, so the
constant content can be modified.  Also, equal constant strings can be
collapsed into the same string, so we have to be careful about
unexpected side effects when modifying a constant string.


@deftypefn {Neko Builtin} string $scopy (@var{s} : string)
Make a copy of a string.  Example:

@example
var s = "ciao";
var c = $scopy(s);
@end example
@end deftypefn


@deftypefn {Neko Builtin} string $ssub (@var{s} : string, @var{position} : int, @var{number_of_bytes} : int)
Return @var{number_of_bytes} chars starting at @var{position} in
@var{s}.  An exception is raised if @var{position} is out of string
bounds.  Example:

@example
var s = "hello";
$print( $ssub(s,1,3) ); // prints "ell"
@end example
@end deftypefn


@deftypefn {Neko Builtin} void $sblit (@var{dst} : string, @var{dst_pos} : int, @var{src} : string, @var{src_pos} : int, @var{len} : int)
Copy @var{len} chars from @var{src_pos} of @var{src} to @var{dst_pos} of
@var{dst}; return the number of bytes copied or @null{} if the copy
failed.  An exception is raised if the arguments select ranges that are
out of strings bounds.  Examples:

@example
s = "some string to blit from";
s2 = $smake(14);
$sblit(s2,0,s,5,14);
$print(s2); // prints "string to blit"
@end example
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs string inspect
@subsection Inspecting strings


@deftypefn {Neko Builtin} int $ssize (@var{s} : string)
Return the size of a string.
@end deftypefn


@deftypefn {Neko Builtin} int $sfind (@var{s} : string, @var{position} : int, @var{pattern} : string)
Return the index of the first occurrence of @var{pattern} in @var{s},
beginning the search at @var{position}.  Return @null{} if not found.
An exception is raised if @var{position} is out of bounds.  Example:

@example
s = "some string to search";
$print($sfind(s, 0,"to"));       // prints 12
$print($sfind(s,20,"to"));      // prints null
@end example
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs exceptions
@section Exceptions


@cindex @code{try}
@cindex @code{catch}
@findex @builtin{excstack}
@findex @builtin{callstack}


@noindent
Exceptions are often referred to as ``non local jumps'' or ``non local
exits''.  They are a very good way to handle errors than can happen at
several calls between the function that yields an error and the handler
that will take care of it.  Raising an exception is done using
@builtin{throw}, and catching it is done using the @code{try...catch}
syntax.  Notice that any value can be an exception, it's up to us to
decide which structure we want to use:

@example
var foo = function() @{
  $throw("failure");
@}
try
  foo()
catch e @{
  $print(e); // prints "failure"
@}
@end example

@deftypefn {Neko Builtin} any $throw (@var{v} : any)
Throw any value as an exception.  Never return.
@end deftypefn


Every time an exception is catched, the call stack is saved and it can
be retrieved using @builtin{excstack()}.  It contains the file names and
positions of the different calls between the try and the place the
exception was raised:

@example
try
  foo()
catch e @{
  $print(e, " raised from : ", $excstack());
@}
@end example


@deftypefn {Neko Builtin} array $excstack (void)
Return the stack between the place the last exception was raised and the
place it was catched.  The stack is composed of the following items:

@itemize
@item
@null{} when it's a C function;

@item
a string when it's a module without debug informations;

@item
an array of two elements (usually file and line) if debug informations
where available.
@end itemize
@end deftypefn


In some cases, we may want to filter exceptions, that is: catch only
some of them.  To do this we catch all the exceptions, check if the
exception is filtered, and raise it again if not.  However, in order not
to loose the call stack by throwing a new exception, we can use
@builtin{rethrow} which will add the two stacks together (the current
one and the one to the next @code{catch}).

@example
try
  foo()
catch e @{
  if( $typeof(e) == $tint )
    $print("catched !")
  else
    $rethrow(e);
@}
@end example

Notice that we can rethrow another exception, so it's more easy to
rewrap some Neko libraries exceptions with our own format.


@deftypefn {Neko Builtin} any $rethrow (@var{v} : any)
Throw any value as an exception while keeping previous exception
stack.  Never returns.
@end deftypefn


@deftypefn {Neko Builtin} array $callstack ()
Return the current call stack.  Same format as @builtin{excstack}.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs hash tables
@section Hash tables


@menu
* specs hash tables making::    Creating hash tables.
* specs hash tables access::    Accessing elements.
* specs hash tables inspect::   Inspecting tables.
@end menu


@noindent
Neko's hash tables are abstract types; they can only be manipulated
using the following operations.  A hash table stores the key/value
binding in one chained list per bucket; adding a new binding with the
same key will @strong{mask} the previous one.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs hash tables making
@subsection Creating hash tables


@deftypefn {Neko Builtin} 'hash $hnew (@var{size} : int)
Create and return a new table having, initially, @code{size} buckets.
@end deftypefn


@deftypefn {Neko Builtin} void $hresize (@var{table} : 'hash, @var{new_size} : int)
Resize the table to have @var{new_size} buckets; note that the size is
usually automatically handled.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs hash tables access
@subsection Accessing elements


@noindent
The hash function cannot be overridden, but the comparison function
between keys can be: we just have to provide a custom function as
argument to the built in operations @builtin{hget}, @builtin{hmem},
@builtin{hset}, @builtin{$hadd} and @builtin{hremove}.

In the following description: to compare the @var{key} argument to the
keys in the hash table, the built in operations will use the comparison
function selected with the @var{compar} argument, or @builtin{compare}
if @var{compar} is @null{}.

Remember that a comparison function must return a ternary result:
@code{0} for equality, @code{+1} or @code{-1} otherwise; from the point
of view of the hash table operations: the result of the comparison
function is zero or non--zero, it makes no difference if the non--zero
result is @code{+1} or @code{-1}.


@deftypefn {Neko Builtin} int $hkey (@var{value} : any)
The hash function used internally to compute the position of a hash
table element; @builtin{hkey} returns a positive integer for any Neko
value.  Examples:

@example
$print($hkey("ciao"));  // prints 798460
$print($hkey("hello")); // prints 15247414
@end example
@end deftypefn


@deftypefn {Neko Builtin} any $hget (@var{table} : 'hash, @var{key} : any, @var{compar} : function:2?)
Look for the values bound to @var{key} in @var{table}; return the first
value found or @null{} if no value is found.  Examples:

@example
var T = $hnew(10);
$hadd(T, 123, "ciao");
$print($hget(T, 123, null)); // prints "ciao"

$hadd(T, 123, "hello");
$print($hget(T, 123, null)); // prints "hello"

$hremove(T, 123, null);
$print($hget(T, 123, null)); // prints "ciao"
@end example
@end deftypefn


@deftypefn {Neko Builtin} bool $hmem (@var{table} : 'hash, @var{key} : any, @var{compar} : function:2?)
Look for the value bound to @var{key} in @var{table}; return @true{} if
the value was found, @false{} otherwise.
@end deftypefn


@deftypefn {Neko Builtin} bool $hset (@var{table} : 'hash, @var{key} : any, @var{value} : any, @var{compar} : function:2?)
Set the value bound to @var{key} to @var{value} or add it to @var{table}
if not found.  Return @true{} if a new @var{key}/@var{value} binding was
added to the table; return @false{} if @var{key} was already present and
so @var{value} replaced the old value.
@end deftypefn


@deftypefn {Neko Builtin} void $hadd (@var{table} : 'hash, @var{key} : any, @var{value} : any)
Bind @var{value} to @var{key} in @var{table}; the previous binding, if
any, is masked but not removed.  See the example given for
@builtin{hget}.
@end deftypefn


@deftypefn {Neko Builtin} bool $hremove (@var{table} : 'hash, @var{key} : any, @var{compar} : function:2?)
Look for the value bound to @var{key} in @var{table}; return @true{} if
such a value exists and remove it from the table, return @false{}
otherwise.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs hash tables inspect
@subsection Inspecting tables


@deftypefn {Neko Builtin} void $hiter (@var{table} : 'hash, @var{func} : function:2)
Apply @var{func} to every key and value in @var{table}.  For example
calling:

@example
var h = $hnew(10);
$hadd(h, "a", 1);
$hadd(h, "b", 2);
$hadd(h, "c", 3);

var func = function (key, val) @{
  $print(key + " " + val + "\n");
@};

$hiter(h, func);
@end example

@noindent
is equivalent to evaluating:

@example
$print("a" + " " + 1 + "\n");
$print("b" + " " + 2 + "\n");
$print("c" + " " + 3 + "\n");
@end example
@end deftypefn


@deftypefn {Neko Builtin} int $hcount (@var{table} : 'hash)
Return the number of elements in @var{table}.
@end deftypefn


@deftypefn {Neko Builtin} int $hsize (@var{table} : 'hash)
Return the number of buckets in @var{table}.
@end deftypefn

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs goto
@section Labels and gotos


@findex @builtin{goto}

@noindent
It is sometimes useful to be able to jump directly at some code
location; labels provide a way to mark a location in the code and the
builtin @builtin{goto} can jump to it:

@example
 $print("enter");
 $goto(next);
 $print("skipping");
next:
 $print("done");
@end example

Please note that label identifiers are global to the file, but cannot be
defined in all expressions.  The reason is to simplify the compiler
since labels normally require multiple passes for stack preservation
(see below).  In the case a label cannot be declared an error is printed
at compilation--time.


The builtin @builtin{goto} can only be used with a valid label identifier,
in that case only, the identifier is treated as a label and not as a
variable.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@subsection Gotos and stack preservation


@noindent
In all cases, gotos to labels are preserving the stack.  For example in
the following case, the variable @code{x} is popped out of the stack
when the goto occurs:

@example
@{
  var x = 0;
  $goto(next);
@}
next:
@end example

If the goto is done inside a block having defined local variables, these
variables are also accessible but their values are unspecified:

@example
$goto(next);
@{
  var x = 0;
next:
  $print(x);  // nobody knows what this will print
@}
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@subsection Gotos and exceptions


@noindent
In the same way gotos are preserving the stack, they are also preserving
the exception handlers, so that the following program is correctly
compiled:

@example
try @{
  $goto(next);
@} catch e @{
  ...
@}
next:
@end example

In the case a goto is done inside a @code{try...catch} block, a
temporary exception handler will be set that will only reraise the
exception.  The exception is not handled by the catch block since the
@code{try} setup has been skipped:

@example
$goto(next);
try @{
 next:
  $throw("error");
@} catch e @{
  ...
@}
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs misc
@section Miscellaneous builtins


@deftypefn {Neko Builtin} void $print (... : any)
Can print any value.
@end deftypefn


@deftypefn {Neko Builtin} int $version (void)
Return the version of Neko: @code{135} means @code{1.3.5}.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node specs modules
@section Modules


@cindex Loading primitives
@cindex Loading modules
@cindex Loading shared libraries

@noindent
A Neko module is a set of constants and functions defined in a Neko file
that is compiled and installed in a location reachable by the Neko
virtual machine.  @ref{neko} for details about running the virtual
machine.


@defvr {Neko Variable} $exports
Each Neko module has an object bound to @builtin{exports} in the top
level scope.  The module can set fields into this object in order to
export some values that will be usable from other modules.  Example:

@example
$exports.log = function() @{ $print("log test") @};
@end example
@end defvr


@defvr {Neko Variable} $loader
Each Neko module has a loader which is an object that can be used to
load other Neko modules and C primitives.  The loader is bound to
@builtin{loader} in the top level scope of the module.
@end defvr


@deftypefn {Neko Method} object loadmodule (@var{module_name} : string, @var{loader} : object)
In order to load a module, we can simply call the @function{loadmodule}
method of @builtin{loader}.  @var{module_name} is the name of the file
with the extension stripped.  @var{loader} is the loader that the newly
loaded module will use: it will be bound to @builtin{loader} in its top
level scope.

If a module @code{@var{module_name}.n} is found: the file is loaded, its
code evaluated, then its @builtin{exports} table is returned; if not
found: an exception is thrown.

Example of loading the module @file{log.n}:

@example
var m = $loader.loadmodule("log",$loader);
m.log();
@end example

The only thing needed to implement a custom loader is to define the
methods @code{loadmodule} and @code{loadprim}.
@end deftypefn


@deftypefn {Neko Method} object loadprim (@var{prim_spec} : string, @var{arity} : int)
The loader can import C language primitives exported by platform
specific shared libraries.  A primitive is loaded with the
@function{loadprim} method of the @builtin{loader} object.
@var{prim_spec} is a string formed by concatenating: the library name,
the @code{@@} character, the primitive name.  @var{arity} is the number
of arguments accepted by the primitive.

If success, a Neko function is returned to be used to call the
primitive.  If not found, an exception is thrown.

Example of loading the C language primitive @cfunction{file_open} from
the Neko standard library, and binding it to the Neko symbol
@code{file_open}:

@example
var file_open = $loader.loadprim("std@@file_open", 2);
@end example

The Neko standard library is a file called @file{std.ndll}; the ``name''
of the library is the file name with the extension stripped.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi
@chapter Foreign functions interface


@menu
* ffi example::                 A small example.
* ffi values::                  Manipulating values.
* ffi objects::                 Working with objects.
* ffi callbacks::               Function callbacks.
* ffi abstracts::               Abstracts and kinds.
* ffi varargs::                 Variable arguments functions.
* ffi int32::                   Using 32 bits integers.
* ffi memory::                  Managing memory.
* ffi misc::                    Misc @api{} functions.
@end menu


@noindent
The @nvm{} itself has enough operations to compute any value.  However
it cannot do everything, like accessing files, connecting to network
servers, or display and manage a @gui{} window with menus and buttons.
All these features and much more are however accessible from C language
code that will use operating system libraries.  Since the @nvm{} cannot
directly call C functions, it is needed to write some glue C code that
will wrap the @acronym{OS} libraries in order to make them accessible.
These glue functions are called ``primitives''.

When we're writing primitives, we need to use the Neko C @ffi{}.  We
only need to include the @file{neko.h} file which is part of the Neko
distribution, and to link with the Neko library (@file{libneko.so} on
Unix, @file{libneko.dylib} on OSX, and @file{neko.lib} on Windows).


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi example
@section A small example


@noindent
Here's an ``Hello World'' sample on how to write a Neko primitive in C:

@example
#include <neko.h>
 
value test()
@{
  return alloc_string("Hello world");
@}
 
DEFINE_PRIM(test,0); // function 'test' with 0 arguments
@end example

Now all we have to do is to compile this C file into a shared library
named @file{hello.ndll}.  In order to test our primitive, we simply call
the @builtin{loader.loadprim} method and request the primitive with the
declared number of arguments:

@example
var p = $loader.loadprim("hello@@test",0);
$print( p() );
@end example

The format of primitive name is:

@example
name_of_the_library@@name_of_the_function
@end example

@noindent
we can then define several primitives in the same library.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values
@section Manipulating values


@menu
* ffi values types::            Data types.
* ffi values const::            Constant values.
* ffi values predicates::       Type predicates.
* ffi values assert::           Asserting the types of values.
* ffi values access::           Access functions.
* ffi values alloc::            Allocation functions.
* ffi values print::            Printing values.
* ffi values buffers::          Buffers.
@end menu


@noindent
There are several kind of @api{} functions:

@table @code
@item val_is_*
they work on any value and return @code{1} if the value is of the given
type, or @code{0} otherwise;

@item val_*
they enable us to retrieve the content of a value; please note that we
must first @strong{ensure} that the value is of the given type before
using such a function or the program might crash or have unpredictable
behaviour;

@item alloc_*
functions enable us to convert a C value to a Neko value;
@end table

@noindent
notice that most (almost all) of these functions are actually C macros.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values types
@subsection Data types


@menu
* ffi values types other::      Other data types.
@end menu


@noindent
The following types of values are available:

@example
null
integer
float
boolean
string
array
object
abstract
@end example

@noindent
every value given as argument to a primitive or returned by a primitive
must be of the C type @code{value}.

@deftp {C Language Type} value
The type of Neko values.  Instances of this type are garbage
collected.
@end deftp


@deftp {C Language Enum} val_type
The type of constants that identify types.  Defined values follow.
@end deftp

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@deffn {C Language Type Constant} VAL_INT
The identifier of integers.
@end deffn


@deffn {C Language Type Constant} VAL_NULL
The identifier of @null{}.
@end deffn


@deffn {C Language Type Constant} VAL_FLOAT
The identifier of floating point numbers.
@end deffn


@deffn {C Language Type Constant} VAL_BOOL
The identifier of boolean values.
@end deffn


@deffn {C Language Type Constant} VAL_STRING
The identifier of strings.
@end deffn


@deffn {C Language Type Constant} VAL_OBJECT
The identifier of objects.
@end deffn


@deffn {C Language Type Constant} VAL_ARRAY
The identifier of arrays.
@end deffn


@deffn {C Language Type Constant} VAL_FUNCTION
The identifier of functions.
@end deffn


@deffn {C Language Type Constant} VAL_ABSTRACT
The identifier of abstracts.
@end deffn


@deffn {C Language Type Constant} VAL_PRIMITIVE
The identifier of primitive functions.
@end deffn


@c @deffn {C Language Type Constant} VAL_JITFUN
@c The identifier of integers.
@c @end deffn


@deffn {C Language Type Constant} VAL_32_BITS
The identifier of 32-bits integers.
@end deffn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values types other
@subsubsection Other data types


@deftp {C Language Type} tfloat
An alias for a C language floating point number type; defined to be
@code{double}.
@end deftp


@deftp {C Language Type} field
The type of an object's field.
@end deftp


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values const
@subsection Constant values


@deftypevr {C Language Variable} value val_null
The @null{} value.
@end deftypevr


@deftypevr {C Language Variable} value val_true
@deftypevrx {C Language Variable} value val_false
The @true{} and @false{} values.
@end deftypevr


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values predicates
@subsection Type predicates


@deftypefn {C Macro} int val_is_null (value @var{v})
Check if a value is @null{}.
@end deftypefn


@deftypefn {C Macro} int val_is_int (value @var{v})
Check if a value is an integer.
@end deftypefn


@deftypefn {C Macro} int val_is_float (value @var{v})
Check if a value is a float.
@end deftypefn


@deftypefn {C Macro} int val_is_string (value @var{v})
Check if a value is a string.
@end deftypefn


@deftypefn {C Macro} int val_is_bool (value @var{v})
Check if a value is a boolean.
@end deftypefn


@deftypefn {C Macro} int val_is_array (value @var{v})
Check if a value is an array.
@end deftypefn


@deftypefn {C Macro} int val_is_object (value @var{v})
Check if a value is an object.
@end deftypefn


@deftypefn {C Macro} int val_is_function (value @var{v})
Check if a value is a function.
@end deftypefn


@deftypefn {C Macro} int val_is_abstract (value @var{v})
Check if a value is an abstract.
@end deftypefn


@deftypefn {C Macro} int val_is_kind (value @var{v}, value k)
Check if a value is an abstract of the kind @var{k}.
@end deftypefn


@deftypefn {C Macro} int val_is_number (value @var{v})
Check if a value is either an integer or a float.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values assert
@subsection Asserting the types of values


@noindent
Often, when we're writing primitives, we expect the arguments to be of
one given type.  So the first thing done in primitives is to check that
the types are correct and have an exception raised if not.  Neko
provides several functions for that.


@deftypefn {C Macro} void val_check (value @var{v}, @var{type})
If @var{v} is not of type @var{type}: call @cfunction{neko_error}.
@var{type} is used by the C preprocessor to compose the type check
function like this: @code{val_is_##@var{type}}.  Usage example:

@example
value v;

val_check(v, int);
@end example
@end deftypefn


@deftypefn {C Macro} void val_check_kind (value @var{v}, vkind @var{t})
If @var{v} is not an abstract value of kind @var{t}: call
@cfunction{neko_error}.
@end deftypefn


@deftypefn {C Macro} void val_check_function (value @var{v}, int @var{arity})
If @var{v} is not a function or the number of arguments it accepts is
not @var{arity}: call @cfunction{neko_error}.
@end deftypefn


@deftypefn {C Macro} val_type val_type (value @var{v})
Return the type identifier of the value.
@end deftypefn


@deftypefn {C Macro} {void *} neko_error (void)
Simply @code{return} the C @code{NULL} value.  This special value will
be catched by the virtual machine that will raise an exception.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values access
@subsection Access functions


@noindent
In order to use the following functions, we must be sure first that the
type of the value is correct by using the functions described in
@ref{ffi values assert}.  If we do not the behaviour is undefined.


@deftypefn {C Macro} int val_int (value @var{v})
Retrieve the integer stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_bool (value @var{v})
Retrieve the boolean stored into a value.
@end deftypefn


@deftypefn {C Macro} double val_float (value @var{v})
Retrieve the float stored into a value.
@end deftypefn


@deftypefn {C Macro} {char *} val_string (value @var{v})
Retrieve the string stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_strlen (value @var{v})
Retrieve the length of the string stored into a value.
@end deftypefn


@deffn {C Macro} val_number (value @var{v})
Retrieve the float or the integer stored into a value.
@end deffn


@deftypefn {C Macro} {value *} val_array_ptr (value @var{v})
Retrieve the array stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_array_size (value @var{v})
Retrieve the size of the array stored into a value.
@end deftypefn


@deftypefn {C Macro} int val_fun_nargs (value @var{v})
Retrieve the arity (number of accepted arguments) of the function stored
into a value.
@end deftypefn


@deftypefn {C Macro} {void *} val_data (value @var{v})
Retrieve the data stored into an abstract value.
@end deftypefn


@deftypefn {C Macro} vkind val_kind (value @var{v})
Retrieve the kind of an abstract value.
@end deftypefn



@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values alloc
@subsection Allocation functions


@deftypefn {C Macro} value alloc_int (int @var{i})
Return a value from a C @code{int}.
@end deftypefn

      
@deftypefn {C Macro} value alloc_bool (@var{b})
Return a value from a C boolean which can be anything; notice that
@code{0} is false and Neko @true{} either.
@end deftypefn


@deftypefn {C Function} value alloc_float (tfloat @var{f})
@deftypefnx {C Function} value neko_alloc_float (tfloat @var{f})
Return a value from a C float.
@end deftypefn

      
@deftypefn {C Function} value alloc_array (unsigned int @var{size})
@deftypefnx {C Function} value neko_alloc_array (unsigned int @var{size})
Create a Neko array of the given size.
@end deftypefn


@deftypefn {C Function} value alloc_string (const char * @var{str})
@deftypefnx {C Function} value neko_alloc_string (const char * @var{str})
Return a value from a C string; this function makes a copy of the memory
block referenced by @var{str}.
@end deftypefn


@deftypefn {C Function} value alloc_empty_string (unsigned int @var{size})
@deftypefnx {C Function} value neko_alloc_empty_string (unsigned int @var{size})
Return an uninitialised string value that can hold @var{size} bytes
@strong{without} the terminating @code{\0} byte.

Neko string values have the number of bytes stored in the data
structure, so there is no need to include a terminating @code{\0} byte.
@end deftypefn


@deftypefn {C Function} value copy_string (value @var{str}, unsigned int @var{size})
@deftypefnx {C Function} value neko_copy_string (value @var{str}, unsigned int @var{size})
Return a copy of the @var{size} first bytes of the string @var{str} as a
value.
@end deftypefn

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values print
@subsection Printing values


@noindent
Using what we have learned from the Neko @api{}, we can now write a
function that prints any value:

@example
#include <stdio.h>
#include <neko.h>
 
value
print (value v)
@{
  if (val_is_null(v))
    printf("null");

  else if (val_is_int(v))
    printf("int : %d",val_int(v));

  else if (val_is_float(v))
    printf("float : %f",val_float(v));

  else if (val_is_bool(v))
    printf("bool : %s",val_bool(v)?"true":"false");

  else if (val_is_array(v))
    printf("array : size %d",val_array_size(v));

  else if (val_is_function(v))
    printf("function : %d args",val_fun_nargs(v));

  else if (val_is_string(v))
    printf("string : %s (%d bytes)",val_string(v),val_strlen(v));

  else if (val_is_object(v))
    printf("object");

  else if (val_is_abstract(v))
    printf("abstract of kind %X",val_kind(v));

  else
    printf("?????");

  return val_null;
@}
 
DEFINE_PRIM(print,1);
@end example

Please note that it's pretty inefficient since we are are doing a test
for each type, while we could simply dispatch using @code{val_type}:

@example
#include <stdio.h>
#include <neko.h>
 
value
print (value v)
@{
  switch (val_type(v))
  @{
    case VAL_NULL:
      printf("null");
      break;
    case VAL_INT:
      printf("int : %d",val_int(v));
      break;
    case VAL_FLOAT:
      printf("float : %f",val_float(v));
      break;
    case VAL_BOOL:
      printf("bool : %s",val_bool(v)?"true":"false");
      break;
    case VAL_ARRAY:
      printf("array : size %d",val_array_size(v));
      break;
    case VAL_FUNCTION:
      printf("function : %d args",val_fun_nargs(v));
      break;
    case VAL_STRING:
      printf("string : %s (%d bytes)",val_string(v),val_strlen(v));
      break;
    case VAL_OBJECT:
      printf("object");
      break;
    case VAL_ABSTRACT:
      printf("abstract of kind %X",val_kind(v));
      break;
    default:
      printf("?????");
      break;
  @}
  return val_null;
@}
 
DEFINE_PRIM(print,1);
@end example

The default case is not supposed to happen unless there is some bug into
a C code function that doesn't return a correct value (or memory
corruption).  Since the @nvm{} is safe in regard to memory manipulation,
such problem can only arise from a buggy C primitive.

@strong{*FIXME*} This is not true because not all the @code{VAL_} values
are in this function.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi values buffers
@subsection Buffers


@noindent
The printing of a value is a little more complex than what is described
in @ref{ffi values print}.  In particular, in case of objects we must
call the @code{__string} method to retrieve a representation of the
object if available.

In order to easily construct strings of mixed constant C strings and
values converted to strings, the Neko @api{} has buffers.  A buffer is
@strong{not} a @code{value}, so we cannot return it from C primitives,
but it is garbage collected so we don't have to free them after usage.


@deftypefn {C Function} buffer alloc_buffer (const char * @var{str})
@deftypefnx {C Function} buffer neko_alloc_buffer (const char * @var{str})
Allocate a fresh buffer with a string @var{str} or no data if @var{str}
is @code{NULL}.
@end deftypefn


@deftypefn {C Function} void val_buffer (buffer @var{b}, value @var{v})
@deftypefnx {C Function} void neko_val_buffer (buffer @var{b}, value @var{v})
Add a string representation of the value @var{v} to the buffer @var{b}.

@strong{Warning} Be careful with this function: its name has the format
@code{val_*} but it does @strong{not} retrieve a buffer from a
@code{value}.
@end deftypefn


@deftypefn {C Function} void buffer_append (buffer @var{b}, const char * @var{str})
@deftypefnx {C Function} void neko_buffer_append (buffer @var{b}, const char * @var{str})
Append the C string @var{str} at the end of the buffer @var{b}.
@end deftypefn


@deftypefn {C Function} void buffer_append_sub (buffer @var{b}, const char * @var{str}, int_val @var{n})
@deftypefnx {C Function} void neko_buffer_append_sub (buffer @var{b}, const char * @var{str}, int_val @var{n})
Append the @var{n} first bytes of the C string @var{str} at the end of
the buffer @var{b}.@footnote{Neko type @code{int_val} is here to mean
a 64bit integer on 64--bits system.  The reason is that at several
places we might want to use a difference between two @code{char *} in
order to measure the length:

@example
char * begin = "aaaaxbbb";
char * end   = strstr(begin,"x");

buffer_append_sub(b, begin, end - begin);
@end example

@noindent
the problem is that differences between pointers are not of type
@code{int}; same for @cfunction{strlen}.

Neko type @code{int_val} is defined to be @code{intptr_t}, which for
the @gnu{} C Library is defined to be @code{long int}; see the file
@file{stdint.h}.}
@end deftypefn


@deftypefn {C Function} value buffer_to_string (buffer @var{b})
@deftypefnx {C Function} value neko_buffer_to_string (buffer @var{b})
Allocate and return a string @code{value} holding the content of a
buffer.
@end deftypefn


Example of buffer usage:

@example
value 
print2 (value @var{v1}, value @var{v2})
@{
  buffer b = alloc_buffer("Values");

  buffer_append(b," = ");
  val_buffer(b,v1);
  buffer_append_sub(b,",xxx",1); // only first byte, so ','
  val_buffer(b,v2);
  return buffer_to_string(b);
@}
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi objects
@section Working with objects


@noindent
Objects in Neko are also values, and there are several functions in the
Neko @api{} to access and modify object's fields.

@menu
* ffi objects api::             Objects @api{}.
* ffi objects methods::         Object methods.
@end menu

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi objects api
@subsection Objects @api{}


@deftypefn {C Function} value alloc_object (value @var{o})
@deftypefnx {C Function} value neko_alloc_object (value @var{o})
Return a copy of the object @var{o}, or an empty object if @var{o} is
@code{NULL} or @code{val_null}.
@end deftypefn


@deftypefn {C Macro} int val_is_object (value @var{v})
Check that the value is an object.
@end deftypefn


@deftypefn {C Function} field val_id (const char * @var{field_name})
@deftypefnx {C Function} field neko_val_id (const char * @var{field_name})
In the Neko specification, it is told that object tables do not directly
contain field names but hashed identifiers of the field names.  This
function returns a field identifier from a field name.
@end deftypefn


@deftypefn {C Function} value val_field (value @var{o}, field @var{f})
@deftypefnx {C Function} value neko_val_field (value @var{o}, field @var{f})
Access an object field for reading; return @code{val_null} if the field
is not found in @var{o}.  @var{f} is the field identifier returned by
@cfunction{val_id}.
@end deftypefn


@deftypefn {C Function} value val_field_name (field @var{f})
@deftypefnx {C Function} value neko_val_field_name (field @var{f})
Return the field name as value from its identifier; return
@code{val_null} if the field is not found.
@end deftypefn


@deftypefn {C Function} void alloc_field (value @var{o}, field @var{f}, value @var{v})
@deftypefnx {C Function} void neko_alloc_field (value @var{o}, field @var{f}, value @var{v})
Set or replace the value of the field @var{f}, in the object @var{o},
with the value @var{v}.
@end deftypefn


@deftypefn {C Function} value val_this (void)
@deftypefnx {C Function} value neko_val_this (void)
Return the value of @code{this} in the current context.
@end deftypefn


@deftypefn {C Function} void val_iter_fields (value @var{o}, void * @var{f} (value, field, void *), void * @var{p})
@deftypefnx {C Function} void neko_val_iter_fields (value @var{o}, void * @var{f} (value, field, void *), void * @var{p})
Iterate over the fields of @var{o} invoking the function @var{f} for
each of them; the arguments to @var{f} are: the object @var{o} itself,
the field's identifier and the custom data pointer @var{p} which can
reference anything we want.
@end deftypefn


Here's a small example that allocates an object with two fields @code{x}
and @code{y} from two values:

@example
#include <neko.h>
 
value
make_point (value x, value y)
@{
  value         o;

  val_check(x,number);
  val_check(y,number);

  o = alloc_object(NULL);
  alloc_field(o,val_id("x"),x);
  alloc_field(o,val_id("y"),y);
  return o;
@}
 
DEFINE_PRIM(make_point, 2);
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi objects methods
@subsection Object methods


@noindent
If we want to add a method @code{__string} to the object in order to
display its content when printed, we can do the following:

@example
#include <neko.h>
 
value
point_to_string (void)
@{
  value  o = neko_val_this();
  value  x, y;
  buffer b;

  val_check(o,object);

  x = neko_val_field(o, neko_val_id("x"));
  y = neko_val_field(o, neko_val_id("y"))

  b = neko_alloc_buffer("Point : ");
  neko_val_buffer(b, x);
  neko_buffer_append(b, " , ");
  neko_val_buffer(b, y);
  return neko_buffer_to_string(b);
@}
 
value
make_point (value x, value y)
@{
  value f = neko_alloc_function(point_to_string, 0,
                                "point_to_string");
  value o;

  ...
  neko_alloc_field(o, neko_val_id("%%__string%%"), f);
  return o;
@}
@end example

Let's see what is done here:

@itemize
@item
in @cfunction{make_point} we are setting the field @code{__string} of
the object @code{o} to a function value allocated with
@cfunction{alloc_function}, which takes 3 parameters: the address of the
C function, the number of arguments, and a name for the function that
will help for debugging and errors location;
@item
in @cfunction{point_to_string} we are first retrieving
@cfunction{neko_val_this} which is the current @code{this} value; since
it might not be an object, we test it first before accessing its fields
@code{x} and @code{y}; then we want to construct, as object's
representation, the string @code{Point : x , y} with the values of
@code{x} and @code{y}, we're using a buffer for this.
@end itemize

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi callbacks
@section Function callbacks


@noindent
At some point, we might need to call back a value function or an object
method.


@deftypefn {C Function} void val_callEx (value @var{vthis}, value @var{f}, value * @var{args}, int @var{nargs}, value * @var{exc})
@deftypefnx {C Function} void neko_val_callEx (value @var{vthis}, value @var{f}, value * @var{args}, int @var{nargs}, value * @var{exc})
This is the most general callback function; all the other callback
functions are only some easier ways of making calls to
@cfunction{val_callEx}.  Arguments' descriptions follows:

@table @var
@item vthis
a value specifying which will be the @code{this} value inside the call;

@item f
the function we want to call;

@item args
a C array of values storing the arguments, in left--to--right order;

@item nargs
the number of arguments stored into @var{args};

@item exc
a value pointer to store an exception if it is raised in a subcall; if
@code{NULL}, exceptions will not be catched and they will go through the
function calling @cfunction{val_callEx}.
@end table

The function @var{f} must have either a variable number of arguments
(@code{VAR_ARGS}) or the exact @var{nargs} number of arguments, or an
exception will be raised.

If the call is successful, the value returned by @var{f} is returned by
@cfunction{val_callEx}.
@end deftypefn


@deftypefn {C Function} value val_call0 (value @var{f})
@deftypefnx {C Function} value val_call1 (value @var{f}, value @var{arg1})
@deftypefnx {C Function} value val_call2 (value @var{f}, value @var{arg1}, value @var{arg2})
@deftypefnx {C Function} value val_call3 (value @var{f}, value @var{arg1}, value @var{arg2}, value @var{arg3})
Call the function @var{f} with 0, 1, 2 or 3 arguments.
@end deftypefn


@deftypefn {C Function} value val_callN (value @var{f}, value * @var{args}, int @var{nargs})
Call the function @var{f} with the arguments in the array @var{args}.
@end deftypefn


In the following functions, @var{f} is a field, so it's not the value of
the method but the hash of the field name.  The method is fetched from
the object table before the call is performed.


@deftypefn {C Function} value val_ocall0 (value @var{o}, field @var{f})
@deftypefnx {C Function} value val_ocall1 (value @var{o}, field @var{f}, value @var{arg1})
@deftypefnx {C Function} value val_ocall2 (value @var{o}, field @var{f}, value @var{arg1}, value @var{arg2})
Call the method @var{f} from the object @var{o} with 0, 1, 2 arguments.
@end deftypefn


@deftypefn {C Function} value val_ocallN (value @var{o}, field @var{f}, value * @var{args}, int @var{nargs})
Call the method @var{f} from the object @var{o} with the arguments in
@var{args}.
@end deftypefn


This is a small example that enable the C code to callback a Neko
function.  First we define a primitive so that we can register our
callback:

@example
#include <neko.h>
 
value * function_storage = NULL;
 
static value
set_handler (value f)
@{
  val_check_function(f,1); // checks that f has 1 argument

  if( function_storage == NULL )
    function_storage = alloc_root(1);
  *function_storage = f;
  return val_null;
@}
 
DEFINE_PRIM(set_handler,1);
@end example

Since the function is a value, we have to store it into a place that can
be accessed by the garbage collector; this is why we allocate a
@code{function_storage} with @cfunction{alloc_root}.  The
@cfunction{alloc_root} parameter is the number of values that can be
stored in the allocated pointer.

Once the callback is set, we can call it from C by using the following
code:

@example
// call the function with the Neko string "Hello"
value ret = val_call1(*function_storage, alloc_string("Hello"));
// ... handle the ret value
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi abstracts
@section Abstracts and kinds


@noindent
Most of the time, when we have to write an interface from Neko to a C
library, we get some pointer to some mallocated memory.  We can't safely
return this value to the Neko program for the following reasons:

@itemize
@item
it is not a value so it does not match the NekoVM memory model;

@item
it might then crash the program when accessed inappropriately;

@item
even it if was a value, it would have to be free explicitly;

@item
we cannot distinguish the types between two C pointers.
@end itemize

For all of these reasons, we need to be able to store a C pointer into
an abstract Neko value and mark it with some type information called
``kind''.  The kind of an abstract value is its type, and the data of an
abstract value is the corresponding C pointer.

Please note that the @vm{} itself cannot access either the kind or the
data of an abstract value; for the @vm{}, an abstract is an opaque value
without any structure.  It's up to our C primitives to manipulate the
abstract.  This ensures also that if we don't make any mistake in our C
primitives, the whole program will be kept memory--safe.

First, we need to define a kind somewhere in our C file, using the macro
@code{DEFINE_KIND} from the Neko @api{}.  By convention, we often prefix
the kind with @code{k_} but it's not mandatory:

@example
#include <neko.h>

DEFINE_KIND(k_mykind);
@end example

Now that we have a kind, we can create an abstract value of this kind
using the @cfunction{alloc_abstract} Neko @api{} function:

@example
value
create (void)
@{
  void *ptr = ...

  return alloc_abstract(k_mykind,ptr);
@}
@end example

It is possible to store another value in the data part of an abstract,
since it will still be checked by the garbage collector.

When we get back a value into one of our primitives, we can check if
it's an abstract value using @cfunction{val_is_abstract} then check its
kind using the @cfunction{val_is_kind} @api{} function and then access
its data using the @cfunction{val_data} @api{} function:

@example
value
dosomething (value v)
@{
  if((! val_is_abstract(v)) || (! val_is_kind(v,k_mykind)))
    neko_error();

  do_something_in_C(val_data(v));
  return val_true;
@}
@end example

Instead of writing these checks all the time, we can use the
@cfunction{val_check_kind} macro which is more convenient:

@example
value
dosomething( value v )
@{
  val_check_kind(v,k_mykind);

  do_something_in_C(val_data(v));
  return val_true;
@}
@end example

In some cases, we might want the user to free the pointer stored into an
abstract explicitly.  At this time, we can set its kind to @code{NULL}
so it is not accessible anymore:

@example
value
destroy (value v)
@{
  val_check_kind(v,k_mykind);

  free_data(val_data(v));
  val_kind(v) = NULL;
  return val_true;
@}
@end example

In other cases, we might want the pointer data to be free when the
abstract value becomes garbage--collected.  In that case we have to bind
a finalise function on it.  Please note that it might take some time
between the value becomes unreachable and the finalise function is called.

@example
void
finalize (value v)
@{
  free_data(val_data(v));
@}
 
value
create (void)
@{
  void *ptr = ....
  value v   = alloc_abstract(k_mykind, ptr);

  val_gc(v,finalize);
  return v;
@}
@end example

We can remove the finalise function from an abstract value by calling
@code{val_gc(v,NULL)}.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi varargs
@section Variable arguments functions


@noindent
If we want to pass more than five arguments, or a variable number of
arguments, in a single Neko--to--C function call, we can use the
@cfunction{DEFINE_PRIM_MULT} macro:

@example
value
myprim (value *args, int nargs)
@{
  ...
@}

DEFINE_PRIM_MULT(myprim);
@end example

@noindent
then, pass @code{-1} as the number of arguments to @builtin{loadprim}.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi int32
@section Using 32 bits integers


@noindent
As explained before, Neko integers are only signed 31 bits.  While this
is enough for most of the cases, there are times where we want to use
the full 32 bits.  It was then added a common @code{int32} abstract
type.

We can use @cfunction{val_is_int32} to check that the value is either an
integer or an @code{int32}.  And @cfunction{val_int32} will return the
corresponding integer.  If we want to check that the value is exactly an
@code{int32}, then we can use @code{val_is_kind(i,k_in32)}.

To create an @code{int32} value, we can use @cfunction{alloc_int32}.
Please note that unlike @cfunction{alloc_int}a which is a fast macro,
@cfunction{alloc_int32} allocate some memory to store the integer so it
is slower.

In the case most of our integers are using only 31 bits but we still
want to be able to use the full 32 bits, we can use the
@cfunction{alloc_best_int} macro that will use either
@cfunction{alloc_int} or @cfunction{alloc_int32} depending on the needed
bits.  Use then the @code{val_check(i,int32)} and @code{val_is_int32(v)}
macros in order to accept both kind of integers.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi memory
@section Managing memory


@noindent
When we're working with abstracts, we might want to allocate
garbage--collected memory so we don't have to add finalise functions for our
data (finalise functions are more expensive than garbage--collected memory).


@deftypefn {C Function} {char *} alloc (unsigned int @var{nbytes})
@deftypefnx {C Function} {char *} neko_alloc (unsigned int @var{nbytes})
Return a pointer capable of storing up to @var{nbytes}.  So it's
equivalent to @code{malloc(nbytes)} but the memory will be automatically
collected when unreachable from the @vm{}.  Please note that C static
values are not reachable by the @vm{}.

The memory allocated with @cfunction{alloc} will be scanned by the
garbage collector so we can store values and other allocated pointers
into it.  As long as our pointer is reachable these values will also be
reachable so they will not be collected.
@end deftypefn


@deftypefn {C Function} {char *} alloc_private (unsigned int @var{nbytes})
@deftypefnx {C Function} {char *} neko_alloc_private (unsigned int @var{nbytes})
If we want to allocate big chunks of memory and we're sure they will
not contain any value (strings for example) we can this function that
will return @var{nbytes} of memory but that will not be scanned by the
garbage collector.
@end deftypefn


In some cases, we might need to store some value into a static variable.
First, we have to be sure of what we're doing: since the Neko @vm{} can
run in several threads, we need to protect the accesses to this value to
ensure that our library will work when used simultaneously by multiple
threads.  Second, since the statics are not reachable by the garbage
collector, we have to allocate a root value.

A root value is a pointer that can store several values and that will
always be scanned by the garbage collector.  Since it will never be
garbage--collected we can store it anywhere.  However we'll have to free
it explicitly.


@deftypefn {C Function} {value *} alloc_root (unsigned int @var{nvals})
@deftypefnx {C Function} {value *} neko_alloc_root (unsigned int @var{nvals})
Allocate a root value array, capable of storing up to @var{nvals}
values.
@end deftypefn


@deftypefn {C Function} void free_root (value * @var{root})
Free a previously allocated root value array.
@end deftypefn


Try to avoid the use of roots and static values as much as possible.
Always store data into abstract values if possible.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node ffi misc
@section Misc @api{} functions


@deftypefn {C Function} int val_compare (value @var{a}, value @var{b})
@deftypefnx {C Function} int neko_val_compare (value @var{a}, value @var{b})
Compare two values according to Neko specification.  Return an integer
that will be @code{0} if @code{a = b}, @code{-1} if @code{a < b},
@code{1} if @code{a > b} or @code{invalid_comparison} if @var{a} and
@var{b} can't be compared.
@end deftypefn


@defmac invalid_comparison
A constant value returned by @cfunction{val_compare} when the two
operands of a comparison cannot be compared.
@end defmac


@deftypefn {C Function} value val_print (value @var{v})
@deftypefnx {C Function} value neko_val_print (value @var{v})
Print the value to the defined output of the virtual machine.
@end deftypefn


@deftypefn {C Function} int val_hash (value @var{v})
@deftypefnx {C Function} int neko_val_hash (value @var{v})
Hash any value into a positive integer.
@end deftypefn


@deftypefn {C Function} void val_throw (value @var{v})
@deftypefnx {C Function} void val_rethrow (value @var{v})
Throw the value @var{v} as an exception.
@end deftypefn


@deftypefn {C Function} void failure (value @var{msg})
@deftypefnx {C Function} void bfailure (buffer @var{msg})
Throw a failure exception using a constant C string as error message.
This is a convenient way of handling errors in our primitives, since the
exception will contain our error message as well as the C file name and
the line where the error occurred.
@end deftypefn

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node embedding
@chapter Embedding the @vm{}


@menu
* embedding example::           Example of embedding the @vm{}.
* embedding threads::           Multithreading.
@end menu


@noindent
The Neko Virtual Machine and its C @ffi{} are packaged into a single
shared library (@file{libneko.so} on Unix systems and @code{neko.dll} on
Windows).  Along with the garbage collector library (@file{libgc} on
Unix and @file{gc.dll} on Windows) it is all we need to add to our
application in order to be able to run a Neko program.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node embedding example
@section Example of embedding the @vm{}


@noindent
Here's a code snippet that initialises a @vm{} and runs a Neko module
inside it, then it accesses some data:

@example
#include <stdio.h>
#include <neko_vm.h>
 
value
load (char * file)
@{
  value loader;
  value args[2];
  value exc = NULL;
  value ret;

  loader  = neko_default_loader(NULL, 0);
  args[0] = alloc_string(file);
  args[1] = loader;
  ret     = val_callEx(loader,
                       val_field(loader, val_id("loadmodule")),
                       args, 2, &exc);

  if (NULL != exc)
    @{
      buffer b = alloc_buffer(NULL);

      val_buffer(b,exc);
      printf("Uncaught exception - %s\n", val_string(buffer_to_string(b)));
      return NULL;
    @}
  return ret;
@}
 
void
execute (value module)
@{
  value x = val_field(module, val_id("x"));
  value f = val_field(module, val_id("f"));
  value ret;

  if (! val_is_int(x))
    return; 
  printf("x = %d\n",val_int(x));
  if (! val_is_function(f,1))
    return;
  ret = val_call1(f,x);
  if (! val_is_int(ret))
    return;
  printf("f(x) = %d\n",val_int(ret));
@}
 
int
main (int argc, char *argv[])
@{
  neko_vm *     vm;
  value         module;

  neko_global_init(NULL);
  vm = neko_vm_alloc(NULL);
  neko_vm_select(vm);
 
  module = load("mymodule.n");
  if (NULL == module)
    @{
      printf("Failed to load module !\n");
      return -1;
    @}
  execute(module);
 
  neko_global_free();    
  return 0;
@}
@end example 

We can use it to load the following @file{mymodule.neko} file after
compilation:

@example
$exports.x = 33;
$exports.f = function(x) @{ return x * 2 + 1; @}
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node embedding threads
@section Multithreading


@noindent
@nvm{} supports multithreading and multiple @vm{} instances; it means
that we can run some Neko code into a multithreaded program, as long as
we respect the following guidelines:

@enumerate
@item
we can allocate a @vm{} with @cfunction{neko_vm_alloc}; the @vm{} holds
the Neko stack and registers;

@item
a given thread can allocate several @vm{};

@item
only one @vm{} is ``active'' for a thread at a given time; we can choose
the local thread current @vm{} by calling @code{neko_vm_select(neko_vm
*vm)};

@item
we can retrieve the selected @vm{} for the current thread by calling
@cfunction{neko_vm_current};

@item
a single @vm{} should not be used to execute code on several threads at
the same time;

@item
a Neko Module can be used by several @vm{}/Threads at the same time.
@end enumerate

Using some non--basic data structures such as loaders, hash tables or
abstracts values (files, regular expressions@dots{}) from multiple
threads can results in crashes.  Try to always keep these data
structures in the thread that allocated them in the first place.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
@c ------------------------------------------------------------
@node nxml
@chapter Neko in @xml{} format


@noindent
Neko sources syntax is easy to read but can sometimes be difficult to
generate; also, it does not permit embedding file and line numbers
informations.  For example: if we convert a file in our language,
@file{MyFile.mylang}, into a file in Neko language, @file{myfile.neko},
we would like to get error traces in terms of position in the original
@file{MyFile.mylang} file.

For these reasons, an extension of the neko syntax is proposed: it is
called @nxml{}.  This is not a different format: we can easily mix
@nxml{} and Neko sources together.  We can put some @nxml{} expressions
in Neko sources and some Neko sources into an @nxml{} document.  @nxml{}
is based on @xml{} and it represents a Neko Abstract Syntax Tree
(@acronym{AST}).


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@section @nxml{} nodes


@noindent
In order to use the @nxml{} syntax we start with @code{<nxml>} and
finish with @code{</nxml>}; all @nxml{} nodes inside are Neko
expressions.  @nxml{} blocks are like Neko blocks; for example:
@code{<nxml></nxml>} is the equivalent of the empty Neko block @code{@{
@}}.

Examples of other nodes follow:

@table @code
@item <i v="3"/>
the literal integer 3;

@item <f v="1.5"/>
the literal float @code{1.5};

@item <s v="a string"/>
the literal string @code{a string};

@item <v v="id"/>
the identifier @code{id} (includes special identifiers such as @null{},
@true{}, @false{} and @code{this});

@item <b>e1 e2 e3...</b>
a block having several subexpressions;

@item <p>e</p>
parentheses around a subexpression;

@item <g v="field">e</g>
field access of a subexpression @code{(e).field};

@item <c>e0 e1 e2 e3...</c>
call of @code{e0(e1,e2,e3...)};

@item <a>e1 e2</a>
array access @code{e1[e2]};

@item <var><v v="x">e</v><v v="y"/></var>
local variable declaration, equivalent to @code{var x = e, y};

@item <while>e1 e2</while>
@code{while} loop: @code{while e1 e2};

@item <do>e1 e2</do>
@code{do...while} loop: @code{do e1 while e2};

@item <if>e0 e1</if>
equivalent of @code{if e0 e1};

@item <if>e0 e1 e2</if>
equivalent of @code{if e0 e1 else e2};

@item <o v="*">e1 e2</o>
a binary operation such as @code{e1 * e2};

@item <try v="exc">e1 e2</try>
a @code{try..catch} block: @code{try e1 catch exc e2};

@item <function v="x:y:z">e</function>
a function declaration such as @code{function(x,y,z) e};

@item <return/>
the @code{return} statement without expression;

@item <return>e</return>
@code{return} of an expression value;

@item <break/>
the @code{break} statement without expression;

@item <break>e</break>
@code{break} with an expression value;

@item <continue/>
the @code{continue} statement;

@item <next>e1 e2</next>
a way to tie two expressions together, such as @code{e1;e2};

@item <label v="here"/>
the @code{goto} label @code{here:};

@item <switch>e0 <case>e1 e2</case> <case>e1 e2</case> <default>edef</default></switch>
a @code{switch} with several cases and an optional default;

@item <object><v v="f0"><i v="42"/></v><v v="f1"><s v="foo"/></v></object>
an object literal, equivalent to the neko code @code{@{ f0 => 42, f1 =>
"foo" @}};

@item <neko>....</neko>
some neko source, can be embedded into a @code{<!CDATA[[...]]>} section.
@end table

For example, if we want to represent the Fibonacci function in @nxml{}:

@example
fib = function(n) @{
    if( n <= 1 ) 1 else fib(n-1)+fib(n-2)
@}

<o v="=">
  <v v="fib"/>
  <function v="n">
    <if>
      <o v="<="><v v="n"/><i v="1"/></o>
      <i v="1"/>
      <o v="+">
        <c><v v="fib"/><o v="-"><v v="n"/><i v="1"/></o></c>
        <c><v v="fib"/><o v="-"><v v="n"/><i v="2"/></o></c>
      </o>
    </if>
  </function>
</o>
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@section File position


@noindent
The additional attribute @code{p} can be placed on every @nxml{} node in
order to specify from which original file and line the expression is
generated.  For example @code{<i v="33" p="myfile.l:478"/>} is the
integer @code{33} referenced in @code{myfile.l} at line @code{478}.

When encountered, such position is stored and remains valid for all @nxml{}
nodes.  For example:

@example
<nxml>
  <i v="33" p="myfile.l:478"/>
  <i v="34"/>
</nxml>
@end example

@noindent
is listing two integers from @code{myfile.l}, both at line @code{478}.

If we do not specify the file name in the @code{p} attribute, it's
considered to be a number of lines skipped since the last @code{p}
information.  For example:

@example
<nxml>
  <i v="33" p="myfile.l:478"/>
  <i v="34" p="2"/>
</nxml>
@end example

@noindent
is listing two integers from @code{myfile.l}, the first is @code{33} at
line @code{478} and the second is @code{34} at line @code{480} (478 +
2).


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@section @nxml{} to Neko


@noindent
There is a @nxml{} to Neko generator which is available using the
@command{nekoc} compiler.  Simply run @code{nekoc myfile.neko}
containing Neko/@nxml{} syntax, it will create a @file{myfile2.neko}
that will only contain Neko source code.

There is no Neko to @nxml{} generator right now, although it should be
possible to write one very easily.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib
@chapter Neko library


@menu
* lib loading::                 Loading the standard library.

The standard library

* lib list::                    The list custom type.
* lib int32::                   Using 32 bits integers.
* lib buffer::                  Buffers.
* lib date::                    Date.
* lib file::                    File.
* lib math::                    Mathematical functions.
* lib md5::                     MD5.
* lib memory::                  Memory.
* lib module::                  Modules.
* lib process::                 Process.
* lib random::                  Pseudo--random numbers generation.
* lib serialise::               Serialisation.
* lib socket::                  @acronym{TCP} and @acronym{UDP} sockets.
* lib string::                  Additional string functions.
* lib sys::                     Interaction with the operating system.
* lib thread::                  Creating and managing system threads.
* lib utf8::                    Handling @utf8{} strings.
* lib xml::                     The standard event--driven @xml{} parser. 
* lib misc::                    Miscellaneous functions.

Additionally libraries

* lib cgi::                     Apache access when running @modneko{}.
* lib mysql::                   Connecting to and using MySQL databases.
* lib sqlite::                  Connecting to and using Sqlite databases.
* lib regexp::                  Regular expressions using the @acronym{PCRE} engine.
* lib gui::                     Core native user interface support.
* lib zlib::                    Compression library.
@end menu


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib loading
@section Loading the standard library


@noindent
The following is an example module that can be used to load the Neko
standard library.  The module must be compiled and installed in a
reachable directory, for example, under the name @file{stdlib.n}.

The suggested way to use it is to adopt @code{std} as name of the table
of imported functions; so we should do:

@example
var std = $loader.loadmodule("stdlib", $loader);
@end example

@noindent
and then call the library functions like this:

@example
var current_data = std.date_now();
@end example

@noindent
using the @code{std.} prefix.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@example
// stdlib.neko --
//
// Load the Neko standard library.

var stdload = function (name, arity) @{
  return $loader.loadprim("std" + "@@" + name, arity);
@}

$exports.buffer_new             = stdload("buffer_new",         0);
$exports.buffer_add             = stdload("buffer_add",         2);
$exports.buffer_add_char        = stdload("buffer_add_char",    2);
$exports.buffer_add_sub         = stdload("buffer_add_sub",     4);
$exports.buffer_string          = stdload("buffer_string",      1);
$exports.buffer_reset           = stdload("buffer_reset",       1);

$exports.date_now               = stdload("date_now",           0);
$exports.date_new               = stdload("date_new",           1);
$exports.date_format            = stdload("date_format",        2);
$exports.date_set_hour          = stdload("date_set_hour",      4);
$exports.date_set_day           = stdload("date_set_day",       4);
$exports.date_get_day           = stdload("date_get_day",       1);
$exports.date_get_hour          = stdload("date_get_hour",      1);
$exports.date_get_tz            = stdload("date_get_tz",        0);

$exports.file_open              = stdload("file_open",          2);
$exports.file_close             = stdload("file_close",         1);
$exports.file_name              = stdload("file_name",          1);
$exports.file_write             = stdload("file_write",         4);
$exports.file_read              = stdload("file_read",          4);
$exports.file_write_char        = stdload("file_write_char",    2);
$exports.file_read_char         = stdload("file_read_char",     1);
$exports.file_seek              = stdload("file_seek",          3);
$exports.file_tell              = stdload("file_tell",          1);
$exports.file_eof               = stdload("file_eof",           1);
$exports.file_flush             = stdload("file_flush",         1);
$exports.file_contents          = stdload("file_contents",      1);
$exports.file_stdin             = stdload("file_stdin",         0);
$exports.file_stdout            = stdload("file_stdout",        0);
$exports.file_stderr            = stdload("file_stderr",        0);
  
$exports.math_atan2             = stdload("math_atan2",         2);
$exports.math_pow               = stdload("math_pow",           2);
$exports.math_abs               = stdload("math_abs",           1);
$exports.math_ceil              = stdload("math_ceil",          1);
$exports.math_floor             = stdload("math_floor",         1);
$exports.math_round             = stdload("math_round",         1);
$exports.math_pi                = stdload("math_pi",            0);
$exports.math_sqrt              = stdload("math_sqrt",          1);
$exports.math_atan              = stdload("math_atan",          1);
$exports.math_cos               = stdload("math_cos",           1);
$exports.math_sin               = stdload("math_sin",           1);
$exports.math_tan               = stdload("math_tan",           1);
$exports.math_log               = stdload("math_log",           1);
$exports.math_exp               = stdload("math_exp",           1);
$exports.math_acos              = stdload("math_acos",          1);
$exports.math_asin              = stdload("math_asin",          1);

$exports.make_md5               = stdload("make_md5",           1);

$exports.mem_size               = stdload("mem_size",           1);

$exports.module_read            = stdload("module_read",        2);
$exports.module_read_path       = stdload("module_read_path",   3);
$exports.module_exec            = stdload("module_exec",        1);
$exports.module_name            = stdload("module_name",        1);
$exports.module_exports         = stdload("module_exports",     1);
$exports.module_loader          = stdload("module_loader",      1);
$exports.module_nglobals        = stdload("module_nglobals",    1);
$exports.module_global_get      = stdload("module_global_get",  2);
$exports.module_global_set      = stdload("module_global_set",  3);
$exports.module_code_size       = stdload("module_code_size",   1);

$exports.process_run            = stdload("process_run",         2);
$exports.process_stdout_read    = stdload("process_stdout_read", 4);
$exports.process_stderr_read    = stdload("process_stderr_read", 4);
$exports.process_stdin_write    = stdload("process_stdin_write", 4);
$exports.process_stdin_close    = stdload("process_stdin_close", 1);
$exports.process_exit           = stdload("process_exit",        1);
$exports.process_pid            = stdload("process_pid",         1);
$exports.process_close          = stdload("process_close",       1);

$exports.random_new             = stdload("random_new",         0);
$exports.random_set_seed        = stdload("random_set_seed",    2);
$exports.random_int             = stdload("random_int",         2);
$exports.random_float           = stdload("random_float",       1);

$exports.serialize              = stdload("serialize",          1);
$exports.unserialize            = stdload("unserialize",        2);

$exports.socket_init            = stdload("socket_init",        0);
$exports.socket_new             = stdload("socket_new",         1);
$exports.socket_close           = stdload("socket_close",       1);
$exports.socket_send_char       = stdload("socket_send_char",   2);
$exports.socket_send            = stdload("socket_send",        4);
$exports.socket_recv            = stdload("socket_recv",        4);
$exports.socket_recv_char       = stdload("socket_recv_char",   1);
$exports.socket_write           = stdload("socket_write",       2);
$exports.socket_read            = stdload("socket_read",        1);
$exports.host_resolve           = stdload("host_resolve",       1);
$exports.host_to_string         = stdload("host_to_string",     1);
$exports.host_reverse           = stdload("host_reverse",       1);
$exports.host_local             = stdload("host_local",         0);
$exports.socket_connect         = stdload("socket_connect",     3);
$exports.socket_listen          = stdload("socket_listen",      2);
$exports.socket_select          = stdload("socket_select",      4);
$exports.socket_bind            = stdload("socket_bind",        3);
$exports.socket_accept          = stdload("socket_accept",      1);
$exports.socket_peer            = stdload("socket_peer",        1);
$exports.socket_host            = stdload("socket_host",        1);
$exports.socket_set_timeout     = stdload("socket_set_timeout", 2);
$exports.socket_shutdown        = stdload("socket_shutdown",    3);
$exports.socket_set_blocking    = stdload("socket_set_blocking",2);
$exports.socket_poll_alloc      = stdload("socket_poll_alloc",  1);
$exports.socket_poll_prepare    = stdload("socket_poll_prepare",3);
$exports.socket_poll_events     = stdload("socket_poll_events", 2);
$exports.socket_poll            = stdload("socket_poll",        3);

$exports.string_split           = stdload("string_split",       2);
$exports.sprintf                = stdload("sprintf",            2);
$exports.url_encode             = stdload("url_encode",         1);
$exports.url_decode             = stdload("url_decode",         1);
$exports.base_encode            = stdload("base_encode",        2);
$exports.base_decode            = stdload("base_decode",        2);

$exports.get_env                = stdload("get_env",            1);
$exports.put_env                = stdload("put_env",            2);
$exports.sys_env                = stdload("sys_env",            0);
$exports.sys_sleep              = stdload("sys_sleep",          1);
$exports.set_time_locale        = stdload("set_time_locale",    1);
$exports.sys_time               = stdload("sys_time",           0);
$exports.sys_cpu_time           = stdload("sys_cpu_time",       0);
$exports.get_cwd                = stdload("get_cwd",            0);
$exports.set_cwd                = stdload("set_cwd",            1);
$exports.sys_string             = stdload("sys_string",         0);
$exports.sys_is64               = stdload("sys_is64",           0);
$exports.sys_command            = stdload("sys_command",        1);
$exports.sys_exit               = stdload("sys_exit",           1);
$exports.sys_exists             = stdload("sys_exists",         1);
$exports.file_exists            = stdload("file_exists",        1);
$exports.file_delete            = stdload("file_delete",        1);
$exports.sys_rename             = stdload("sys_rename",         2);
$exports.sys_stat               = stdload("sys_stat",           1);
$exports.sys_file_type          = stdload("sys_file_type",      1);
$exports.sys_create_dir         = stdload("sys_create_dir",     2);
$exports.sys_remove_dir         = stdload("sys_remove_dir",     1);
$exports.sys_read_dir           = stdload("sys_read_dir",       1);
$exports.file_full_path         = stdload("file_full_path",     1);
$exports.sys_exe_path           = stdload("sys_exe_path",       0);
$exports.sys_getch              = stdload("sys_getch",          1);
$exports.sys_get_pid            = stdload("sys_get_pid",        0);

$exports.thread_create          = stdload("thread_create",      2);
$exports.thread_current         = stdload("thread_current",     0);
$exports.thread_send            = stdload("thread_send",        2);
$exports.thread_read_message    = stdload("thread_read_message",1);
$exports.lock_create            = stdload("lock_create",        0);
$exports.lock_release           = stdload("lock_release",       1);
$exports.lock_wait              = stdload("lock_wait",          2);
$exports.tls_create             = stdload("tls_create",         0);
$exports.tls_set                = stdload("tls_set",            2);
$exports.tls_get                = stdload("tls_get",            1);
$exports.mutex_create           = stdload("mutex_create",       0);
$exports.mutex_acquire          = stdload("mutex_acquire",      1);
$exports.mutex_try              = stdload("mutex_try",          1);
$exports.mutex_release          = stdload("mutex_release",      1);
$exports.deque_create           = stdload("deque_create",       0);
$exports.deque_add              = stdload("deque_add",          2);
$exports.deque_push             = stdload("deque_push",         2);
$exports.deque_pop              = stdload("deque_pop",          2);

$exports.utf8_buf_alloc         = stdload("utf8_buf_alloc",     1);
$exports.utf8_buf_add           = stdload("utf8_buf_add",       2);
$exports.utf8_buf_content       = stdload("utf8_buf_content",   1);
$exports.utf8_buf_length        = stdload("utf8_buf_length",    1);
$exports.utf8_buf_size          = stdload("utf8_buf_size",      1);
$exports.utf8_validate          = stdload("utf8_validate",      1);
$exports.utf8_length            = stdload("utf8_length",        1);
$exports.utf8_sub               = stdload("utf8_sub",           3);
$exports.utf8_get               = stdload("utf8_get",           2);
$exports.utf8_iter              = stdload("utf8_iter",          2);
$exports.utf8_compare           = stdload("utf8_compare",       2);

$exports.parse_xml              = stdload("parse_xml",          2);

$exports.float_bytes            = stdload("float_bytes",        2);
$exports.double_bytes           = stdload("double_bytes",       2);
$exports.float_of_bytes         = stdload("float_of_bytes",     2);
$exports.double_of_bytes        = stdload("double_of_bytes",    2);
$exports.run_gc                 = stdload("run_gc",             1);
$exports.gc_stats               = stdload("gc_stats",           0);
$exports.enable_jit             = stdload("enable_jit",         1);
$exports.test                   = stdload("test",               0);
$exports.print_redirect         = stdload("print_redirect",     1);

$exports.int32_new              = stdload("int32_new",          1);
$exports.int32_to_int           = stdload("int32_to_int",       1);
$exports.int32_to_float         = stdload("int32_to_float",     1);
$exports.int32_compare          = stdload("int32_compare",      2);
$exports.int32_add              = stdload("int32_add",          2);
$exports.int32_sub              = stdload("int32_sub",          2);
$exports.int32_mul              = stdload("int32_mul",          2);
$exports.int32_div              = stdload("int32_div",          2);
$exports.int32_neg              = stdload("int32_neg",          1);
$exports.int32_ushr             = stdload("int32_ushr",         2);
$exports.int32_shl              = stdload("int32_shl",          2);
$exports.int32_shr              = stdload("int32_shr",          2);
$exports.int32_mod              = stdload("int32_mod",          2);
$exports.int32_complement       = stdload("int32_complement",   1);
$exports.int32_or               = stdload("int32_or",           2);
$exports.int32_and              = stdload("int32_and",          2);
$exports.int32_xor              = stdload("int32_xor",          2);
$exports.int32_address          = stdload("int32_address",      1);

/// end of file
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib list
@section The list custom type


@cindex @code{#list} custom type


@noindent
Sometimes the Neko library makes use of a custom list type to organise a
sequence of values; a @code{#list} is a tree of nested arrays organised
like a Lisp list:

@example
  -------     -------     -------
 | 0 | 1 |-->| 0 | 1 |-->| 0 | 1 |--> [null]
  -------     -------     -------
   |           |           |
   v           v           v
[value]     [value]     [value]
@end example

@noindent
to build such a tree of arrays we can use code like this:

@example
var the_list = $array("one", 
                      $array("two",
                             $array("three", null)));
@end example

@noindent
and to extract values we do:

@example
the_list[0];            // evaluate to: "one"
the_list[1][0];         // evaluate to: "two"
the_list[1][1][0];      // evaluate to: "three"
the_list[1][1][1];      // evaluate to: null
@end example

@noindent
and to iterate over the values:

@example
var ell = the_list;

while (null != ell)
  @{
    $print("the value is: " + ell[0] + "\n");
    ell = ell[1];
  @}
@end example

@ref{examples list} for a Neko module that manipulates lists.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib int32
@section Using 32 bits integers


@menu
* lib int32 make::              Constructors.
* lib int32 conversion::        Conversion.
* lib int32 comparison::        Comparison.
* lib int32 arithmetics::       Arithmetic operations.
* lib int32 bitwise::           Bitwise operations.
* lib int32 misc::              Miscellaneous operations.
@end menu


@noindent
Int32 is an abstract type that can be used to store the full 32 bits of
an integer.  The type @code{'int32} means that the value is a real
int32.  The type @code{#int32} means @code{(int | 'int32)}.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib int32 make
@subsection Constructors


@deftypefn {Neko Function} 'int32 int32_new (@var{value} : #int32 | float)
Allocate an int32 from any integer or float.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib int32 conversion
@subsection Conversion


@deftypefn {Neko Function} int int32_to_int (@var{value} : #int32)
Return the integer value if it can be represented using 31 bits.
Otherwise an error is raised.
@end deftypefn


@deftypefn {Neko Function} float int32_to_float (@var{value} : #int32)
Return a float representing the integer.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib int32 comparison
@subsection Comparison


@deftypefn {Neko Function} int int32_compare (@var{a} : #int32, @var{b} : #int32)
Compare two integers.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib int32 arithmetics
@subsection Arithmetic operations


@deftypefn {Neko Function} #int32 int32_add (@var{a} : #int32, @var{b} : #int32)
Add two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_sub (@var{a} : #int32, @var{b} : #int32)
Subtract two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_mul (@var{a} : #int32, @var{b} : #int32)
Multiply two integers.
@end deftypefn
 

@deftypefn {Neko Function} #int32 int32_div (@var{a} : #int32, @var{b} : #int32)
Divide two integers.  An error is raised on division by zero.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_neg (@var{value} : #int32)
Return the negative value of an integer.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib int32 bitwise
@subsection Bitwise operations



@deftypefn {Neko Function} #int32 int32_ushr (@var{value} : #int32, @var{amount} : #int32)
Perform unsigned bits right shifting upon @var{value}.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_shl (@var{value} : #int32, @var{amount} : #int32)
Perform bit left shifting.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_shr (@var{value} : #int32, @var{amound} : #int32)
Perform bit right shifting.
@end deftypefn

 
@deftypefn {Neko Function} #int32 int32_mod (@var{value} : #int32, @var{base} : #int32)
Return the modulo of one integer by the other.  An error is raised if
@var{base} is zero.
@end deftypefn
 

@deftypefn {Neko Function} #int32 int32_complement (@var{value} : #int32)
Return the bitwise one--complement integer of @var{value}.
@end deftypefn
 

@deftypefn {Neko Function} #int32 int32_or (@var{a} : #int32, @var{b} : #int32)
Return the bitwise OR between two integers.
@end deftypefn

 
@deftypefn {Neko Function} #int32 int32_and (@var{a} : #int32, @var{b} : #int32)
Return the bitwise AND between two integers.
@end deftypefn


@deftypefn {Neko Function} #int32 int32_xor (@var{a} : #int32, @var{b} : #int32)
Return the bitwise XOR of two integers.
@end deftypefn
 

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib int32 misc
@subsection Miscellaneous operations


@deftypefn {Neko Function} #int32 int32_address (@var{value} : any)
Return the address of the value.  The address should not be considered
constant.  It is not unique either unless we are sure we are running on
a 32 bits platform.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib buffer
@section Buffers


@noindent
A buffer can store any value as a string and will only allocate the
total needed space when requested.  It makes a copy of each value when
stored so modifying them later is not a problem.


@deftypefn {Neko Function} 'buffer buffer_new (void)
Allocate a new empty buffer.
@end deftypefn


@deftypefn {Neko Function} void buffer_add (@var{b} : 'buffer, @var{value} : any)
Convert @var{value} to a string then append the string to @var{b}.
@end deftypefn


@deftypefn {Neko Function} void buffer_add_char (@var{b} : 'buffer, @var{c} : int)
Add a single char to a buffer; it is an error if @var{c} is not in the
@code{[0, 255]} range.
@end deftypefn


@deftypefn {Neko Function} void buffer_add_sub (@var{b} : 'buffer, @var{string} : string, @var{position} : int, @var{number_of_chars} : int)
Append to the buffer @var{number_of_chars} from @var{string}, starting
at @var{position}.  An error occurs if out of string bounds.
@end deftypefn


@deftypefn {Neko Function} string buffer_string (@var{b} : 'buffer)
Build and return a string holding the buffer contents.
@end deftypefn


@deftypefn {Neko Function} void buffer_reset (@var{b} : 'buffer)
Clean the buffer contents, leaving it empty.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib date
@section Date


@noindent
The date module uses standard C functions in order to manipulate 32 bits
integers.  Dates are represented as the number of seconds elapsed since
1st January 1970.


@deftypefn {Neko Function} 'int32 date_now (void)
Return current date and time.
@end deftypefn


@deftypefn {Neko Function} 'int32 date_new (@var{s} : string?)
Parse a date formatted string.  The following formats are accepted:

@table @code
@item null
return current date and time;

@item YYYY-MM-DD HH:MM:SS
full date and time;

@item YYYY-MM-DD
date only (time will be set to midnight);

@item HH:MM:SS
this represents an elapsed time; it will be corrected with timezone so
we can subtract it from a date.
@end table
@end deftypefn


@deftypefn {Neko Function} string date_format (@var{date} : 'int32, @var{fmt} : string?)
Format a date using the C language function @cfunction{strftime}.  If
@var{fmt} is @null{} then the default format is used.
@end deftypefn


@deftypefn {Neko Function} 'int32 date_set_hour (@var{date} : 'int32, @var{hours} : int, @var{minutes} : int, @var{seconds} : int)
Change the time of a date.  Return the modified date.
@end deftypefn


@deftypefn {Neko Function} 'int32 date_set_day (@var{date} 'int32, @var{year} : int, @var{month} : int, @var{day} : int)
Change the day of a date.  Return the modified date.
@end deftypefn


@deftypefn {Neko Function} {@{ y => int, m => int, d => int@}} date_get_day (@var{date} : 'int32)
Return the year month and day of a date stored in an object.  Object
fields are: @code{y} holds the year as string, @code{m} holds the month
as string, @code{d} holds the day as string.
@end deftypefn


@deftypefn {Neko Function} {@{ h => int, m => int, s => int@}} date_get_hour (@var{date} : 'int32)
Return the hour minutes and seconds of a date stored in an object.
Object fields are: @code{h} holds the hour as string, @code{m} holds the
minutes as string, @code{s} holds the seconds as string.
@end deftypefn


@deftypefn {Neko Function} int date_get_tz (void)
Return the local Timezone (in seconds).
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib file
@section File


@menu
* lib file open::               Opening and closing files.
* lib file io::                 Input/output upon files.
* lib file seek::               Setting the position.
@end menu


@noindent
The file @api{} can be used for different kind of file I/O; it is mostly
based upon the standard C language functions.


@deftypefn {Neko Function} 'file file_stdin (void)
@deftypefnx {Neko Function} 'file file_stdout (void)
@deftypefnx {Neko Function} 'file file_stderr (void)
Return a standard channel.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib file open
@subsection Opening and closing files


@deftypefn {Neko Function} 'file file_open (@var{pathname} : string, @var{access} : string)
Call @cfunction{fopen} with the given @var{pathname} and access rights.
Return the opened file or throw an exception if an error occurs.
@end deftypefn


@deftypefn {Neko Function} void file_close (@var{f} : 'file)
Close a file.  Any operation on @var{f} file will fail after
@function{file_close} has been applied to it.
@end deftypefn


@deftypefn {Neko Function} string file_name (@var{f} : 'file)
Return the name of the file associated to @var{f}.
@end deftypefn


@deftypefn {Neko Function} int file_write (@var{f} : 'file, @var{s} : string, @var{p} : int, @var{l} : int)
Write up to @var{l} chars from the string @var{s} starting at position
@var{p}.  Return the number of chars written, which will be zero or a
positive number.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib file io
@subsection Input/output upon files


@deftypefn {Neko Function} int file_read (@var{f} : 'file, @var{s} : string, @var{p} : int, @var{l} : int)
Read up to @var{l} chars into the string @var{s} starting at position
@var{p}.  Return the number of chars read, which will be a positive
number or @code{0} if @code{@var{l} == 0}.
@end deftypefn


@deftypefn {Neko Function} void file_write_char (@var{f} : 'file, @var{c} : int)
Write the char @var{c}.  It is an error if @var{c} is outside of the
range @code{[0, 255]}.
@end deftypefn


@deftypefn {Neko Function} int file_read_char (@var{f} : 'file)
Read a char from the file.  Throw an exception if an error occurs.
@end deftypefn


@deftypefn {Neko Function} void file_flush (@var{f} : 'file)
Flush the file buffer.
@end deftypefn


@deftypefn {Neko Function} string file_contents (@var{pathname} : string)
Read the content of the file and return it.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib file seek
@subsection Setting the position


@deftypefn {Neko Function} void file_seek (@var{f} : 'file, @var{pos} : int, @var{mode} : int)
Use @cfunction{fseek} to move the file position.
@end deftypefn


@deftypefn {Neko Function} int file_tell (@var{f} : 'file)
Return the current position in the file.
@end deftypefn


@deftypefn {Neko Function} bool file_eof (@var{f} : 'file)
Tell if we have reached the end of the file.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib math
@section Mathematical functions


@deftypefn {Neko Function} float math_atan2 (@var{y} : number, @var{x} : number)
Return the @cfunction{atan2} calculus.
@end deftypefn


@deftypefn {Neko Function} float math_pow (@var{n} : number, @var{exp} : number)
Return power calculus.
@end deftypefn


@deftypefn {Neko Function} number math_abs (@var{n} : number)
Return absolute value of a number.
@end deftypefn


@deftypefn {Neko Function} int math_ceil (@var{n} : number)
Return rounded--up integer.
@end deftypefn


@deftypefn {Neko Function} int math_floor (@var{n} : number)
Return rounded--down integer.
@end deftypefn


@deftypefn {Neko Function} int math_round (@var{n} : number)
Return nearest integer.
@end deftypefn


@deftypefn {Neko Function} float math_pi (void)
Return the value of PI.
@end deftypefn


@deftypefn {Neko Function} float math_sqrt (@var{n} : number)
Return the square root.
@end deftypefn


@deftypefn {Neko Function} float math_atan (@var{n} : number)
Return the arctangent.
@end deftypefn


@deftypefn {Neko Function} float math_cos (@var{n} : number)
Return the cosine.
@end deftypefn


@deftypefn {Neko Function} float math_sin (@var{n} : number)
Return the sine.
@end deftypefn


@deftypefn {Neko Function} float math_tan (@var{n} : number)
Return the tangent.
@end deftypefn


@deftypefn {Neko Function} float math_log (@var{n} : number)
Return the logarithm.
@end deftypefn


@deftypefn {Neko Function} float math_exp (@var{n} : number)
Return the exponent.
@end deftypefn


@deftypefn {Neko Function} float math_acos (@var{n} : number)
Return the arccosine.
@end deftypefn


@deftypefn {Neko Function} float math_asin (@var{n} : number)
Return the arcsine.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib md5
@section MD5


@deftypefn {Neko Function} string make_md5 (@var{value} : any)
Build a MD5 digest (16 bytes binary string) from any value. 
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib memory
@section Memory


@noindent
An @api{} for memory manipulation and statistics.


@deftypefn {Neko Function} int mem_size (@var{value} : any)
Calculate the quite precise amount of @vm{} memory reachable from this
value.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib module
@section Modules


@noindent
An @api{} for reflexion of Neko bytecode modules.


@deftypefn {C Language Function} 'module module_read (@var{fread} : function:3, @var{loader} : object)
Read a module using the selected read function and the specified loader.
The reader function has Neko signature:

@example
int @var{fread} (@var{b} : string, @var{position} : int, @var{number_of_bytes} : int)
@end example

@noindent
where: @var{b} is a string in which to store loaded code, @var{position}
is the offset from the start of the string to which append the code,
@var{number_of_bytes} is the maximum size of code to append.

The return value of @var{fread} must be the number of bytes appended to
the string or @code{-1} if an error occurred; it is an error to return a
value equal to or grater than @var{number_of_bytes}.

@var{fread} can be invoked any number of times to load chunk after chunk
of bytecode; when all the available bytecode has been read: @var{fread}
should just return @code{0} to signal the end of code event.
@end deftypefn


@deftypefn {Neko Function} 'module module_read_path (@var{path} : string #list, @var{module_name} : string, @var{loader} : object)
Read a module using the specified search path and loader.
@var{module_name} can be a platform specific file pathname or the file
name with or without the @code{.n} extension.

If the attempt to open @var{module_name} directly fails: @var{path} is
used to build a set of alternative file pathnames.  @var{path} must be a
list of strings representing file pathname prefixes: they will be
prepended to @var{module_name} as is; this means that if the elements of
@var{path} are directory pathnames, they must end with a separator
(@code{/} on Unix) or the prepending operation will build an invalid
pathname.  Example:

@example
var the_path = $array("/usr/lib/neko/",
                      $array("/usr/local/lib/neko/", null);
var mod = module_read_path(the_path, "the_module", $loader);
@end example

@noindent
will search the file @file{the_module.n} in the following locations:

@example
./the_module.n
/usr/lib/neko/the_module.n
/usr/local/lib/neko/the_module.n
@end example

@ref{lib list} for an explanation of what a @code{#list} is.
@end deftypefn


@deftypefn {Neko Function} any module_exec (@var{m} : 'module)
Execute the module in the current @vm{}; return the calculated value,
that is the result of evaluating the last expression in the module.

If the module just defines functions to be exported: the return value
will be the last defined function, which, usually, is useless.
@end deftypefn


@deftypefn {Neko Function} string module_name (@var{m} : 'module)
Return the module name: actually this is the file pathname that was used
to load the file (directory part included).
@end deftypefn


@deftypefn {Neko Function} object module_exports (@var{m} : 'module)
Return the module export table: the value bound to @builtin{exports} in
the module top level scope.
@end deftypefn


@deftypefn {Neko Function} object module_loader (@var{m} : 'module)
Return the module loader: the value bound to @builtin{$loader} in the
module top level scope, which was selected when loading the module.
@end deftypefn


@deftypefn {Neko Function} int module_nglobals (@var{m} : 'module)
Return the number of globals for this module.
@end deftypefn


@deftypefn {Neko Function} any module_global_get (@var{m} : 'module, @var{n} : int)
Get the nth global.
@end deftypefn


@deftypefn {Neko Function} void module_global_set (@var{m} : 'module, @var{n} : int, @var{value} : any)
Set the nth global.
@end deftypefn


@deftypefn {Neko Function} int module_code_size (@var{m} : 'module)
Return the code size of the module.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib process
@section Process


@noindent
An @api{} for starting and communication with sub processes.


@deftypefn {Neko Function} 'process process_run (@var{cmd} : string, @var{args} : string array)
Start a process using a command and the specified arguments.  Example:

@example
var p = process_run("ls", $amake("-l", "-R"));
@end example

@var{cmd} must be the pathname of the executable file or the name of the
executable file; in the latter case the environment is examined to find
the executable on the system.  On Unix like systems the C functions
@cfunction{fork} and @cfunction{execvp} are used, on Windows systems
@cfunction{CreateProcess} is used.

If there are no arguments we have to use @code{$amake(0)} as value of
@var{args}.
@end deftypefn


@deftypefn {Neko Function} int process_stdout_read (@var{p} : 'process, @var{buf} : string, @var{position} : int, @var{number_of_bytes} : int)
Read up to @var{number_of_bytes} from the standard output channel of
@var{p} and append them to @var{buf} starting at @var{position}.  Return
the number of bytes read this way.  Raise an exception if this process'
@code{stdout} is closed and no more data is available for reading.
@end deftypefn


@deftypefn {Neko Function} int process_stderr_read (@var{p} : 'process, @var{buf} : string, @var{position} : int, @var{number_of_bytes} : int)
Read up to @var{number_of_bytes} from the standard error channel of
@var{p} and append them to @var{buf} starting at @var{position}.  Return
the number of bytes read this way.  Raise an exception if this process'
@code{stderr} is closed and no more data is available for reading.
@end deftypefn


@deftypefn {Neko Function} int process_stdin_write (@var{p} : 'process, @var{buf} : string, @var{position} : int, @var{number_of_bytes} : int)
Write up to @var{number_of_bytes} bytes from @var{buf} starting at
@var{position} to the process' @code{stdin}.  Return the number of bytes
written this way.  Raise an exception if this process' @code{stdin} is
closed.
@end deftypefn


@deftypefn {Neko Function} void process_stdin_close (@var{p} : 'process)
Close the process standard input.
@end deftypefn


@deftypefn {Neko Function} int process_exit (@var{p} : 'process)
Wait until the process terminates, then returns its exit code.
@end deftypefn


@deftypefn {Neko Function} int process_pid (@var{p} : 'process)
Returns the process' id.
@end deftypefn


@deftypefn {Neko Function} void process_close (@var{p} : 'process)
Close the process' input/output channels and terminate the process.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib random
@section Pseudo--random numbers generation


@deftypefn {Neko Function} 'random random_new (void)
Create a new random with random seed.
@end deftypefn


@deftypefn {Neko Function} void random_set_seed (@var{r} : 'random, @var{seed} : int)
Set the generator seed.
@end deftypefn


@deftypefn {Neko Function} int random_int (@var{r} : 'random, @var{max} : int)
Return a random integer modulo @var{max}.
@end deftypefn


@deftypefn {Neko Function} float random_float (@var{r} : 'random)
Return a random float.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib serialise
@section Serialisation


@findex __serialize

@noindent
Serialisation can be used in order to store permanently some runtime
value.  Serialisation of all values is possible, except @emph{abstracts}
with the special cases of @code{'int32} and @code{'hash} which are
handled by Neko.

Serialisation of bytecode functions is possible, but it will result in a
runtime exception when deserialising if the function offset in the
bytecode has changed.

We can define the @function{__serialize} method of an object.  When this
method is found, while serialising the object, it is called with no
arguments and its return value will be serialised.  The name of the
module the method is declared in will also be serialised.  When
deserialising, the module is loaded and its @function{__unserialize}
exported function is called with the value that was returned by
@function{__serialize}.


@deftypefn {Neko Function} string serialize (@var{value} : any)
Serialise any value recursively.
@end deftypefn


@deftypefn {Neko Function} any unserialize (@var{s} : string, @var{loader} : object)
Deserialise a stored value.  Need a loader to look for modules if some
bytecode functions have been serialised.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket
@section @acronym{TCP} and @acronym{UDP} sockets


@menu
* lib socket creating::         Creating sockets.
* lib socket client::           Connecting as client.
* lib socket server::           Setting up a server.
* lib socket io::               Sending and receiving.
* lib socket select::           Selecting events on sockets.
* lib socket poll::             Polling events on sockets.
* lib socket resolver::         Resolving addresses.
* lib socket misc::             Miscellaneous functions.
@end menu


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket creating
@subsection Creating sockets


@deftypefn {Neko Function} void socket_init (void)
Initialise the socket @api{}.  Must be called at least once per process
before using any socket or host function.
@end deftypefn


@deftypefn {Neko Function} 'socket socket_new (@var{udp} : bool)
Create a new socket, @acronym{TCP} or @acronym{UDP}.  @acronym{UDP} is
selected if @var{udp} is @true{}.
@end deftypefn


@deftypefn {Neko Function} void socket_close (@var{sock} : 'socket)
Close a socket.  Any subsequent operation on this socket will fail.
@end deftypefn


@deftypefn {Neko Function} void socket_shutdown (@var{sock} : 'socket, @var{read} : bool, @var{write} : bool)
Prevent the socket from further reading or writing or both.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket client
@subsection Connecting as client


@deftypefn {Neko Function} void socket_connect (@var{sock} : 'socket, @var{host} : 'int32, @var{port} : int)
Connect the socket the given @var{host} and @var{port}.
@end deftypefn


Example of @acronym{TCP} connection to @code{localhost:8080}:

@example
socket_init();

var sock = socket_new(false);
var ip   = host_resolve("localhost");
var port = 8080;

socket_connect(client, ip, port);

... // read/write data using 'sock'

socket_close(sock);
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket server
@subsection Setting up a server


@deftypefn {Neko Function} void socket_bind (@var{sock} : 'socket, @var{host} : 'int32, @var{port} : int)
Bind the socket for server usage on the given host and port.
@end deftypefn


@deftypefn {Neko Function} void socket_listen (@var{sock} : 'socket, @var{n} : int)
Listen for a number of connections.
@end deftypefn


@deftypefn {Neko Function} 'socket socket_accept (@var{sock} : 'socket)
Accept an incoming connection request.
@end deftypefn


Example of @acronym{TCP} listening and accepting on @code{localhost:8080}:

@example
socket_init();

var server = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);

var sock = socket_accept(server);

socket_set_timeout(client, 1);

... // read/write data using 'sock'

socket_close(sock);
socket_close(server);
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket io
@subsection Sending and receiving


@subsubsection Characters


@deftypefn {Neko Function} void socket_send_char (@var{sock} : 'socket, @var{c} : int)
Send a character over a connected socket; return @true{} is success.
@var{c} must be in the range @code{[0, 255]}.
@end deftypefn


@deftypefn {Neko Function} int socket_recv_char (@var{sock} : 'socket)
Read and return a single char from a connected socket.
@end deftypefn


Example of exchanging a character through @code{localhost:8080}:

@example
socket_init();
var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

socket_send_char(sock, 65);
socket_recv_char(client);   // return 65

socket_close(sock);
socket_close(server);
socket_close(client);
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@subsubsection Data using buffers


@noindent
The following functions send and receive data from strings used as
buffers.


@deftypefn {Neko Function} int socket_send (@var{sock} : 'socket, @var{buf} : string, @var{pos} : int, @var{len} : int)
Send up to @var{len} bytes from @var{buf} starting at @var{pos} over a
connected socket.  Return the number of sent bytes.
@end deftypefn


@deftypefn {Neko Function} int socket_recv (@var{sock} 'socket, @var{buf} : string, @var{pos} : int, @var{len} : int)
Read up to @var{len} bytes from @var{buf} starting at @var{pos} from a
connected socket.  Return the number of received bytes.
@end deftypefn


Example of exchanging a data through @code{localhost:8080}:

@example
socket_init();
var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var out = "ciao";
var in  = $smake(4);
socket_send(sock,   out, 0, 4);  // return 4
socket_recv(client, in,  0, 4);  // return 4

// here 'in' holds "ciao"

socket_close(sock);
socket_close(server);
socket_close(client);
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@subsubsection Whole strings


@deftypefn {Neko Function} void socket_write (@var{sock} : 'socket, @var{s} : string)
Send the whole content of a string over a connected socket.  Return
@true{} if success.
@end deftypefn


@deftypefn {Neko Function} string socket_read (@var{sock} : 'socket)
Read and return the whole content of a the data available from a socket
until the connection is closed by the foreign host.  If the socket
hasn't been closed by the other side, the function might block.
@end deftypefn


Example of exchanging a string through @code{localhost:8080}:

@example
socket_init();
var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

socket_write(sock, "hello");
socket_close(sock);
socket_read(client);  // return "hello"

socket_close(server);
socket_close(client);
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@subsubsection Configuration


@deftypefn {Neko Function} void socket_set_blocking (@var{sock} : 'socket, @var{b} : bool)
Turn on/off the socket blocking mode.
@end deftypefn


@deftypefn {Neko Function} void socket_set_timeout (@var{sock} : 'socket, @var{timeout} : number?)
Set the socket send and recv timeout in seconds to the given value (or
@null{} for blocking).
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket select
@subsection Selecting events on sockets


@deftypefn {Neko Function} {'socket array? array} socket_select (@var{read} : 'socket array?, @var{write} : 'socket array?, @var{others} : 'socket array?, @var{timeout} : number?)
Perform the @cfunction{select} operation.  Arguments description:

@table @var
@item read
must be an array of sockets for which we want to know if data is
available for reading;

@item write
must be an array of sockets for which we want to know if they are ready
to send data; usually a socket @strong{is} ready to send data;

@item others
must be an array of sockets for which we want to know if an exception
was detected;

@item timeout
is in seconds or @null{} if infinite.
@end table

If we are not interested in events of a kind: we must set @var{read},
@var{write} or @var{others} to @null{}, @strong{not} to the empty array.

The return value is an array of 3 elements, one for each kind of event:
the element with index @code{0} for read--ready sockets; the element
with index @code{1} for write--ready sockets; the element with index
@code{2} or sockets under exception condition.

The elements of the returned array can be:

@table @asis
@item @null{}
if @null{} was used as parameter for a kind, then @null{} is stored in
the returned array for that kind;

@item @code{'socket array}
the array of sockets that are ready for an event; this array can be
empty if no sockets are ready.
@end table
@end deftypefn


Example of exchanging a character through @code{localhost:8080}:

@example
socket_init();

var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var them = socket_select($array(sock, client), $array(sock, client), null, 1);

// Result of select:
//
// no read-ready sockets:               0 == $asize(them[0])
// 2 write-ready sockets:               2 == $asize(them[1])
// the first write-ready is 'sock':     sock   == them[1][0]
// the second write-ready is 'client':  client == them[1][1]
// no exception sockets:                null == them[2]

socket_send_char(sock, 65);

var them = socket_select($array(sock, client), $array(sock, client), null, 1);

// Result of select:
//
// 1 read-ready socket:                 1 == $asize(them[0])
// the read-ready socket is 'client':   client == them[0][0]
// 2 write-ready sockets:               2 == $asize(them[1])
// the first write-ready is 'sock':     sock   == them[1][0]
// the second write-ready is 'client':  client == them[1][1]
// no exception sockets:                null == them[2]

socket_recv_char(client);

var them = socket_select($array(sock, client), $array(sock, client), null, 1);

// Result of select:
//
// no read-ready sockets:               0 == $asize(them[0])
// 2 write-ready sockets:               2 == $asize(them[1])
// the first write-ready is 'sock':     sock   == them[1][0]
// the second write-ready is 'client':  client == them[1][1]
// no exception sockets:                null == them[2]

socket_close(sock);
socket_close(server);
socket_close(client);
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket poll
@subsection Polling events on sockets


@menu
* lib socket poll events ex::   Example of polling for events.
* lib socket poll read ex::     Example of polling for available data.
@end menu


@deftypefn {Neko Function} 'poll socket_poll_alloc (@var{n} : int)
Allocate memory to perform polling on a given number of sockets.
@end deftypefn


@deftypefn {Neko Function} {int array array} socket_poll_prepare (@var{p} : 'poll, @var{read} : 'socket array, @var{write} : 'socket array)
Prepare a @code{'poll} for scanning events on sets of sockets.  Return
an array of two elements: the first will hold informations about sockets
that have data available for reading; the second will hold informations
about sockets that are ready to accept data for writing.

Both the elements of the returned array are arrays of integers in which,
initially, all the elements are set to @code{-1}.  These arrays are
logically linked to the @var{p} object and the @var{read} and
@var{write} arrays.  See @function{socket_poll_events} for more.
@end deftypefn


@deftypefn {Neko Function} void socket_poll_events (@var{p} : 'poll, @var{timeout} : float)
Poll for read/write events the sockets previously registered into
@var{p} by @function{socket_poll_prepare}, then update the array
previously returned by the same function.

Sockets that are read or write ready are selected by this function by
storing the associated indexes in the @var{read} and @var{write}
arguments to @function{socket_poll_prepare} in the arrays returned by
the same function, and terminating the sequence with a @code{-1}.

Example of polling 4 sockets for both reading and writing:

@example
socket_init();

var socks = $array(socket_new(false), socket_new(false),
                   socket_new(false), socket_new(false));

var ip   = host_resolve("localhost");
var port = 8080;
socket_connect(socks[0], ip, port);
socket_connect(socks[1], ip, port);
socket_connect(socks[2], ip, port);
socket_connect(socks[2], ip, port);

var poll = socket_poll_alloc(4 + 4);
var them = socket_poll_prepare(poll, socks, socks);

socket_poll_events(poll, 0.1);

// Ready for reading:
var i = 0;
while (-1 != them[0][i]) @{
  var readable = socks[them[0][i]];
  ... // read data from 'readable'
@}

// Ready for writing:
var i = 0;
while (-1 != them[1][i]) @{
  var writable = socks[them[1][i]];
  ... // write data into 'writable'
@}
@end example
@end deftypefn


@deftypefn {Neko Function} {'socket array} socket_poll (@var{sock} : 'socket array, @var{p} : 'poll, @var{timeout} : float)
Poll the sockets in @var{sock} for data available for reading; return an
array holding the read ready sockets.  @var{timeout} selects an upper
limit on the time for which @function{socket_poll} will block; the limit
is given in seconds and can be less than zero.  @strong{Warning} Beware
of not setting @var{timeout} to a negative value.

This is similar to @function{socket_select} except that
@function{socket_select} is limited to a given number of simultaneous
sockets to check.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket poll events ex
@subsubsection Example of polling for events


@noindent
Example of exchanging a character through @code{localhost:8080} using
the complex @function{socket_poll_events} interface:

@example
socket_init();

var count_number_of_ready_sockets = function (flags, idx) @{
  var i = 0;
  while (-1 != flags[idx][i]) i += 1;
  return i;
@};
var count_number_of_read_ready_sockets = function (flags) @{
  return count_number_of_ready_sockets(flags, 0);
@}
var count_number_of_write_ready_sockets = function (flags) @{
  return count_number_of_ready_sockets(flags, 1);
@}

var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var sockets = $array(sock, client);
var poll    = socket_poll_alloc(2 * $asize(sockets));
var flags   = socket_poll_prepare(poll, sockets, sockets);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      0 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// end of readable sequence:     -1     == flags[0][0]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_send_char(sock, 65);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      1 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// client socket is read-ready:  client == sockets[flags[0][0]]
// end of readable sequence:     -1     == flags[0][1]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_recv_char(client);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      0 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// end of readable sequence:     -1     == flags[0][0]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_send_char(client, 65);

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      1 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// server socket is read-ready:  sock   == sockets[flags[0][0]]
// end of readable sequence:     -1     == flags[0][1]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

dotest.test("server socket recv char", 65, socket_recv_char(sock));

socket_poll_events(poll, 0.1);

// Poll results:
//
// number of read-ready sockets:
//      0 == count_number_of_read_ready_sockets(flags)
// number of write-ready sockets:
//      2 == count_number_of_write_ready_sockets(flags)
// end of readable sequence:     -1     == flags[0][0]
// end of readable sequence:     null   == sockets[flags[0][0]]
// server socket is write-ready: sock   == sockets[flags[1][0]]
// client socket is write-ready: client == sockets[flags[1][1]]
// end of writable sequence:     -1     == flags[1][2]
// end of writable sequence:     null   == sockets[flags[1][2]]

socket_close(sock);
socket_close(server);
socket_close(client);
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket poll read ex
@subsubsection Example of polling for available data


@noindent
Example of exchanging a character through @code{localhost:8080} using
the simple @function{socket_poll} interface:

@example
socket_init();

var server = socket_new(false);
var client = socket_new(false);
var ip     = host_resolve("localhost");
var port   = 8080;

socket_bind(server, ip, port);
socket_listen(server, 1);
socket_connect(client, ip, port);
var sock = socket_accept(server);

var poll = socket_poll_alloc(2);
var them = socket_poll($array(sock, client), poll, 0.1);

// Polling result:
//
// no sockets read ready:       0 == $asize(them)

socket_send_char(sock, 65));

var them = socket_poll($array(sock, client), poll, 0.1);

// Polling result:
//
// 1 socket read ready:         1 == $asize(them)
// read ready socket is client: client == them[0]

socket_recv_char(client);

var them = socket_poll($array(sock, client), poll, 0.1);

// Polling result:
//
// no sockets read ready:       0 == $asize(them)

socket_close(sock);
socket_close(server);
socket_close(client);
@end example

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket resolver
@subsection Resolving addresses


@deftypefn {Neko Function} 'int32 host_resolve (@var{url} : string)
Resolve the given host string into an @acronym{IP} address.
@end deftypefn


@deftypefn {Neko Function} string host_to_string (@var{address} : 'int32)
Return a string representation of an @acronym{IP} address.  Example:

@example
$print(host_to_string(host_resolve("localhost")));
  // prints "127.0.0.1"
@end example
@end deftypefn


@deftypefn {Neko Function} string host_reverse (@var{address} : 'int32)
Reverse the @acronym{DNS} of the given @acronym{IP} address.  Example:

@example
$print(host_reverse(host_resolve("localhost")));
  // prints "localhost"
@end example
@end deftypefn


@deftypefn {Neko Function} string host_local (void)
Return the local host name.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib socket misc
@subsection Miscellaneous functions


@deftypefn {Neko Function} #address socket_host (@var{sock} : 'socket)
Return the socket local address composed of an (host,port) array.
Example:

@example
var sock = ...;
var host = socket_host(sock);

$print("hostname: " + host_to_string(host[0])
       + ", port: " + host[1] + "\n");
@end example
@end deftypefn


@deftypefn {Neko Function} #address socket_peer (@var{sock} : 'socket)
Return the socket connected peer @code{#address} composed of an
(host,port) array.  Example:

@example
var sock = ...;
var host = socket_peer(sock);

$print("hostname: " + host_to_string(host[0])
       + ", port: " + host[1] + "\n");
@end example
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib string
@section Additional string functions


@deftypefn {Neko Function} {string #list} string_split (@var{s} : string, @var{sep} : string)
Split the string s using separator @var{sep}.

@ref{lib list} to understand what a @code{#list} is.
@end deftypefn


@deftypefn {Neko Function} string sprintf (@var{fmt} : string, @var{params} : (any | array))
Format a string.  If only one parameter is needed then it can be
directly passed, either the parameters need to be stored in an array.
The following formats are accepted (with corresponding types):

@table @code
@item %s
string;

@item %d %x %X
@code{int};

@item %c
@code{int} in the @code{[0, 255]} range;

@item %b
@code{bool};

@item %f
@code{float}.
@end table

Examples:

@example
sprintf("alpha %s %d", $array("beta", 123));
  // return: "alpha beta 123"

sprintf("float %f", 1.2);
  // return: "float 1.2"
@end example
@end deftypefn


@deftypefn {Neko Function} string url_decode (@var{s} : string)
Decode an @urla{} using escaped format.
@end deftypefn


@deftypefn {Neko Function} string url_encode (@var{s} : string)
Encode an @urla{} using escaped format.
@end deftypefn


@deftypefn {Neko Function} string base_encode (@var{s} : string, @var{charset} : string)
Encode a string using the specified @var{charset}; the length of the
string @var{charset} must be a power of two (2, 4, 8, 16, @dots{}).
This encoding has nothing to do with hexadecimal, base64, basE91,
@dots{} rather it is a lossless encoding that converts @var{s} to
another string using only bytes from the set @var{charset}.
@end deftypefn


@deftypefn {Neko Function} string base_decode (@var{s} : string, @var{charset} : string)
Decode a string encoded using characters from the specified
@var{charset}.  This is the inverse of @function{base_encode}.
@end deftypefn

Example:

@example
var base = "hello123"; // the length is 8
var s    = "the quick fox jumps over the lazy dog";

var enc  = base_encode(s, base);
// enc == "l1h2oeo1ehh3h121lll2e11lehh2le13l2hlhe1ll1l2212hlo2lhe13l1o2l12lehh3le1hlellhe1olhl31e3eehh2le13le2"
var dec  = base_decode(enc, base);
// dec == "the quick fox jumps over the lazy dog"
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib sys
@section Interaction with the operating system


@subsection Environment variables


@deftypefn {Neko Function} string? get_env (@var{s} : string)
Get some environment variable if exists.
@end deftypefn


@deftypefn {Neko Function} void put_env (@var{var} : string, @var{val} : string)
Set some environment variable value.
@end deftypefn


@deftypefn {Neko Function} #list sys_env (void)
Return all the (key,value) pairs in the environment as a chained list.
@ref{lib list} to understand what a @code{#list} is.
@end deftypefn


@subsection Time related functions


@deftypefn {Neko Function} void sys_sleep (@var{n} : number)
Sleep a given number of seconds.
@end deftypefn


@deftypefn {Neko Function} bool set_time_locale (@var{s} : string)
Set the locale for @env{LC_TIME}, returns true on success.
@end deftypefn


@deftypefn {Neko Function} float sys_time (void)
Return an accurate local time stamp in seconds since Jan 1 1970.
@end deftypefn


@deftypefn {Neko Function} float sys_cpu_time (void)
Return the most accurate @acronym{CPU} time spent since the process
started (in seconds).
@end deftypefn


@subsection Current working directory


@deftypefn {Neko Function} string get_cwd (void)
Return current working directory.
@end deftypefn


@deftypefn {Neko Function} void set_cwd (@var{s} : string)
Set current working directory.
@end deftypefn


@subsection System properties


@deftypefn {Neko Function} string sys_string (void)
Return the local system string.  Currently the following values are possible:
@code{Windows}, @code{Linux}, @code{BSD}, @code{Mac}.
@end deftypefn


@deftypefn {Neko Function} bool sys_is64 (void)
Return @true{} if we are on a 64 bits system.
@end deftypefn


@subsection Shell commands


@deftypefn {Neko Function} int sys_command (@var{s} : string)
Run a shell command and return its exit code.
@end deftypefn


@subsection Process termination


@deftypefn {Neko Function} void sys_exit (@var{code} : int)
Exit with the given error code.  Never return.
@end deftypefn


@subsection File system


@deftypefn {Neko Function} bool sys_exists (@var{pathname} : string)
Returns true if the file or directory exists.
@end deftypefn


@deftypefn {Neko Function} bool file_exists (@var{pathname} : string)
Deprecated: use @function{sys_exists} instead.
@end deftypefn


@deftypefn {Neko Function} void file_delete (@var{pathname} : string)
Delete the file.  Exception on error.
@end deftypefn


@deftypefn {Neko Function} void sys_rename (@var{from} : string, @var{to} : string)
Rename the file or directory.  Exception on error.
@end deftypefn


@deftypefn {Neko Function} {@{ gid => int, uid => int, atime => 'int32, mtime => 'int32, ctime => 'int32, dev => int, ino => int, nlink => int, rdev => int, size => int, mode => int @}} sys_stat (@var{pathname} : string)
Apply the @cfunction{stat} function to the given file or directory.
@end deftypefn


@deftypefn {Neko Function} string sys_file_type (@var{pathname} : string)
Return the type of the file.  Currently the following return values are
possible: @code{file}, @code{dir}, @code{symlink}, @code{sock},
@code{char}, @code{block}, @code{fifo}.
@end deftypefn


@deftypefn {Neko Function} void sys_create_dir (@var{pathname} : string, @var{mode} : int)
Create a directory with the specified rights.
@end deftypefn


@deftypefn {Neko Function} void sys_remove_dir (@var{pathname} : string) 
Remove a directory.  Exception on error.
@end deftypefn


@deftypefn {Neko Function} {string #list} sys_read_dir (@var{pathname} : string)
Return the content of a directory. @ref{lib list} to understand what a
@code{#list} is.
@end deftypefn


@deftypefn {Neko Function} string file_full_path (@var{pathname} : string)
Return an absolute path from a relative one.  The file or directory must
exists.
@end deftypefn


@deftypefn {Neko Function} string sys_exe_path (void)
Return the path of the executable.
@end deftypefn


@subsection Miscellaneous functions


@deftypefn {Neko Function} int sys_getch (@var{b} : bool)
Read a character from @code{stdin} with or without echo.
@end deftypefn


@deftypefn {Neko Function} int sys_get_pid (void)
Returns the current process identifier.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib thread
@section Creating and managing system threads


@menu
* lib thread create::           Creating threads.
* lib thread message::          Sending and receiving messages.
* lib thread deque::            Handling deques.
* lib thread lock::             Handling locks.
* lib thread mux::              Handling mutexes.
* lib thread storage::          Handling thread local storage.
@end menu

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib thread create
@subsection Creating threads


@deftypefn {Neko Function} 'thread thread_create (@var{f} : function:1, @var{p} : any)
Create a thread that will be running the function
@code{@var{f}(@var{p})}.
@end deftypefn


@deftypefn {Neko Function} 'thread thread_current (void)
Return the current thread.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib thread message
@subsection Sending and receiving messages


@deftypefn {Neko Function} void thread_send (@var{thd} : 'thread, @var{msg} : any)
Send a message into the target thread message queue.
@end deftypefn


@deftypefn {Neko Function} any thread_read_message (@var{block} : bool)
Read a message from the message queue.  If @var{block} is @true{}, the
function only returns when a message is available.  If @var{block} is
@false{} and no message is available in the queue, the function will
immediately return @null{}.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib thread deque
@subsection Handling deques


@deftypefn {Neko Function} 'deque deque_create (void)
Create a message queue for multithread access.
@end deftypefn


@deftypefn {Neko Function} void deque_add (@var{d} : 'deque, @var{value} : any)
Add a message at the @strong{end} of the queue.
@end deftypefn


@deftypefn {Neko Function} void deque_push (@var{d} : 'deque, @var{value} : any)
Add a message at the @strong{head} of the queue.
@end deftypefn


@deftypefn {Neko Function} any? deque_pop (@var{d} : 'deque, @var{block} : bool)
Pop a message from the @strong{head} of the queue.  If @var{block} is
true: block until a message is available; else return @null{}
immediately.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib thread lock
@subsection Handling locks


@deftypefn {Neko Function} 'lock lock_create (void)
Create a lock which is initially locked.
@end deftypefn


@deftypefn {Neko Function} void lock_release (@var{lock} : 'lock)
Release a lock.  The thread does not need to own the lock to be able to
release it.  If a lock is released several times, it can be acquired as
many times.
@end deftypefn


@deftypefn {Neko Function} bool lock_wait (@var{lock} : 'lock, @var{timeout} : number?)
Waits for a lock to be released, then acquire it.  If @var{timeout} (in
seconds) is not @null{} and expires then the returned value is @false{}.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib thread mux
@subsection Handling mutexes


@deftypefn {Neko Function} 'mutex mutex_create (void)
Create a mutex, which can be used to acquire a temporary lock to access
some resource.  The main difference with a lock is that a mutex must
always be released by the owner thread.
@end deftypefn


@deftypefn {Neko Function} void mutex_acquire (@var{mux} : 'mutex)
Make the current thread acquire the mutex or wait if not available.  The
same thread can acquire several times the same mutex, but it must
release it as many times it has been acquired.
@end deftypefn


@deftypefn {Neko Function} bool mutex_try (@var{mux} : 'mutex)
Try to acquire the mutex, return @true{} if success or @false{} if
@var{mux} is already locked by another thread.
@end deftypefn


@deftypefn {Neko Function} void mutex_release (@var{mux} : 'mutex)
Release a mutex that has been acquired by the current thread.  The
behavior is undefined if the current thread does not own the mutex.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib thread storage
@subsection Handling thread local storage


@deftypefn {Neko Function} 'tls tls_create (void)
Creates thread local storage.  A thread local storage area can hold a
value that will be different depending on the local thread.

@strong{Warning} We must set the @acronym{TLS} value to @null{} before
exiting the thread or the memory will never be collected.
@end deftypefn


@deftypefn {Neko Function} void tls_set (@var{r} : 'tls, @var{value} : any)
Set the value of the @acronym{TLS} for the local thread.
@end deftypefn


@deftypefn {Neko Function} any tls_get (@var{t} : 'tls)
Return the value set by @function{tls_set} for the local thread.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib utf8
@section Handling @utf8{} strings


@noindent
Most of the operations are optimised for speed; they might still succeed
on some malformed @utf8{} string.  The only function that completely
checks the @utf8{} format is @function{utf8_validate}.  Other functions
might raise exceptions or not depending on the malformed data.


@deftypefn {Neko Function} 'ubuf utf8_buf_alloc (@var{size} : int)
Create a new buffer with an initial @var{size} in bytes.
@end deftypefn


@deftypefn {Neko Function} void utf8_buf_add (@var{b} : 'buf, @var{c} : int)
Add a valid @utf8{} char (in the range @code{[0, 0x10FFFF]}) to
the buffer.
@end deftypefn


@deftypefn {Neko Function} string utf8_buf_content (@var{b} : 'buf)
Return the current content of the buffer.  This is not a copy of the
buffer but the shared content.  Retrieving content and then continuing
to add chars is possible but not very efficient.
@end deftypefn


@deftypefn {Neko Function} int utf8_buf_length (@var{b} : 'buf)
Return the number of @utf8{} chars stored in the buffer.
@end deftypefn


@deftypefn {Neko Function} int utf8_buf_size (@var{b} : 'buf)
Return the current size of the buffer in bytes.
@end deftypefn


@deftypefn {Neko Function} bool utf8_validate (@var{s} : string)
Validate if a string is encoded using the @utf8{} format.
@end deftypefn


@deftypefn {Neko Function} int utf8_length (@var{s} : string)
Return the number of @utf8{} chars in the string.
@end deftypefn


@deftypefn {Neko Function} string utf8_sub (@var{s} : string, @var{pos} : int, @var{len} : int)
Return a part of an @utf8{} string.
@end deftypefn


@deftypefn {Neko Function} int utf8_get (@var{s} : string, @var{n} : int)
Return the nth char in an @utf8{} string.  This might be
inefficient if @var{n} is big.
@end deftypefn


@deftypefn {Neko Function} void utf8_iter (@var{s} : string, @var{f} : ((int -> void)))
Call @var{f} with each of @utf8{} char of the string.
@end deftypefn


@deftypefn {Neko Function} int utf8_compare (@var{s1} : string, @var{s2} : string)
Compare two @utf8{} strings according to @utf8{} char codes.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib xml
@section The standard event--driven @xml{} parser. 


@deftypefn {Neko Function} void parse_xml (@var{xml} : string, @var{events} : object)
Parse a string and, for each parsed element, call the corresponding
object method in events:

@table @code
@item void xml (name : string, attribs : object)
when an @xml{} node is found;

@item void done (void)
when an @xml{} node is closed;

@item void pcdata (s : string)
when @code{PCData} are chars found;

@item void cdata (s : string)
when a @code{CData} session is found;

@item void comment (s : string)
when some comment or special header is found.
@end table

We can implement the events so they build the appropriate @xml{} data
structure needed by our language.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib misc
@section Miscellaneous functions


@deftypefn {Neko Function} string float_bytes (@var{n} : number, @var{bigendian} : bool)
Return the 4 bytes representation of the number as an @acronym{IEEE} 32
bits float.
@end deftypefn


@deftypefn {Neko Function} string double_bytes (@var{n} number, @var{bigendian} : bool)
Return the 8 bytes representation of the number as an @acronym{IEEE} 64
bits float.
@end deftypefn


@deftypefn {Neko Function} float float_of_bytes (@var{s} : string, @var{bigendian} : bool)
Return a float from a 4 bytes @acronym{IEEE} 32 bits representation.
@end deftypefn


@deftypefn {Neko Function} float double_of_bytes (@var{s} : string, @var{bigendian} : bool)
Returns a float from a 8 bytes @acronym{IEEE} 64 bits representation.
@end deftypefn


@deftypefn {Neko Function} void run_gc (@var{major} : bool)
Run the Neko garbage collector.
@end deftypefn


@deftypefn {Neko Function} {@{ heap => int, free => int@}} gc_stats (void)
Return the size of the GC heap and the among of free space, in bytes.
@end deftypefn


@deftypefn {Neko Function} void enable_jit (@var{b} : bool)
Enable or disable the @acronym{JIT}.
@end deftypefn


@deftypefn {Neko Function} void test (void)
The test function, to check that library is reachable and correctly
linked.
@end deftypefn


@deftypefn {Neko Function} void print_redirect (@var{f} : function:1?)
Set a redirection function for all printed values.  Setting it to
@null{} will cancel the redirection and restore previous printer.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib cgi
@section Apache access when running @modneko{}


@noindent
The following functions are defined only when running @modneko{}, they
are @strong{not} in the standard library.


@deftypefn {Neko Function} 'list get_cookies (void)
Return a cookie list as a (name,value) chained list.
@end deftypefn


@deftypefn {Neko Function} void set_cookie (@var{name} : string, @var{val} : string)
Set a cookie.
@end deftypefn


@deftypefn {Neko Function} string get_host_name (void)
Get the local host @acronym{IP}.
@end deftypefn


@deftypefn {Neko Function} string get_client_ip (void)
Get the connected client @acronym{IP}.
@end deftypefn


@deftypefn {Neko Function} string get_uri (void)
Get the original @acronym{URI} requested by the client (before any
internal redirection).
@end deftypefn


@deftypefn {Neko Function} void redirect (@var{uri} : string)
Redirect the client to another page (Location header).
@end deftypefn


@deftypefn {Neko Function} void set_return_code (@var{code} : int)
Set the @acronym{HTTP} return code.
@end deftypefn


@deftypefn {Neko Function} void set_header (@var{name} : string, @var{val} : string)
Set a @acronym{HTTP} header value.
@end deftypefn


@deftypefn {Neko Function} string? get_client_header (@var{name} : string)
Get a @acronym{HTTP} header sent by the client.
@end deftypefn


@deftypefn {Neko Function} {string list} get_client_headers (void)
Get all the @acronym{HTTP} client headers.
@end deftypefn


@deftypefn {Neko Function} string get_params_string (void)
Return the whole parameters string.
@end deftypefn


@deftypefn {Neko Function} string get_post_data (void)
Return the whole unparsed @code{POST} string.
@end deftypefn


@deftypefn {Neko Function} void parse_multipart_data (@var{onpart} : function:2, @var{ondata} : function:3)
Incrementally parse the multipart data.  Call
@code{onpart(name,filename)} for each part found and
@code{ondata(buf,pos,len)} when some data is available.
@end deftypefn


@deftypefn {Neko Function} #list get_params (void)
Parse all @code{GET} and @code{POST} params and return them into a
chained list.
@end deftypefn


@deftypefn {Neko Function} string cgi_get_cwd (void)
Return current bytecode file working directory.
@end deftypefn


@deftypefn {Neko Function} void cgi_set_main (@var{f} : function:0)
Set the main entry point function.
@end deftypefn


@deftypefn {Neko Function} void cgi_flush (void)
Flush the data written so it's immediately sent to the client.
@end deftypefn


@deftypefn {Neko Function} object cgi_get_config (void)
Return the current configuration.
@end deftypefn


@deftypefn {Neko Function} void cgi_set_config (@var{o} : object)
Set the current configuration.
@end deftypefn


@deftypefn {Neko Function} any cgi_command (@var{value} : any)
Perform a configuration--specific command:

@table @code
@item stats
returns the statistics;

@item cache
returns the current cache.
@end table
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib mysql
@section Connecting and using MySQL databases


@noindent
The following functions are available only if the interface library has
been built and installed; the library is called @file{mysql.ndll} and
can be loaded using the following Neko module:

@example
// mysql.neko --
//
// Load the Neko interface library to MySQL.

var stdload = function (name, arity) @{
  return $loader.loadprim("mysql" + "@@" + name, arity);
@}


$exports.connect                = stdload("connect",    1);
$exports.close                  = stdload("close",      1);
$exports.select_db              = stdload("select_db",  2);
$exports.request                = stdload("request",    2);
$exports.escape                 = stdload("escape",     1);
$exports.result_set_conv_date   = stdload("result_set_conv_date", 2);
$exports.result_get_length      = stdload("result_get_length",    1);
$exports.result_get_nfields     = stdload("result_get_nfields",   1);
$exports.result_next            = stdload("result_next",          1);
$exports.result_get             = stdload("result_get",           2);
$exports.result_get_int         = stdload("result_get_int",       2);
$exports.result_get_float       = stdload("result_get_float",     2);

/// end of file
@end example


@subsection Connecting


@deftypefn {Neko Function} 'connection connect (@var{o} : @{ host => string, port => int, user => string, pass => string, socket => string?@})
Connect to a database using the connection informations.
@end deftypefn


@deftypefn {Neko Function} void close (@var{c} : 'connection)
Close the connection.  Any subsequent operation on @var{c} will fail.
@end deftypefn


@deftypefn {Neko Function} void select_db (@var{c} : 'connection, @var{s} : string)
Select the database.
@end deftypefn


@deftypefn {Neko Function} 'result request (@var{c} : 'connection, @var{query} : string)
Execute a @acronym{SQL} request.  An exception is raised on error.
@end deftypefn


@deftypefn {Neko Function} string escape (@var{s} : string)
Escape the string for inserting into a @acronym{SQL} request.
@end deftypefn


@subsection Handling the result


@deftypefn {Neko Function} void result_set_conv_date (@var{r} : 'result, @var{f} : function:1)
Set the function that will convert a @code{Date} or @code{DateTime}
string to the corresponding value.
@end deftypefn


@deftypefn {Neko Function} int result_get_length (@var{r} : 'result)
Return the number of rows returned or affected.
@end deftypefn


@deftypefn {Neko Function} int result_get_nfields (@var{r} : 'result)
Return the number of fields in a result row.
@end deftypefn


@deftypefn {Neko Function} object? result_next (@var{r} : 'result)
Return the next row if available.

A row is represented as an object, which fields have been converted to
the corresponding Neko value (@code{int}, @code{float} or
@code{string}).

For @code{Date} and @code{DateTime} we can specify our own conversion
function using @function{result_set_conv_date}.  By default they're
returned as plain strings.

Additionally, the @code{TINYINT(1)} will be converted to either @true{}
or @false{} if equal to @code{0}.
@end deftypefn


@deftypefn {Neko Function} string result_get (@var{r} : 'result, @var{n} : int)
Return the nth field of the current row.
@end deftypefn


@deftypefn {Neko Function} int result_get_int (@var{r} : 'result, @var{n} : int)
Return the nth field of the current row as an integer (or 0).
@end deftypefn


@deftypefn {Neko Function} float result_get_float (@var{r} : 'result, @var{n} : int)
Return the nth field of the current row as a float (or 0).
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib sqlite
@section Connecting to and using Sqlite databases


@noindent
Sqlite is a small embeddable @acronym{SQL} database that stores all its
data into a single file.  See @url{http://sqlite.org} for more details.

The following functions are available only if the interface library has
been built and installed; the library is called @file{sqlite.ndll} and
can be loaded using the following Neko module:

@example
// sqlite.neko --
//
// Load the Neko interface library to Sqlite.

var stdload = function (name, arity) @{
  return $loader.loadprim("sqlite" + "@@" + name, arity);
@}


$exports.connect                = stdload("connect",            1);
$exports.last_insert_id         = stdload("last_insert_id",     1);
$exports.request                = stdload("request",            2);
$exports.result_get_length      = stdload("result_get_length",  1);
$exports.result_get_nfields     = stdload("result_get_nfields", 1);
$exports.result_next            = stdload("result_next",        1);
$exports.result_get             = stdload("result_get",         2);
$exports.result_get_int         = stdload("result_get_int",     2);
$exports.result_get_float       = stdload("result_get_float",   2);

/// end of file
@end example


@subsection Connecting


@deftypefn {Neko Function} 'db connect (@var{filename} : string)
Open or create the database stored in the specified file.
@end deftypefn


@deftypefn {Neko Function} void close (@var{db} : 'db)
Close the database.
@end deftypefn


@deftypefn {Neko Function} int last_insert_id (@var{db} : 'db)
Return the last inserted @code{auto_increment} id.
@end deftypefn


@subsection Handling the result


@deftypefn {Neko Function} 'result request (@var{db} : 'db, @var{query} : string)
Executes the @acronym{SQL} request and returns its result.
@end deftypefn


@deftypefn {Neko Function} int result_get_length (@var{r} : 'result)
Return the number of rows in the result or the number of rows changed by
the request.
@end deftypefn


@deftypefn {Neko Function} int result_get_nfields (@var{r} : 'result)
Return the number of fields in the result.
@end deftypefn


@deftypefn {Neko Function} object? result_next (@var{r} : 'result)
Return the next row in the result or @null{} if no more result.
@end deftypefn


@deftypefn {Neko Function} string result_get (@var{r} : 'result, @var{n} : int)
Return the nth field of the current result row.
@end deftypefn


@deftypefn {Neko Function} int result_get_int (@var{r} : 'result, @var{n} : int)
Return the nth field of the current result row as an integer.
@end deftypefn


@deftypefn {Neko Function} float result_get_float (@var{r} : 'result, @var{n} : int)
Return the nth field of the current result row as a float.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib regexp
@section Regular expressions using the @acronym{PCRE} engine


@noindent
The following functions are available only if the regexp library has
been built and installed; the library file name is @file{regexp.ndll}.
To access the functions we can load the following module:

@example
// regexp.neko --
//
// Load the Neko regexp library.

var stdload = function (name, arity) @{
  return $loader.loadprim("regexp" + "@@" + name, arity);
@}

$exports.regexp_new_options     = stdload("regexp_new_options", 2);
$exports.regexp_new             = stdload("regexp_new",         1);
$exports.regexp_match           = stdload("regexp_match",       4);
$exports.regexp_replace         = stdload("regexp_replace",     3);
$exports.regexp_replace_all     = stdload("regexp_replace_all", 3);
$exports.regexp_replace_fun     = stdload("regexp_replace_fun", 3);
$exports.regexp_matched         = stdload("regexp_matched",     2);
$exports.regexp_matched_pos     = stdload("regexp_matched_pos", 2);

/// end of file
@end example


@deftypefn {Neko Function} 'regexp regexp_new_options (@var{pattern} : string, @var{options} : string)
Build a new regexp with the following options:

@table @code
@item i
case insensitive matching;

@item s
@code{.} matches anything including newlines;

@item m
treat the input as a multiline string;

@item u
run in @utf8{} mode;

@item g
turn off greedy behaviour.
@end table
@end deftypefn


@deftypefn {Neko Function} 'regexp regexp_new (@var{pattern} : string)
Build a new regexp.
@end deftypefn


@deftypefn {Neko Function} bool regexp_match (@var{rex} : 'regexp, @var{s} : string, @var{pos} : int, @var{len} : int)
Match @var{len} chars of a string starting at @var{pos} using @var{rex}.
Return @true{} if a match is found.
@end deftypefn


@deftypefn {Neko Function} string regexp_replace (@var{rex} : 'regexp, @var{from} : string, @var{by} : string)
Perform a replacement using a regexp.
@end deftypefn


@deftypefn {Neko Function} string regexp_replace_all (@var{rex} : 'regexp, @var{from} : string, @var{by} : string)
Perform a replacement of all matched substrings using a regexp.
@end deftypefn


@deftypefn {Neko Function} string regexp_replace_fun (@var{rex} : 'regexp, @var{from} : string, @var{f} : (('regexp -> any)))
Perform a replacement of all matched substrings by calling @var{f} for
every match.
@end deftypefn


@deftypefn {Neko Function} string regexp_matched (@var{rex} : 'regexp, @var{n} : int)
Return the nth matched block by the regexp.  If @var{n} is @code{0} then
return the whole matched substring.
@end deftypefn


@deftypefn {Neko Function} {@{ pos => int, len => int@}} regexp_matched_pos (@var{rex} : 'regexp, @var{n} : int)
Return the position of the nth block matched by the regexp.  If @var{n}
is @code{0} then return the whole matched substring position.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib gui
@section Core native user interface support


@noindent
This @api{} uses native Win32 @api{} on Windows, Carbon @api{} on
@acronym{OSX}, and @acronym{GTK2} on Linux.  The following functions are
available only if the @gui{} library has been built and installed; the
library file name is @file{ui.ndll}.  To access the functions we can
load the following module:

@example
// ui.neko --
//
// Load the Neko interface library to GUI.

var stdload = function (name, arity) @{
  // The library is called "ui.ndll".
  return $loader.loadprim("ui" + "@@" + name, arity);
@}

$exports.ui_is_main     = stdload("ui_is_main",         0);
$exports.ui_loop        = stdload("ui_loop",            0);
$exports.ui_stop_loop   = stdload("ui_stop_loop",       0);
$exports.ui_sync        = stdload("ui_sync",            1);

/// end of file
@end example


@deftypefn {Neko Function} bool ui_is_main (void)
Tell if the current thread is the main loop thread or not.  The main
loop thread is the one in which the first @gui{} library primitive has
been loaded.
@end deftypefn


@deftypefn {Neko Function} void ui_loop (void)
Start the native @gui{} event loop.  This method can only be called from
the main thread.
@end deftypefn


@deftypefn {Neko Function} void ui_stop_loop (void)
Stop the native @gui{} event loop.  This method can only be called from
the main thread.
@end deftypefn


@deftypefn {Neko Function} void ui_sync (@var{callb} : ((void -> void)))
Queue a method call to @var{callb} to be executed by the main thread
while running the @gui{} event loop.  This can be used to perform @gui{}
updates in the @gui{} thread using results processed by another thread.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node lib zlib
@section Compression library


@noindent
The following @api{} gives access to the popular ZLib compression
library, used in several file formats such as @acronym{ZIP} and
@acronym{PNG}.

The following functions are available only if the interface library has
been built and installed; the library file name is @file{zlib.ndll}.  To
access the functions we can load the following module:

@example
// zlib.neko --
//
// Load the Neko interface library to Zlib.

var stdload = function (name, arity) @{
  return $loader.loadprim("zlib" + "@@" + name, arity);
@}

$exports.set_flush_mode = stdload("set_flush_mode",     2);
$exports.deflate_bound  = stdload("deflate_bound",      2);
$exports.deflate_init   = stdload("deflate_init",       1);
$exports.deflate_buffer = stdload("deflate_buffer",     5);
$exports.deflate_end    = stdload("deflate_end",        1);
$exports.inflate_init   = stdload("inflate_init",       1);
$exports.inflate_buffer = stdload("inflate_buffer",     5);
$exports.inflate_end    = stdload("inflate_end",        1);
$exports.get_adler32    = stdload("get_adler32",        1);
$exports.update_adler32 = stdload("update_adler32",     4);
$exports.update_crc32   = stdload("update_crc32",       4);

/// end of file
@end example


@subsection Stream configuration


@deftypefn {Neko Function} void set_flush_mode (@var{s} : 'stream, @var{mode} : string)
Change the flush mode of a stream; supported modes are: @code{NO},
@code{SYNC}, @code{FULL}, @code{FINISH}, @code{BLOCK}.
@end deftypefn


@subsection Stream compression


@deftypefn {Neko Function} int deflate_bound (@var{d} : 'dstream, @var{n} : int)
Return the maximum buffer size needed to write @var{n} bytes.
@end deftypefn


@deftypefn {Neko Function} 'dstream deflate_init (@var{level} : int)
Open a compression stream with the given level of compression.
@end deftypefn


@deftypefn {Neko Function} {@{ done => bool, read => int, write => int@}} deflate_buffer (@var{d} : 'dstream, @var{src} : string, @var{srcpos} : int, @var{dst} : string, @var{dstpos} : int)
Compresses a string and store the output into a string.
@end deftypefn


@deftypefn {Neko Function} void deflate_end (@var{d} : 'dstream)
Close a compression stream.
@end deftypefn


@subsection Stream decompression


@deftypefn {Neko Function} 'istream inflate_init (@var{window_size} : int?)
Open a decompression stream.
@end deftypefn


@deftypefn {Neko Function} {@{ done => bool, read => int, write => int@}} inflate_buffer (@var{i} : 'istream, @var{src} : string, @var{srcpos} : int, @var{dst} : string, @var{dstpos} : int) 
Decompresses a string and store the output into a string.
@end deftypefn


@deftypefn {Neko Function} void inflate_end (@var{i} : 'istream)
Close a decompression stream.
@end deftypefn


@subsection Sums


@deftypefn {Neko Function} 'int32 get_adler32 (@var{s} : 'stream)
Return the adler32 value of the stream.
@end deftypefn


@deftypefn {Neko Function} 'int32 update_adler32 (@var{adler} : 'int32, @var{s} : string, @var{pos} : int, @var{len} : int)
Update an adler32 value with a substring.
@end deftypefn


@deftypefn {Neko Function} 'int32 update_crc32 (@var{crc} : 'int32, @var{s} : string, @var{pos} : int, @var{len} : int)
Update a @acronym{CRC32} value with a substring.
@end deftypefn


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node faq
@appendix Frequently asked questions


@appendixsec How is Neko different from .Net's @acronym{CLR} or the Java's @acronym{JVM}?

@noindent
The .Net's @acronym{CLR} and the Java Virtual Machine are both defined
by a bytecode language with a static type system based on classes.  As a
result, you can easily run languages that have a type system compatible
with Java or C# on these virtual machines.  But if you have a
dynamically typed language or no class system, you'll have to trick the
virtual machine and find a type mapping from your type system to the
@acronym{JVM} or .Net one.

Neko is a lot more simple.  First it is not a bytecode language but a
high--level programming language.  You don't have then to write a
compiler for it, a simple generator that translates your program into
the corresponding Neko program is enough.  You still have to find a
mapping from your values to Neko data structures but Neko gives you a
dynamically typed language with no fixed class system.  You have then to
find a runtime mapping so that your program executes correctly on Neko,
and not a type mapping so that your program types correctly like with
.Net/@acronym{JVM}.

As a result, it is easier to write a new or existing language on the
NekoVM than it is for the @acronym{CLR}/@acronym{JVM}, since you don't
have to deal with a high level type system.  Also, this means that
languages can interoperate more easily since they only need to share the
same data structures and not always the same types.


@appendixsec How is Neko different from @acronym{LLVM} or C-- ?


@noindent
These are compiler frameworks with low--level abstract processor
instructions and a static type system with low--level memory
manipulation functions.  For example, it would be possible to use these
frameworks to compile Neko, which stands as a higher--level language,
although Neko is powered by its own runtime.

As a result, Neko is perhaps less suitable to optimisations than these
abstract processors but is a lot easier to target for language designers
that want to reuse a runtime.  Since Neko is not a framework, it is very
lightweight.  For example, you only need @file{libneko.so}, which is
only 68 kB, in order to embed and run Neko programs in your application.


@appendixsec How is Neko different from @acronym{PHP}/Perl/Python/Ruby/Javascript?


@noindent
These languages are meant to be used by people.  They contain powerful
but sometimes complex features.  Often their runtimes are written
entirely in C and can thus be difficult to maintain and their
interpreters can be rather slow.  Neko runtime could be used to run
these languages more efficiently, and help them interact together and
share the same libraries.

Actually, it is one of the goals of Neko to be able to run these
languages on the same runtime.  Since current implementations are either
interpreted or running in a not--so--fast virtual machine using an
intermediate compilable representation such as Neko should be a good
improvement, especially when @acronym{JIT} is added.


@appendixsec How is Neko different from Lua?


@noindent
A complete comparison is available on the website.  Neko has better
@acronym{OO} support and a more easy--to--use C @ffi{}.  Neko is faster
for data structures manipulation but slower for floating--point
arithmetics.


@appendixsec How is Neko different from Parrot?


@noindent
Targeting Parrot is quite complex, with different languages at different
levels (low level @acronym{PASM} and medium level @acronym{PIR}).  In
particular, it is difficult to differentiate between the language and
the libraries.  Also, it gives access to more low level bytecode which
make it difficult to change it later without breaking backward
compatibility.  The Neko compiler is handling the low level and the Neko
language is as much abstract as possible.

Parrot is written in C while Neko compiler is written... in Neko.  The
language is fully bootstrapped right now.  Also, Neko is lightweight and
the Virtual Machine is only 68 kB on Linux and 40 kB on Windows, while
still offering a very good speed.


@appendixsec What garbage collector is Neko using?


@noindent
Neko is using the Boehm GC which is a conservative multithreaded mark
and sweep collector.  However since all calls to the GC are wrapper by
the Neko @api{} in @file{vm/alloc.c} it might be possible in the future
to switch easily to another garbage collector.


@appendixsec On which architecture can Neko run?


@noindent
Neko is known to run on Windows x86, Linux, @acronym{BSD},
@acronym{OSX}, and Linux @acronym{AMD64} architectures.  A lot more
architectures should be easily targeted since the @nvm{} is written in
pure @acronym{ANSI} C with only some differences for specific things
such as some standard library functions for system @api{} and dynamic
loading.


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node mod_neko
@appendix An introduction to @modneko{}


@noindent
@modneko{} is an Apache module for Neko: it makes possible to run Neko
programs on the server side, in order to serve web pages using Apache.
Here's a step--by--step tutorial on how to configure and use @modneko{}.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@appendixsec Quick configuration


@noindent
If we don't have @modneko{} compiled or we don't want to setup
Apache, we can use a @modneko{} emulator by using the Neko Web
Server.  It is a very small web server running locally for development
purposes only.  It mimics the same @api{} as @modneko{} so we can
use it instead.

In order to start the server, simply run the following command:

@example
$ nekotools server
@end example

@noindent
it should start the local server, by default on @code{localhost}, port
@code{2000}, so we can browse the configuration page by visiting:

@center @url{http://localhost:2000/server:config}

From the displayed page we can change the server's base path to our
website directory and we can start browsing it.  If it contains Neko
bytecode files, extension @code{.n}, they will be loaded and executed
just like Apache @modneko{} does.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@appendixsec Apache configuration


@noindent
To use Apache with @modneko{}, once Neko is correctly configured,
we can edit the Apache configuration file, @file{httpd.conf}, in order
to add @modneko{}.  Each statement must be added on a single line
at the proper place in the Apache configuration file:

@enumerate
@item
add:

@example
LoadModule neko_module
@end example

@noindent
our path to @file{mod_neko.ndll};

@item
add:

@example
AddModule mod_neko.c
@end example

@item
add:

@example
AddHandler neko-handler .n
@end example

@item
add @code{index.n} to the list of @code{DirectoryIndex};
@end enumerate

@noindent
now we can restart Apache to check that @modneko{} is correctly
loaded.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@appendixsec Some tests


@noindent
We can simply edit a Neko file and print a welcome message:

@example
$print("Hello Mod_neko !");
@end example

@noindent
compile it, then install the bytecode file in the web directory so that
it can be accessed by Apache; browsing it should display the message.

Now let's try to print the @acronym{HTTP} parameters that are passed to
the script, using the @modneko{} @api{}:

@example
get_params = $loader.loadprim("mod_neko@@get_params",0);

// or:
//   $loader.loadprim("mod_neko2@@get_params",0)
// for the 'mod_neko2.ndll' module

$print("PARAMS = " + get_params());
@end example

We can now set @acronym{HTTP} parameters @code{<THE-URL>?p1=v1;p2=v2...}
and see them displayed on the web page.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@appendixsec Script versus application


@noindent
Usage of Neko is separated into two different phases: compile and run.
We cannot directly see the modifications we are making to the script
since we need to compile it first: this is a disadvantage.  However,
this approach has also several advantages:

@itemize
@item
the code it runs faster;

@item
the source code is checked at compile--time, before we attempt to browse
the page;

@item
we don't need to have sources on the server, only binaries are required;

@item
we can run our module in application mode (see below).
@end itemize

Every time a request is made by the browser, @modneko{} loads the
Neko bytecode files and executes them.  If we have a very big script it
might take some time (although it's already faster than other web
scripting languages).

The idea of running in Application Mode is to have first an
initialisation phase for our script that will create objects, load
libraries, initialise global data, and then setup an entry point which
will be the function called for every request.  Here's an example:

@example
$print("Initializing...");
 
// this is the entry point
entry = function() @{
  $print("Main...");
@}
 
// setup the entry point
set_main = $loader.loadprim("mod_neko@@cgi_set_main",1);
set_main(entry);
 
// call it the first time as well
entry();
@end example

Now, after compiling, if we browse this page it should display
@code{Initializing... Main...} the first time and then @code{Main...}
for every refresh.  It means that we can initialise a lot of things at
loading time and store values into globals that will be persistent
between calls.

If we recompile, this will change the time stamp of the @code{.n} file so
it will reload and initialise it again.  That means we should be able to
reload everything we need at loading time.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node nekoml
@appendix A quick guide to NekoML


@noindent
NekoML is a high--order functional language with type inference.  It can
be seen as Neko with a powerful static type system.  It is very suitable
for complex data structure manipulations, such as the ones performed by
compilers.  NekoML is inspired by OCaml, but walks different ways for
some points.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@appendixsec Types


@noindent
NekoML comes with several builtin types, and we can define our own types
quite easily:

@itemize
@item
core types:

@example
1234    : int
1.234   : float
"hello" : string
true    : bool
'\n'    : char
()      : void
@end example

@item
tuples:

@example
(1,true) : (int, bool)
("a",(),1.23) : (string, void, float)
@end example

@item
union types:

@example
type t @{
  A;
  B;
  C : int;
  D : (int , string);
@}

A : t;
B : t;
C(0) : t;
D(1,"") : t;
D : int -> string -> t;
@end example

@item
records:

@example
type t @{
  x : int;
  y : int;
@}

@{ x = 1; y = 2 @} : t
@end example

@item
mutable record fields:

@example
type t @{
	mutable counter : int;
@}

var x = @{ counter = 0 @};
x.counter := 1;
@end example

@item
abstract types:

@example
type t
@end example

@item
recursive types:

@example
type t1 // declare as abstract

type t2 @{
  A : t1;
  B : t2;
@}

type t1 @{ // declare
  C : t1;
  D : t2;
@}
@end example

@item
parametrised types:

@example
type ('a,'b) pair @{
  fst : 'a;
  snd : 'b;
@}
@end example

@item
function types:

@example
function() @{ @} : void -> void;
function(x,y) @{ x + y @} : int -> int -> int
@end example

@item
lists:

@example
[1; 2; 3] : int list
@end example

@item
lists constructors:

@example
[] : 'a list;
0 :: [] : int list;
"a" :: "" :: [] : string list
@end example
@end itemize

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@appendixsec Syntax


@noindent
The syntax of NekoML if similar to the syntax of Neko, but with some
additional constructs:

@itemize
@item
blocks:

@example
@{ f(); g(); h() @}
@end example

@item
variables declaration:

@example
var x = (expr);
@end example

@item
conditions:

@example
if (expr) then (expr) [else (expr)]
@end example

@item
calls using parenthesis:

@example
f(1,2,3);
g();
h((1,2)); // call with a tuple
@end example

@item
calls using spaces:

@example
f 1 2 3;
g ();
h (1,2); // call with a tuple
@end example

@item
mixed calls:

@example
f (1,2) g() h (1,2);
// means
f((1,2),g(),h,(1,2));
@end example

@item
function declarations, we can declare a function anonymously or with a
name to add it to the local scope:

@example
var f = function() @{ ... @};
// equivalent to
function f() @{
  ...
@}
@end example

@item
recursive functions, when several following functions are declared
recursive (using rec), they're mutually recursive so they can call each
other:

@example
function rec f() @{
  g()
@}

function rec g() @{
  f()
@}
@end example
@end itemize

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node examples
@appendix Neko code examples


@menu
* examples list::               A module that manipulates lists.
* examples o32::                An object interface to @code{'int32}
                                abstract numbers.
@end menu


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node examples list
@appendixsec A module that manipulates lists


@example
// Part of: Marco's Test modules
// Contents: Lisp like lists using arrays
// Date: Sun Aug 17, 2008
// 
// Abstract
// 
// This module exports a  set of function to manipulate Neko
// '#list' values.  Sometimes the  Neko library makes use of
// a custom  list type to  organise a sequence of  values; a
// '#list' is a tree of  nested arrays organised like a Lisp
// list:
//
//      -------     -------     -------
//     | 0 | 1 |-->| 0 | 1 |-->| 0 | 1 |--> [null]
//      -------     -------     -------
//       |           |           |
//       v           |           |
//  [first value]    |           |
//                   v           |
//             [second value]    |
//                               |
//                         [third value]
//
// each array has two values and the end of the list must be
// marked with 'null'.
//
//   The interpretation protocol  for '#list' values defined
// by this module is:
//
// 1. a '#list' is a  chain of 2-values arrays terminated by
//    'null';
//
// 2. 'null' itself is interpreted as the empty list;
//
// 3. an array of two  values is called "pair"; so a '#list'
//    is made up of pairs;
//
// 4. each pair in a list can hold a value;
// 
// 5. the length of the  list is the number of values, which
//    equals the number of pairs.
//
//   Most  of  the  functions  in this  module  assume  that
// arguments are of the  correct type; calling them with bad
// values  will cause  undefined behaviour.   Predicates and
// assertion  functions are provided  to validate  lists and
// pairs.
// 
// Copyright (c) 2008 Marco Maggi <marcomaggi@@gna.org>
//
// What follows is a list of contributors to this module:
// 
// Copyright (c) 2008 Vitali Falileev <insideable@@gmail.com>
// 
// This  is free  software; you  can redistribute  it and/or
// modify  it under  the  terms of  the  GNU Lesser  General
// Public  License   as  published  by   the  Free  Software
// Foundation;  either version  2.1 of  the License,  or (at
// your option) any later version.
// 
// This library is  distributed in the hope that  it will be
// useful,  but  WITHOUT  ANY  WARRANTY;  without  even  the
// implied  warranty  of MERCHANTABILITY  or  FITNESS FOR  A
// PARTICULAR  PURPOSE.  See the  GNU Lesser  General Public
// License for more details.
// 
// You should have received a copy of the GNU Lesser General
// Public License along with  this library; if not, write to
// the  Free  Software Foundation,  Inc.,  59 Temple  Place,
// Suite 330, Boston, MA 02111-1307 USA.
// 

//page
// ------------------------------------------------------------
// Constructors.
// ------------------------------------------------------------

// Synopsis: #list cons (car : any, cdr : any)
//
// Build and return a pair.
$exports.cons = function (car, cdr) @{
  $array(car, cdr);
@};

// Synopsis: #list copy (ell : #list)
//
// Build and return a new  list holding the same elements of
// ELL.
$exports.copy = function (ell) @{
  var result, last_pair;

  if (null != ell)
    @{
      result    = $array(ell[0], null);
      last_pair = result;
      ell       = ell[1];
    @}
  while (null != ell)
    @{
      last_pair[1] = $array(ell[0], null);
      last_pair    = last_pair[1];
      ell          = ell[1];
    @}
  result;
@};

// '$exports.list' is defined in the "Conversion" section.

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Type predicates.
// ------------------------------------------------------------

// Synopsis: bool pairp (value : any)
//
// Return  'true' if  VALUE  is a  pair, 'false'  otherwise.
// Notice that 'null' is NOT a valid pair.
$exports.pairp = function (value) @{
  (($tarray == $typeof(value)) && (2 == $asize(value)));
@};

// Synopsis: bool listp (value : any)
//
// Return  'true' if  VALUE  is a  list, 'false'  otherwise.
// Notice that 'null' is a valid list: the empty list.
$exports.listp = function (value) @{
  if (null == value)
    true;
  else
    @{
      var last_pair;

      while (null != value)
        @{
          if ($exports.pairp(value))
            @{
              last_pair = value;
              value     = value[1];
            @}
          else
            return false;
        @}
      return (null == last_pair[1]);
    @}
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Type assertions.
// ------------------------------------------------------------

// Synopsis: void assert_pair (value : any)
//
// Raise an exception if VALUE is not a pair.
$exports.assert_pair = function (value) @{
  if ($tarray != $typeof(value))
    $throw("expected array got: " + value);
  if (2 != $asize(value))
    $throw("expected array of 2 elements got size: " + $asize(value));
@};

// Synopsis: void assert_list (value : any)
//
// Raise an exception if VALUE is not a list.
$exports.assert_list = function (value) @{
  while (null != value)
    @{
      $exports.assert_pair(value);
      value = value[1];
    @}
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Comparison.
// ------------------------------------------------------------

var list_comparison = function (compar, a, b) @{
  var v;

  while ((null != a) && (null != b))
    @{
      v = compar(a[0], b[0]);
      if (0 != v)
        return v;
      else
        @{
          a = a[1];
          b = b[1];
        @}
    @}

  if ((null == a) && (null != b))
    @{ -1 @}
  else
    if ((null != a) && (null == b)) @{ 1 @} else 0;
@};

// Synopsis: bool compare (a : #list, b : #list)
//
// Compare two lists element by element using '$compare' and
// return a ternary result:
//
// 0: if the  lists have equal length and  equal elements in
// the same position;
//
// -1:  if the  lists have  equal length  and for  the first
// different element the one of A is lesser;
//
// 1:  if the  lists have  equal  length and  for the  first
// different element the one of A is greater;
//
// -1:  if  the  lists   have  different  length  and  equal
// elements, but A is shorter;
//
// 1: if the lists have different length and equal elements,
// but A is longer.
$exports.compare = function (a, b) @{
  list_comparison($compare, a, b);
@};

// Synopsis: bool equalp (a : #list, b : #list)
//
// Compare two  lists element by element and  return true if
// the elements are equal according to '$compare'.
$exports.equalp = function (a, b) @{
  return (0 == list_comparison($compare, a, b));
@};

// Synopsis: bool eqp (a : #list, b : #list)
//
// Compare two  lists element by element and  return true if
// the elements are equal according to '$pcompare'.
$exports.eqp = function (a, b) @{
  return (0 == list_comparison($pcompare, a, b));
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Inspection.
// ------------------------------------------------------------

// Synopsis: int length (ell : #list)
//
// Return the length of a list.
$exports.length = function (ell) @{
  var len = 0;

  if ($istrue(ell))
    @{
      while (null != ell)
        @{
          len += 1;
          ell = ell[1];
        @}
    @}
  len;
@};

var member_sub = function (compar, x, ell) @{
  while (null != ell)
    @{
      if (0 == compar(x, ell[0]))
        return ell;
      else
        ell = ell[1];
    @}
  null;
@};

// Synopsis: #list memq (x : any, ell : #list)
//
// Return the first  sublist of ELL whose car  is equal to X
// according  to '$pcompare';  if X  does not  occur  in ELL
// return 'null'.
$exports.memq = function (x, ell) @{
  member_sub($pcompare, x, ell);
@};

// Synopsis: #list member (x : any, ell : #list)
//
// Return the first  sublist of ELL whose car  is equal to X
// according  to '$compare';  if  X does  not  occur in  ELL
// return 'null'.
$exports.member = function (x, ell) @{
  member_sub($compare, x, ell);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Common getters.
// ------------------------------------------------------------

// Synopsis: any car (pair : #pair)
//
// Return the first element in a pair.
$exports.car = function (pair) @{
  if ($tarray == $typeof(pair))
    pair[0];
  else
    $throw("cannot take the car of: " + pair);
@};

// Synopsis: any cdr (pair : #pair)
//
// Return the second element in a pair.
$exports.cdr = function (pair) @{
  if ($tarray == $typeof(pair))
    pair[1];
  else
    $throw("cannot take the cdr of: " + pair);
@};

// ------------------------------------------------------------

// Synopsis: any caar (ell : #list)
//
// Apply 'car' twice.
//
// It is an equivalent of 'ell[0][0]'.
$exports.caar = function (ell) @{
  $exports.car($exports.car(ell));
@};

// Synopsis: any cddr (ell : #list)
//
// Apply 'cdr' twice.
//
// It is an equivalent of 'ell[1][1]'.
$exports.cddr = function (ell) @{
  $exports.cdr($exports.cdr(ell));
@};

// Synopsis: any cadr (ell : #list)
//
// Apply 'cdr' then 'car'.
//
// It is an equivalent of 'ell[1][0]'.
$exports.cadr = function (ell) @{
  $exports.car($exports.cdr(ell));
@};

// Synopsis: any cdar (ell : #list)
//
// Apply 'car' then 'cdr'.
//
// It is an equivalent of 'ell[1][0]'.
$exports.cdar = function (ell) @{
  $exports.cdr($exports.car(ell));
@};

// ------------------------------------------------------------

// Synopsis: any caaar (ell : #list)
//
// Apply 'car' three times.
//
// It is an equivalent of 'ell[0][0][0]'.
$exports.caaar = function (ell) @{
  $exports.car($exports.caar(ell));
@};

// Synopsis: any cdddr (ell : #list)
//
// Apply 'cdr' three times.
//
// It is an equivalent of 'ell[1][1][1]'.
$exports.cdddr = function (ell) @{
  $exports.cdr($exports.cddr(ell));
@};

// ------------------------------------------------------------
// Two 'cdr' and one 'car'.

// Synopsis: any caddr (ell : #list)
//
// Apply 'cdr' then 'cdr' then 'car'.
//
// It is an equivalent of 'ell[1][1][0]'.
$exports.caddr = function (ell) @{
  $exports.car($exports.cddr(ell));
@};

// Synopsis: any cdadr (ell : #list)
//
// Apply 'cdr' then 'car' then 'cdr'.
//
// It is an equivalent of 'ell[1][0][1]'.
$exports.cdadr = function (ell) @{
  $exports.cdr($exports.cadr(ell));
@};

// Synopsis: any cddar (ell : #list)
//
// Apply 'car' then 'cdr' then 'cdr'.
//
// It is an equivalent of 'ell[0][1][1]'.
$exports.cddar = function (ell) @{
  $exports.cdr($exports.cdar(ell));
@};

// ------------------------------------------------------------
// Two 'car' and one 'cdr'.

// Synopsis: any caadr (ell : #list)
//
// Apply 'cdr' then 'car' then 'car'.
//
// It is an equivalent of 'ell[1][0][0]'.
$exports.caadr = function (ell) @{
  $exports.car($exports.cadr(ell));
@};

// Synopsis: any cadar (ell : #list)
//
// Apply 'car' then 'cdr' then 'car'.
//
// It is an equivalent of 'ell[0][1][0]'.
$exports.cadar = function (ell) @{
  $exports.car($exports.cdar(ell));
@};

// Synopsis: any cdaar (ell : #list)
//
// Apply 'cdr' then 'car' then 'car'.
//
// It is an equivalent of 'ell[1][0][0]'.
$exports.cdaar = function (ell) @{
  $exports.cdr($exports.caar(ell));
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Other getters.
// ------------------------------------------------------------

// Synopsis: #pair last_pair (ell : #list)
//
// Return the last pair of ELL or 'null' if ELL is the empty
// string.
$exports.last_pair = function (ell) @{
  if (null != ell)
    while(null != ell[1])
      ell = ell[1];
  ell;
@};

// Synopsis: any list_ref (ell : #list, i : int)
//
// Return the I-th element from ELL.
$exports.list_ref = function (ell, i) @{
  var count = 0;

  while (null != ell)
    @{
      if (count == i)
        return ell[0];
      else
        @{
          count += 1;
          ell    = ell[1];
        @}
    @}
  $throw("attempting to get element " + i
         + " from list, got list of length " + count);
@};

// Synopsis: #list head (ell : #list, count : integer)
//
// Build  and return  an new  list holding  the  first COUNT
// elements from ELL.
$exports.head = function (ell, count) @{
  if (0 == count)
    null;
  else if (null == ell)
    $throw("expected non-empty list");
  else
    @{
      var result = null;
      var i = 0;


      while (null != ell)
        @{
          result = $array(ell[0], result);
          ell    = ell[1];
          i += 1;

          if (i == count)
            return $exports.reverse(result);
        @}
      $throw("attempting to get " + count
             + "elements from list got list of length " + i);
    @}
@};

// Synopsis: #list tail (ell : #list, count : integer)
//
// Build  and return  an  new list  holding  the last  COUNT
// elements from ELL.
$exports.tail = function (ell, count) @{
  $exports.reverse($exports.head($exports.reverse(ell), count));
@};  

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Function application.
// ------------------------------------------------------------

// Synopsis: void for_each (func : function:1, ell : #list)
//
// Map a function to each element of ELL.
$exports.for_each = function (func, ell) @{
  while (null != ell)
    @{
      func(ell[0]);
      ell = ell[1];
    @}
@};

// Synopsis: #list map (func : function:1, ell : #list)
//
// Map  a function  to each  element of  ELL, return  a list
// holding the return values.
$exports.map = function (func, ell) @{
  var result = null;

  while (null != ell)
    @{
      result = $array(func(ell[0]), result);
      ell = ell[1];
    @}
  $exports.reverse(result);
@};

// Synopsis: any fold (proc : function:2, init : any, ell : #list)
//
// Apply PROC to the elements of ELL to build a result; then
// return that result.  Each call is 'PROC(E,PREV)', where E
// is the  next element  from ELL and  PREV is  the previous
// result.  The result is initialised with INIT.
//
// If ELL is 'null': the return value is INIT.
$exports.fold = function (proc, accumulator, ell) @{
  while (null != ell)
    @{
      accumulator = proc(ell[0], accumulator);
      ell = ell[1];
    @}
  accumulator;
@};

// Synopsis: any reduce (proc : function:2, DEFVALUE : any, ell : #list)
//
// It is a  variant of FOLD where the first  call to PROC is
// on 2 elements of ELL.
//
// If ELL is 'null': the  return value is DEFVALUE.  This is
// the only use of DEFVALUE.
$exports.reduce = function (proc, default_value, ell) @{
  if (null == ell)
    default_value;
  else
    @{
      var accumulator = ell[0];

      ell = ell[1];
      while (null != ell)
        @{
          accumulator = proc(ell[0], accumulator);
          ell = ell[1];
        @}
      accumulator;
    @}
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Operations.
// ------------------------------------------------------------

// Synopsis: #list reverse (ell : #list)
//
// Build and return a new  list holding the values of ELL in
// reversed order.
$exports.reverse = function (ell) @{
  var result = null;

  while (null != ell)
    @{
      result = $array(ell[0], result);
      ell    = ell[1];
    @}
  result;
@};

// Synopsis: #list do_append (args : array)
//
// Interpret all the elements  in ARGS as lists, concatenate
// them and return the result.
var do_append = function (args) @{
  var i = 0;
  var result = null;

  while (i < $asize(args))
    @{
      var ell = args[i];
      
      while (null != ell)
        @{
          result = $array(ell[0], result);
          ell    = ell[1];
        @}
      i += 1;
    @}
  $exports.reverse(result);
@};

// Synopsis: #list append (ell1 : #list, ...)
//
// Interpret  all the arguments  as lists,  concatenate them
// and return the result.
$exports.append = $varargs(do_append);

// Synopsis: #list filter (pred : function:1, ell : #list)
//
// Build and return  a new list holding all  the elements in
// ELL which satisfy the predicate PRED.
$exports.filter = function (pred, ell) @{
  var result = null;

  while (null != ell)
    @{
      if (pred(ell[0]))
        result = $array(ell[0], result);
      ell = ell[1];
    @}
  $exports.reverse(result);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Array conversion.
// ------------------------------------------------------------

// Synopsis: #list list_from_array (args : array)
//
// Build  and return a  list holding  the elements  from the
// array.   If  the array  is  empty:  the  return value  is
// 'null'.
$exports.list_from_array = function (args) @{
  var i   = $asize(args) - 1;
  var ell = null;

  while (0 <= i)
    @{
      ell = $array(args[i], ell);
      i -= 1;
    @}
  ell;
@};

// Synopsis: #list list (v1 : any, v2 : any, ...)
//
// Build and return a  list holding the given arguments.  If
// called with no arguments: the return value is 'null'.
$exports.list = $varargs($exports.list_from_array);

// Synopsis: array list_to_array (ell : #list)
//
// Build and  return a new  array holding the  elements from
// ELL.  If applied to 'null': the return value is the empty
// array.
$exports.list_to_array = function (ell) @{
  var result = $amake($exports.length(ell));
  var i = 0;

  while (null != ell)
    @{
      result[i] = ell[0];
      ell       = ell[1];
      i        += 1;
    @}
  result;
@};

// ------------------------------------------------------------


/// end of file
// Local Variables:
// fill-column: 60
// End:
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node examples o32
@appendixsec An object interface to @code{'int32} abstract numbers


@example
// Part of: Marco's Test modules
// Contents: object interface to #int32
// Date: Wed Aug 20, 2008
// 
// Abstract
// 
// This module  exports an  object interface to  handle Neko
// 'int32  values.   This  module  defines  a  protocol  for
// handling objects wrapping  'int32 through the object type
// #o32.
//
//   An  object value is  of type  #o32 if:  it has  a field
// named "n" holding an  abstract Neko value of 'int32 kind;
// its  prototype  is the  value  of  "o32_proto" from  this
// module.
// 
// Copyright (c) 2008 Marco Maggi <marcomaggi@@gna.org>
//
// This  is free  software; you  can redistribute  it and/or
// modify  it under  the  terms of  the  GNU Lesser  General
// Public  License   as  published  by   the  Free  Software
// Foundation;  either version  2.1 of  the License,  or (at
// your option) any later version.
// 
// This library is  distributed in the hope that  it will be
// useful,  but  WITHOUT  ANY  WARRANTY;  without  even  the
// implied  warranty  of MERCHANTABILITY  or  FITNESS FOR  A
// PARTICULAR  PURPOSE.  See the  GNU Lesser  General Public
// License for more details.
// 
// You should have received a copy of the GNU Lesser General
// Public License along with  this library; if not, write to
// the  Free  Software Foundation,  Inc.,  59 Temple  Place,
// Suite 330, Boston, MA 02111-1307 USA.
// 

//page
// ------------------------------------------------------------
// Setup.
// ------------------------------------------------------------

var stdload = function (name, arity) @{
  $loader.loadprim("std" + "@@" + name, arity);
@}

var std = $new(null);

std.int32_new           = stdload("int32_new",          1);
std.int32_to_int        = stdload("int32_to_int",       1);
std.int32_to_float      = stdload("int32_to_float",     1);
std.int32_compare       = stdload("int32_compare",      2);
std.int32_add           = stdload("int32_add",          2);
std.int32_sub           = stdload("int32_sub",          2);
std.int32_mul           = stdload("int32_mul",          2);
std.int32_div           = stdload("int32_div",          2);
std.int32_mod           = stdload("int32_mod",          2);

// This  is not  used because  when acting  on  objects Neko
// converts  the unary  negative operator  to  a subtraction
// from zero.
//
//std.int32_neg = stdload("int32_neg", 1);

/* The following are not used.
std.int32_ushr          = stdload("int32_ushr",         2);
std.int32_shl           = stdload("int32_shl",          2);
std.int32_shr           = stdload("int32_shr",          2);
std.int32_complement    = stdload("int32_complement",   1);
std.int32_or            = stdload("int32_or",           2);
std.int32_and           = stdload("int32_and",          2);
std.int32_xor           = stdload("int32_xor",          2);
std.int32_address       = stdload("int32_address",      1);
*/

// ------------------------------------------------------------

// This is  to solve the  chicken and egg problem  of object
// prototype  definition.  Notice  that the  "make" variable
// has to be  defined WITHOUT the "var" keyword,  so that it
// is global to this file and not captured by functions.
make = null;
$exports.o32_proto = null;

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Type predicates and assertions.
// ------------------------------------------------------------

// Synopsis: bool o32p (o : any)
//
// Return true if O is a Neko object value of type #o32.
//
// *FIXME* This function does not verify if the value in the
// *"n" field is an abstract of 'int32 kind.
$exports.o32p = function (o) @{
  (($tobject == $typeof(o)) &&
   ($objfield(o,$hash("n"))) &&
   ($exports.o32_proto == $objgetproto(o)));
@};

// Synopsis: void o32_assert (o : any)
//
// Raise an  error if O is  not an #o32  object according to
// "o32p()".
$exports.o32_assert = function (o) @{
  if ($not($exports.o32p(o)))
    $throw("expected #o32 object, got: " + o);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Comparison.
// ------------------------------------------------------------

// Synopsis: int o32_compare (o : any)
//
// Return a comparison ternary  result between "this" and O;
// this function  assumes that both "this" and  O hold valid
// #o32 objects.
//
// Notice that, as per the specs of Neko: comparison between
// an  object  and  a  non-object returns  "null"  directly,
// without examining the fields  of the object itself.  This
// means  that  "__compare"   is  invoked  only  whenever  a
// comparison between  two objects happens,  and the invoked
// "__compare" is the one of  the objects to the left.  Neko
// does not support the "__rcompare" method.

var o32_compare = function (num) @{
  if ($exports.o32p(num))
    std.int32_compare(this.n, num.n);
  else
    null;
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Arithmetics.
// ------------------------------------------------------------

// Synopsis: #o32 o32_add  (num : #o32|string|number)
// Synopsis: #o32 o32_radd (num : #o32|string|number)
//
// Return the sum between "this" and NUM.
// 
// When dealing with numbers:  left and right adding are the
// same; when dealing with strings: left and right adding is
// different.  This is why we have two add functions.

var o32_add = function (num) @{
  switch ($typeof(num)) @{
    $tint       => make(std.int32_add(this.n, std.int32_new(num)))
    $tfloat     => make(std.int32_add(this.n, std.int32_new(num)))
    $tstring    => this.n + num
  default       => if ($exports.o32p(num))
      make(std.int32_add(this.n, num.n));
    else
      $throw("expected value summable to an #o32, got: " + num)
        @}
@};
var o32_radd = function (num) @{
  switch ($typeof(num)) @{
    $tint       => make(std.int32_add(this.n, std.int32_new(num)))
    $tfloat     => make(std.int32_add(this.n, std.int32_new(num)))
    $tstring    => num + this.n
  default       => if ($exports.o32p(num))
      make(std.int32_add(this.n, num.n));
    else
      $throw("expected value summable to an #o32, got: " + num)
        @}
@};

// ------------------------------------------------------------

var number_dispatcher = function (num) @{
  switch ($typeof(num)) @{
    $tint       => std.int32_new(num)
    $tfloat     => std.int32_new(num)
  default       => if ($exports.o32p(num))
      num.n;
    else
      $throw("expected number got: '" + num + "'")
        @}
@};

// ------------------------------------------------------------

// Synopsis: #o32 o32_sub  (num : #o32|number)
// Synopsis: #o32 o32_rsub (num : #o32|number)
//
// Return the subtraction between  "this" and NUM, right and
// left order.
//
// Notice that  the unary negative operator  is converted by
// Neko into the  subtraction: 0 - number; so  it is handled
// by the "__sub" method.

var o32_sub = function (num) @{
  make(std.int32_sub(this.n, number_dispatcher(num)));
@};
var o32_rsub = function (num) @{
  make(std.int32_sub(number_dispatcher(num), this.n));
@};

// Synopsis: #o32 o32_mul  (num : #o32|number)
//
// Return the  multiplication between "this"  and NUM; right
// and left order does not matter.
var o32_mul = function (num) @{
  make(std.int32_mul(this.n, number_dispatcher(num)));
@};

// Synopsis: #o32 o32_div  (num : #o32|number)
// Synopsis: #o32 o32_rdiv (num : #o32|number)
//
// Return  the division  between "this"  and NUM,  right and
// left order.
var o32_div = function (num) @{
  make(std.int32_div(this.n, number_dispatcher(num)));
@};
var o32_rdiv = function (num) @{
  make(std.int32_div(number_dispatcher(num), this.n));
@};

// Synopsis: #o32 o32_mod  (num : #o32|number)
// Synopsis: #o32 o32_rmod (num : #o32|number)
//
// Return the modulo between  "this" and NUM, right and
// left order.
var o32_mod = function (num) @{
  make(std.int32_mod(this.n, number_dispatcher(num)));
@};
var o32_rmod = function (num) @{
  make(std.int32_mod(number_dispatcher(num), this.n));
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Conversion.
// ------------------------------------------------------------

// Synopsis: string o32_to_string (void)
//
// Interpret "this" as an  #o32 object and return its string
// representation.
var o32_to_string = function () @{
  $string(this.n);
@};

// Synopsis: string o32_to_int (void)
//
// Interpret "this" as an #o32 object and return its integer
// representation.
var o32_to_int = function () @{
  std.int32_to_int(this.n);
@};

// Synopsis: string o32_to_float (void)
//
// Interpret "this"  as an #o32 object and  return its float
// representation.
var o32_to_float = function () @{
  std.int32_to_float(this.n);
@};

// ------------------------------------------------------------

//page
// ------------------------------------------------------------
// Constructors.
// ------------------------------------------------------------

$exports.o32_proto = @{
  __string      => o32_to_string
  __compare     => o32_compare
  __add         => o32_add
  __radd        => o32_radd
  __sub         => o32_sub
  __rsub        => o32_rsub
  __mult        => o32_mul
  __rmult       => o32_mul
  __div         => o32_div
  __rdiv        => o32_rdiv
  __mod         => o32_mod
  __rmod        => o32_rmod

  int           => o32_to_int
  float         => o32_to_float
@};

var basic_new = function (number) @{
  var o = $new(null);

  o.n = number;
  $objsetproto(o, $exports.o32_proto);
  o;
@};

// Synopsis: #o32 o32 (n : int|float|string)
//
// Build  and return  a new  #o32 value;  N must  be  a Neko
// number or  string integer  representation and it  will be
// used to initialise the object.
$exports.o32 = function (value) @{
  basic_new(switch ($typeof(value))
    @{
      $tint     => std.int32_new(value)
      $tfloat   => std.int32_new(value)
      $tstring  => std.int32_new($int(value))
      default   => $throw("expected number got: " + value)
    @});
@};

// This is  to solve the  chicken and egg problem  of object
// prototype definition.
make = basic_new;


/// end of file
// Local Variables:
// fill-column: 60
// End:
@end example


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node Software License
@appendix @gnu{} Lesser General Public License


@cindex LGPL, Lesser General Public License
@center Version 2.1, February 1999

@display
Copyright @copyright{} 1991, 1999 Free Software Foundation, Inc.
59 Temple Place -- Suite 330, Boston, MA 02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.

[This is the first released version of the Lesser GPL.  It also counts
as the successor of the GNU Library Public License, version 2, hence the
version number 2.1.]
@end display

@appendixsubsec Preamble

  The licenses for most software are designed to take away your
freedom to share and change it.  By contrast, the GNU General Public
Licenses are intended to guarantee your freedom to share and change
free software---to make sure the software is free for all its users.

  This license, the Lesser General Public License, applies to some
specially designated software---typically libraries---of the Free
Software Foundation and other authors who decide to use it.  You can use
it too, but we suggest you first think carefully about whether this
license or the ordinary General Public License is the better strategy to
use in any particular case, based on the explanations below.

  When we speak of free software, we are referring to freedom of use,
not price.  Our General Public Licenses are designed to make sure that
you have the freedom to distribute copies of free software (and charge
for this service if you wish); that you receive source code or can get
it if you want it; that you can change the software and use pieces of it
in new free programs; and that you are informed that you can do these
things.

  To protect your rights, we need to make restrictions that forbid
distributors to deny you these rights or to ask you to surrender these
rights.  These restrictions translate to certain responsibilities for
you if you distribute copies of the library or if you modify it.

  For example, if you distribute copies of the library, whether gratis
or for a fee, you must give the recipients all the rights that we gave
you.  You must make sure that they, too, receive or can get the source
code.  If you link other code with the library, you must provide
complete object files to the recipients, so that they can relink them
with the library after making changes to the library and recompiling
it.  And you must show them these terms so they know their rights.

  We protect your rights with a two-step method: (1) we copyright the
library, and (2) we offer you this license, which gives you legal
permission to copy, distribute and/or modify the library.

  To protect each distributor, we want to make it very clear that
there is no warranty for the free library.  Also, if the library is
modified by someone else and passed on, the recipients should know
that what they have is not the original version, so that the original
author's reputation will not be affected by problems that might be
introduced by others.

  Finally, software patents pose a constant threat to the existence of
any free program.  We wish to make sure that a company cannot
effectively restrict the users of a free program by obtaining a
restrictive license from a patent holder.  Therefore, we insist that
any patent license obtained for a version of the library must be
consistent with the full freedom of use specified in this license.

  Most GNU software, including some libraries, is covered by the
ordinary GNU General Public License.  This license, the GNU Lesser
General Public License, applies to certain designated libraries, and
is quite different from the ordinary General Public License.  We use
this license for certain libraries in order to permit linking those
libraries into non-free programs.

  When a program is linked with a library, whether statically or using
a shared library, the combination of the two is legally speaking a
combined work, a derivative of the original library.  The ordinary
General Public License therefore permits such linking only if the
entire combination fits its criteria of freedom.  The Lesser General
Public License permits more lax criteria for linking other code with
the library.

  We call this license the @dfn{Lesser} General Public License because it
does @emph{Less} to protect the user's freedom than the ordinary General
Public License.  It also provides other free software developers Less
of an advantage over competing non-free programs.  These disadvantages
are the reason we use the ordinary General Public License for many
libraries.  However, the Lesser license provides advantages in certain
special circumstances.

  For example, on rare occasions, there may be a special need to
encourage the widest possible use of a certain library, so that it becomes
a de-facto standard.  To achieve this, non-free programs must be
allowed to use the library.  A more frequent case is that a free
library does the same job as widely used non-free libraries.  In this
case, there is little to gain by limiting the free library to free
software only, so we use the Lesser General Public License.

  In other cases, permission to use a particular library in non-free
programs enables a greater number of people to use a large body of
free software.  For example, permission to use the GNU C Library in
non-free programs enables many more people to use the whole GNU
operating system, as well as its variant, the GNU/Linux operating
system.

  Although the Lesser General Public License is Less protective of the
users' freedom, it does ensure that the user of a program that is
linked with the Library has the freedom and the wherewithal to run
that program using a modified version of the Library.

  The precise terms and conditions for copying, distribution and
modification follow.  Pay close attention to the difference between a
``work based on the library'' and a ``work that uses the library''.  The
former contains code derived from the library, whereas the latter must
be combined with the library in order to run.

@iftex
@appendixsubsec TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
@end iftex
@ifinfo
@center GNU LESSER GENERAL PUBLIC LICENSE
@center TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
@end ifinfo

@enumerate 0
@item
This License Agreement applies to any software library or other program
which contains a notice placed by the copyright holder or other
authorized party saying it may be distributed under the terms of this
Lesser General Public License (also called ``this License'').  Each
licensee is addressed as ``you''.

  A ``library'' means a collection of software functions and/or data
prepared so as to be conveniently linked with application programs
(which use some of those functions and data) to form executables.

  The ``Library'', below, refers to any such software library or work
which has been distributed under these terms.  A ``work based on the
Library'' means either the Library or any derivative work under
copyright law: that is to say, a work containing the Library or a
portion of it, either verbatim or with modifications and/or translated
straightforwardly into another language.  (Hereinafter, translation is
included without limitation in the term ``modification''.)

  ``Source code'' for a work means the preferred form of the work for
making modifications to it.  For a library, complete source code means
all the source code for all modules it contains, plus any associated
interface definition files, plus the scripts used to control compilation
and installation of the library.

  Activities other than copying, distribution and modification are not
covered by this License; they are outside its scope.  The act of
running a program using the Library is not restricted, and output from
such a program is covered only if its contents constitute a work based
on the Library (independent of the use of the Library in a tool for
writing it).  Whether that is true depends on what the Library does
and what the program that uses the Library does.

@item
You may copy and distribute verbatim copies of the Library's
complete source code as you receive it, in any medium, provided that
you conspicuously and appropriately publish on each copy an
appropriate copyright notice and disclaimer of warranty; keep intact
all the notices that refer to this License and to the absence of any
warranty; and distribute a copy of this License along with the
Library.

  You may charge a fee for the physical act of transferring a copy,
and you may at your option offer warranty protection in exchange for a
fee.

@item
You may modify your copy or copies of the Library or any portion
of it, thus forming a work based on the Library, and copy and
distribute such modifications or work under the terms of Section 1
above, provided that you also meet all of these conditions:

@enumerate a
@item
The modified work must itself be a software library.

@item
You must cause the files modified to carry prominent notices
stating that you changed the files and the date of any change.

@item
You must cause the whole of the work to be licensed at no
charge to all third parties under the terms of this License.

@item
If a facility in the modified Library refers to a function or a
table of data to be supplied by an application program that uses
the facility, other than as an argument passed when the facility
is invoked, then you must make a good faith effort to ensure that,
in the event an application does not supply such function or
table, the facility still operates, and performs whatever part of
its purpose remains meaningful.

(For example, a function in a library to compute square roots has
a purpose that is entirely well-defined independent of the
application.  Therefore, Subsection 2d requires that any
application-supplied function or table used by this function must
be optional: if the application does not supply it, the square
root function must still compute square roots.)
@end enumerate

These requirements apply to the modified work as a whole.  If
identifiable sections of that work are not derived from the Library,
and can be reasonably considered independent and separate works in
themselves, then this License, and its terms, do not apply to those
sections when you distribute them as separate works.  But when you
distribute the same sections as part of a whole which is a work based
on the Library, the distribution of the whole must be on the terms of
this License, whose permissions for other licensees extend to the
entire whole, and thus to each and every part regardless of who wrote
it.

Thus, it is not the intent of this section to claim rights or contest
your rights to work written entirely by you; rather, the intent is to
exercise the right to control the distribution of derivative or
collective works based on the Library.

In addition, mere aggregation of another work not based on the Library
with the Library (or with a work based on the Library) on a volume of
a storage or distribution medium does not bring the other work under
the scope of this License.

@item
You may opt to apply the terms of the ordinary GNU General Public
License instead of this License to a given copy of the Library.  To do
this, you must alter all the notices that refer to this License, so
that they refer to the ordinary GNU General Public License, version 2,
instead of to this License.  (If a newer version than version 2 of the
ordinary GNU General Public License has appeared, then you can specify
that version instead if you wish.)  Do not make any other change in
these notices.

  Once this change is made in a given copy, it is irreversible for
that copy, so the ordinary GNU General Public License applies to all
subsequent copies and derivative works made from that copy.

  This option is useful when you wish to copy part of the code of
the Library into a program that is not a library.

@item
You may copy and distribute the Library (or a portion or
derivative of it, under Section 2) in object code or executable form
under the terms of Sections 1 and 2 above provided that you accompany
it with the complete corresponding machine-readable source code, which
must be distributed under the terms of Sections 1 and 2 above on a
medium customarily used for software interchange.

  If distribution of object code is made by offering access to copy
from a designated place, then offering equivalent access to copy the
source code from the same place satisfies the requirement to
distribute the source code, even though third parties are not
compelled to copy the source along with the object code.

@item
A program that contains no derivative of any portion of the
Library, but is designed to work with the Library by being compiled or
linked with it, is called a ``work that uses the Library''.  Such a
work, in isolation, is not a derivative work of the Library, and
therefore falls outside the scope of this License.

  However, linking a ``work that uses the Library'' with the Library
creates an executable that is a derivative of the Library (because it
contains portions of the Library), rather than a ``work that uses the
library''.  The executable is therefore covered by this License.
Section 6 states terms for distribution of such executables.

  When a ``work that uses the Library'' uses material from a header file
that is part of the Library, the object code for the work may be a
derivative work of the Library even though the source code is not.
Whether this is true is especially significant if the work can be
linked without the Library, or if the work is itself a library.  The
threshold for this to be true is not precisely defined by law.

  If such an object file uses only numerical parameters, data
structure layouts and accessors, and small macros and small inline
functions (ten lines or less in length), then the use of the object
file is unrestricted, regardless of whether it is legally a derivative
work.  (Executables containing this object code plus portions of the
Library will still fall under Section 6.)

  Otherwise, if the work is a derivative of the Library, you may
distribute the object code for the work under the terms of Section 6.
Any executables containing that work also fall under Section 6,
whether or not they are linked directly with the Library itself.

@item
As an exception to the Sections above, you may also combine or
link a ``work that uses the Library'' with the Library to produce a
work containing portions of the Library, and distribute that work
under terms of your choice, provided that the terms permit
modification of the work for the customer's own use and reverse
engineering for debugging such modifications.

  You must give prominent notice with each copy of the work that the
Library is used in it and that the Library and its use are covered by
this License.  You must supply a copy of this License.  If the work
during execution displays copyright notices, you must include the
copyright notice for the Library among them, as well as a reference
directing the user to the copy of this License.  Also, you must do one
of these things:

@enumerate a
@item
Accompany the work with the complete corresponding
machine-readable source code for the Library including whatever
changes were used in the work (which must be distributed under
Sections 1 and 2 above); and, if the work is an executable linked
with the Library, with the complete machine-readable ``work that
uses the Library'', as object code and/or source code, so that the
user can modify the Library and then relink to produce a modified
executable containing the modified Library.  (It is understood
that the user who changes the contents of definitions files in the
Library will not necessarily be able to recompile the application
to use the modified definitions.)

@item
Use a suitable shared library mechanism for linking with the Library.  A
suitable mechanism is one that (1) uses at run time a copy of the
library already present on the user's computer system, rather than
copying library functions into the executable, and (2) will operate
properly with a modified version of the library, if the user installs
one, as long as the modified version is interface-compatible with the
version that the work was made with.

@item
Accompany the work with a written offer, valid for at
least three years, to give the same user the materials
specified in Subsection 6a, above, for a charge no more
than the cost of performing this distribution.

@item
If distribution of the work is made by offering access to copy
from a designated place, offer equivalent access to copy the above
specified materials from the same place.

@item
Verify that the user has already received a copy of these
materials or that you have already sent this user a copy.
@end enumerate

  For an executable, the required form of the ``work that uses the
Library'' must include any data and utility programs needed for
reproducing the executable from it.  However, as a special exception,
the materials to be distributed need not include anything that is
normally distributed (in either source or binary form) with the major
components (compiler, kernel, and so on) of the operating system on
which the executable runs, unless that component itself accompanies the
executable.

  It may happen that this requirement contradicts the license
restrictions of other proprietary libraries that do not normally
accompany the operating system.  Such a contradiction means you cannot
use both them and the Library together in an executable that you
distribute.

@item
You may place library facilities that are a work based on the
Library side-by-side in a single library together with other library
facilities not covered by this License, and distribute such a combined
library, provided that the separate distribution of the work based on
the Library and of the other library facilities is otherwise
permitted, and provided that you do these two things:

@enumerate a
@item
Accompany the combined library with a copy of the same work
based on the Library, uncombined with any other library
facilities.  This must be distributed under the terms of the
Sections above.

@item
Give prominent notice with the combined library of the fact
that part of it is a work based on the Library, and explaining
where to find the accompanying uncombined form of the same work.
@end enumerate

@item
You may not copy, modify, sublicense, link with, or distribute
the Library except as expressly provided under this License.  Any
attempt otherwise to copy, modify, sublicense, link with, or
distribute the Library is void, and will automatically terminate your
rights under this License.  However, parties who have received copies,
or rights, from you under this License will not have their licenses
terminated so long as such parties remain in full compliance.

@item
You are not required to accept this License, since you have not
signed it.  However, nothing else grants you permission to modify or
distribute the Library or its derivative works.  These actions are
prohibited by law if you do not accept this License.  Therefore, by
modifying or distributing the Library (or any work based on the
Library), you indicate your acceptance of this License to do so, and
all its terms and conditions for copying, distributing or modifying
the Library or works based on it.

@item
Each time you redistribute the Library (or any work based on the
Library), the recipient automatically receives a license from the
original licensor to copy, distribute, link with or modify the Library
subject to these terms and conditions.  You may not impose any further
restrictions on the recipients' exercise of the rights granted herein.
You are not responsible for enforcing compliance by third parties with
this License.

@item
If, as a consequence of a court judgment or allegation of patent
infringement or for any other reason (not limited to patent issues),
conditions are imposed on you (whether by court order, agreement or
otherwise) that contradict the conditions of this License, they do not
excuse you from the conditions of this License.  If you cannot
distribute so as to satisfy simultaneously your obligations under this
License and any other pertinent obligations, then as a consequence you
may not distribute the Library at all.  For example, if a patent
license would not permit royalty-free redistribution of the Library by
all those who receive copies directly or indirectly through you, then
the only way you could satisfy both it and this License would be to
refrain entirely from distribution of the Library.

If any portion of this section is held invalid or unenforceable under any
particular circumstance, the balance of the section is intended to apply,
and the section as a whole is intended to apply in other circumstances.

It is not the purpose of this section to induce you to infringe any
patents or other property right claims or to contest validity of any
such claims; this section has the sole purpose of protecting the
integrity of the free software distribution system which is
implemented by public license practices.  Many people have made
generous contributions to the wide range of software distributed
through that system in reliance on consistent application of that
system; it is up to the author/donor to decide if he or she is willing
to distribute software through any other system and a licensee cannot
impose that choice.

This section is intended to make thoroughly clear what is believed to
be a consequence of the rest of this License.

@item
If the distribution and/or use of the Library is restricted in
certain countries either by patents or by copyrighted interfaces, the
original copyright holder who places the Library under this License may add
an explicit geographical distribution limitation excluding those countries,
so that distribution is permitted only in or among countries not thus
excluded.  In such case, this License incorporates the limitation as if
written in the body of this License.

@item
The Free Software Foundation may publish revised and/or new
versions of the Lesser General Public License from time to time.
Such new versions will be similar in spirit to the present version,
but may differ in detail to address new problems or concerns.

Each version is given a distinguishing version number.  If the Library
specifies a version number of this License which applies to it and
``any later version'', you have the option of following the terms and
conditions either of that version or of any later version published by
the Free Software Foundation.  If the Library does not specify a
license version number, you may choose any version ever published by
the Free Software Foundation.

@item
If you wish to incorporate parts of the Library into other free
programs whose distribution conditions are incompatible with these,
write to the author to ask for permission.  For software which is
copyrighted by the Free Software Foundation, write to the Free
Software Foundation; we sometimes make exceptions for this.  Our
decision will be guided by the two goals of preserving the free status
of all derivatives of our free software and of promoting the sharing
and reuse of software generally.

@iftex
@heading NO WARRANTY
@end iftex
@ifinfo
@center NO WARRANTY
@end ifinfo

@item
BECAUSE THE LIBRARY IS LICENSED FREE OF CHARGE, THERE IS NO
WARRANTY FOR THE LIBRARY, TO THE EXTENT PERMITTED BY APPLICABLE LAW.
EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT HOLDERS AND/OR
OTHER PARTIES PROVIDE THE LIBRARY ``AS IS'' WITHOUT WARRANTY OF ANY
KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT NOT LIMITED TO, THE
IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
PURPOSE.  THE ENTIRE RISK AS TO THE QUALITY AND PERFORMANCE OF THE
LIBRARY IS WITH YOU.  SHOULD THE LIBRARY PROVE DEFECTIVE, YOU ASSUME
THE COST OF ALL NECESSARY SERVICING, REPAIR OR CORRECTION.

@item
IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY MODIFY
AND/OR REDISTRIBUTE THE LIBRARY AS PERMITTED ABOVE, BE LIABLE TO YOU
FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL, INCIDENTAL OR
CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR INABILITY TO USE THE
LIBRARY (INCLUDING BUT NOT LIMITED TO LOSS OF DATA OR DATA BEING
RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU OR THIRD PARTIES OR A
FAILURE OF THE LIBRARY TO OPERATE WITH ANY OTHER SOFTWARE), EVEN IF
SUCH HOLDER OR OTHER PARTY HAS BEEN ADVISED OF THE POSSIBILITY OF SUCH
DAMAGES.
@end enumerate

@iftex
@heading END OF TERMS AND CONDITIONS
@end iftex
@ifinfo
@center END OF TERMS AND CONDITIONS
@end ifinfo

@page
@appendixsubsec How to Apply These Terms to Your New Libraries

  If you develop a new library, and you want it to be of the greatest
possible use to the public, we recommend making it free software that
everyone can redistribute and change.  You can do so by permitting
redistribution under these terms (or, alternatively, under the terms of the
ordinary General Public License).

  To apply these terms, attach the following notices to the library.  It is
safest to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least the
``copyright'' line and a pointer to where the full notice is found.

@smallexample
@var{one line to give the library's name and an idea of what it does.}
Copyright (C) @var{year}  @var{name of author}

This library is free software; you can redistribute it and/or modify it
under the terms of the GNU Lesser General Public License as published by
the Free Software Foundation; either version 2.1 of the License, or (at
your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307,
USA.
@end smallexample

Also add information on how to contact you by electronic and paper mail.

You should also get your employer (if you work as a programmer) or your
school, if any, to sign a ``copyright disclaimer'' for the library, if
necessary.  Here is a sample; alter the names:

@smallexample
Yoyodyne, Inc., hereby disclaims all copyright interest in the library
`Frob' (a library for tweaking knobs) written by James Random Hacker.

@var{signature of Ty Coon}, 1 April 1990
Ty Coon, President of Vice
@end smallexample

That's all there is to it!


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node Documentation License
@appendix GNU Free Documentation License

@cindex FDL, GNU Free Documentation License
@center Version 1.1, March 2000

@display
Copyright @copyright{} 2000 Free Software Foundation, Inc.
59 Temple Place, Suite 330, Boston, MA  02111-1307, USA

Everyone is permitted to copy and distribute verbatim copies
of this license document, but changing it is not allowed.
@end display

@enumerate 0
@item
PREAMBLE

The purpose of this License is to make a manual, textbook, or other
written document @dfn{free} in the sense of freedom: to assure everyone
the effective freedom to copy and redistribute it, with or without
modifying it, either commercially or noncommercially.  Secondarily,
this License preserves for the author and publisher a way to get
credit for their work, while not being considered responsible for
modifications made by others.

This License is a kind of ``copyleft'', which means that derivative
works of the document must themselves be free in the same sense.  It
complements the GNU General Public License, which is a copyleft
license designed for free software.

We have designed this License in order to use it for manuals for free
software, because free software needs free documentation: a free
program should come with manuals providing the same freedoms that the
software does.  But this License is not limited to software manuals;
it can be used for any textual work, regardless of subject matter or
whether it is published as a printed book.  We recommend this License
principally for works whose purpose is instruction or reference.

@item
APPLICABILITY AND DEFINITIONS

This License applies to any manual or other work that contains a
notice placed by the copyright holder saying it can be distributed
under the terms of this License.  The ``Document'', below, refers to any
such manual or work.  Any member of the public is a licensee, and is
addressed as ``you''.

A ``Modified Version'' of the Document means any work containing the
Document or a portion of it, either copied verbatim, or with
modifications and/or translated into another language.

A ``Secondary Section'' is a named appendix or a front-matter section of
the Document that deals exclusively with the relationship of the
publishers or authors of the Document to the Document's overall subject
(or to related matters) and contains nothing that could fall directly
within that overall subject.  (For example, if the Document is in part a
textbook of mathematics, a Secondary Section may not explain any
mathematics.)  The relationship could be a matter of historical
connection with the subject or with related matters, or of legal,
commercial, philosophical, ethical or political position regarding
them.

The ``Invariant Sections'' are certain Secondary Sections whose titles
are designated, as being those of Invariant Sections, in the notice
that says that the Document is released under this License.

The ``Cover Texts'' are certain short passages of text that are listed,
as Front-Cover Texts or Back-Cover Texts, in the notice that says that
the Document is released under this License.

A ``Transparent'' copy of the Document means a machine-readable copy,
represented in a format whose specification is available to the
general public, whose contents can be viewed and edited directly and
straightforwardly with generic text editors or (for images composed of
pixels) generic paint programs or (for drawings) some widely available
drawing editor, and that is suitable for input to text formatters or
for automatic translation to a variety of formats suitable for input
to text formatters.  A copy made in an otherwise Transparent file
format whose markup has been designed to thwart or discourage
subsequent modification by readers is not Transparent.  A copy that is
not ``Transparent'' is called ``Opaque''.

Examples of suitable formats for Transparent copies include plain
@sc{ascii} without markup, Texinfo input format, La@TeX{} input format,
@acronym{SGML} or @acronym{XML} using a publicly available
@acronym{DTD}, and standard-conforming simple @acronym{HTML} designed
for human modification.  Opaque formats include PostScript,
@acronym{PDF}, proprietary formats that can be read and edited only by
proprietary word processors, @acronym{SGML} or @acronym{XML} for which
the @acronym{DTD} and/or processing tools are not generally available,
and the machine-generated @acronym{HTML} produced by some word
processors for output purposes only.

The ``Title Page'' means, for a printed book, the title page itself,
plus such following pages as are needed to hold, legibly, the material
this License requires to appear in the title page.  For works in
formats which do not have any title page as such, ``Title Page'' means
the text near the most prominent appearance of the work's title,
preceding the beginning of the body of the text.

@item
VERBATIM COPYING

You may copy and distribute the Document in any medium, either
commercially or noncommercially, provided that this License, the
copyright notices, and the license notice saying this License applies
to the Document are reproduced in all copies, and that you add no other
conditions whatsoever to those of this License.  You may not use
technical measures to obstruct or control the reading or further
copying of the copies you make or distribute.  However, you may accept
compensation in exchange for copies.  If you distribute a large enough
number of copies you must also follow the conditions in section 3.

You may also lend copies, under the same conditions stated above, and
you may publicly display copies.

@item
COPYING IN QUANTITY

If you publish printed copies of the Document numbering more than 100,
and the Document's license notice requires Cover Texts, you must enclose
the copies in covers that carry, clearly and legibly, all these Cover
Texts: Front-Cover Texts on the front cover, and Back-Cover Texts on
the back cover.  Both covers must also clearly and legibly identify
you as the publisher of these copies.  The front cover must present
the full title with all words of the title equally prominent and
visible.  You may add other material on the covers in addition.
Copying with changes limited to the covers, as long as they preserve
the title of the Document and satisfy these conditions, can be treated
as verbatim copying in other respects.

If the required texts for either cover are too voluminous to fit
legibly, you should put the first ones listed (as many as fit
reasonably) on the actual cover, and continue the rest onto adjacent
pages.

If you publish or distribute Opaque copies of the Document numbering
more than 100, you must either include a machine-readable Transparent
copy along with each Opaque copy, or state in or with each Opaque copy
a publicly-accessible computer-network location containing a complete
Transparent copy of the Document, free of added material, which the
general network-using public has access to download anonymously at no
charge using public-standard network protocols.  If you use the latter
option, you must take reasonably prudent steps, when you begin
distribution of Opaque copies in quantity, to ensure that this
Transparent copy will remain thus accessible at the stated location
until at least one year after the last time you distribute an Opaque
copy (directly or through your agents or retailers) of that edition to
the public.

It is requested, but not required, that you contact the authors of the
Document well before redistributing any large number of copies, to give
them a chance to provide you with an updated version of the Document.

@item
MODIFICATIONS

You may copy and distribute a Modified Version of the Document under
the conditions of sections 2 and 3 above, provided that you release
the Modified Version under precisely this License, with the Modified
Version filling the role of the Document, thus licensing distribution
and modification of the Modified Version to whoever possesses a copy
of it.  In addition, you must do these things in the Modified Version:

@enumerate A
@item
Use in the Title Page (and on the covers, if any) a title distinct
from that of the Document, and from those of previous versions
(which should, if there were any, be listed in the History section
of the Document).  You may use the same title as a previous version
if the original publisher of that version gives permission.

@item
List on the Title Page, as authors, one or more persons or entities
responsible for authorship of the modifications in the Modified
Version, together with at least five of the principal authors of the
Document (all of its principal authors, if it has less than five).

@item
State on the Title page the name of the publisher of the
Modified Version, as the publisher.

@item
Preserve all the copyright notices of the Document.

@item
Add an appropriate copyright notice for your modifications
adjacent to the other copyright notices.

@item
Include, immediately after the copyright notices, a license notice
giving the public permission to use the Modified Version under the
terms of this License, in the form shown in the Addendum below.

@item
Preserve in that license notice the full lists of Invariant Sections
and required Cover Texts given in the Document's license notice.

@item
Include an unaltered copy of this License.

@item
Preserve the section entitled ``History'', and its title, and add to
it an item stating at least the title, year, new authors, and
publisher of the Modified Version as given on the Title Page.  If
there is no section entitled ``History'' in the Document, create one
stating the title, year, authors, and publisher of the Document as
given on its Title Page, then add an item describing the Modified
Version as stated in the previous sentence.

@item
Preserve the network location, if any, given in the Document for
public access to a Transparent copy of the Document, and likewise
the network locations given in the Document for previous versions
it was based on.  These may be placed in the ``History'' section.
You may omit a network location for a work that was published at
least four years before the Document itself, or if the original
publisher of the version it refers to gives permission.

@item
In any section entitled ``Acknowledgments'' or ``Dedications'',
preserve the section's title, and preserve in the section all the
substance and tone of each of the contributor acknowledgments
and/or dedications given therein.

@item
Preserve all the Invariant Sections of the Document,
unaltered in their text and in their titles.  Section numbers
or the equivalent are not considered part of the section titles.

@item
Delete any section entitled ``Endorsements''.  Such a section
may not be included in the Modified Version.

@item
Do not retitle any existing section as ``Endorsements''
or to conflict in title with any Invariant Section.
@end enumerate

If the Modified Version includes new front-matter sections or
appendices that qualify as Secondary Sections and contain no material
copied from the Document, you may at your option designate some or all
of these sections as invariant.  To do this, add their titles to the
list of Invariant Sections in the Modified Version's license notice.
These titles must be distinct from any other section titles.

You may add a section entitled ``Endorsements'', provided it contains
nothing but endorsements of your Modified Version by various
parties---for example, statements of peer review or that the text has
been approved by an organization as the authoritative definition of a
standard.

You may add a passage of up to five words as a Front-Cover Text, and a
passage of up to 25 words as a Back-Cover Text, to the end of the list
of Cover Texts in the Modified Version.  Only one passage of
Front-Cover Text and one of Back-Cover Text may be added by (or
through arrangements made by) any one entity.  If the Document already
includes a cover text for the same cover, previously added by you or
by arrangement made by the same entity you are acting on behalf of,
you may not add another; but you may replace the old one, on explicit
permission from the previous publisher that added the old one.

The author(s) and publisher(s) of the Document do not by this License
give permission to use their names for publicity for or to assert or
imply endorsement of any Modified Version.

@item
COMBINING DOCUMENTS

You may combine the Document with other documents released under this
License, under the terms defined in section 4 above for modified
versions, provided that you include in the combination all of the
Invariant Sections of all of the original documents, unmodified, and
list them all as Invariant Sections of your combined work in its
license notice.

The combined work need only contain one copy of this License, and
multiple identical Invariant Sections may be replaced with a single
copy.  If there are multiple Invariant Sections with the same name but
different contents, make the title of each such section unique by
adding at the end of it, in parentheses, the name of the original
author or publisher of that section if known, or else a unique number.
Make the same adjustment to the section titles in the list of
Invariant Sections in the license notice of the combined work.

In the combination, you must combine any sections entitled ``History''
in the various original documents, forming one section entitled
``History''; likewise combine any sections entitled ``Acknowledgments'',
and any sections entitled ``Dedications''.  You must delete all sections
entitled ``Endorsements.''

@item
COLLECTIONS OF DOCUMENTS

You may make a collection consisting of the Document and other documents
released under this License, and replace the individual copies of this
License in the various documents with a single copy that is included in
the collection, provided that you follow the rules of this License for
verbatim copying of each of the documents in all other respects.

You may extract a single document from such a collection, and distribute
it individually under this License, provided you insert a copy of this
License into the extracted document, and follow this License in all
other respects regarding verbatim copying of that document.

@item
AGGREGATION WITH INDEPENDENT WORKS

A compilation of the Document or its derivatives with other separate
and independent documents or works, in or on a volume of a storage or
distribution medium, does not as a whole count as a Modified Version
of the Document, provided no compilation copyright is claimed for the
compilation.  Such a compilation is called an ``aggregate'', and this
License does not apply to the other self-contained works thus compiled
with the Document, on account of their being thus compiled, if they
are not themselves derivative works of the Document.

If the Cover Text requirement of section 3 is applicable to these
copies of the Document, then if the Document is less than one quarter
of the entire aggregate, the Document's Cover Texts may be placed on
covers that surround only the Document within the aggregate.
Otherwise they must appear on covers around the whole aggregate.

@item
TRANSLATION

Translation is considered a kind of modification, so you may
distribute translations of the Document under the terms of section 4.
Replacing Invariant Sections with translations requires special
permission from their copyright holders, but you may include
translations of some or all Invariant Sections in addition to the
original versions of these Invariant Sections.  You may include a
translation of this License provided that you also include the
original English version of this License.  In case of a disagreement
between the translation and the original English version of this
License, the original English version will prevail.

@item
TERMINATION

You may not copy, modify, sublicense, or distribute the Document except
as expressly provided for under this License.  Any other attempt to
copy, modify, sublicense or distribute the Document is void, and will
automatically terminate your rights under this License.  However,
parties who have received copies, or rights, from you under this
License will not have their licenses terminated so long as such
parties remain in full compliance.

@item
FUTURE REVISIONS OF THIS LICENSE

The Free Software Foundation may publish new, revised versions
of the GNU Free Documentation License from time to time.  Such new
versions will be similar in spirit to the present version, but may
differ in detail to address new problems or concerns.  See
@uref{http://www.gnu.org/copyleft/}.

Each version of the License is given a distinguishing version number.
If the Document specifies that a particular numbered version of this
License ``or any later version'' applies to it, you have the option of
following the terms and conditions either of that specified version or
of any later version that has been published (not as a draft) by the
Free Software Foundation.  If the Document does not specify a version
number of this License, you may choose any version ever published (not
as a draft) by the Free Software Foundation.
@end enumerate

@page
@appendixsubsec ADDENDUM: How to use this License for your documents

To use this License in a document you have written, include a copy of
the License in the document and put the following copyright and
license notices just after the title page:

@smallexample
@group
  Copyright (C)  @var{year}  @var{your name}.
  Permission is granted to copy, distribute and/or modify this document
  under the terms of the GNU Free Documentation License, Version 1.1
  or any later version published by the Free Software Foundation;
  with the Invariant Sections being @var{list their titles}, with the
  Front-Cover Texts being @var{list}, and with the Back-Cover Texts being @var{list}.
  A copy of the license is included in the section entitled ``GNU
  Free Documentation License''.
@end group
@end smallexample

If you have no Invariant Sections, write ``with no Invariant Sections''
instead of saying which ones are invariant.  If you have no
Front-Cover Texts, write ``no Front-Cover Texts'' instead of
``Front-Cover Texts being @var{list}''; likewise for Back-Cover Texts.

If your document contains nontrivial examples of program code, we
recommend releasing these examples in parallel under your choice of
free software license, such as the GNU General Public License,
to permit their use in free software.

@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node References
@appendix Bibliography and references


@noindent
@nvm{} Home Page:

@center @url{http://www.nekovm.org/}


@c  ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++

@c ------------------------------------------------------------
@node Concept Index
@appendix An entry for each concept
     
@printindex cp
     
@node Function Index
@appendix An entry for each function. 

@printindex fn

@node Variable Index
@appendix An entry for each variable. 

@printindex vr

@node Type Index
@appendix An entry for each type. 

@printindex tp

@contents
@bye

@c end of file
@c Local Variables:
@c mode: texinfo
@c page-separator: \"^@c -+$\"
@c End:
